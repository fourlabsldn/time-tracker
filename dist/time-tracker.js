(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.timeTracker = factory());
}(this, (function () { 'use strict';

/* eslint-disable no-unused-vars */
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (e) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

var index$1 = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

function invariant$1(condition, format, a, b, c, d, e, f) {
  {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

var invariant_1 = invariant$1;

var invariant = invariant_1;

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler$1 = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler$1 = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4, a5);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4, a5);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? invariant(false, 'Trying to release an instance into a pool of a different type.') : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances.
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function (CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass$1 = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler$1,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler$1,
  fiveArgumentPooler: fiveArgumentPooler
};

var PooledClass_1 = PooledClass$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner$1 = {

  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null

};

var ReactCurrentOwner_1 = ReactCurrentOwner$1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction$2 = function emptyFunction$2() {};

emptyFunction$2.thatReturns = makeEmptyFunction;
emptyFunction$2.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction$2.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction$2.thatReturnsNull = makeEmptyFunction(null);
emptyFunction$2.thatReturnsThis = function () {
  return this;
};
emptyFunction$2.thatReturnsArgument = function (arg) {
  return arg;
};

var emptyFunction_1 = emptyFunction$2;

var emptyFunction$1 = emptyFunction_1;

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning$2 = emptyFunction$1;

{
  (function () {
    var printWarning = function printWarning(format) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };

    warning$2 = function warning$2(condition, format) {
      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }

      if (format.indexOf('Failed Composite propType: ') === 0) {
        return; // Ignore CompositeComponent proptype check.
      }

      if (!condition) {
        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }

        printWarning.apply(undefined, [format].concat(args));
      }
    };
  })();
}

var warning_1 = warning$2;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

var canDefineProperty$1 = false;
{
  try {
    // $FlowFixMe https://github.com/facebook/flow/issues/285
    Object.defineProperty({}, 'x', { get: function () {} });
    canDefineProperty$1 = true;
  } catch (x) {
    // IE will fail on defineProperty
  }
}

var canDefineProperty_1 = canDefineProperty$1;

/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.

var REACT_ELEMENT_TYPE$1 = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

var ReactElementSymbol = REACT_ELEMENT_TYPE$1;

var _assign$1 = index$1;

var ReactCurrentOwner = ReactCurrentOwner_1;

var warning$1 = warning_1;
var canDefineProperty = canDefineProperty_1;
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

var REACT_ELEMENT_TYPE = ReactElementSymbol;

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown;
var specialPropRefWarningShown;

function hasValidRef(config) {
  {
    if (hasOwnProperty$1.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty$1.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      warning$1(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      warning$1(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement$2 = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    if (canDefineProperty) {
      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      });
      // self and source are DEV only properties.
      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      });
      // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.
      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });
    } else {
      element._store.validated = false;
      element._self = self;
      element._source = source;
    }
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
 */
ReactElement$2.createElement = function (type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty$1.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement$2(type, key, ref, self, source, ReactCurrentOwner.current, props);
};

/**
 * Return a function that produces ReactElements of a given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
 */
ReactElement$2.createFactory = function (type) {
  var factory = ReactElement$2.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook TODO: Warn if this is accessed
  factory.type = type;
  return factory;
};

ReactElement$2.cloneAndReplaceKey = function (oldElement, newKey) {
  var newElement = ReactElement$2(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
};

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
 */
ReactElement$2.cloneElement = function (element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign$1({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty$1.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement$2(element.type, key, ref, self, source, owner, props);
};

/**
 * Verifies the object is a ReactElement.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement$2.isValidElement = function (object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
};

var ReactElement_1 = ReactElement$2;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

/* global Symbol */

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn$1(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

var getIteratorFn_1 = getIteratorFn$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * Unescape and unwrap key for human-readable display
 *
 * @param {string} key to unescape.
 * @return {string} the unescaped key.
 */
function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}

var KeyEscapeUtils$1 = {
  escape: escape,
  unescape: unescape
};

var KeyEscapeUtils_1 = KeyEscapeUtils$1;

var ReactCurrentOwner$2 = ReactCurrentOwner_1;
var REACT_ELEMENT_TYPE$2 = ReactElementSymbol;

var getIteratorFn = getIteratorFn_1;
var invariant$2 = invariant_1;
var KeyEscapeUtils = KeyEscapeUtils_1;
var warning$3 = warning_1;

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE$2) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner$2.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner$2.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          warning$3(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum);
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner$2.current) {
          var name = ReactCurrentOwner$2.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
      invariant$2(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren$1(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

var traverseAllChildren_1 = traverseAllChildren$1;

var PooledClass = PooledClass_1;
var ReactElement$1 = ReactElement_1;

var emptyFunction = emptyFunction_1;
var traverseAllChildren = traverseAllChildren_1;

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var fourArgumentPooler = PooledClass.fourArgumentPooler;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
ForEachBookKeeping.prototype.destructor = function () {
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function () {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (ReactElement$1.isValidElement(mappedChild)) {
      mappedChild = ReactElement$1.cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

var ReactChildren$1 = {
  forEach: forEachChildren,
  map: mapChildren,
  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
  count: countChildren,
  toArray: toArray
};

var ReactChildren_1 = ReactChildren$1;

var warning$5 = warning_1;

function warnNoop(publicInstance, callerName) {
  {
    var constructor = publicInstance.constructor;
    warning$5(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass');
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue$1 = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback) {},

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    warnNoop(publicInstance, 'setState');
  }
};

var ReactNoopUpdateQueue_1 = ReactNoopUpdateQueue$1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

var emptyObject$1 = {};

{
  Object.freeze(emptyObject$1);
}

var emptyObject_1 = emptyObject$1;

var ReactNoopUpdateQueue = ReactNoopUpdateQueue_1;

var canDefineProperty$2 = canDefineProperty_1;
var emptyObject = emptyObject_1;
var invariant$3 = invariant_1;
var warning$4 = warning_1;

/**
 * Base class helpers for the updating state of a component.
 */
function ReactComponent$1(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

ReactComponent$1.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
ReactComponent$1.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant$3(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
ReactComponent$1.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'forceUpdate');
  }
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    if (canDefineProperty$2) {
      Object.defineProperty(ReactComponent$1.prototype, methodName, {
        get: function () {
          warning$4(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
          return undefined;
        }
      });
    }
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

var ReactComponent_1 = ReactComponent$1;

var _assign$2 = index$1;

var ReactComponent$2 = ReactComponent_1;
var ReactNoopUpdateQueue$2 = ReactNoopUpdateQueue_1;

var emptyObject$2 = emptyObject_1;

/**
 * Base class helpers for the updating state of a component.
 */
function ReactPureComponent$1(props, context, updater) {
  // Duplicated from ReactComponent.
  this.props = props;
  this.context = context;
  this.refs = emptyObject$2;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue$2;
}

function ComponentDummy() {}
ComponentDummy.prototype = ReactComponent$2.prototype;
ReactPureComponent$1.prototype = new ComponentDummy();
ReactPureComponent$1.prototype.constructor = ReactPureComponent$1;
// Avoid an extra prototype jump for these methods.
_assign$2(ReactPureComponent$1.prototype, ReactComponent$2.prototype);
ReactPureComponent$1.prototype.isPureReactComponent = true;

var ReactPureComponent_1 = ReactPureComponent$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

var ReactPropTypeLocationNames$1 = {};

{
  ReactPropTypeLocationNames$1 = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

var ReactPropTypeLocationNames_1 = ReactPropTypeLocationNames$1;

var _assign$3 = index$1;

var ReactComponent$3 = ReactComponent_1;
var ReactElement$3 = ReactElement_1;
var ReactPropTypeLocationNames = ReactPropTypeLocationNames_1;
var ReactNoopUpdateQueue$3 = ReactNoopUpdateQueue_1;

var emptyObject$3 = emptyObject_1;
var invariant$4 = invariant_1;
var warning$6 = warning_1;

var MIXINS_KEY = 'mixins';

// Helper function to allow the creation of anonymous functions which do not
// have .name set to the name of the variable being assigned to.
function identity(fn) {
  return fn;
}

/**
 * Policies that describe methods in `ReactClassInterface`.
 */


var injectedMixins = [];

/**
 * Composite components are higher-level components that compose other composite
 * or host components.
 *
 * To create a new type of `ReactClass`, pass a specification of
 * your new class to `React.createClass`. The only requirement of your class
 * specification is that you implement a `render` method.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return <div>Hello World</div>;
 *     }
 *   });
 *
 * The class specification supports a specific protocol of methods that have
 * special meaning (e.g. `render`). See `ReactClassInterface` for
 * more the comprehensive protocol. Any other properties and methods in the
 * class specification will be available on the prototype.
 *
 * @interface ReactClassInterface
 * @internal
 */
var ReactClassInterface = {

  /**
   * An array of Mixin objects to include when defining your component.
   *
   * @type {array}
   * @optional
   */
  mixins: 'DEFINE_MANY',

  /**
   * An object containing properties and methods that should be defined on
   * the component's constructor instead of its prototype (static methods).
   *
   * @type {object}
   * @optional
   */
  statics: 'DEFINE_MANY',

  /**
   * Definition of prop types for this component.
   *
   * @type {object}
   * @optional
   */
  propTypes: 'DEFINE_MANY',

  /**
   * Definition of context types for this component.
   *
   * @type {object}
   * @optional
   */
  contextTypes: 'DEFINE_MANY',

  /**
   * Definition of context types this component sets for its children.
   *
   * @type {object}
   * @optional
   */
  childContextTypes: 'DEFINE_MANY',

  // ==== Definition methods ====

  /**
   * Invoked when the component is mounted. Values in the mapping will be set on
   * `this.props` if that prop is not specified (i.e. using an `in` check).
   *
   * This method is invoked before `getInitialState` and therefore cannot rely
   * on `this.state` or use `this.setState`.
   *
   * @return {object}
   * @optional
   */
  getDefaultProps: 'DEFINE_MANY_MERGED',

  /**
   * Invoked once before the component is mounted. The return value will be used
   * as the initial value of `this.state`.
   *
   *   getInitialState: function() {
   *     return {
   *       isOn: false,
   *       fooBaz: new BazFoo()
   *     }
   *   }
   *
   * @return {object}
   * @optional
   */
  getInitialState: 'DEFINE_MANY_MERGED',

  /**
   * @return {object}
   * @optional
   */
  getChildContext: 'DEFINE_MANY_MERGED',

  /**
   * Uses props from `this.props` and state from `this.state` to render the
   * structure of the component.
   *
   * No guarantees are made about when or how often this method is invoked, so
   * it must not have side effects.
   *
   *   render: function() {
   *     var name = this.props.name;
   *     return <div>Hello, {name}!</div>;
   *   }
   *
   * @return {ReactComponent}
   * @nosideeffects
   * @required
   */
  render: 'DEFINE_ONCE',

  // ==== Delegate methods ====

  /**
   * Invoked when the component is initially created and about to be mounted.
   * This may have side effects, but any external subscriptions or data created
   * by this method must be cleaned up in `componentWillUnmount`.
   *
   * @optional
   */
  componentWillMount: 'DEFINE_MANY',

  /**
   * Invoked when the component has been mounted and has a DOM representation.
   * However, there is no guarantee that the DOM node is in the document.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been mounted (initialized and rendered) for the first time.
   *
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidMount: 'DEFINE_MANY',

  /**
   * Invoked before the component receives new props.
   *
   * Use this as an opportunity to react to a prop transition by updating the
   * state using `this.setState`. Current props are accessed via `this.props`.
   *
   *   componentWillReceiveProps: function(nextProps, nextContext) {
   *     this.setState({
   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
   *     });
   *   }
   *
   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
   * transition may cause a state change, but the opposite is not true. If you
   * need it, you are probably looking for `componentWillUpdate`.
   *
   * @param {object} nextProps
   * @optional
   */
  componentWillReceiveProps: 'DEFINE_MANY',

  /**
   * Invoked while deciding if the component should be updated as a result of
   * receiving new props, state and/or context.
   *
   * Use this as an opportunity to `return false` when you're certain that the
   * transition to the new props/state/context will not require a component
   * update.
   *
   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
   *     return !equal(nextProps, this.props) ||
   *       !equal(nextState, this.state) ||
   *       !equal(nextContext, this.context);
   *   }
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @return {boolean} True if the component should update.
   * @optional
   */
  shouldComponentUpdate: 'DEFINE_ONCE',

  /**
   * Invoked when the component is about to update due to a transition from
   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
   * and `nextContext`.
   *
   * Use this as an opportunity to perform preparation before an update occurs.
   *
   * NOTE: You **cannot** use `this.setState()` in this method.
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @param {ReactReconcileTransaction} transaction
   * @optional
   */
  componentWillUpdate: 'DEFINE_MANY',

  /**
   * Invoked when the component's DOM representation has been updated.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been updated.
   *
   * @param {object} prevProps
   * @param {?object} prevState
   * @param {?object} prevContext
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidUpdate: 'DEFINE_MANY',

  /**
   * Invoked when the component is about to be removed from its parent and have
   * its DOM representation destroyed.
   *
   * Use this as an opportunity to deallocate any external resources.
   *
   * NOTE: There is no `componentDidUnmount` since your component will have been
   * destroyed by that point.
   *
   * @optional
   */
  componentWillUnmount: 'DEFINE_MANY',

  // ==== Advanced methods ====

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   * @overridable
   */
  updateComponent: 'OVERRIDE_BASE'

};

/**
 * Mapping from class specification keys to special processing functions.
 *
 * Although these are declared like instance properties in the specification
 * when defining classes using `React.createClass`, they are actually static
 * and are accessible on the constructor instead of the prototype. Despite
 * being static, they must be defined outside of the "statics" key under
 * which all other static methods are defined.
 */
var RESERVED_SPEC_KEYS = {
  displayName: function (Constructor, displayName) {
    Constructor.displayName = displayName;
  },
  mixins: function (Constructor, mixins) {
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        mixSpecIntoComponent(Constructor, mixins[i]);
      }
    }
  },
  childContextTypes: function (Constructor, childContextTypes) {
    {
      validateTypeDef(Constructor, childContextTypes, 'childContext');
    }
    Constructor.childContextTypes = _assign$3({}, Constructor.childContextTypes, childContextTypes);
  },
  contextTypes: function (Constructor, contextTypes) {
    {
      validateTypeDef(Constructor, contextTypes, 'context');
    }
    Constructor.contextTypes = _assign$3({}, Constructor.contextTypes, contextTypes);
  },
  /**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */
  getDefaultProps: function (Constructor, getDefaultProps) {
    if (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
    } else {
      Constructor.getDefaultProps = getDefaultProps;
    }
  },
  propTypes: function (Constructor, propTypes) {
    {
      validateTypeDef(Constructor, propTypes, 'prop');
    }
    Constructor.propTypes = _assign$3({}, Constructor.propTypes, propTypes);
  },
  statics: function (Constructor, statics) {
    mixStaticSpecIntoComponent(Constructor, statics);
  },
  autobind: function () {} };

function validateTypeDef(Constructor, typeDef, location) {
  for (var propName in typeDef) {
    if (typeDef.hasOwnProperty(propName)) {
      // use a warning instead of an invariant so components
      // don't show up in prod but only in __DEV__
      warning$6(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName);
    }
  }
}

function validateMethodOverride(isAlreadyDefined, name) {
  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

  // Disallow overriding of base class methods unless explicitly allowed.
  if (ReactClassMixin.hasOwnProperty(name)) {
    !(specPolicy === 'OVERRIDE_BASE') ? invariant$4(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : void 0;
  }

  // Disallow defining methods more than once unless explicitly allowed.
  if (isAlreadyDefined) {
    !(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED') ? invariant$4(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : void 0;
  }
}

/**
 * Mixin helper which handles policy validation and reserved
 * specification keys when building React classes.
 */
function mixSpecIntoComponent(Constructor, spec) {
  if (!spec) {
    {
      var typeofSpec = typeof spec;
      var isMixinValid = typeofSpec === 'object' && spec !== null;

      warning$6(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec);
    }

    return;
  }

  !(typeof spec !== 'function') ? invariant$4(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : void 0;
  !!ReactElement$3.isValidElement(spec) ? invariant$4(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : void 0;

  var proto = Constructor.prototype;
  var autoBindPairs = proto.__reactAutoBindPairs;

  // By handling mixins before any other properties, we ensure the same
  // chaining order is applied to methods with DEFINE_MANY policy, whether
  // mixins are listed before or after these methods in the spec.
  if (spec.hasOwnProperty(MIXINS_KEY)) {
    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
  }

  for (var name in spec) {
    if (!spec.hasOwnProperty(name)) {
      continue;
    }

    if (name === MIXINS_KEY) {
      // We have already handled mixins in a special case above.
      continue;
    }

    var property = spec[name];
    var isAlreadyDefined = proto.hasOwnProperty(name);
    validateMethodOverride(isAlreadyDefined, name);

    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } else {
      // Setup methods on prototype:
      // The following member methods should not be automatically bound:
      // 1. Expected ReactClass methods (in the "interface").
      // 2. Overridden methods (that were mixed in).
      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
      var isFunction = typeof property === 'function';
      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

      if (shouldAutoBind) {
        autoBindPairs.push(name, property);
        proto[name] = property;
      } else {
        if (isAlreadyDefined) {
          var specPolicy = ReactClassInterface[name];

          // These cases should already be caught by validateMethodOverride.
          !(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY')) ? invariant$4(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : void 0;

          // For methods which are defined more than once, call the existing
          // methods before calling the new property, merging if appropriate.
          if (specPolicy === 'DEFINE_MANY_MERGED') {
            proto[name] = createMergedResultFunction(proto[name], property);
          } else if (specPolicy === 'DEFINE_MANY') {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } else {
          proto[name] = property;
          {
            // Add verbose displayName to the function, which helps when looking
            // at profiling tools.
            if (typeof property === 'function' && spec.displayName) {
              proto[name].displayName = spec.displayName + '_' + name;
            }
          }
        }
      }
    }
  }
}

function mixStaticSpecIntoComponent(Constructor, statics) {
  if (!statics) {
    return;
  }
  for (var name in statics) {
    var property = statics[name];
    if (!statics.hasOwnProperty(name)) {
      continue;
    }

    var isReserved = name in RESERVED_SPEC_KEYS;
    !!isReserved ? invariant$4(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : void 0;

    var isInherited = name in Constructor;
    !!isInherited ? invariant$4(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : void 0;
    Constructor[name] = property;
  }
}

/**
 * Merge two objects, but throw if both contain the same key.
 *
 * @param {object} one The first object, which is mutated.
 * @param {object} two The second object
 * @return {object} one after it has been mutated to contain everything in two.
 */
function mergeIntoWithNoDuplicateKeys(one, two) {
  !(one && two && typeof one === 'object' && typeof two === 'object') ? invariant$4(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : void 0;

  for (var key in two) {
    if (two.hasOwnProperty(key)) {
      !(one[key] === undefined) ? invariant$4(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : void 0;
      one[key] = two[key];
    }
  }
  return one;
}

/**
 * Creates a function that invokes two functions and merges their return values.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createMergedResultFunction(one, two) {
  return function mergedResult() {
    var a = one.apply(this, arguments);
    var b = two.apply(this, arguments);
    if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    }
    var c = {};
    mergeIntoWithNoDuplicateKeys(c, a);
    mergeIntoWithNoDuplicateKeys(c, b);
    return c;
  };
}

/**
 * Creates a function that invokes two functions and ignores their return vales.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createChainedFunction(one, two) {
  return function chainedFunction() {
    one.apply(this, arguments);
    two.apply(this, arguments);
  };
}

/**
 * Binds a method to the component.
 *
 * @param {object} component Component whose method is going to be bound.
 * @param {function} method Method to be bound.
 * @return {function} The bound method.
 */
function bindAutoBindMethod(component, method) {
  var boundMethod = method.bind(component);
  {
    boundMethod.__reactBoundContext = component;
    boundMethod.__reactBoundMethod = method;
    boundMethod.__reactBoundArguments = null;
    var componentName = component.constructor.displayName;
    var _bind = boundMethod.bind;
    boundMethod.bind = function (newThis) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      // User is trying to bind() an autobound method; we effectively will
      // ignore the value of "this" that the user is trying to use, so
      // let's warn.
      if (newThis !== component && newThis !== null) {
        warning$6(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName);
      } else if (!args.length) {
        warning$6(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName);
        return boundMethod;
      }
      var reboundMethod = _bind.apply(boundMethod, arguments);
      reboundMethod.__reactBoundContext = component;
      reboundMethod.__reactBoundMethod = method;
      reboundMethod.__reactBoundArguments = args;
      return reboundMethod;
    };
  }
  return boundMethod;
}

/**
 * Binds all auto-bound methods in a component.
 *
 * @param {object} component Component whose method is going to be bound.
 */
function bindAutoBindMethods(component) {
  var pairs = component.__reactAutoBindPairs;
  for (var i = 0; i < pairs.length; i += 2) {
    var autoBindKey = pairs[i];
    var method = pairs[i + 1];
    component[autoBindKey] = bindAutoBindMethod(component, method);
  }
}

/**
 * Add more to the ReactClass base class. These are all legacy features and
 * therefore not already part of the modern ReactComponent.
 */
var ReactClassMixin = {

  /**
   * TODO: This will be deprecated because state should always keep a consistent
   * type signature and the only use case for this, is to avoid that.
   */
  replaceState: function (newState, callback) {
    this.updater.enqueueReplaceState(this, newState);
    if (callback) {
      this.updater.enqueueCallback(this, callback, 'replaceState');
    }
  },

  /**
   * Checks whether or not this composite component is mounted.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function () {
    return this.updater.isMounted(this);
  }
};

var ReactClassComponent = function () {};
_assign$3(ReactClassComponent.prototype, ReactComponent$3.prototype, ReactClassMixin);

/**
 * Module for creating composite components.
 *
 * @class ReactClass
 */
var ReactClass$1 = {

  /**
   * Creates a composite component class given a class specification.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  createClass: function (spec) {
    // To keep our warnings more understandable, we'll use a little hack here to
    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
    // unnecessarily identify a class without displayName as 'Constructor'.
    var Constructor = identity(function (props, context, updater) {
      // This constructor gets overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      {
        warning$6(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory');
      }

      // Wire up auto-binding
      if (this.__reactAutoBindPairs.length) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject$3;
      this.updater = updater || ReactNoopUpdateQueue$3;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      {
        // We allow auto-mocks to proceed as if they're returning null.
        if (initialState === undefined && this.getInitialState._isMockFunction) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? invariant$4(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : void 0;

      this.state = initialState;
    });
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;
    Constructor.prototype.__reactAutoBindPairs = [];

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, spec);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    !Constructor.prototype.render ? invariant$4(false, 'createClass(...): Class specification must implement a `render` method.') : void 0;

    {
      warning$6(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component');
      warning$6(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component');
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  },

  injection: {
    injectMixin: function (mixin) {
      injectedMixins.push(mixin);
    }
  }

};

var ReactClass_1 = ReactClass$1;

var ReactCurrentOwner$4 = ReactCurrentOwner_1;

var invariant$5 = invariant_1;
var warning$8 = warning_1;

function isNative(fn) {
  // Based on isNative() from Lodash
  var funcToString = Function.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var reIsNative = RegExp('^' + funcToString
  // Take an example native function source for comparison
  .call(hasOwnProperty)
  // Strip regex characters so we can use it for regex
  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  // Remove hasOwnProperty from the template to make it generic
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  try {
    var source = funcToString.call(fn);
    return reIsNative.test(source);
  } catch (err) {
    return false;
  }
}

var canUseCollections =
// Array.from
typeof Array.from === 'function' &&
// Map
typeof Map === 'function' && isNative(Map) &&
// Map.prototype.keys
Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
// Set
typeof Set === 'function' && isNative(Set) &&
// Set.prototype.keys
Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);

var setItem;
var getItem;
var removeItem;
var getItemIDs;
var addRoot;
var removeRoot;
var getRootIDs;

if (canUseCollections) {
  var itemMap = new Map();
  var rootIDSet = new Set();

  setItem = function (id, item) {
    itemMap.set(id, item);
  };
  getItem = function (id) {
    return itemMap.get(id);
  };
  removeItem = function (id) {
    itemMap['delete'](id);
  };
  getItemIDs = function () {
    return Array.from(itemMap.keys());
  };

  addRoot = function (id) {
    rootIDSet.add(id);
  };
  removeRoot = function (id) {
    rootIDSet['delete'](id);
  };
  getRootIDs = function () {
    return Array.from(rootIDSet.keys());
  };
} else {
  var itemByKey = {};
  var rootByKey = {};

  // Use non-numeric keys to prevent V8 performance issues:
  // https://github.com/facebook/react/pull/7232
  var getKeyFromID = function (id) {
    return '.' + id;
  };
  var getIDFromKey = function (key) {
    return parseInt(key.substr(1), 10);
  };

  setItem = function (id, item) {
    var key = getKeyFromID(id);
    itemByKey[key] = item;
  };
  getItem = function (id) {
    var key = getKeyFromID(id);
    return itemByKey[key];
  };
  removeItem = function (id) {
    var key = getKeyFromID(id);
    delete itemByKey[key];
  };
  getItemIDs = function () {
    return Object.keys(itemByKey).map(getIDFromKey);
  };

  addRoot = function (id) {
    var key = getKeyFromID(id);
    rootByKey[key] = true;
  };
  removeRoot = function (id) {
    var key = getKeyFromID(id);
    delete rootByKey[key];
  };
  getRootIDs = function () {
    return Object.keys(rootByKey).map(getIDFromKey);
  };
}

var unmountedIDs = [];

function purgeDeep(id) {
  var item = getItem(id);
  if (item) {
    var childIDs = item.childIDs;

    removeItem(id);
    childIDs.forEach(purgeDeep);
  }
}

function describeComponentFrame(name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
}

function getDisplayName(element) {
  if (element == null) {
    return '#empty';
  } else if (typeof element === 'string' || typeof element === 'number') {
    return '#text';
  } else if (typeof element.type === 'string') {
    return element.type;
  } else {
    return element.type.displayName || element.type.name || 'Unknown';
  }
}

function describeID(id) {
  var name = ReactComponentTreeHook$1.getDisplayName(id);
  var element = ReactComponentTreeHook$1.getElement(id);
  var ownerID = ReactComponentTreeHook$1.getOwnerID(id);
  var ownerName;
  if (ownerID) {
    ownerName = ReactComponentTreeHook$1.getDisplayName(ownerID);
  }
  warning$8(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id);
  return describeComponentFrame(name, element && element._source, ownerName);
}

var ReactComponentTreeHook$1 = {
  onSetChildren: function (id, nextChildIDs) {
    var item = getItem(id);
    !item ? invariant$5(false, 'Item must have been set') : void 0;
    item.childIDs = nextChildIDs;

    for (var i = 0; i < nextChildIDs.length; i++) {
      var nextChildID = nextChildIDs[i];
      var nextChild = getItem(nextChildID);
      !nextChild ? invariant$5(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : void 0;
      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? invariant$5(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : void 0;
      !nextChild.isMounted ? invariant$5(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : void 0;
      if (nextChild.parentID == null) {
        nextChild.parentID = id;
        // TODO: This shouldn't be necessary but mounting a new root during in
        // componentWillMount currently causes not-yet-mounted components to
        // be purged from our tree data so their parent id is missing.
      }
      !(nextChild.parentID === id) ? invariant$5(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : void 0;
    }
  },
  onBeforeMountComponent: function (id, element, parentID) {
    var item = {
      element: element,
      parentID: parentID,
      text: null,
      childIDs: [],
      isMounted: false,
      updateCount: 0
    };
    setItem(id, item);
  },
  onBeforeUpdateComponent: function (id, element) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.element = element;
  },
  onMountComponent: function (id) {
    var item = getItem(id);
    !item ? invariant$5(false, 'Item must have been set') : void 0;
    item.isMounted = true;
    var isRoot = item.parentID === 0;
    if (isRoot) {
      addRoot(id);
    }
  },
  onUpdateComponent: function (id) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.updateCount++;
  },
  onUnmountComponent: function (id) {
    var item = getItem(id);
    if (item) {
      // We need to check if it exists.
      // `item` might not exist if it is inside an error boundary, and a sibling
      // error boundary child threw while mounting. Then this instance never
      // got a chance to mount, but it still gets an unmounting event during
      // the error boundary cleanup.
      item.isMounted = false;
      var isRoot = item.parentID === 0;
      if (isRoot) {
        removeRoot(id);
      }
    }
    unmountedIDs.push(id);
  },
  purgeUnmountedComponents: function () {
    if (ReactComponentTreeHook$1._preventPurging) {
      // Should only be used for testing.
      return;
    }

    for (var i = 0; i < unmountedIDs.length; i++) {
      var id = unmountedIDs[i];
      purgeDeep(id);
    }
    unmountedIDs.length = 0;
  },
  isMounted: function (id) {
    var item = getItem(id);
    return item ? item.isMounted : false;
  },
  getCurrentStackAddendum: function (topElement) {
    var info = '';
    if (topElement) {
      var name = getDisplayName(topElement);
      var owner = topElement._owner;
      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
    }

    var currentOwner = ReactCurrentOwner$4.current;
    var id = currentOwner && currentOwner._debugID;

    info += ReactComponentTreeHook$1.getStackAddendumByID(id);
    return info;
  },
  getStackAddendumByID: function (id) {
    var info = '';
    while (id) {
      info += describeID(id);
      id = ReactComponentTreeHook$1.getParentID(id);
    }
    return info;
  },
  getChildIDs: function (id) {
    var item = getItem(id);
    return item ? item.childIDs : [];
  },
  getDisplayName: function (id) {
    var element = ReactComponentTreeHook$1.getElement(id);
    if (!element) {
      return null;
    }
    return getDisplayName(element);
  },
  getElement: function (id) {
    var item = getItem(id);
    return item ? item.element : null;
  },
  getOwnerID: function (id) {
    var element = ReactComponentTreeHook$1.getElement(id);
    if (!element || !element._owner) {
      return null;
    }
    return element._owner._debugID;
  },
  getParentID: function (id) {
    var item = getItem(id);
    return item ? item.parentID : null;
  },
  getSource: function (id) {
    var item = getItem(id);
    var element = item ? item.element : null;
    var source = element != null ? element._source : null;
    return source;
  },
  getText: function (id) {
    var element = ReactComponentTreeHook$1.getElement(id);
    if (typeof element === 'string') {
      return element;
    } else if (typeof element === 'number') {
      return '' + element;
    } else {
      return null;
    }
  },
  getUpdateCount: function (id) {
    var item = getItem(id);
    return item ? item.updateCount : 0;
  },


  getRootIDs: getRootIDs,
  getRegisteredIDs: getItemIDs
};

var ReactComponentTreeHook_1 = ReactComponentTreeHook$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

var ReactPropTypesSecret$1 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;

var ReactPropTypeLocationNames$2 = ReactPropTypeLocationNames_1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;

var invariant$6 = invariant_1;
var warning$9 = warning_1;

var ReactComponentTreeHook$2;

if (typeof process !== 'undefined' && process.env && "development" === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook$2 = ReactComponentTreeHook_1;
}

var loggedTypeFailures = {};

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?object} element The React element that is being type-checked
 * @param {?number} debugID The React component instance that is being type-checked
 * @private
 */
function checkReactTypeSpec$1(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof typeSpecs[typeSpecName] === 'function') ? invariant$6(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames$2[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
      } catch (ex) {
        error = ex;
      }
      warning$9(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames$2[location], typeSpecName, typeof error);
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var componentStackInfo = '';

        {
          if (!ReactComponentTreeHook$2) {
            ReactComponentTreeHook$2 = ReactComponentTreeHook_1;
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook$2.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook$2.getCurrentStackAddendum(element);
          }
        }

        warning$9(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo);
      }
    }
  }
}

var checkReactTypeSpec_1 = checkReactTypeSpec$1;

var ReactCurrentOwner$3 = ReactCurrentOwner_1;
var ReactComponentTreeHook = ReactComponentTreeHook_1;
var ReactElement$5 = ReactElement_1;

var checkReactTypeSpec = checkReactTypeSpec_1;

var canDefineProperty$3 = canDefineProperty_1;
var getIteratorFn$2 = getIteratorFn_1;
var warning$7 = warning_1;

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner$3.current) {
    var name = ReactCurrentOwner$3.current.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = ' Check the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (memoizer[currentComponentErrorInfo]) {
    return;
  }
  memoizer[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner$3.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
  }

  warning$7(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element));
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (ReactElement$5.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement$5.isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn$2(node);
    // Entry iterators provide implicit keys.
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement$5.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  if (componentClass.propTypes) {
    checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    warning$7(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
  }
}

var ReactElementValidator$2 = {

  createElement: function (type, props, children) {
    var validType = typeof type === 'string' || typeof type === 'function';
    // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.
    if (!validType) {
      warning$7(false, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum());
    }

    var element = ReactElement$5.createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)
    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }

    validatePropTypes(element);

    return element;
  },

  createFactory: function (type) {
    var validatedFactory = ReactElementValidator$2.createElement.bind(null, type);
    // Legacy hook TODO: Warn if this is accessed
    validatedFactory.type = type;

    {
      if (canDefineProperty$3) {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function () {
            warning$7(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
    }

    return validatedFactory;
  },

  cloneElement: function (element, props, children) {
    var newElement = ReactElement$5.cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }

};

var ReactElementValidator_1 = ReactElementValidator$2;

var ReactElement$4 = ReactElement_1;

/**
 * Create a factory that creates HTML tag elements.
 *
 * @private
 */
var createDOMFactory = ReactElement$4.createFactory;
{
  var ReactElementValidator$1 = ReactElementValidator_1;
  createDOMFactory = ReactElementValidator$1.createFactory;
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 * This is also accessible via `React.DOM`.
 *
 * @public
 */
var ReactDOMFactories$1 = {
  a: createDOMFactory('a'),
  abbr: createDOMFactory('abbr'),
  address: createDOMFactory('address'),
  area: createDOMFactory('area'),
  article: createDOMFactory('article'),
  aside: createDOMFactory('aside'),
  audio: createDOMFactory('audio'),
  b: createDOMFactory('b'),
  base: createDOMFactory('base'),
  bdi: createDOMFactory('bdi'),
  bdo: createDOMFactory('bdo'),
  big: createDOMFactory('big'),
  blockquote: createDOMFactory('blockquote'),
  body: createDOMFactory('body'),
  br: createDOMFactory('br'),
  button: createDOMFactory('button'),
  canvas: createDOMFactory('canvas'),
  caption: createDOMFactory('caption'),
  cite: createDOMFactory('cite'),
  code: createDOMFactory('code'),
  col: createDOMFactory('col'),
  colgroup: createDOMFactory('colgroup'),
  data: createDOMFactory('data'),
  datalist: createDOMFactory('datalist'),
  dd: createDOMFactory('dd'),
  del: createDOMFactory('del'),
  details: createDOMFactory('details'),
  dfn: createDOMFactory('dfn'),
  dialog: createDOMFactory('dialog'),
  div: createDOMFactory('div'),
  dl: createDOMFactory('dl'),
  dt: createDOMFactory('dt'),
  em: createDOMFactory('em'),
  embed: createDOMFactory('embed'),
  fieldset: createDOMFactory('fieldset'),
  figcaption: createDOMFactory('figcaption'),
  figure: createDOMFactory('figure'),
  footer: createDOMFactory('footer'),
  form: createDOMFactory('form'),
  h1: createDOMFactory('h1'),
  h2: createDOMFactory('h2'),
  h3: createDOMFactory('h3'),
  h4: createDOMFactory('h4'),
  h5: createDOMFactory('h5'),
  h6: createDOMFactory('h6'),
  head: createDOMFactory('head'),
  header: createDOMFactory('header'),
  hgroup: createDOMFactory('hgroup'),
  hr: createDOMFactory('hr'),
  html: createDOMFactory('html'),
  i: createDOMFactory('i'),
  iframe: createDOMFactory('iframe'),
  img: createDOMFactory('img'),
  input: createDOMFactory('input'),
  ins: createDOMFactory('ins'),
  kbd: createDOMFactory('kbd'),
  keygen: createDOMFactory('keygen'),
  label: createDOMFactory('label'),
  legend: createDOMFactory('legend'),
  li: createDOMFactory('li'),
  link: createDOMFactory('link'),
  main: createDOMFactory('main'),
  map: createDOMFactory('map'),
  mark: createDOMFactory('mark'),
  menu: createDOMFactory('menu'),
  menuitem: createDOMFactory('menuitem'),
  meta: createDOMFactory('meta'),
  meter: createDOMFactory('meter'),
  nav: createDOMFactory('nav'),
  noscript: createDOMFactory('noscript'),
  object: createDOMFactory('object'),
  ol: createDOMFactory('ol'),
  optgroup: createDOMFactory('optgroup'),
  option: createDOMFactory('option'),
  output: createDOMFactory('output'),
  p: createDOMFactory('p'),
  param: createDOMFactory('param'),
  picture: createDOMFactory('picture'),
  pre: createDOMFactory('pre'),
  progress: createDOMFactory('progress'),
  q: createDOMFactory('q'),
  rp: createDOMFactory('rp'),
  rt: createDOMFactory('rt'),
  ruby: createDOMFactory('ruby'),
  s: createDOMFactory('s'),
  samp: createDOMFactory('samp'),
  script: createDOMFactory('script'),
  section: createDOMFactory('section'),
  select: createDOMFactory('select'),
  small: createDOMFactory('small'),
  source: createDOMFactory('source'),
  span: createDOMFactory('span'),
  strong: createDOMFactory('strong'),
  style: createDOMFactory('style'),
  sub: createDOMFactory('sub'),
  summary: createDOMFactory('summary'),
  sup: createDOMFactory('sup'),
  table: createDOMFactory('table'),
  tbody: createDOMFactory('tbody'),
  td: createDOMFactory('td'),
  textarea: createDOMFactory('textarea'),
  tfoot: createDOMFactory('tfoot'),
  th: createDOMFactory('th'),
  thead: createDOMFactory('thead'),
  time: createDOMFactory('time'),
  title: createDOMFactory('title'),
  tr: createDOMFactory('tr'),
  track: createDOMFactory('track'),
  u: createDOMFactory('u'),
  ul: createDOMFactory('ul'),
  'var': createDOMFactory('var'),
  video: createDOMFactory('video'),
  wbr: createDOMFactory('wbr'),

  // SVG
  circle: createDOMFactory('circle'),
  clipPath: createDOMFactory('clipPath'),
  defs: createDOMFactory('defs'),
  ellipse: createDOMFactory('ellipse'),
  g: createDOMFactory('g'),
  image: createDOMFactory('image'),
  line: createDOMFactory('line'),
  linearGradient: createDOMFactory('linearGradient'),
  mask: createDOMFactory('mask'),
  path: createDOMFactory('path'),
  pattern: createDOMFactory('pattern'),
  polygon: createDOMFactory('polygon'),
  polyline: createDOMFactory('polyline'),
  radialGradient: createDOMFactory('radialGradient'),
  rect: createDOMFactory('rect'),
  stop: createDOMFactory('stop'),
  svg: createDOMFactory('svg'),
  text: createDOMFactory('text'),
  tspan: createDOMFactory('tspan')
};

var ReactDOMFactories_1 = ReactDOMFactories$1;

var ReactElement$6 = ReactElement_1;
var ReactPropTypeLocationNames$3 = ReactPropTypeLocationNames_1;
var ReactPropTypesSecret$2 = ReactPropTypesSecret_1;

var emptyFunction$3 = emptyFunction_1;
var getIteratorFn$3 = getIteratorFn_1;
var warning$10 = warning_1;

/**
 * Collection of methods that allow declaration and validation of props that are
 * supplied to React components. Example usage:
 *
 *   var Props = require('ReactPropTypes');
 *   var MyArticle = React.createClass({
 *     propTypes: {
 *       // An optional string prop named "description".
 *       description: Props.string,
 *
 *       // A required enum prop named "category".
 *       category: Props.oneOf(['News','Photos']).isRequired,
 *
 *       // A prop named "dialog" that requires an instance of Dialog.
 *       dialog: Props.instanceOf(Dialog).isRequired
 *     },
 *     render: function() { ... }
 *   });
 *
 * A more formal specification of how these methods are used:
 *
 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
 *   decl := ReactPropTypes.{type}(.isRequired)?
 *
 * Each and every declaration produces a function with the same signature. This
 * allows the creation of custom validation functions. For example:
 *
 *  var MyLink = React.createClass({
 *    propTypes: {
 *      // An optional string or URI prop named "href".
 *      href: function(props, propName, componentName) {
 *        var propValue = props[propName];
 *        if (propValue != null && typeof propValue !== 'string' &&
 *            !(propValue instanceof URI)) {
 *          return new Error(
 *            'Expected a string or an URI for ' + propName + ' in ' +
 *            componentName
 *          );
 *        }
 *      }
 *    },
 *    render: function() {...}
 *  });
 *
 * @internal
 */

var ANONYMOUS = '<<anonymous>>';

var ReactPropTypes$1 = {
  array: createPrimitiveTypeChecker('array'),
  bool: createPrimitiveTypeChecker('boolean'),
  func: createPrimitiveTypeChecker('function'),
  number: createPrimitiveTypeChecker('number'),
  object: createPrimitiveTypeChecker('object'),
  string: createPrimitiveTypeChecker('string'),
  symbol: createPrimitiveTypeChecker('symbol'),

  any: createAnyTypeChecker(),
  arrayOf: createArrayOfTypeChecker,
  element: createElementTypeChecker(),
  instanceOf: createInstanceTypeChecker,
  node: createNodeChecker(),
  objectOf: createObjectOfTypeChecker,
  oneOf: createEnumTypeChecker,
  oneOfType: createUnionTypeChecker,
  shape: createShapeTypeChecker
};

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
/*eslint-disable no-self-compare*/
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return x !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}
/*eslint-enable no-self-compare*/

/**
 * We use an Error-like object for backward compatibility as people may call
 * PropTypes directly and inspect their output. However we don't use real
 * Errors anymore. We don't inspect their stack anyway, and creating them
 * is prohibitively expensive if they are created too often, such as what
 * happens in oneOfType() for any type before the one that matched.
 */
function PropTypeError(message) {
  this.message = message;
  this.stack = '';
}
// Make `instanceof Error` still work for returned errors.
PropTypeError.prototype = Error.prototype;

function createChainableTypeChecker(validate) {
  {
    var manualPropTypeCallCache = {};
  }
  function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
    componentName = componentName || ANONYMOUS;
    propFullName = propFullName || propName;
    {
      if (secret !== ReactPropTypesSecret$2 && typeof console !== 'undefined') {
        var cacheKey = componentName + ':' + propName;
        if (!manualPropTypeCallCache[cacheKey]) {
          warning$10(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in production with the next major version. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName);
          manualPropTypeCallCache[cacheKey] = true;
        }
      }
    }
    if (props[propName] == null) {
      var locationName = ReactPropTypeLocationNames$3[location];
      if (isRequired) {
        if (props[propName] === null) {
          return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
        }
        return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
      }
      return null;
    } else {
      return validate(props, propName, componentName, location, propFullName);
    }
  }

  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);

  return chainedCheckType;
}

function createPrimitiveTypeChecker(expectedType) {
  function validate(props, propName, componentName, location, propFullName, secret) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== expectedType) {
      var locationName = ReactPropTypeLocationNames$3[location];
      // `propValue` being instance of, say, date/regexp, pass the 'object'
      // check, but we can offer a more precise error message here rather than
      // 'of type `object`'.
      var preciseType = getPreciseType(propValue);

      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createAnyTypeChecker() {
  return createChainableTypeChecker(emptyFunction$3.thatReturns(null));
}

function createArrayOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    if (typeof typeChecker !== 'function') {
      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
    }
    var propValue = props[propName];
    if (!Array.isArray(propValue)) {
      var locationName = ReactPropTypeLocationNames$3[location];
      var propType = getPropType(propValue);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
    }
    for (var i = 0; i < propValue.length; i++) {
      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret$2);
      if (error instanceof Error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createElementTypeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    if (!ReactElement$6.isValidElement(propValue)) {
      var locationName = ReactPropTypeLocationNames$3[location];
      var propType = getPropType(propValue);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createInstanceTypeChecker(expectedClass) {
  function validate(props, propName, componentName, location, propFullName) {
    if (!(props[propName] instanceof expectedClass)) {
      var locationName = ReactPropTypeLocationNames$3[location];
      var expectedClassName = expectedClass.name || ANONYMOUS;
      var actualClassName = getClassName(props[propName]);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createEnumTypeChecker(expectedValues) {
  if (!Array.isArray(expectedValues)) {
    warning$10(false, 'Invalid argument supplied to oneOf, expected an instance of array.');
    return emptyFunction$3.thatReturnsNull;
  }

  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    for (var i = 0; i < expectedValues.length; i++) {
      if (is(propValue, expectedValues[i])) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames$3[location];
    var valuesString = JSON.stringify(expectedValues);
    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
  }
  return createChainableTypeChecker(validate);
}

function createObjectOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    if (typeof typeChecker !== 'function') {
      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
    }
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames$3[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
    }
    for (var key in propValue) {
      if (propValue.hasOwnProperty(key)) {
        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret$2);
        if (error instanceof Error) {
          return error;
        }
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createUnionTypeChecker(arrayOfTypeCheckers) {
  if (!Array.isArray(arrayOfTypeCheckers)) {
    warning$10(false, 'Invalid argument supplied to oneOfType, expected an instance of array.');
    return emptyFunction$3.thatReturnsNull;
  }

  function validate(props, propName, componentName, location, propFullName) {
    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret$2) == null) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames$3[location];
    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
  }
  return createChainableTypeChecker(validate);
}

function createNodeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!isNode(props[propName])) {
      var locationName = ReactPropTypeLocationNames$3[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createShapeTypeChecker(shapeTypes) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames$3[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
    }
    for (var key in shapeTypes) {
      var checker = shapeTypes[key];
      if (!checker) {
        continue;
      }
      var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret$2);
      if (error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function isNode(propValue) {
  switch (typeof propValue) {
    case 'number':
    case 'string':
    case 'undefined':
      return true;
    case 'boolean':
      return !propValue;
    case 'object':
      if (Array.isArray(propValue)) {
        return propValue.every(isNode);
      }
      if (propValue === null || ReactElement$6.isValidElement(propValue)) {
        return true;
      }

      var iteratorFn = getIteratorFn$3(propValue);
      if (iteratorFn) {
        var iterator = iteratorFn.call(propValue);
        var step;
        if (iteratorFn !== propValue.entries) {
          while (!(step = iterator.next()).done) {
            if (!isNode(step.value)) {
              return false;
            }
          }
        } else {
          // Iterator will provide entry [k,v] tuples rather than values.
          while (!(step = iterator.next()).done) {
            var entry = step.value;
            if (entry) {
              if (!isNode(entry[1])) {
                return false;
              }
            }
          }
        }
      } else {
        return false;
      }

      return true;
    default:
      return false;
  }
}

function isSymbol(propType, propValue) {
  // Native Symbol.
  if (propType === 'symbol') {
    return true;
  }

  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
  if (propValue['@@toStringTag'] === 'Symbol') {
    return true;
  }

  // Fallback for non-spec compliant Symbols which are polyfilled.
  if (typeof Symbol === 'function' && propValue instanceof Symbol) {
    return true;
  }

  return false;
}

// Equivalent of `typeof` but with special handling for array and regexp.
function getPropType(propValue) {
  var propType = typeof propValue;
  if (Array.isArray(propValue)) {
    return 'array';
  }
  if (propValue instanceof RegExp) {
    // Old webkits (at least until Android 4.0) return 'function' rather than
    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
    // passes PropTypes.object.
    return 'object';
  }
  if (isSymbol(propType, propValue)) {
    return 'symbol';
  }
  return propType;
}

// This handles more types than `getPropType`. Only used for error messages.
// See `createPrimitiveTypeChecker`.
function getPreciseType(propValue) {
  var propType = getPropType(propValue);
  if (propType === 'object') {
    if (propValue instanceof Date) {
      return 'date';
    } else if (propValue instanceof RegExp) {
      return 'regexp';
    }
  }
  return propType;
}

// Returns class name of the object, if any.
function getClassName(propValue) {
  if (!propValue.constructor || !propValue.constructor.name) {
    return ANONYMOUS;
  }
  return propValue.constructor.name;
}

var ReactPropTypes_1 = ReactPropTypes$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

var ReactVersion$1 = '15.4.1';

var ReactElement$7 = ReactElement_1;

var invariant$7 = invariant_1;

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild$1(children) {
  !ReactElement$7.isValidElement(children) ? invariant$7(false, 'React.Children.only expected to receive a single React element child.') : void 0;
  return children;
}

var onlyChild_1 = onlyChild$1;

var _assign = index$1;

var ReactChildren = ReactChildren_1;
var ReactComponent = ReactComponent_1;
var ReactPureComponent = ReactPureComponent_1;
var ReactClass = ReactClass_1;
var ReactDOMFactories = ReactDOMFactories_1;
var ReactElement = ReactElement_1;
var ReactPropTypes = ReactPropTypes_1;
var ReactVersion = ReactVersion$1;

var onlyChild = onlyChild_1;
var warning = warning_1;

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;

{
  var ReactElementValidator = ReactElementValidator_1;
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
  cloneElement = ReactElementValidator.cloneElement;
}

var __spread = _assign;

{
  var warned = false;
  __spread = function () {
    warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.');
    warned = true;
    return _assign.apply(null, arguments);
  };
}

var React$1 = {

  // Modern

  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    toArray: ReactChildren.toArray,
    only: onlyChild
  },

  Component: ReactComponent,
  PureComponent: ReactPureComponent,

  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,

  // Classic

  PropTypes: ReactPropTypes,
  createClass: ReactClass.createClass,
  createFactory: createFactory,
  createMixin: function (mixin) {
    // Currently a noop. Will be used to validate and trace mixins.
    return mixin;
  },

  // This looks DOM specific but these are actually isomorphic helpers
  // since they are just generating DOM strings.
  DOM: ReactDOMFactories,

  version: ReactVersion,

  // Deprecated hook for JSX spread, don't use this for anything.
  __spread: __spread
};

var React_1 = React$1;

var react = React_1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

var invariant$9 = invariant_1;

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_PROPERTY: 0x1,
  HAS_BOOLEAN_VALUE: 0x4,
  HAS_NUMERIC_VALUE: 0x8,
  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * isCustomAttribute: function that given an attribute name will return true
   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
   * attributes where it's impossible to enumerate all of the possible
   * attribute names,
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    if (domPropertyConfig.isCustomAttribute) {
      DOMProperty$1._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
    }

    for (var propName in Properties) {
      !!DOMProperty$1.properties.hasOwnProperty(propName) ? invariant$9(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : void 0;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
      };
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? invariant$9(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : void 0;

      {
        DOMProperty$1.getPossibleStandardName[lowerCased] = propName;
      }

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];
        propertyInfo.attributeName = attributeName;
        {
          DOMProperty$1.getPossibleStandardName[attributeName] = propName;
        }
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMPropertyNames.hasOwnProperty(propName)) {
        propertyInfo.propertyName = DOMPropertyNames[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      DOMProperty$1.properties[propName] = propertyInfo;
    }
  }
};

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
/* eslint-enable max-len */

/**
 * DOMProperty exports lookup objects that can be used like functions:
 *
 *   > DOMProperty.isValid['id']
 *   true
 *   > DOMProperty.isValid['foobar']
 *   undefined
 *
 * Although this may be confusing, it performs better in general.
 *
 * @see http://jsperf.com/key-exists
 * @see http://jsperf.com/key-missing
 */
var DOMProperty$1 = {

  ID_ATTRIBUTE_NAME: 'data-reactid',
  ROOT_ATTRIBUTE_NAME: 'data-reactroot',

  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',

  /**
   * Map from property "standard name" to an object with info about how to set
   * the property in the DOM. Each object contains:
   *
   * attributeName:
   *   Used when rendering markup or with `*Attribute()`.
   * attributeNamespace
   * propertyName:
   *   Used on DOM node instances. (This includes properties that mutate due to
   *   external factors.)
   * mutationMethod:
   *   If non-null, used instead of the property or `setAttribute()` after
   *   initial render.
   * mustUseProperty:
   *   Whether the property must be accessed and mutated as an object property.
   * hasBooleanValue:
   *   Whether the property should be removed when set to a falsey value.
   * hasNumericValue:
   *   Whether the property must be numeric or parse as a numeric and should be
   *   removed when set to a falsey value.
   * hasPositiveNumericValue:
   *   Whether the property must be positive numeric or parse as a positive
   *   numeric and should be removed when set to a falsey value.
   * hasOverloadedBooleanValue:
   *   Whether the property can be used as a flag as well as with a value.
   *   Removed when strictly equal to false; present without a value when
   *   strictly equal to true; present with a value otherwise.
   */
  properties: {},

  /**
   * Mapping from lowercase property names to the properly cased version, used
   * to warn in the case of missing properties. Available only in __DEV__.
   *
   * autofocus is predefined, because adding it to the property whitelist
   * causes unintended side effects.
   *
   * @type {Object}
   */
  getPossibleStandardName: { autofocus: 'autoFocus' },

  /**
   * All of the isCustomAttribute() functions that have been injected.
   */
  _isCustomAttributeFunctions: [],

  /**
   * Checks whether a property name is a custom attribute.
   * @method
   */
  isCustomAttribute: function (attributeName) {
    for (var i = 0; i < DOMProperty$1._isCustomAttributeFunctions.length; i++) {
      var isCustomAttributeFn = DOMProperty$1._isCustomAttributeFunctions[i];
      if (isCustomAttributeFn(attributeName)) {
        return true;
      }
    }
    return false;
  },

  injection: DOMPropertyInjection
};

var DOMProperty_1 = DOMProperty$1;

/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

var ReactDOMComponentFlags$1 = {
  hasCachedChildNodes: 1 << 0
};

var ReactDOMComponentFlags_1 = ReactDOMComponentFlags$1;

var DOMProperty = DOMProperty_1;
var ReactDOMComponentFlags = ReactDOMComponentFlags_1;

var invariant$8 = invariant_1;

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var Flags = ReactDOMComponentFlags;

var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);

/**
 * Drill down (through composites and empty components) until we get a host or
 * host text component.
 *
 * This is pretty polymorphic but unavoidable with the current structure we have
 * for `_renderedChildren`.
 */
function getRenderedHostOrTextFromComponent(component) {
  var rendered;
  while (rendered = component._renderedComponent) {
    component = rendered;
  }
  return component;
}

/**
 * Populate `_hostNode` on the rendered host/text component with the given
 * DOM node. The passed `inst` can be a composite.
 */
function precacheNode(inst, node) {
  var hostInst = getRenderedHostOrTextFromComponent(inst);
  hostInst._hostNode = node;
  node[internalInstanceKey] = hostInst;
}

function uncacheNode(inst) {
  var node = inst._hostNode;
  if (node) {
    delete node[internalInstanceKey];
    inst._hostNode = null;
  }
}

/**
 * Populate `_hostNode` on each child of `inst`, assuming that the children
 * match up with the DOM (element) children of `node`.
 *
 * We cache entire levels at once to avoid an n^2 problem where we access the
 * children of a node sequentially and have to walk from the start to our target
 * node every time.
 *
 * Since we update `_renderedChildren` and the actual DOM at (slightly)
 * different times, we could race here and see a newer `_renderedChildren` than
 * the DOM nodes we see. To avoid this, ReactMultiChild calls
 * `prepareToManageChildren` before we change `_renderedChildren`, at which
 * time the container's child nodes are always cached (until it unmounts).
 */
function precacheChildNodes(inst, node) {
  if (inst._flags & Flags.hasCachedChildNodes) {
    return;
  }
  var children = inst._renderedChildren;
  var childNode = node.firstChild;
  outer: for (var name in children) {
    if (!children.hasOwnProperty(name)) {
      continue;
    }
    var childInst = children[name];
    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
    if (childID === 0) {
      // We're currently unmounting this child in ReactMultiChild; skip it.
      continue;
    }
    // We assume the child nodes are in the same order as the child instances.
    for (; childNode !== null; childNode = childNode.nextSibling) {
      if (childNode.nodeType === 1 && childNode.getAttribute(ATTR_NAME) === String(childID) || childNode.nodeType === 8 && childNode.nodeValue === ' react-text: ' + childID + ' ' || childNode.nodeType === 8 && childNode.nodeValue === ' react-empty: ' + childID + ' ') {
        precacheNode(childInst, childNode);
        continue outer;
      }
    }
    // We reached the end of the DOM children without finding an ID match.
    invariant$8(false, 'Unable to find element with ID %s.', childID);
  }
  inst._flags |= Flags.hasCachedChildNodes;
}

/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */
function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  // Walk up the tree until we find an ancestor whose instance we have cached.
  var parents = [];
  while (!node[internalInstanceKey]) {
    parents.push(node);
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var closest;
  var inst;
  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
    closest = inst;
    if (parents.length) {
      precacheChildNodes(inst, node);
    }
  }

  return closest;
}

/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */
function getInstanceFromNode(node) {
  var inst = getClosestInstanceFromNode(node);
  if (inst != null && inst._hostNode === node) {
    return inst;
  } else {
    return null;
  }
}

/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */
function getNodeFromInstance(inst) {
  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  !(inst._hostNode !== undefined) ? invariant$8(false, 'getNodeFromInstance: Invalid argument.') : void 0;

  if (inst._hostNode) {
    return inst._hostNode;
  }

  // Walk up the tree until we find an ancestor whose DOM node we have cached.
  var parents = [];
  while (!inst._hostNode) {
    parents.push(inst);
    !inst._hostParent ? invariant$8(false, 'React DOM tree root should always have a node reference.') : void 0;
    inst = inst._hostParent;
  }

  // Now parents contains each ancestor that does *not* have a cached native
  // node, and `inst` is the deepest ancestor that does.
  for (; parents.length; inst = parents.pop()) {
    precacheChildNodes(inst, inst._hostNode);
  }

  return inst._hostNode;
}

var ReactDOMComponentTree$1 = {
  getClosestInstanceFromNode: getClosestInstanceFromNode,
  getInstanceFromNode: getInstanceFromNode,
  getNodeFromInstance: getNodeFromInstance,
  precacheChildNodes: precacheChildNodes,
  precacheNode: precacheNode,
  uncacheNode: uncacheNode
};

var ReactDOMComponentTree_1 = ReactDOMComponentTree$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

var ARIADOMPropertyConfig$1 = {
  Properties: {
    // Global States and Properties
    'aria-current': 0, // state
    'aria-details': 0,
    'aria-disabled': 0, // state
    'aria-hidden': 0, // state
    'aria-invalid': 0, // state
    'aria-keyshortcuts': 0,
    'aria-label': 0,
    'aria-roledescription': 0,
    // Widget Attributes
    'aria-autocomplete': 0,
    'aria-checked': 0,
    'aria-expanded': 0,
    'aria-haspopup': 0,
    'aria-level': 0,
    'aria-modal': 0,
    'aria-multiline': 0,
    'aria-multiselectable': 0,
    'aria-orientation': 0,
    'aria-placeholder': 0,
    'aria-pressed': 0,
    'aria-readonly': 0,
    'aria-required': 0,
    'aria-selected': 0,
    'aria-sort': 0,
    'aria-valuemax': 0,
    'aria-valuemin': 0,
    'aria-valuenow': 0,
    'aria-valuetext': 0,
    // Live Region Attributes
    'aria-atomic': 0,
    'aria-busy': 0,
    'aria-live': 0,
    'aria-relevant': 0,
    // Drag-and-Drop Attributes
    'aria-dropeffect': 0,
    'aria-grabbed': 0,
    // Relationship Attributes
    'aria-activedescendant': 0,
    'aria-colcount': 0,
    'aria-colindex': 0,
    'aria-colspan': 0,
    'aria-controls': 0,
    'aria-describedby': 0,
    'aria-errormessage': 0,
    'aria-flowto': 0,
    'aria-labelledby': 0,
    'aria-owns': 0,
    'aria-posinset': 0,
    'aria-rowcount': 0,
    'aria-rowindex': 0,
    'aria-rowspan': 0,
    'aria-setsize': 0
  },
  DOMAttributeNames: {},
  DOMPropertyNames: {}
};

var ARIADOMPropertyConfig_1 = ARIADOMPropertyConfig$1;

var invariant$11 = invariant_1;

/**
 * Injectable ordering of event plugins.
 */
var eventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!eventPluginOrder) {
    // Wait until an `eventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var pluginModule = namesToPlugins[pluginName];
    var pluginIndex = eventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? invariant$11(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;
    if (EventPluginRegistry$1.plugins[pluginIndex]) {
      continue;
    }
    !pluginModule.extractEvents ? invariant$11(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;
    EventPluginRegistry$1.plugins[pluginIndex] = pluginModule;
    var publishedEvents = pluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant$11(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
  !!EventPluginRegistry$1.eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant$11(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;
  EventPluginRegistry$1.eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, pluginModule, eventName) {
  !!EventPluginRegistry$1.registrationNameModules[registrationName] ? invariant$11(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;
  EventPluginRegistry$1.registrationNameModules[registrationName] = pluginModule;
  EventPluginRegistry$1.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

  {
    var lowerCasedName = registrationName.toLowerCase();
    EventPluginRegistry$1.possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      EventPluginRegistry$1.possibleRegistrationNames.ondblclick = registrationName;
    }
  }
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry$1 = {

  /**
   * Ordered list of injected plugins.
   */
  plugins: [],

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},

  /**
   * Mapping from registration name to plugin module
   */
  registrationNameModules: {},

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},

  /**
   * Mapping from lowercase registration names to the properly cased version,
   * used to warn in the case of missing event handlers. Available
   * only in __DEV__.
   * @type {Object}
   */
  possibleRegistrationNames: {},
  // Trust the developer to only use possibleRegistrationNames in __DEV__

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function (injectedEventPluginOrder) {
    !!eventPluginOrder ? invariant$11(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0;
    // Clone the ordering so it cannot be dynamically mutated.
    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function (injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var pluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
        !!namesToPlugins[pluginName] ? invariant$11(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;
        namesToPlugins[pluginName] = pluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function (event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry$1.registrationNameModules[dispatchConfig.registrationName] || null;
    }
    if (dispatchConfig.phasedRegistrationNames !== undefined) {
      // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
      // that it is not undefined.
      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

      for (var phase in phasedRegistrationNames) {
        if (!phasedRegistrationNames.hasOwnProperty(phase)) {
          continue;
        }
        var pluginModule = EventPluginRegistry$1.registrationNameModules[phasedRegistrationNames[phase]];
        if (pluginModule) {
          return pluginModule;
        }
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function () {
    eventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry$1.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry$1.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry$1.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }

    {
      var possibleRegistrationNames = EventPluginRegistry$1.possibleRegistrationNames;
      for (var lowerCasedName in possibleRegistrationNames) {
        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
          delete possibleRegistrationNames[lowerCasedName];
        }
      }
    }
  }

};

var EventPluginRegistry_1 = EventPluginRegistry$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

var caughtError = null;

/**
 * Call a function while guarding against errors that happens within it.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} a First argument
 * @param {*} b Second argument
 */
function invokeGuardedCallback(name, func, a) {
  try {
    func(a);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
  }
}

var ReactErrorUtils$2 = {
  invokeGuardedCallback: invokeGuardedCallback,

  /**
   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
   * handler are sure to be rethrown by rethrowCaughtError.
   */
  invokeGuardedCallbackWithCatch: invokeGuardedCallback,

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function () {
    if (caughtError) {
      var error = caughtError;
      caughtError = null;
      throw error;
    }
  }
};

{
  /**
   * To help development we can get better devtools integration by simulating a
   * real browser event.
   */
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');
    ReactErrorUtils$2.invokeGuardedCallback = function (name, func, a) {
      var boundFunc = func.bind(null, a);
      var evtType = 'react-' + name;
      fakeNode.addEventListener(evtType, boundFunc, false);
      var evt = document.createEvent('Event');
      // $FlowFixMe https://github.com/facebook/flow/issues/2336
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);
      fakeNode.removeEventListener(evtType, boundFunc, false);
    };
  }
}

var ReactErrorUtils_1 = ReactErrorUtils$2;

var ReactErrorUtils$1 = ReactErrorUtils_1;

var invariant$12 = invariant_1;
var warning$13 = warning_1;

/**
 * Injected dependencies:
 */

/**
 * - `ComponentTree`: [required] Module that can convert between React instances
 *   and actual node references.
 */
var ComponentTree;
var TreeTraversal;
var injection = {
  injectComponentTree: function (Injected) {
    ComponentTree = Injected;
    {
      warning$13(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');
    }
  },
  injectTreeTraversal: function (Injected) {
    TreeTraversal = Injected;
    {
      warning$13(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.');
    }
  }
};

function isEndish(topLevelType) {
  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
}

function isMoveish(topLevelType) {
  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
}
function isStartish(topLevelType) {
  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
}

var validateEventDispatches;
{
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    var instancesIsArr = Array.isArray(dispatchInstances);
    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

    warning$13(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.');
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = EventPluginUtils$2.getNodeFromInstance(inst);
  if (simulated) {
    ReactErrorUtils$1.invokeGuardedCallbackWithCatch(type, listener, event);
  } else {
    ReactErrorUtils$1.invokeGuardedCallback(type, listener, event);
  }
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return {?string} id of the first dispatch execution who's listener returns
 * true, or null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchInstances[i])) {
        return dispatchInstances[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchInstances)) {
      return dispatchInstances;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchInstances = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchInstance = event._dispatchInstances;
  !!Array.isArray(dispatchListener) ? invariant$12(false, 'executeDirectDispatch(...): Invalid `event`.') : void 0;
  event.currentTarget = dispatchListener ? EventPluginUtils$2.getNodeFromInstance(dispatchInstance) : null;
  var res = dispatchListener ? dispatchListener(event) : null;
  event.currentTarget = null;
  event._dispatchListeners = null;
  event._dispatchInstances = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/**
 * General utilities that are useful in creating custom Event Plugins.
 */
var EventPluginUtils$2 = {
  isEndish: isEndish,
  isMoveish: isMoveish,
  isStartish: isStartish,

  executeDirectDispatch: executeDirectDispatch,
  executeDispatchesInOrder: executeDispatchesInOrder,
  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
  hasDispatches: hasDispatches,

  getInstanceFromNode: function (node) {
    return ComponentTree.getInstanceFromNode(node);
  },
  getNodeFromInstance: function (node) {
    return ComponentTree.getNodeFromInstance(node);
  },
  isAncestor: function (a, b) {
    return TreeTraversal.isAncestor(a, b);
  },
  getLowestCommonAncestor: function (a, b) {
    return TreeTraversal.getLowestCommonAncestor(a, b);
  },
  getParentInstance: function (inst) {
    return TreeTraversal.getParentInstance(inst);
  },
  traverseTwoPhase: function (target, fn, arg) {
    return TreeTraversal.traverseTwoPhase(target, fn, arg);
  },
  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
  },

  injection: injection
};

var EventPluginUtils_1 = EventPluginUtils$2;

var invariant$13 = invariant_1;

/**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto$2(current, next) {
  !(next != null) ? invariant$13(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;

  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

var accumulateInto_1 = accumulateInto$2;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */

function forEachAccumulated$2(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
}

var forEachAccumulated_1 = forEachAccumulated$2;

var EventPluginRegistry = EventPluginRegistry_1;
var EventPluginUtils$1 = EventPluginUtils_1;
var ReactErrorUtils = ReactErrorUtils_1;

var accumulateInto$1 = accumulateInto_1;
var forEachAccumulated$1 = forEachAccumulated_1;
var invariant$10 = invariant_1;

/**
 * Internal store for event listeners
 */
var listenerBank = {};

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils$1.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

var getDictionaryKey = function (inst) {
  // Prevents V8 performance issue:
  // https://github.com/facebook/react/pull/7232
  return '.' + inst._rootNodeID;
};

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
      return !!(props.disabled && isInteractive(type));
    default:
      return false;
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */
var EventPluginHub$1 = {

  /**
   * Methods for injecting dependencies.
   */
  injection: {

    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

  },

  /**
   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {function} listener The callback to store.
   */
  putListener: function (inst, registrationName, listener) {
    !(typeof listener === 'function') ? invariant$10(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : void 0;

    var key = getDictionaryKey(inst);
    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[key] = listener;

    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.didPutListener) {
      PluginModule.didPutListener(inst, registrationName, listener);
    }
  },

  /**
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  getListener: function (inst, registrationName) {
    // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
    // live here; needs to be moved to a better place soon
    var bankForRegistrationName = listenerBank[registrationName];
    if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
      return null;
    }
    var key = getDictionaryKey(inst);
    return bankForRegistrationName && bankForRegistrationName[key];
  },

  /**
   * Deletes a listener from the registration bank.
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function (inst, registrationName) {
    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.willDeleteListener) {
      PluginModule.willDeleteListener(inst, registrationName);
    }

    var bankForRegistrationName = listenerBank[registrationName];
    // TODO: This should never be null -- when is it?
    if (bankForRegistrationName) {
      var key = getDictionaryKey(inst);
      delete bankForRegistrationName[key];
    }
  },

  /**
   * Deletes all listeners for the DOM element with the supplied ID.
   *
   * @param {object} inst The instance, which is the source of events.
   */
  deleteAllListeners: function (inst) {
    var key = getDictionaryKey(inst);
    for (var registrationName in listenerBank) {
      if (!listenerBank.hasOwnProperty(registrationName)) {
        continue;
      }

      if (!listenerBank[registrationName][key]) {
        continue;
      }

      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
      if (PluginModule && PluginModule.willDeleteListener) {
        PluginModule.willDeleteListener(inst, registrationName);
      }

      delete listenerBank[registrationName][key];
    }
  },

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0; i < plugins.length; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
        if (extractedEvents) {
          events = accumulateInto$1(events, extractedEvents);
        }
      }
    }
    return events;
  },

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  enqueueEvents: function (events) {
    if (events) {
      eventQueue = accumulateInto$1(eventQueue, events);
    }
  },

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  processEventQueue: function (simulated) {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    if (simulated) {
      forEachAccumulated$1(processingEventQueue, executeDispatchesAndReleaseSimulated);
    } else {
      forEachAccumulated$1(processingEventQueue, executeDispatchesAndReleaseTopLevel);
    }
    !!eventQueue ? invariant$10(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;
    // This would be a good time to rethrow if any of the event handlers threw.
    ReactErrorUtils.rethrowCaughtError();
  },

  /**
   * These are needed for tests only. Do not use!
   */
  __purge: function () {
    listenerBank = {};
  },

  __getListenerBank: function () {
    return listenerBank;
  }

};

var EventPluginHub_1 = EventPluginHub$1;

var EventPluginHub = EventPluginHub_1;
var EventPluginUtils = EventPluginUtils_1;

var accumulateInto = accumulateInto_1;
var forEachAccumulated = forEachAccumulated_1;
var warning$12 = warning_1;

var getListener = EventPluginHub.getListener;

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(inst, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(inst, registrationName);
}

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(inst, phase, event) {
  {
    warning$12(inst, 'Dispatching inst must not be null');
  }
  var listener = listenerAtPhase(inst, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    var targetInst = event._targetInst;
    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(inst, ignoredDirection, event) {
  if (event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(inst, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event._targetInst, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing event a
 * single one.
 *
 * @constructor EventPropagators
 */
var EventPropagators$1 = {
  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
  accumulateDirectDispatches: accumulateDirectDispatches,
  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
};

var EventPropagators_1 = EventPropagators$1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment$2 = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

var ExecutionEnvironment_1 = ExecutionEnvironment$2;

var invariant$14 = invariant_1;

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler$1 = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler$2 = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler$1 = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler$2 = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var fiveArgumentPooler$1 = function (a1, a2, a3, a4, a5) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4, a5);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4, a5);
  }
};

var standardReleaser$1 = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? invariant$14(false, 'Trying to release an instance into a pool of a different type.') : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE$1 = 10;
var DEFAULT_POOLER$1 = oneArgumentPooler$1;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances.
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo$1 = function (CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER$1;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE$1;
  }
  NewKlass.release = standardReleaser$1;
  return NewKlass;
};

var PooledClass$3 = {
  addPoolingTo: addPoolingTo$1,
  oneArgumentPooler: oneArgumentPooler$1,
  twoArgumentPooler: twoArgumentPooler$2,
  threeArgumentPooler: threeArgumentPooler$1,
  fourArgumentPooler: fourArgumentPooler$2,
  fiveArgumentPooler: fiveArgumentPooler$1
};

var PooledClass_1$2 = PooledClass$3;

var ExecutionEnvironment$3 = ExecutionEnvironment_1;

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor$1() {
  if (!contentKey && ExecutionEnvironment$3.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

var getTextContentAccessor_1 = getTextContentAccessor$1;

var _assign$4 = index$1;

var PooledClass$2 = PooledClass_1$2;

var getTextContentAccessor = getTextContentAccessor_1;

/**
 * This helper class stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 * @param {DOMEventTarget} root
 */
function FallbackCompositionState$1(root) {
  this._root = root;
  this._startText = this.getText();
  this._fallbackText = null;
}

_assign$4(FallbackCompositionState$1.prototype, {
  destructor: function () {
    this._root = null;
    this._startText = null;
    this._fallbackText = null;
  },

  /**
   * Get current text of input.
   *
   * @return {string}
   */
  getText: function () {
    if ('value' in this._root) {
      return this._root.value;
    }
    return this._root[getTextContentAccessor()];
  },

  /**
   * Determine the differing substring between the initially stored
   * text content and the current content.
   *
   * @return {string}
   */
  getData: function () {
    if (this._fallbackText) {
      return this._fallbackText;
    }

    var start;
    var startValue = this._startText;
    var startLength = startValue.length;
    var end;
    var endValue = this.getText();
    var endLength = endValue.length;

    for (start = 0; start < startLength; start++) {
      if (startValue[start] !== endValue[start]) {
        break;
      }
    }

    var minEnd = startLength - start;
    for (end = 1; end <= minEnd; end++) {
      if (startValue[startLength - end] !== endValue[endLength - end]) {
        break;
      }
    }

    var sliceTail = end > 1 ? 1 - end : undefined;
    this._fallbackText = endValue.slice(start, sliceTail);
    return this._fallbackText;
  }
});

PooledClass$2.addPoolingTo(FallbackCompositionState$1);

var FallbackCompositionState_1 = FallbackCompositionState$1;

var _assign$5 = index$1;

var PooledClass$4 = PooledClass_1$2;

var emptyFunction$4 = emptyFunction_1;
var warning$14 = warning_1;

var didWarnForAddedNewProperty = false;
var isProxySupported = typeof Proxy === 'function';

var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction$4.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */
function SyntheticEvent$1(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
  {
    // these have a getter/setter for warnings
    delete this.nativeEvent;
    delete this.preventDefault;
    delete this.stopPropagation;
  }

  this.dispatchConfig = dispatchConfig;
  this._targetInst = targetInst;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    {
      delete this[propName]; // this has a getter/setter for warnings
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction$4.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction$4.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction$4.thatReturnsFalse;
  return this;
}

_assign$5(SyntheticEvent$1.prototype, {

  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else if (typeof event.returnValue !== 'unknown') {
      // eslint-disable-line valid-typeof
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction$4.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else if (typeof event.cancelBubble !== 'unknown') {
      // eslint-disable-line valid-typeof
      // The ChangeEventPlugin registers a "propertychange" event for
      // IE. This event does not support bubbling or cancelling, and
      // any references to cancelBubble throw "Member not found".  A
      // typeof check of "unknown" circumvents this issue (and is also
      // IE specific).
      event.cancelBubble = true;
    }

    this.isPropagationStopped = emptyFunction$4.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction$4.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction$4.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      {
        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
      }
    }
    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
      this[shouldBeReleasedProperties[i]] = null;
    }
    {
      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction$4));
      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction$4));
    }
  }

});

SyntheticEvent$1.Interface = EventInterface;

{
  if (isProxySupported) {
    /*eslint-disable no-func-assign */
    SyntheticEvent$1 = new Proxy(SyntheticEvent$1, {
      construct: function (target, args) {
        return this.apply(target, Object.create(target.prototype), args);
      },
      apply: function (constructor, that, args) {
        return new Proxy(constructor.apply(that, args), {
          set: function (target, prop, value) {
            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
              warning$14(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.');
              didWarnForAddedNewProperty = true;
            }
            target[prop] = value;
            return true;
          }
        });
      }
    });
    /*eslint-enable no-func-assign */
  }
}
/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent$1.augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign$5(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign$5({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass$4.addPoolingTo(Class, PooledClass$4.fourArgumentPooler);
};

PooledClass$4.addPoolingTo(SyntheticEvent$1, PooledClass$4.fourArgumentPooler);

var SyntheticEvent_1 = SyntheticEvent$1;

/**
  * Helper to nullify syntheticEvent instance properties when destructing
  *
  * @param {object} SyntheticEvent
  * @param {String} propName
  * @return {object} defineProperty object
  */
function getPooledWarningPropertyDefinition(propName, getVal) {
  var isFunction = typeof getVal === 'function';
  return {
    configurable: true,
    set: set,
    get: get
  };

  function set(val) {
    var action = isFunction ? 'setting the method' : 'setting the property';
    warn(action, 'This is effectively a no-op');
    return val;
  }

  function get() {
    var action = isFunction ? 'accessing the method' : 'accessing the property';
    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
    warn(action, result);
    return getVal;
  }

  function warn(action, result) {
    var warningCondition = false;
    warning$14(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);
  }
}

var SyntheticEvent = SyntheticEvent_1;

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticCompositionEvent$1(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticCompositionEvent$1, CompositionEventInterface);

var SyntheticCompositionEvent_1 = SyntheticCompositionEvent$1;

var SyntheticEvent$2 = SyntheticEvent_1;

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticInputEvent$1(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$2.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$2.augmentClass(SyntheticInputEvent$1, InputEventInterface);

var SyntheticInputEvent_1 = SyntheticInputEvent$1;

var EventPropagators = EventPropagators_1;
var ExecutionEnvironment$1 = ExecutionEnvironment_1;
var FallbackCompositionState = FallbackCompositionState_1;
var SyntheticCompositionEvent = SyntheticCompositionEvent_1;
var SyntheticInputEvent = SyntheticInputEvent_1;

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment$1.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment$1.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment$1.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment$1.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: 'onBeforeInput',
      captured: 'onBeforeInputCapture'
    },
    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionEnd',
      captured: 'onCompositionEndCapture'
    },
    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionStart',
      captured: 'onCompositionStartCapture'
    },
    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionUpdate',
      captured: 'onCompositionUpdateCapture'
    },
    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case 'topCompositionStart':
      return eventTypes.compositionStart;
    case 'topCompositionEnd':
      return eventTypes.compositionEnd;
    case 'topCompositionUpdate':
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topKeyUp':
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case 'topKeyDown':
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case 'topKeyPress':
    case 'topMouseDown':
    case 'topBlur':
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition fallback object, if any.
var currentComposition = null;

/**
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!currentComposition) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!currentComposition && eventType === eventTypes.compositionStart) {
      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (currentComposition) {
        fallbackData = currentComposition.getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topCompositionEnd':
      return getDataFromCustomEvent(nativeEvent);
    case 'topKeyPress':
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case 'topTextInput':
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (currentComposition) {
    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = currentComposition.getData();
      FallbackCompositionState.release(currentComposition);
      currentComposition = null;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case 'topPaste':
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case 'topKeyPress':
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
        return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case 'topCompositionEnd':
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

  event.data = chars;
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin$1 = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
  }
};

var BeforeInputEventPlugin_1 = BeforeInputEventPlugin$1;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PooledClass$6 = PooledClass_1$2;

var invariant$16 = invariant_1;

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.getPooled()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue$1 = function () {
  function CallbackQueue(arg) {
    _classCallCheck(this, CallbackQueue);

    this._callbacks = null;
    this._contexts = null;
    this._arg = arg;
  }

  /**
   * Enqueues a callback to be invoked when `notifyAll` is invoked.
   *
   * @param {function} callback Invoked when `notifyAll` is invoked.
   * @param {?object} context Context to call `callback` with.
   * @internal
   */


  CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
    this._callbacks = this._callbacks || [];
    this._callbacks.push(callback);
    this._contexts = this._contexts || [];
    this._contexts.push(context);
  };

  /**
   * Invokes all enqueued callbacks and clears the queue. This is invoked after
   * the DOM representation of a component has been created or updated.
   *
   * @internal
   */


  CallbackQueue.prototype.notifyAll = function notifyAll() {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    var arg = this._arg;
    if (callbacks && contexts) {
      !(callbacks.length === contexts.length) ? invariant$16(false, 'Mismatched list of contexts in callback queue') : void 0;
      this._callbacks = null;
      this._contexts = null;
      for (var i = 0; i < callbacks.length; i++) {
        callbacks[i].call(contexts[i], arg);
      }
      callbacks.length = 0;
      contexts.length = 0;
    }
  };

  CallbackQueue.prototype.checkpoint = function checkpoint() {
    return this._callbacks ? this._callbacks.length : 0;
  };

  CallbackQueue.prototype.rollback = function rollback(len) {
    if (this._callbacks && this._contexts) {
      this._callbacks.length = len;
      this._contexts.length = len;
    }
  };

  /**
   * Resets the internal queue.
   *
   * @internal
   */


  CallbackQueue.prototype.reset = function reset() {
    this._callbacks = null;
    this._contexts = null;
  };

  /**
   * `PooledClass` looks for this.
   */


  CallbackQueue.prototype.destructor = function destructor() {
    this.reset();
  };

  return CallbackQueue;
}();

var CallbackQueue_1 = PooledClass$6.addPoolingTo(CallbackQueue$1);

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

var ReactFeatureFlags$1 = {
  // When true, call console.time() before and .timeEnd() after each top-level
  // render (both initial renders and updates). Useful when looking at prod-mode
  // timeline profiles in Chrome, for example.
  logTopLevelRenders: false
};

var ReactFeatureFlags_1 = ReactFeatureFlags$1;

var invariant$17 = invariant_1;

/**
 * @param {?object} object
 * @return {boolean} True if `object` is a valid owner.
 * @final
 */
function isValidOwner(object) {
  return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
}

/**
 * ReactOwners are capable of storing references to owned components.
 *
 * All components are capable of //being// referenced by owner components, but
 * only ReactOwner components are capable of //referencing// owned components.
 * The named reference is known as a "ref".
 *
 * Refs are available when mounted and updated during reconciliation.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return (
 *         <div onClick={this.handleClick}>
 *           <CustomComponent ref="custom" />
 *         </div>
 *       );
 *     },
 *     handleClick: function() {
 *       this.refs.custom.handleClick();
 *     },
 *     componentDidMount: function() {
 *       this.refs.custom.initialize();
 *     }
 *   });
 *
 * Refs should rarely be used. When refs are used, they should only be done to
 * control data that is not handled by React's data flow.
 *
 * @class ReactOwner
 */
var ReactOwner$1 = {
  /**
   * Adds a component by ref to an owner component.
   *
   * @param {ReactComponent} component Component to reference.
   * @param {string} ref Name by which to refer to the component.
   * @param {ReactOwner} owner Component on which to record the ref.
   * @final
   * @internal
   */
  addComponentAsRefTo: function (component, ref, owner) {
    !isValidOwner(owner) ? invariant$17(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : void 0;
    owner.attachRef(ref, component);
  },

  /**
   * Removes a component by ref from an owner component.
   *
   * @param {ReactComponent} component Component to dereference.
   * @param {string} ref Name of the ref to remove.
   * @param {ReactOwner} owner Component on which the ref is recorded.
   * @final
   * @internal
   */
  removeComponentAsRefFrom: function (component, ref, owner) {
    !isValidOwner(owner) ? invariant$17(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : void 0;
    var ownerPublicInstance = owner.getPublicInstance();
    // Check that `component`'s owner is still alive and that `component` is still the current ref
    // because we do not want to detach the ref if another component stole it.
    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
      owner.detachRef(ref);
    }
  }

};

var ReactOwner_1 = ReactOwner$1;

var ReactOwner = ReactOwner_1;

var ReactRef$1 = {};

function attachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(component.getPublicInstance());
  } else {
    // Legacy ref
    ReactOwner.addComponentAsRefTo(component, ref, owner);
  }
}

function detachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(null);
  } else {
    // Legacy ref
    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
  }
}

ReactRef$1.attachRefs = function (instance, element) {
  if (element === null || typeof element !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    attachRef(ref, instance, element._owner);
  }
};

ReactRef$1.shouldUpdateRefs = function (prevElement, nextElement) {
  // If either the owner or a `ref` has changed, make sure the newest owner
  // has stored a reference to `this`, and the previous owner (if different)
  // has forgotten the reference to `this`. We use the element instead
  // of the public this.props because the post processing cannot determine
  // a ref. The ref conceptually lives on the element.

  // TODO: Should this even be possible? The owner cannot change because
  // it's forbidden by shouldUpdateReactComponent. The ref can change
  // if you swap the keys of but not the refs. Reconsider where this check
  // is made. It probably belongs where the key checking and
  // instantiateReactComponent is done.

  var prevRef = null;
  var prevOwner = null;
  if (prevElement !== null && typeof prevElement === 'object') {
    prevRef = prevElement.ref;
    prevOwner = prevElement._owner;
  }

  var nextRef = null;
  var nextOwner = null;
  if (nextElement !== null && typeof nextElement === 'object') {
    nextRef = nextElement.ref;
    nextOwner = nextElement._owner;
  }

  return prevRef !== nextRef ||
  // If owner changes but we have an unchanged function ref, don't update refs
  typeof nextRef === 'string' && nextOwner !== prevOwner;
};

ReactRef$1.detachRefs = function (instance, element) {
  if (element === null || typeof element !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    detachRef(ref, instance, element._owner);
  }
};

var ReactRef_1 = ReactRef$1;

var warning$17 = warning_1;

{
  var processingChildContext = false;

  var warnInvalidSetState = function () {
    warning$17(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()');
  };
}

var ReactInvalidSetStateWarningHook$1 = {
  onBeginProcessingChildContext: function () {
    processingChildContext = true;
  },
  onEndProcessingChildContext: function () {
    processingChildContext = false;
  },
  onSetState: function () {
    warnInvalidSetState();
  }
};

var ReactInvalidSetStateWarningHook_1 = ReactInvalidSetStateWarningHook$1;

/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

var history = [];

var ReactHostOperationHistoryHook$1 = {
  onHostOperation: function (operation) {
    history.push(operation);
  },
  clearHistory: function () {
    if (ReactHostOperationHistoryHook$1._preventClearing) {
      // Should only be used for tests.
      return;
    }

    history = [];
  },
  getHistory: function () {
    return history;
  }
};

var ReactHostOperationHistoryHook_1 = ReactHostOperationHistoryHook$1;

var ExecutionEnvironment$6 = ExecutionEnvironment_1;

var performance$2;

if (ExecutionEnvironment$6.canUseDOM) {
  performance$2 = window.performance || window.msPerformance || window.webkitPerformance;
}

var performance_1 = performance$2 || {};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var performance$1 = performance_1;

var performanceNow$1;

/**
 * Detect if we can use `window.performance.now()` and gracefully fallback to
 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
 * because of Facebook's testing infrastructure.
 */
if (performance$1.now) {
  performanceNow$1 = function performanceNow$1() {
    return performance$1.now();
  };
} else {
  performanceNow$1 = function performanceNow$1() {
    return Date.now();
  };
}

var performanceNow_1 = performanceNow$1;

var ReactInvalidSetStateWarningHook = ReactInvalidSetStateWarningHook_1;
var ReactHostOperationHistoryHook = ReactHostOperationHistoryHook_1;
var ReactComponentTreeHook$3 = ReactComponentTreeHook_1;
var ExecutionEnvironment$5 = ExecutionEnvironment_1;

var performanceNow = performanceNow_1;
var warning$16 = warning_1;

var hooks = [];
var didHookThrowForEvent = {};

function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
  try {
    fn.call(context, arg1, arg2, arg3, arg4, arg5);
  } catch (e) {
    warning$16(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack);
    didHookThrowForEvent[event] = true;
  }
}

function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
  for (var i = 0; i < hooks.length; i++) {
    var hook = hooks[i];
    var fn = hook[event];
    if (fn) {
      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
    }
  }
}

var isProfiling = false;
var flushHistory = [];
var lifeCycleTimerStack = [];
var currentFlushNesting = 0;
var currentFlushMeasurements = [];
var currentFlushStartTime = 0;
var currentTimerDebugID = null;
var currentTimerStartTime = 0;
var currentTimerNestedFlushDuration = 0;
var currentTimerType = null;

var lifeCycleTimerHasWarned = false;

function clearHistory() {
  ReactComponentTreeHook$3.purgeUnmountedComponents();
  ReactHostOperationHistoryHook.clearHistory();
}

function getTreeSnapshot(registeredIDs) {
  return registeredIDs.reduce(function (tree, id) {
    var ownerID = ReactComponentTreeHook$3.getOwnerID(id);
    var parentID = ReactComponentTreeHook$3.getParentID(id);
    tree[id] = {
      displayName: ReactComponentTreeHook$3.getDisplayName(id),
      text: ReactComponentTreeHook$3.getText(id),
      updateCount: ReactComponentTreeHook$3.getUpdateCount(id),
      childIDs: ReactComponentTreeHook$3.getChildIDs(id),
      // Text nodes don't have owners but this is close enough.
      ownerID: ownerID || parentID && ReactComponentTreeHook$3.getOwnerID(parentID) || 0,
      parentID: parentID
    };
    return tree;
  }, {});
}

function resetMeasurements() {
  var previousStartTime = currentFlushStartTime;
  var previousMeasurements = currentFlushMeasurements;
  var previousOperations = ReactHostOperationHistoryHook.getHistory();

  if (currentFlushNesting === 0) {
    currentFlushStartTime = 0;
    currentFlushMeasurements = [];
    clearHistory();
    return;
  }

  if (previousMeasurements.length || previousOperations.length) {
    var registeredIDs = ReactComponentTreeHook$3.getRegisteredIDs();
    flushHistory.push({
      duration: performanceNow() - previousStartTime,
      measurements: previousMeasurements || [],
      operations: previousOperations || [],
      treeSnapshot: getTreeSnapshot(registeredIDs)
    });
  }

  clearHistory();
  currentFlushStartTime = performanceNow();
  currentFlushMeasurements = [];
}

function checkDebugID(debugID) {
  var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (allowRoot && debugID === 0) {
    return;
  }
  if (!debugID) {
    warning$16(false, 'ReactDebugTool: debugID may not be empty.');
  }
}

function beginLifeCycleTimer(debugID, timerType) {
  if (currentFlushNesting === 0) {
    return;
  }
  if (currentTimerType && !lifeCycleTimerHasWarned) {
    warning$16(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another');
    lifeCycleTimerHasWarned = true;
  }
  currentTimerStartTime = performanceNow();
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = debugID;
  currentTimerType = timerType;
}

function endLifeCycleTimer(debugID, timerType) {
  if (currentFlushNesting === 0) {
    return;
  }
  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
    warning$16(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another');
    lifeCycleTimerHasWarned = true;
  }
  if (isProfiling) {
    currentFlushMeasurements.push({
      timerType: timerType,
      instanceID: debugID,
      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
    });
  }
  currentTimerStartTime = 0;
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = null;
  currentTimerType = null;
}

function pauseCurrentLifeCycleTimer() {
  var currentTimer = {
    startTime: currentTimerStartTime,
    nestedFlushStartTime: performanceNow(),
    debugID: currentTimerDebugID,
    timerType: currentTimerType
  };
  lifeCycleTimerStack.push(currentTimer);
  currentTimerStartTime = 0;
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = null;
  currentTimerType = null;
}

function resumeCurrentLifeCycleTimer() {
  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
      startTime = _lifeCycleTimerStack$.startTime,
      nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
      debugID = _lifeCycleTimerStack$.debugID,
      timerType = _lifeCycleTimerStack$.timerType;

  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
  currentTimerStartTime = startTime;
  currentTimerNestedFlushDuration += nestedFlushDuration;
  currentTimerDebugID = debugID;
  currentTimerType = timerType;
}

var lastMarkTimeStamp = 0;
var canUsePerformanceMeasure =
// $FlowFixMe https://github.com/facebook/flow/issues/2345
typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

function shouldMark(debugID) {
  if (!isProfiling || !canUsePerformanceMeasure) {
    return false;
  }
  var element = ReactComponentTreeHook$3.getElement(debugID);
  if (element == null || typeof element !== 'object') {
    return false;
  }
  var isHostElement = typeof element.type === 'string';
  if (isHostElement) {
    return false;
  }
  return true;
}

function markBegin(debugID, markType) {
  if (!shouldMark(debugID)) {
    return;
  }

  var markName = debugID + '::' + markType;
  lastMarkTimeStamp = performanceNow();
  performance.mark(markName);
}

function markEnd(debugID, markType) {
  if (!shouldMark(debugID)) {
    return;
  }

  var markName = debugID + '::' + markType;
  var displayName = ReactComponentTreeHook$3.getDisplayName(debugID) || 'Unknown';

  // Chrome has an issue of dropping markers recorded too fast:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=640652
  // To work around this, we will not report very small measurements.
  // I determined the magic number by tweaking it back and forth.
  // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.
  // When the bug is fixed, we can `measure()` unconditionally if we want to.
  var timeStamp = performanceNow();
  if (timeStamp - lastMarkTimeStamp > 0.1) {
    var measurementName = displayName + ' [' + markType + ']';
    performance.measure(measurementName, markName);
  }

  performance.clearMarks(markName);
  performance.clearMeasures(measurementName);
}

var ReactDebugTool$1 = {
  addHook: function (hook) {
    hooks.push(hook);
  },
  removeHook: function (hook) {
    for (var i = 0; i < hooks.length; i++) {
      if (hooks[i] === hook) {
        hooks.splice(i, 1);
        i--;
      }
    }
  },
  isProfiling: function () {
    return isProfiling;
  },
  beginProfiling: function () {
    if (isProfiling) {
      return;
    }

    isProfiling = true;
    flushHistory.length = 0;
    resetMeasurements();
    ReactDebugTool$1.addHook(ReactHostOperationHistoryHook);
  },
  endProfiling: function () {
    if (!isProfiling) {
      return;
    }

    isProfiling = false;
    resetMeasurements();
    ReactDebugTool$1.removeHook(ReactHostOperationHistoryHook);
  },
  getFlushHistory: function () {
    return flushHistory;
  },
  onBeginFlush: function () {
    currentFlushNesting++;
    resetMeasurements();
    pauseCurrentLifeCycleTimer();
    emitEvent('onBeginFlush');
  },
  onEndFlush: function () {
    resetMeasurements();
    currentFlushNesting--;
    resumeCurrentLifeCycleTimer();
    emitEvent('onEndFlush');
  },
  onBeginLifeCycleTimer: function (debugID, timerType) {
    checkDebugID(debugID);
    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
    markBegin(debugID, timerType);
    beginLifeCycleTimer(debugID, timerType);
  },
  onEndLifeCycleTimer: function (debugID, timerType) {
    checkDebugID(debugID);
    endLifeCycleTimer(debugID, timerType);
    markEnd(debugID, timerType);
    emitEvent('onEndLifeCycleTimer', debugID, timerType);
  },
  onBeginProcessingChildContext: function () {
    emitEvent('onBeginProcessingChildContext');
  },
  onEndProcessingChildContext: function () {
    emitEvent('onEndProcessingChildContext');
  },
  onHostOperation: function (operation) {
    checkDebugID(operation.instanceID);
    emitEvent('onHostOperation', operation);
  },
  onSetState: function () {
    emitEvent('onSetState');
  },
  onSetChildren: function (debugID, childDebugIDs) {
    checkDebugID(debugID);
    childDebugIDs.forEach(checkDebugID);
    emitEvent('onSetChildren', debugID, childDebugIDs);
  },
  onBeforeMountComponent: function (debugID, element, parentDebugID) {
    checkDebugID(debugID);
    checkDebugID(parentDebugID, true);
    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
    markBegin(debugID, 'mount');
  },
  onMountComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'mount');
    emitEvent('onMountComponent', debugID);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    checkDebugID(debugID);
    emitEvent('onBeforeUpdateComponent', debugID, element);
    markBegin(debugID, 'update');
  },
  onUpdateComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'update');
    emitEvent('onUpdateComponent', debugID);
  },
  onBeforeUnmountComponent: function (debugID) {
    checkDebugID(debugID);
    emitEvent('onBeforeUnmountComponent', debugID);
    markBegin(debugID, 'unmount');
  },
  onUnmountComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'unmount');
    emitEvent('onUnmountComponent', debugID);
  },
  onTestEvent: function () {
    emitEvent('onTestEvent');
  }
};

// TODO remove these when RN/www gets updated
ReactDebugTool$1.addDevtool = ReactDebugTool$1.addHook;
ReactDebugTool$1.removeDevtool = ReactDebugTool$1.removeHook;

ReactDebugTool$1.addHook(ReactInvalidSetStateWarningHook);
ReactDebugTool$1.addHook(ReactComponentTreeHook$3);
var url = ExecutionEnvironment$5.canUseDOM && window.location.href || '';
if (/[?&]react_perf\b/.test(url)) {
  ReactDebugTool$1.beginProfiling();
}

var ReactDebugTool_1 = ReactDebugTool$1;

// Trust the developer to only use ReactInstrumentation with a __DEV__ check

var debugTool = null;

{
  var ReactDebugTool = ReactDebugTool_1;
  debugTool = ReactDebugTool;
}

var ReactInstrumentation$2 = { debugTool: debugTool };

var ReactRef = ReactRef_1;
var ReactInstrumentation$1 = ReactInstrumentation$2;

var warning$15 = warning_1;

/**
 * Helper to call ReactRef.attachRefs with this composite component, split out
 * to avoid allocations in the transaction mount-ready queue.
 */
function attachRefs() {
  ReactRef.attachRefs(this, this._currentElement);
}

var ReactReconciler$2 = {

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} the containing host component instance
   * @param {?object} info about the host container
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots
  ) {
    {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation$1.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
      }
    }
    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
    {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation$1.debugTool.onMountComponent(internalInstance._debugID);
      }
    }
    return markup;
  },

  /**
   * Returns a value that can be passed to
   * ReactComponentEnvironment.replaceNodeWithMarkup.
   */
  getHostNode: function (internalInstance) {
    return internalInstance.getHostNode();
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (internalInstance, safely) {
    {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation$1.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
      }
    }
    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
    internalInstance.unmountComponent(safely);
    {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation$1.debugTool.onUnmountComponent(internalInstance._debugID);
      }
    }
  },

  /**
   * Update a component using a new element.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @internal
   */
  receiveComponent: function (internalInstance, nextElement, transaction, context) {
    var prevElement = internalInstance._currentElement;

    if (nextElement === prevElement && context === internalInstance._context) {
      // Since elements are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the element. We explicitly check for the existence of an owner since
      // it's possible for an element created outside a composite to be
      // deeply mutated and reused.

      // TODO: Bailing out early is just a perf optimization right?
      // TODO: Removing the return statement should affect correctness?
      return;
    }

    {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation$1.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
      }
    }

    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

    if (refsChanged) {
      ReactRef.detachRefs(internalInstance, prevElement);
    }

    internalInstance.receiveComponent(nextElement, transaction, context);

    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }

    {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation$1.debugTool.onUpdateComponent(internalInstance._debugID);
      }
    }
  },

  /**
   * Flush any dirty changes in a component.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
      // The component's enqueued batch number should always be the current
      // batch or the following one.
      warning$15(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber);
      return;
    }
    {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation$1.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
      }
    }
    internalInstance.performUpdateIfNecessary(transaction);
    {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation$1.debugTool.onUpdateComponent(internalInstance._debugID);
      }
    }
  }

};

var ReactReconciler_1 = ReactReconciler$2;

var invariant$18 = invariant_1;

var OBSERVED_ERROR = {};

/**
 * `Transaction` creates a black box that is able to wrap any method such that
 * certain invariants are maintained before and after the method is invoked
 * (Even if an exception is thrown while invoking the wrapped method). Whoever
 * instantiates a transaction can provide enforcers of the invariants at
 * creation time. The `Transaction` class itself will supply one additional
 * automatic invariant for you - the invariant that any transaction instance
 * should not be run while it is already being run. You would typically create a
 * single instance of a `Transaction` for reuse multiple times, that potentially
 * is used to wrap several different methods. Wrappers are extremely simple -
 * they only require implementing two methods.
 *
 * <pre>
 *                       wrappers (injected at creation time)
 *                                      +        +
 *                                      |        |
 *                    +-----------------|--------|--------------+
 *                    |                 v        |              |
 *                    |      +---------------+   |              |
 *                    |   +--|    wrapper1   |---|----+         |
 *                    |   |  +---------------+   v    |         |
 *                    |   |          +-------------+  |         |
 *                    |   |     +----|   wrapper2  |--------+   |
 *                    |   |     |    +-------------+  |     |   |
 *                    |   |     |                     |     |   |
 *                    |   v     v                     v     v   | wrapper
 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | +---+ +---+   +---------+   +---+ +---+ |
 *                    |  initialize                    close    |
 *                    +-----------------------------------------+
 * </pre>
 *
 * Use cases:
 * - Preserving the input selection ranges before/after reconciliation.
 *   Restoring selection even in the event of an unexpected error.
 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
 *   while guaranteeing that afterwards, the event system is reactivated.
 * - Flushing a queue of collected DOM mutations to the main UI thread after a
 *   reconciliation takes place in a worker thread.
 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
 *   content.
 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
 * - (Future use case): Layout calculations before and after DOM updates.
 *
 * Transactional plugin API:
 * - A module that has an `initialize` method that returns any precomputation.
 * - and a `close` method that accepts the precomputation. `close` is invoked
 *   when the wrapped process is completed, or has failed.
 *
 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
 * that implement `initialize` and `close`.
 * @return {Transaction} Single transaction for reuse in thread.
 *
 * @class Transaction
 */
var TransactionImpl = {
  /**
   * Sets up this instance so that it is prepared for collecting metrics. Does
   * so such that this setup method may be used on an instance that is already
   * initialized, in a way that does not consume additional memory upon reuse.
   * That can be useful if you decide to make your subclass of this mixin a
   * "PooledClass".
   */
  reinitializeTransaction: function () {
    this.transactionWrappers = this.getTransactionWrappers();
    if (this.wrapperInitData) {
      this.wrapperInitData.length = 0;
    } else {
      this.wrapperInitData = [];
    }
    this._isInTransaction = false;
  },

  _isInTransaction: false,

  /**
   * @abstract
   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
   */
  getTransactionWrappers: null,

  isInTransaction: function () {
    return !!this._isInTransaction;
  },

  /**
   * Executes the function within a safety window. Use this for the top level
   * methods that result in large amounts of computation/mutations that would
   * need to be safety checked. The optional arguments helps prevent the need
   * to bind in many cases.
   *
   * @param {function} method Member of scope to call.
   * @param {Object} scope Scope to invoke from.
   * @param {Object?=} a Argument to pass to the method.
   * @param {Object?=} b Argument to pass to the method.
   * @param {Object?=} c Argument to pass to the method.
   * @param {Object?=} d Argument to pass to the method.
   * @param {Object?=} e Argument to pass to the method.
   * @param {Object?=} f Argument to pass to the method.
   *
   * @return {*} Return value from `method`.
   */
  perform: function (method, scope, a, b, c, d, e, f) {
    !!this.isInTransaction() ? invariant$18(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : void 0;
    var errorThrown;
    var ret;
    try {
      this._isInTransaction = true;
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // one of these calls threw.
      errorThrown = true;
      this.initializeAll(0);
      ret = method.call(scope, a, b, c, d, e, f);
      errorThrown = false;
    } finally {
      try {
        if (errorThrown) {
          // If `method` throws, prefer to show that stack trace over any thrown
          // by invoking `closeAll`.
          try {
            this.closeAll(0);
          } catch (err) {}
        } else {
          // Since `method` didn't throw, we don't want to silence the exception
          // here.
          this.closeAll(0);
        }
      } finally {
        this._isInTransaction = false;
      }
    }
    return ret;
  },

  initializeAll: function (startIndex) {
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      try {
        // Catching errors makes debugging more difficult, so we start with the
        // OBSERVED_ERROR state before overwriting it with the real return value
        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
        // block, it means wrapper.initialize threw.
        this.wrapperInitData[i] = OBSERVED_ERROR;
        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
      } finally {
        if (this.wrapperInitData[i] === OBSERVED_ERROR) {
          // The initializer for wrapper i threw an error; initialize the
          // remaining wrappers but silence any exceptions from them to ensure
          // that the first error is the one to bubble up.
          try {
            this.initializeAll(i + 1);
          } catch (err) {}
        }
      }
    }
  },

  /**
   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
   * them the respective return values of `this.transactionWrappers.init[i]`
   * (`close`rs that correspond to initializers that failed will not be
   * invoked).
   */
  closeAll: function (startIndex) {
    !this.isInTransaction() ? invariant$18(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : void 0;
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      var initData = this.wrapperInitData[i];
      var errorThrown;
      try {
        // Catching errors makes debugging more difficult, so we start with
        // errorThrown set to true before setting it to false after calling
        // close -- if it's still set to true in the finally block, it means
        // wrapper.close threw.
        errorThrown = true;
        if (initData !== OBSERVED_ERROR && wrapper.close) {
          wrapper.close.call(this, initData);
        }
        errorThrown = false;
      } finally {
        if (errorThrown) {
          // The closer for wrapper i threw an error; close the remaining
          // wrappers but silence any exceptions from them to ensure that the
          // first error is the one to bubble up.
          try {
            this.closeAll(i + 1);
          } catch (e) {}
        }
      }
    }
    this.wrapperInitData.length = 0;
  }
};

var Transaction$1 = TransactionImpl;

var _assign$6 = index$1;

var CallbackQueue = CallbackQueue_1;
var PooledClass$5 = PooledClass_1$2;
var ReactFeatureFlags = ReactFeatureFlags_1;
var ReactReconciler$1 = ReactReconciler_1;
var Transaction = Transaction$1;

var invariant$15 = invariant_1;

var dirtyComponents = [];
var updateBatchNumber = 0;
var asapCallbackQueue = CallbackQueue.getPooled();
var asapEnqueued = false;

var batchingStrategy = null;

function ensureInjected() {
  !(ReactUpdates$2.ReactReconcileTransaction && batchingStrategy) ? invariant$15(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : void 0;
}

var NESTED_UPDATES = {
  initialize: function () {
    this.dirtyComponentsLength = dirtyComponents.length;
  },
  close: function () {
    if (this.dirtyComponentsLength !== dirtyComponents.length) {
      // Additional updates were enqueued by componentDidUpdate handlers or
      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
      // these new updates so that if A's componentDidUpdate calls setState on
      // B, B will update before the callback A's updater provided when calling
      // setState.
      dirtyComponents.splice(0, this.dirtyComponentsLength);
      flushBatchedUpdates();
    } else {
      dirtyComponents.length = 0;
    }
  }
};

var UPDATE_QUEUEING = {
  initialize: function () {
    this.callbackQueue.reset();
  },
  close: function () {
    this.callbackQueue.notifyAll();
  }
};

var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

function ReactUpdatesFlushTransaction() {
  this.reinitializeTransaction();
  this.dirtyComponentsLength = null;
  this.callbackQueue = CallbackQueue.getPooled();
  this.reconcileTransaction = ReactUpdates$2.ReactReconcileTransaction.getPooled(
  /* useCreateElement */true);
}

_assign$6(ReactUpdatesFlushTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  destructor: function () {
    this.dirtyComponentsLength = null;
    CallbackQueue.release(this.callbackQueue);
    this.callbackQueue = null;
    ReactUpdates$2.ReactReconcileTransaction.release(this.reconcileTransaction);
    this.reconcileTransaction = null;
  },

  perform: function (method, scope, a) {
    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
    // with this transaction's wrappers around it.
    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
  }
});

PooledClass$5.addPoolingTo(ReactUpdatesFlushTransaction);

function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}

/**
 * Array comparator for ReactComponents by mount ordering.
 *
 * @param {ReactComponent} c1 first component you're comparing
 * @param {ReactComponent} c2 second component you're comparing
 * @return {number} Return value usable by Array.prototype.sort().
 */
function mountOrderComparator(c1, c2) {
  return c1._mountOrder - c2._mountOrder;
}

function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  !(len === dirtyComponents.length) ? invariant$15(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : void 0;

  // Since reconciling a component higher in the owner hierarchy usually (not
  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
  // them before their children by sorting the array.
  dirtyComponents.sort(mountOrderComparator);

  // Any updates enqueued while reconciling must be performed after this entire
  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
  // C, B could update twice in a single batch if C's render enqueues an update
  // to B (since B would have already updated, we should skip it, and the only
  // way we can know to do so is by checking the batch counter).
  updateBatchNumber++;

  for (var i = 0; i < len; i++) {
    // If a component is unmounted before pending changes apply, it will still
    // be here, but we assume that it has cleared its _pendingCallbacks and
    // that performUpdateIfNecessary is a noop.
    var component = dirtyComponents[i];

    // If performUpdateIfNecessary happens to enqueue any new updates, we
    // shouldn't execute the callbacks until the next render happens, so
    // stash the callbacks first
    var callbacks = component._pendingCallbacks;
    component._pendingCallbacks = null;

    var markerName;
    if (ReactFeatureFlags.logTopLevelRenders) {
      var namedComponent = component;
      // Duck type TopLevelWrapper. This is probably always true.
      if (component._currentElement.type.isReactTopLevelWrapper) {
        namedComponent = component._renderedComponent;
      }
      markerName = 'React update: ' + namedComponent.getName();
      console.time(markerName);
    }

    ReactReconciler$1.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);

    if (markerName) {
      console.timeEnd(markerName);
    }

    if (callbacks) {
      for (var j = 0; j < callbacks.length; j++) {
        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
      }
    }
  }
}

var flushBatchedUpdates = function () {
  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
  // array and perform any updates enqueued by mount-ready handlers (i.e.,
  // componentDidUpdate) but we need to check here too in order to catch
  // updates enqueued by setState callbacks and asap calls.
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }

    if (asapEnqueued) {
      asapEnqueued = false;
      var queue = asapCallbackQueue;
      asapCallbackQueue = CallbackQueue.getPooled();
      queue.notifyAll();
      CallbackQueue.release(queue);
    }
  }
};

/**
 * Mark a component as needing a rerender, adding an optional callback to a
 * list of functions which will be executed once the rerender occurs.
 */
function enqueueUpdate(component) {
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
  if (component._updateBatchNumber == null) {
    component._updateBatchNumber = updateBatchNumber + 1;
  }
}

/**
 * Enqueue a callback to be run at the end of the current batching cycle. Throws
 * if no updates are currently being performed.
 */
function asap(callback, context) {
  !batchingStrategy.isBatchingUpdates ? invariant$15(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : void 0;
  asapCallbackQueue.enqueue(callback, context);
  asapEnqueued = true;
}

var ReactUpdatesInjection = {
  injectReconcileTransaction: function (ReconcileTransaction) {
    !ReconcileTransaction ? invariant$15(false, 'ReactUpdates: must provide a reconcile transaction class') : void 0;
    ReactUpdates$2.ReactReconcileTransaction = ReconcileTransaction;
  },

  injectBatchingStrategy: function (_batchingStrategy) {
    !_batchingStrategy ? invariant$15(false, 'ReactUpdates: must provide a batching strategy') : void 0;
    !(typeof _batchingStrategy.batchedUpdates === 'function') ? invariant$15(false, 'ReactUpdates: must provide a batchedUpdates() function') : void 0;
    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? invariant$15(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : void 0;
    batchingStrategy = _batchingStrategy;
  }
};

var ReactUpdates$2 = {
  /**
   * React references `ReactReconcileTransaction` using this property in order
   * to allow dependency injection.
   *
   * @internal
   */
  ReactReconcileTransaction: null,

  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection,
  asap: asap
};

var ReactUpdates_1 = ReactUpdates$2;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */

function getEventTarget$1(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;

  // Normalize SVG <use> element events #4963
  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }

  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === 3 ? target.parentNode : target;
}

var getEventTarget_1 = getEventTarget$1;

var ExecutionEnvironment$7 = ExecutionEnvironment_1;

var useHasFeature;
if (ExecutionEnvironment$7.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported$1(eventNameSuffix, capture) {
  if (!ExecutionEnvironment$7.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

var isEventSupported_1 = isEventSupported$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */

var supportedInputTypes = {
  'color': true,
  'date': true,
  'datetime': true,
  'datetime-local': true,
  'email': true,
  'month': true,
  'number': true,
  'password': true,
  'range': true,
  'search': true,
  'tel': true,
  'text': true,
  'time': true,
  'url': true,
  'week': true
};

function isTextInputElement$1(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

var isTextInputElement_1 = isTextInputElement$1;

var EventPluginHub$2 = EventPluginHub_1;
var EventPropagators$2 = EventPropagators_1;
var ExecutionEnvironment$4 = ExecutionEnvironment_1;
var ReactDOMComponentTree$3 = ReactDOMComponentTree_1;
var ReactUpdates$1 = ReactUpdates_1;
var SyntheticEvent$3 = SyntheticEvent_1;

var getEventTarget = getEventTarget_1;
var isEventSupported = isEventSupported_1;
var isTextInputElement = isTextInputElement_1;

var eventTypes$1 = {
  change: {
    phasedRegistrationNames: {
      bubbled: 'onChange',
      captured: 'onChangeCapture'
    },
    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
  }
};

/**
 * For IE shims
 */
var activeElement = null;
var activeElementInst = null;
var activeElementValue = null;
var activeElementValueProp = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

var doesChangeEventBubble = false;
if (ExecutionEnvironment$4.canUseDOM) {
  // See `handleChange` comment below
  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = SyntheticEvent$3.getPooled(eventTypes$1.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
  EventPropagators$2.accumulateTwoPhaseDispatches(event);

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates$1.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub$2.enqueueEvents(event);
  EventPluginHub$2.processEventQueue(false);
}

function startWatchingForChangeEventIE8(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
}

function stopWatchingForChangeEventIE8() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
  activeElement = null;
  activeElementInst = null;
}

function getTargetInstForChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topChange') {
    return targetInst;
  }
}
function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForChangeEventIE8();
    startWatchingForChangeEventIE8(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForChangeEventIE8();
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment$4.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  // IE10+ fire input events to often, such when a placeholder
  // changes or when an input with a placeholder is focused.
  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 11);
}

/**
 * (For IE <=11) Replacement getter/setter for the `value` property that gets
 * set on the active element.
 */
var newValueProp = {
  get: function () {
    return activeElementValueProp.get.call(this);
  },
  set: function (val) {
    // Cast to a string so we can do equality checks.
    activeElementValue = '' + val;
    activeElementValueProp.set.call(this, val);
  }
};

/**
 * (For IE <=11) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElementValue = target.value;
  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');

  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
  // on DOM elements
  Object.defineProperty(activeElement, 'value', newValueProp);
  if (activeElement.attachEvent) {
    activeElement.attachEvent('onpropertychange', handlePropertyChange);
  } else {
    activeElement.addEventListener('propertychange', handlePropertyChange, false);
  }
}

/**
 * (For IE <=11) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }

  // delete restores the original property definition
  delete activeElement.value;

  if (activeElement.detachEvent) {
    activeElement.detachEvent('onpropertychange', handlePropertyChange);
  } else {
    activeElement.removeEventListener('propertychange', handlePropertyChange, false);
  }

  activeElement = null;
  activeElementInst = null;
  activeElementValue = null;
  activeElementValueProp = null;
}

/**
 * (For IE <=11) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  var value = nativeEvent.srcElement.value;
  if (value === activeElementValue) {
    return;
  }
  activeElementValue = value;

  manualDispatchChangeEvent(nativeEvent);
}

/**
 * If a `change` event should be fired, returns the target's ID.
 */
function getTargetInstForInputEvent(topLevelType, targetInst) {
  if (topLevelType === 'topInput') {
    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
    // what we want so fall through here and trigger an abstract event
    return targetInst;
  }
}

function handleEventsForInputEventIE(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // In IE8, we can capture almost all .value changes by adding a
    // propertychange handler and looking for events with propertyName
    // equal to 'value'
    // In IE9-11, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetInstForInputEventIE(topLevelType, targetInst) {
  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    if (activeElement && activeElement.value !== activeElementValue) {
      activeElementValue = activeElement.value;
      return activeElementInst;
    }
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(topLevelType, targetInst) {
  if (topLevelType === 'topClick') {
    return targetInst;
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin$1 = {

  eventTypes: eventTypes$1,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var targetNode = targetInst ? ReactDOMComponentTree$3.getNodeFromInstance(targetInst) : window;

    var getTargetInstFunc, handleEventFunc;
    if (shouldUseChangeEvent(targetNode)) {
      if (doesChangeEventBubble) {
        getTargetInstFunc = getTargetInstForChangeEvent;
      } else {
        handleEventFunc = handleEventsForChangeEventIE8;
      }
    } else if (isTextInputElement(targetNode)) {
      if (isInputEventSupported) {
        getTargetInstFunc = getTargetInstForInputEvent;
      } else {
        getTargetInstFunc = getTargetInstForInputEventIE;
        handleEventFunc = handleEventsForInputEventIE;
      }
    } else if (shouldUseClickEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForClickEvent;
    }

    if (getTargetInstFunc) {
      var inst = getTargetInstFunc(topLevelType, targetInst);
      if (inst) {
        var event = SyntheticEvent$3.getPooled(eventTypes$1.change, inst, nativeEvent, nativeEventTarget);
        event.type = 'change';
        EventPropagators$2.accumulateTwoPhaseDispatches(event);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, targetNode, targetInst);
    }
  }

};

var ChangeEventPlugin_1 = ChangeEventPlugin$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */

var DefaultEventPluginOrder$1 = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

var DefaultEventPluginOrder_1 = DefaultEventPluginOrder$1;

var SyntheticEvent$4 = SyntheticEvent_1;

var getEventTarget$2 = getEventTarget_1;

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: function (event) {
    if (event.view) {
      return event.view;
    }

    var target = getEventTarget$2(event);
    if (target.window === target) {
      // target is a window object
      return target;
    }

    var doc = target.ownerDocument;
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    if (doc) {
      return doc.defaultView || doc.parentWindow;
    } else {
      return window;
    }
  },
  detail: function (event) {
    return event.detail || 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent$1(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$4.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$4.augmentClass(SyntheticUIEvent$1, UIEventInterface);

var SyntheticUIEvent_1 = SyntheticUIEvent$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

var ViewportMetrics$1 = {

  currentScrollLeft: 0,

  currentScrollTop: 0,

  refreshScrollValues: function (scrollPosition) {
    ViewportMetrics$1.currentScrollLeft = scrollPosition.x;
    ViewportMetrics$1.currentScrollTop = scrollPosition.y;
  }

};

var ViewportMetrics_1 = ViewportMetrics$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  'Alt': 'altKey',
  'Control': 'ctrlKey',
  'Meta': 'metaKey',
  'Shift': 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState$1(nativeEvent) {
  return modifierStateGetter;
}

var getEventModifierState_1 = getEventModifierState$1;

var SyntheticUIEvent = SyntheticUIEvent_1;
var ViewportMetrics = ViewportMetrics_1;

var getEventModifierState = getEventModifierState_1;

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: function (event) {
    // Webkit, Firefox, IE9+
    // which:  1 2 3
    // button: 0 1 2 (standard)
    var button = event.button;
    if ('which' in event) {
      return button;
    }
    // IE<9
    // which:  undefined
    // button: 0 0 0
    // button: 1 4 2 (onmouseup)
    return button === 2 ? 2 : button === 4 ? 1 : 0;
  },
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  },
  // "Proprietary" Interface.
  pageX: function (event) {
    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
  },
  pageY: function (event) {
    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent$1(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent$1, MouseEventInterface);

var SyntheticMouseEvent_1 = SyntheticMouseEvent$1;

var EventPropagators$3 = EventPropagators_1;
var ReactDOMComponentTree$4 = ReactDOMComponentTree_1;
var SyntheticMouseEvent = SyntheticMouseEvent_1;

var eventTypes$2 = {
  mouseEnter: {
    registrationName: 'onMouseEnter',
    dependencies: ['topMouseOut', 'topMouseOver']
  },
  mouseLeave: {
    registrationName: 'onMouseLeave',
    dependencies: ['topMouseOut', 'topMouseOver']
  }
};

var EnterLeaveEventPlugin$1 = {

  eventTypes: eventTypes$2,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (nativeEventTarget.window === nativeEventTarget) {
      // `nativeEventTarget` is probably a window object.
      win = nativeEventTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = nativeEventTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    if (topLevelType === 'topMouseOut') {
      from = targetInst;
      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
      to = related ? ReactDOMComponentTree$4.getClosestInstanceFromNode(related) : null;
    } else {
      // Moving to a node from outside the window.
      from = null;
      to = targetInst;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromNode = from == null ? win : ReactDOMComponentTree$4.getNodeFromInstance(from);
    var toNode = to == null ? win : ReactDOMComponentTree$4.getNodeFromInstance(to);

    var leave = SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave, from, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = fromNode;
    leave.relatedTarget = toNode;

    var enter = SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter, to, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    EventPropagators$3.accumulateEnterLeaveDispatches(leave, enter, from, to);

    return [leave, enter];
  }

};

var EnterLeaveEventPlugin_1 = EnterLeaveEventPlugin$1;

var DOMProperty$2 = DOMProperty_1;

var MUST_USE_PROPERTY = DOMProperty$2.injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = DOMProperty$2.injection.HAS_BOOLEAN_VALUE;
var HAS_NUMERIC_VALUE = DOMProperty$2.injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty$2.injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty$2.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

var HTMLDOMPropertyConfig$1 = {
  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty$2.ATTRIBUTE_NAME_CHAR + ']*$')),
  Properties: {
    /**
     * Standard Properties
     */
    accept: 0,
    acceptCharset: 0,
    accessKey: 0,
    action: 0,
    allowFullScreen: HAS_BOOLEAN_VALUE,
    allowTransparency: 0,
    alt: 0,
    // specifies target context for links with `preload` type
    as: 0,
    async: HAS_BOOLEAN_VALUE,
    autoComplete: 0,
    // autoFocus is polyfilled/normalized by AutoFocusUtils
    // autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: HAS_BOOLEAN_VALUE,
    cellPadding: 0,
    cellSpacing: 0,
    charSet: 0,
    challenge: 0,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    cite: 0,
    classID: 0,
    className: 0,
    cols: HAS_POSITIVE_NUMERIC_VALUE,
    colSpan: 0,
    content: 0,
    contentEditable: 0,
    contextMenu: 0,
    controls: HAS_BOOLEAN_VALUE,
    coords: 0,
    crossOrigin: 0,
    data: 0, // For `<object />` acts as `src`.
    dateTime: 0,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    dir: 0,
    disabled: HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: 0,
    encType: 0,
    form: 0,
    formAction: 0,
    formEncType: 0,
    formMethod: 0,
    formNoValidate: HAS_BOOLEAN_VALUE,
    formTarget: 0,
    frameBorder: 0,
    headers: 0,
    height: 0,
    hidden: HAS_BOOLEAN_VALUE,
    high: 0,
    href: 0,
    hrefLang: 0,
    htmlFor: 0,
    httpEquiv: 0,
    icon: 0,
    id: 0,
    inputMode: 0,
    integrity: 0,
    is: 0,
    keyParams: 0,
    keyType: 0,
    kind: 0,
    label: 0,
    lang: 0,
    list: 0,
    loop: HAS_BOOLEAN_VALUE,
    low: 0,
    manifest: 0,
    marginHeight: 0,
    marginWidth: 0,
    max: 0,
    maxLength: 0,
    media: 0,
    mediaGroup: 0,
    method: 0,
    min: 0,
    minLength: 0,
    // Caution; `option.selected` is not updated if `select.multiple` is
    // disabled with `removeAttribute`.
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    name: 0,
    nonce: 0,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    optimum: 0,
    pattern: 0,
    placeholder: 0,
    playsInline: HAS_BOOLEAN_VALUE,
    poster: 0,
    preload: 0,
    profile: 0,
    radioGroup: 0,
    readOnly: HAS_BOOLEAN_VALUE,
    referrerPolicy: 0,
    rel: 0,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    role: 0,
    rows: HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: HAS_NUMERIC_VALUE,
    sandbox: 0,
    scope: 0,
    scoped: HAS_BOOLEAN_VALUE,
    scrolling: 0,
    seamless: HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    shape: 0,
    size: HAS_POSITIVE_NUMERIC_VALUE,
    sizes: 0,
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: 0,
    src: 0,
    srcDoc: 0,
    srcLang: 0,
    srcSet: 0,
    start: HAS_NUMERIC_VALUE,
    step: 0,
    style: 0,
    summary: 0,
    tabIndex: 0,
    target: 0,
    title: 0,
    // Setting .type throws on non-<input> tags
    type: 0,
    useMap: 0,
    value: 0,
    width: 0,
    wmode: 0,
    wrap: 0,

    /**
     * RDFa Properties
     */
    about: 0,
    datatype: 0,
    inlist: 0,
    prefix: 0,
    // property is also supported for OpenGraph in meta tags.
    property: 0,
    resource: 0,
    'typeof': 0,
    vocab: 0,

    /**
     * Non-standard Properties
     */
    // autoCapitalize and autoCorrect are supported in Mobile Safari for
    // keyboard hints.
    autoCapitalize: 0,
    autoCorrect: 0,
    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
    autoSave: 0,
    // color is for Safari mask-icon link
    color: 0,
    // itemProp, itemScope, itemType are for
    // Microdata support. See http://schema.org/docs/gs.html
    itemProp: 0,
    itemScope: HAS_BOOLEAN_VALUE,
    itemType: 0,
    // itemID and itemRef are for Microdata support as well but
    // only specified in the WHATWG spec document. See
    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
    itemID: 0,
    itemRef: 0,
    // results show looking glass icon and recent searches on input
    // search fields in WebKit/Blink
    results: 0,
    // IE-only attribute that specifies security restrictions on an iframe
    // as an alternative to the sandbox attribute on IE<10
    security: 0,
    // IE-only attribute that controls focus behavior
    unselectable: 0
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMPropertyNames: {}
};

var HTMLDOMPropertyConfig_1 = HTMLDOMPropertyConfig$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

var DOMNamespaces$1 = {
  html: 'http://www.w3.org/1999/xhtml',
  mathml: 'http://www.w3.org/1998/Math/MathML',
  svg: 'http://www.w3.org/2000/svg'
};

var DOMNamespaces_1 = DOMNamespaces$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* globals MSApp */

/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */

var createMicrosoftUnsafeLocalFunction$3 = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

var createMicrosoftUnsafeLocalFunction_1 = createMicrosoftUnsafeLocalFunction$3;

var ExecutionEnvironment$8 = ExecutionEnvironment_1;
var DOMNamespaces$2 = DOMNamespaces_1;

var WHITESPACE_TEST = /^[ \r\n\t\f]/;
var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

var createMicrosoftUnsafeLocalFunction$2 = createMicrosoftUnsafeLocalFunction_1;

// SVG temp container for IE lacking innerHTML
var reusableSVGContainer;

/**
 * Set the innerHTML property of a node, ensuring that whitespace is preserved
 * even in IE8.
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML$2 = createMicrosoftUnsafeLocalFunction$2(function (node, html) {
  // IE does not have innerHTML for SVG nodes, so instead we inject the
  // new markup in a temp node and then move the child nodes across into
  // the target node
  if (node.namespaceURI === DOMNamespaces$2.svg && !('innerHTML' in node)) {
    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
    var svgNode = reusableSVGContainer.firstChild;
    while (svgNode.firstChild) {
      node.appendChild(svgNode.firstChild);
    }
  } else {
    node.innerHTML = html;
  }
});

if (ExecutionEnvironment$8.canUseDOM) {
  // IE8: When updating a just created node with innerHTML only leading
  // whitespace is removed. When updating an existing node with innerHTML
  // whitespace in root TextNodes is also collapsed.
  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

  // Feature detection; only IE8 is known to behave improperly like this.
  var testElement = document.createElement('div');
  testElement.innerHTML = ' ';
  if (testElement.innerHTML === '') {
    setInnerHTML$2 = function (node, html) {
      // Magic theory: IE8 supposedly differentiates between added and updated
      // nodes when processing innerHTML, innerHTML on updated nodes suffers
      // from worse whitespace behavior. Re-adding a node like this triggers
      // the initial and more favorable whitespace behavior.
      // TODO: What to do on a detached node?
      if (node.parentNode) {
        node.parentNode.replaceChild(node, node);
      }

      // We also implement a workaround for non-visible tags disappearing into
      // thin air on IE8, this only happens if there is no visible text
      // in-front of the non-visible tags. Piggyback on the whitespace fix
      // and simply check if any non-visible tags appear in the source.
      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
        // Recover leading whitespace by temporarily prepending any character.
        // \uFEFF has the potential advantage of being zero-width/invisible.
        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
        // in hopes that this is preserved even if "\uFEFF" is transformed to
        // the actual Unicode character (by Babel, for example).
        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
        node.innerHTML = String.fromCharCode(0xFEFF) + html;

        // deleteData leaves an empty `TextNode` which offsets the index of all
        // children. Definitely want to avoid this.
        var textNode = node.firstChild;
        if (textNode.data.length === 1) {
          node.removeChild(textNode);
        } else {
          textNode.deleteData(0, 1);
        }
      } else {
        node.innerHTML = html;
      }
    };
  }
  testElement = null;
}

var setInnerHTML_1 = setInnerHTML$2;

/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * Based on the escape-html library, which is used under the MIT License below:
 *
 * Copyright (c) 2012-2013 TJ Holowaychuk
 * Copyright (c) 2015 Andreas Lubbe
 * Copyright (c) 2015 Tiancheng "Timothy" Gu
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

// code copied and modified from escape-html
/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        // "
        escape = '&quot;';
        break;
      case 38:
        // &
        escape = '&amp;';
        break;
      case 39:
        // '
        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
        break;
      case 60:
        // <
        escape = '&lt;';
        break;
      case 62:
        // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
// end code copied and modified from escape-html


/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextContentForBrowser$1(text) {
  if (typeof text === 'boolean' || typeof text === 'number') {
    // this shortcircuit helps perf for types that we know will never have
    // special characters, especially given that this function is used often
    // for numeric dom ids.
    return '' + text;
  }
  return escapeHtml(text);
}

var escapeTextContentForBrowser_1 = escapeTextContentForBrowser$1;

var ExecutionEnvironment$9 = ExecutionEnvironment_1;
var escapeTextContentForBrowser = escapeTextContentForBrowser_1;
var setInnerHTML$3 = setInnerHTML_1;

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent$2 = function (node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
};

if (ExecutionEnvironment$9.canUseDOM) {
  if (!('textContent' in document.documentElement)) {
    setTextContent$2 = function (node, text) {
      if (node.nodeType === 3) {
        node.nodeValue = text;
        return;
      }
      setInnerHTML$3(node, escapeTextContentForBrowser(text));
    };
  }
}

var setTextContent_1 = setTextContent$2;

var DOMNamespaces = DOMNamespaces_1;
var setInnerHTML$1 = setInnerHTML_1;

var createMicrosoftUnsafeLocalFunction$1 = createMicrosoftUnsafeLocalFunction_1;
var setTextContent$1 = setTextContent_1;

var ELEMENT_NODE_TYPE = 1;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

/**
 * In IE (8-11) and Edge, appending nodes with no children is dramatically
 * faster than appending a full subtree, so we essentially queue up the
 * .appendChild calls here and apply them so each node is added to its parent
 * before any children are added.
 *
 * In other browsers, doing so is slower or neutral compared to the other order
 * (in Firefox, twice as slow) so we only do this inversion in IE.
 *
 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
 */
var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);

function insertTreeChildren(tree) {
  if (!enableLazy) {
    return;
  }
  var node = tree.node;
  var children = tree.children;
  if (children.length) {
    for (var i = 0; i < children.length; i++) {
      insertTreeBefore(node, children[i], null);
    }
  } else if (tree.html != null) {
    setInnerHTML$1(node, tree.html);
  } else if (tree.text != null) {
    setTextContent$1(node, tree.text);
  }
}

var insertTreeBefore = createMicrosoftUnsafeLocalFunction$1(function (parentNode, tree, referenceNode) {
  // DocumentFragments aren't actually part of the DOM after insertion so
  // appending children won't update the DOM. We need to ensure the fragment
  // is properly populated first, breaking out of our lazy approach for just
  // this level. Also, some <object> plugins (like Flash Player) will read
  // <param> nodes immediately upon insertion into the DOM, so <object>
  // must also be populated prior to insertion into the DOM.
  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
    insertTreeChildren(tree);
    parentNode.insertBefore(tree.node, referenceNode);
  } else {
    parentNode.insertBefore(tree.node, referenceNode);
    insertTreeChildren(tree);
  }
});

function replaceChildWithTree(oldNode, newTree) {
  oldNode.parentNode.replaceChild(newTree.node, oldNode);
  insertTreeChildren(newTree);
}

function queueChild(parentTree, childTree) {
  if (enableLazy) {
    parentTree.children.push(childTree);
  } else {
    parentTree.node.appendChild(childTree.node);
  }
}

function queueHTML(tree, html) {
  if (enableLazy) {
    tree.html = html;
  } else {
    setInnerHTML$1(tree.node, html);
  }
}

function queueText(tree, text) {
  if (enableLazy) {
    tree.text = text;
  } else {
    setTextContent$1(tree.node, text);
  }
}

function toString() {
  return this.node.nodeName;
}

function DOMLazyTree$1(node) {
  return {
    node: node,
    children: [],
    html: null,
    text: null,
    toString: toString
  };
}

DOMLazyTree$1.insertTreeBefore = insertTreeBefore;
DOMLazyTree$1.replaceChildWithTree = replaceChildWithTree;
DOMLazyTree$1.queueChild = queueChild;
DOMLazyTree$1.queueHTML = queueHTML;
DOMLazyTree$1.queueText = queueText;

var DOMLazyTree_1 = DOMLazyTree$1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var invariant$21 = invariant_1;

/**
 * Convert array-like objects to arrays.
 *
 * This API assumes the caller knows the contents of the data type. For less
 * well defined inputs use createArrayFromMixed.
 *
 * @param {object|function|filelist} obj
 * @return {array}
 */
function toArray$1(obj) {
  var length = obj.length;

  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
  // in old versions of Safari).
  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? invariant$21(false, 'toArray: Array-like object expected') : void 0;

  !(typeof length === 'number') ? invariant$21(false, 'toArray: Object needs a length property') : void 0;

  !(length === 0 || length - 1 in obj) ? invariant$21(false, 'toArray: Object should have keys for indices') : void 0;

  !(typeof obj.callee !== 'function') ? invariant$21(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : void 0;

  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
  // without method will throw during the slice call and skip straight to the
  // fallback.
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {
      // IE < 9 does not support Array#slice on collections objects
    }
  }

  // Fall back to copying key by key. This assumes all keys have a value,
  // so will not preserve sparsely populated inputs.
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}

/**
 * Perform a heuristic test to determine if an object is "array-like".
 *
 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
 *   Joshu replied: "Mu."
 *
 * This function determines if its argument has "array nature": it returns
 * true if the argument is an actual array, an `arguments' object, or an
 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
 *
 * It will return false for other array-like objects like Filelist.
 *
 * @param {*} obj
 * @return {boolean}
 */
function hasArrayNature(obj) {
  return (
    // not null/false
    !!obj && (
    // arrays are objects, NodeLists are functions in Safari
    typeof obj == 'object' || typeof obj == 'function') &&
    // quacks like an array
    'length' in obj &&
    // not window
    !('setInterval' in obj) &&
    // no DOM node should be considered an array-like
    // a 'select' element has 'length' and 'item' properties on IE8
    typeof obj.nodeType != 'number' && (
    // a real array
    Array.isArray(obj) ||
    // arguments
    'callee' in obj ||
    // HTMLCollection/NodeList
    'item' in obj)
  );
}

/**
 * Ensure that the argument is an array by wrapping it in an array if it is not.
 * Creates a copy of the argument if it is already an array.
 *
 * This is mostly useful idiomatically:
 *
 *   var createArrayFromMixed = require('createArrayFromMixed');
 *
 *   function takesOneOrMoreThings(things) {
 *     things = createArrayFromMixed(things);
 *     ...
 *   }
 *
 * This allows you to treat `things' as an array, but accept scalars in the API.
 *
 * If you need to convert an array-like object, like `arguments`, into an array
 * use toArray instead.
 *
 * @param {*} obj
 * @return {array}
 */
function createArrayFromMixed$1(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray$1(obj);
  }
}

var createArrayFromMixed_1 = createArrayFromMixed$1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/*eslint-disable fb-www/unsafe-html */

var ExecutionEnvironment$12 = ExecutionEnvironment_1;

var invariant$22 = invariant_1;

/**
 * Dummy container used to detect which wraps are necessary.
 */
var dummyNode$1 = ExecutionEnvironment$12.canUseDOM ? document.createElement('div') : null;

/**
 * Some browsers cannot use `innerHTML` to render certain elements standalone,
 * so we wrap them, render the wrapped nodes, then extract the desired node.
 *
 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
 */

var shouldWrap = {};

var selectWrap = [1, '<select multiple="true">', '</select>'];
var tableWrap = [1, '<table>', '</table>'];
var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

var markupWrap = {
  '*': [1, '?<div>', '</div>'],

  'area': [1, '<map>', '</map>'],
  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  'legend': [1, '<fieldset>', '</fieldset>'],
  'param': [1, '<object>', '</object>'],
  'tr': [2, '<table><tbody>', '</tbody></table>'],

  'optgroup': selectWrap,
  'option': selectWrap,

  'caption': tableWrap,
  'colgroup': tableWrap,
  'tbody': tableWrap,
  'tfoot': tableWrap,
  'thead': tableWrap,

  'td': trWrap,
  'th': trWrap
};

// Initialize the SVG elements since we know they'll always need to be wrapped
// consistently. If they are created inside a <div> they will be initialized in
// the wrong namespace (and will not display).
var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
svgElements.forEach(function (nodeName) {
  markupWrap[nodeName] = svgWrap;
  shouldWrap[nodeName] = true;
});

/**
 * Gets the markup wrap configuration for the supplied `nodeName`.
 *
 * NOTE: This lazily detects which wraps are necessary for the current browser.
 *
 * @param {string} nodeName Lowercase `nodeName`.
 * @return {?array} Markup wrap configuration, if applicable.
 */
function getMarkupWrap$1(nodeName) {
  !!!dummyNode$1 ? invariant$22(false, 'Markup wrapping node not initialized') : void 0;
  if (!markupWrap.hasOwnProperty(nodeName)) {
    nodeName = '*';
  }
  if (!shouldWrap.hasOwnProperty(nodeName)) {
    if (nodeName === '*') {
      dummyNode$1.innerHTML = '<link />';
    } else {
      dummyNode$1.innerHTML = '<' + nodeName + '></' + nodeName + '>';
    }
    shouldWrap[nodeName] = !dummyNode$1.firstChild;
  }
  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
}

var getMarkupWrap_1 = getMarkupWrap$1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/*eslint-disable fb-www/unsafe-html*/

var ExecutionEnvironment$11 = ExecutionEnvironment_1;

var createArrayFromMixed = createArrayFromMixed_1;
var getMarkupWrap = getMarkupWrap_1;
var invariant$20 = invariant_1;

/**
 * Dummy container used to render all markup.
 */
var dummyNode = ExecutionEnvironment$11.canUseDOM ? document.createElement('div') : null;

/**
 * Pattern used by `getNodeName`.
 */
var nodeNamePattern = /^\s*<(\w+)/;

/**
 * Extracts the `nodeName` of the first element in a string of markup.
 *
 * @param {string} markup String of markup.
 * @return {?string} Node name of the supplied markup.
 */
function getNodeName(markup) {
  var nodeNameMatch = markup.match(nodeNamePattern);
  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
}

/**
 * Creates an array containing the nodes rendered from the supplied markup. The
 * optionally supplied `handleScript` function will be invoked once for each
 * <script> element that is rendered. If no `handleScript` function is supplied,
 * an exception is thrown if any <script> elements are rendered.
 *
 * @param {string} markup A string of valid HTML markup.
 * @param {?function} handleScript Invoked once for each rendered <script>.
 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
 */
function createNodesFromMarkup$1(markup, handleScript) {
  var node = dummyNode;
  !!!dummyNode ? invariant$20(false, 'createNodesFromMarkup dummy not initialized') : void 0;
  var nodeName = getNodeName(markup);

  var wrap = nodeName && getMarkupWrap(nodeName);
  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];

    var wrapDepth = wrap[0];
    while (wrapDepth--) {
      node = node.lastChild;
    }
  } else {
    node.innerHTML = markup;
  }

  var scripts = node.getElementsByTagName('script');
  if (scripts.length) {
    !handleScript ? invariant$20(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : void 0;
    createArrayFromMixed(scripts).forEach(handleScript);
  }

  var nodes = Array.from(node.childNodes);
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
  return nodes;
}

var createNodesFromMarkup_1 = createNodesFromMarkup$1;

var DOMLazyTree$2 = DOMLazyTree_1;
var ExecutionEnvironment$10 = ExecutionEnvironment_1;

var createNodesFromMarkup = createNodesFromMarkup_1;
var emptyFunction$5 = emptyFunction_1;
var invariant$19 = invariant_1;

var Danger$1 = {

  /**
   * Replaces a node with a string of markup at its current position within its
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
    !ExecutionEnvironment$10.canUseDOM ? invariant$19(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : void 0;
    !markup ? invariant$19(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : void 0;
    !(oldChild.nodeName !== 'HTML') ? invariant$19(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : void 0;

    if (typeof markup === 'string') {
      var newChild = createNodesFromMarkup(markup, emptyFunction$5)[0];
      oldChild.parentNode.replaceChild(newChild, oldChild);
    } else {
      DOMLazyTree$2.replaceChildWithTree(oldChild, markup);
    }
  }

};

var Danger_1 = Danger$1;

var DOMLazyTree = DOMLazyTree_1;
var Danger = Danger_1;
var ReactDOMComponentTree$5 = ReactDOMComponentTree_1;
var ReactInstrumentation$4 = ReactInstrumentation$2;

var createMicrosoftUnsafeLocalFunction = createMicrosoftUnsafeLocalFunction_1;
var setInnerHTML = setInnerHTML_1;
var setTextContent = setTextContent_1;

function getNodeAfter(parentNode, node) {
  // Special case for text components, which return [open, close] comments
  // from getHostNode.
  if (Array.isArray(node)) {
    node = node[1];
  }
  return node ? node.nextSibling : parentNode.firstChild;
}

/**
 * Inserts `childNode` as a child of `parentNode` at the `index`.
 *
 * @param {DOMElement} parentNode Parent node in which to insert.
 * @param {DOMElement} childNode Child node to insert.
 * @param {number} index Index at which to insert the child.
 * @internal
 */
var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
  // We rely exclusively on `insertBefore(node, null)` instead of also using
  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
  // we are careful to use `null`.)
  parentNode.insertBefore(childNode, referenceNode);
});

function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
}

function moveChild(parentNode, childNode, referenceNode) {
  if (Array.isArray(childNode)) {
    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
  } else {
    insertChildAt(parentNode, childNode, referenceNode);
  }
}

function removeChild(parentNode, childNode) {
  if (Array.isArray(childNode)) {
    var closingComment = childNode[1];
    childNode = childNode[0];
    removeDelimitedText(parentNode, childNode, closingComment);
    parentNode.removeChild(closingComment);
  }
  parentNode.removeChild(childNode);
}

function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
  var node = openingComment;
  while (true) {
    var nextNode = node.nextSibling;
    insertChildAt(parentNode, node, referenceNode);
    if (node === closingComment) {
      break;
    }
    node = nextNode;
  }
}

function removeDelimitedText(parentNode, startNode, closingComment) {
  while (true) {
    var node = startNode.nextSibling;
    if (node === closingComment) {
      // The closing comment is removed by ReactMultiChild.
      break;
    } else {
      parentNode.removeChild(node);
    }
  }
}

function replaceDelimitedText(openingComment, closingComment, stringText) {
  var parentNode = openingComment.parentNode;
  var nodeAfterComment = openingComment.nextSibling;
  if (nodeAfterComment === closingComment) {
    // There are no text nodes between the opening and closing comments; insert
    // a new one if stringText isn't empty.
    if (stringText) {
      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
    }
  } else {
    if (stringText) {
      // Set the text content of the first node after the opening comment, and
      // remove all following nodes up until the closing comment.
      setTextContent(nodeAfterComment, stringText);
      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
    } else {
      removeDelimitedText(parentNode, openingComment, closingComment);
    }
  }

  {
    ReactInstrumentation$4.debugTool.onHostOperation({
      instanceID: ReactDOMComponentTree$5.getInstanceFromNode(openingComment)._debugID,
      type: 'replace text',
      payload: stringText
    });
  }
}

var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
{
  dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
    if (prevInstance._debugID !== 0) {
      ReactInstrumentation$4.debugTool.onHostOperation({
        instanceID: prevInstance._debugID,
        type: 'replace with',
        payload: markup.toString()
      });
    } else {
      var nextInstance = ReactDOMComponentTree$5.getInstanceFromNode(markup.node);
      if (nextInstance._debugID !== 0) {
        ReactInstrumentation$4.debugTool.onHostOperation({
          instanceID: nextInstance._debugID,
          type: 'mount',
          payload: markup.toString()
        });
      }
    }
  };
}

/**
 * Operations for updating with DOM children.
 */
var DOMChildrenOperations$1 = {

  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,

  replaceDelimitedText: replaceDelimitedText,

  /**
   * Updates a component's children by processing a series of updates. The
   * update configurations are each expected to have a `parentNode` property.
   *
   * @param {array<object>} updates List of update configurations.
   * @internal
   */
  processUpdates: function (parentNode, updates) {
    {
      var parentNodeDebugID = ReactDOMComponentTree$5.getInstanceFromNode(parentNode)._debugID;
    }

    for (var k = 0; k < updates.length; k++) {
      var update = updates[k];
      switch (update.type) {
        case 'INSERT_MARKUP':
          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
          {
            ReactInstrumentation$4.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'insert child',
              payload: { toIndex: update.toIndex, content: update.content.toString() }
            });
          }
          break;
        case 'MOVE_EXISTING':
          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
          {
            ReactInstrumentation$4.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'move child',
              payload: { fromIndex: update.fromIndex, toIndex: update.toIndex }
            });
          }
          break;
        case 'SET_MARKUP':
          setInnerHTML(parentNode, update.content);
          {
            ReactInstrumentation$4.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'replace children',
              payload: update.content.toString()
            });
          }
          break;
        case 'TEXT_CONTENT':
          setTextContent(parentNode, update.content);
          {
            ReactInstrumentation$4.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'replace text',
              payload: update.content.toString()
            });
          }
          break;
        case 'REMOVE_NODE':
          removeChild(parentNode, update.fromNode);
          {
            ReactInstrumentation$4.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'remove child',
              payload: { fromIndex: update.fromIndex }
            });
          }
          break;
      }
    }
  }

};

var DOMChildrenOperations_1 = DOMChildrenOperations$1;

var DOMChildrenOperations$2 = DOMChildrenOperations_1;
var ReactDOMComponentTree$6 = ReactDOMComponentTree_1;

/**
 * Operations used to process updates to DOM nodes.
 */
var ReactDOMIDOperations$1 = {

  /**
   * Updates a component's children by processing a series of updates.
   *
   * @param {array<object>} updates List of update configurations.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
    var node = ReactDOMComponentTree$6.getNodeFromInstance(parentInst);
    DOMChildrenOperations$2.processUpdates(node, updates);
  }
};

var ReactDOMIDOperations_1 = ReactDOMIDOperations$1;

var DOMChildrenOperations = DOMChildrenOperations_1;
var ReactDOMIDOperations = ReactDOMIDOperations_1;

/**
 * Abstracts away all functionality of the reconciler that requires knowledge of
 * the browser context. TODO: These callers should be refactored to avoid the
 * need for this injection.
 */
var ReactComponentBrowserEnvironment$1 = {

  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup

};

var ReactComponentBrowserEnvironment_1 = ReactComponentBrowserEnvironment$1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode$1(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

var focusNode_1 = focusNode$1;

var ReactDOMComponentTree$8 = ReactDOMComponentTree_1;

var focusNode = focusNode_1;

var AutoFocusUtils$1 = {
  focusDOMComponent: function () {
    focusNode(ReactDOMComponentTree$8.getNodeFromInstance(this));
  }
};

var AutoFocusUtils_1 = AutoFocusUtils$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * CSS properties which accept numbers but are not in units of "px".
 */

var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridColumn: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Most style properties can be unset by doing .style[prop] = '' but IE8
 * doesn't like doing that with shorthand properties so for the properties that
 * IE8 breaks on, which are listed here, we instead unset each of the
 * individual properties. See http://bugs.jquery.com/ticket/12385.
 * The 4-value 'clock' properties like margin, padding, border-width seem to
 * behave without any problems. Curiously, list-style works too without any
 * special prodding.
 */
var shorthandPropertyExpansions = {
  background: {
    backgroundAttachment: true,
    backgroundColor: true,
    backgroundImage: true,
    backgroundPositionX: true,
    backgroundPositionY: true,
    backgroundRepeat: true
  },
  backgroundPosition: {
    backgroundPositionX: true,
    backgroundPositionY: true
  },
  border: {
    borderWidth: true,
    borderStyle: true,
    borderColor: true
  },
  borderBottom: {
    borderBottomWidth: true,
    borderBottomStyle: true,
    borderBottomColor: true
  },
  borderLeft: {
    borderLeftWidth: true,
    borderLeftStyle: true,
    borderLeftColor: true
  },
  borderRight: {
    borderRightWidth: true,
    borderRightStyle: true,
    borderRightColor: true
  },
  borderTop: {
    borderTopWidth: true,
    borderTopStyle: true,
    borderTopColor: true
  },
  font: {
    fontStyle: true,
    fontVariant: true,
    fontWeight: true,
    fontSize: true,
    lineHeight: true,
    fontFamily: true
  },
  outline: {
    outlineWidth: true,
    outlineStyle: true,
    outlineColor: true
  }
};

var CSSProperty$1 = {
  isUnitlessNumber: isUnitlessNumber,
  shorthandPropertyExpansions: shorthandPropertyExpansions
};

var CSSProperty_1 = CSSProperty$1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize$1(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

var camelize_1 = camelize$1;

var camelize = camelize_1;

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName$1(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

var camelizeStyleName_1 = camelizeStyleName$1;

var CSSProperty$2 = CSSProperty_1;
var warning$20 = warning_1;

var isUnitlessNumber$1 = CSSProperty$2.isUnitlessNumber;
var styleWarnings = {};

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @param {ReactDOMComponent} component
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue$1(name, value, component) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  var isNonNumeric = isNaN(value);
  if (isNonNumeric || value === 0 || isUnitlessNumber$1.hasOwnProperty(name) && isUnitlessNumber$1[name]) {
    return '' + value; // cast to string
  }

  if (typeof value === 'string') {
    {
      // Allow '0' to pass through without warning. 0 is already special and
      // doesn't require units, so we don't need to warn about it.
      if (component && value !== '0') {
        var owner = component._currentElement._owner;
        var ownerName = owner ? owner.getName() : null;
        if (ownerName && !styleWarnings[ownerName]) {
          styleWarnings[ownerName] = {};
        }
        var warned = false;
        if (ownerName) {
          var warnings = styleWarnings[ownerName];
          warned = warnings[name];
          if (!warned) {
            warnings[name] = true;
          }
        }
        if (!warned) {
          warning$20(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value);
        }
      }
    }
    value = value.trim();
  }
  return value + 'px';
}

var dangerousStyleValue_1 = dangerousStyleValue$1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate$1(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

var hyphenate_1 = hyphenate$1;

var hyphenate = hyphenate_1;

var msPattern$1 = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName$1(string) {
  return hyphenate(string).replace(msPattern$1, '-ms-');
}

var hyphenateStyleName_1 = hyphenateStyleName$1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @typechecks static-only
 */

/**
 * Memoizes the return value of a function that accepts one string argument.
 */

function memoizeStringOnly$1(callback) {
  var cache = {};
  return function (string) {
    if (!cache.hasOwnProperty(string)) {
      cache[string] = callback.call(this, string);
    }
    return cache[string];
  };
}

var memoizeStringOnly_1 = memoizeStringOnly$1;

var CSSProperty = CSSProperty_1;
var ExecutionEnvironment$13 = ExecutionEnvironment_1;
var ReactInstrumentation$6 = ReactInstrumentation$2;

var camelizeStyleName = camelizeStyleName_1;
var dangerousStyleValue = dangerousStyleValue_1;
var hyphenateStyleName = hyphenateStyleName_1;
var memoizeStringOnly = memoizeStringOnly_1;
var warning$19 = warning_1;

var processStyleName = memoizeStringOnly(function (styleName) {
  return hyphenateStyleName(styleName);
});

var hasShorthandPropertyBug = false;
var styleFloatAccessor = 'cssFloat';
if (ExecutionEnvironment$13.canUseDOM) {
  var tempStyle = document.createElement('div').style;
  try {
    // IE8 throws "Invalid argument." if resetting shorthand style properties.
    tempStyle.font = '';
  } catch (e) {
    hasShorthandPropertyBug = true;
  }
  // IE8 only supports accessing cssFloat (standard) as styleFloat
  if (document.documentElement.style.cssFloat === undefined) {
    styleFloatAccessor = 'styleFloat';
  }
}

{
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;

  var warnHyphenatedStyleName = function (name, owner) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning$19(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner));
  };

  var warnBadVendoredStyleName = function (name, owner) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning$19(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner));
  };

  var warnStyleValueWithSemicolon = function (name, value, owner) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    warning$19(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, ''));
  };

  var warnStyleValueIsNaN = function (name, value, owner) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;
    warning$19(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner));
  };

  var checkRenderMessage = function (owner) {
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' Check the render method of `' + name + '`.';
      }
    }
    return '';
  };

  /**
   * @param {string} name
   * @param {*} value
   * @param {ReactDOMComponent} component
   */
  var warnValidStyle = function (name, value, component) {
    var owner;
    if (component) {
      owner = component._currentElement._owner;
    }
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name, owner);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name, owner);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value, owner);
    }

    if (typeof value === 'number' && isNaN(value)) {
      warnStyleValueIsNaN(name, value, owner);
    }
  };
}

/**
 * Operations for dealing with CSS properties.
 */
var CSSPropertyOperations$1 = {

  /**
   * Serializes a mapping of style properties for use as inline styles:
   *
   *   > createMarkupForStyles({width: '200px', height: 0})
   *   "width:200px;height:0;"
   *
   * Undefined values are ignored so that declarative programming is easier.
   * The result should be HTML-escaped before insertion into the DOM.
   *
   * @param {object} styles
   * @param {ReactDOMComponent} component
   * @return {?string}
   */
  createMarkupForStyles: function (styles, component) {
    var serialized = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      {
        warnValidStyle(styleName, styleValue, component);
      }
      if (styleValue != null) {
        serialized += processStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
      }
    }
    return serialized || null;
  },

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   * @param {ReactDOMComponent} component
   */
  setValueForStyles: function (node, styles, component) {
    {
      ReactInstrumentation$6.debugTool.onHostOperation({
        instanceID: component._debugID,
        type: 'update styles',
        payload: styles
      });
    }

    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      {
        warnValidStyle(styleName, styles[styleName], component);
      }
      var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
      if (styleName === 'float' || styleName === 'cssFloat') {
        styleName = styleFloatAccessor;
      }
      if (styleValue) {
        style[styleName] = styleValue;
      } else {
        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
        if (expansion) {
          // Shorthand property that IE8 won't like unsetting, so unset each
          // component to placate it
          for (var individualStyleName in expansion) {
            style[individualStyleName] = '';
          }
        } else {
          style[styleName] = '';
        }
      }
    }
  }

};

var CSSPropertyOperations_1 = CSSPropertyOperations$1;

var escapeTextContentForBrowser$3 = escapeTextContentForBrowser_1;

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */
function quoteAttributeValueForBrowser$1(value) {
  return '"' + escapeTextContentForBrowser$3(value) + '"';
}

var quoteAttributeValueForBrowser_1 = quoteAttributeValueForBrowser$1;

var DOMProperty$4 = DOMProperty_1;
var ReactDOMComponentTree$9 = ReactDOMComponentTree_1;
var ReactInstrumentation$7 = ReactInstrumentation$2;

var quoteAttributeValueForBrowser = quoteAttributeValueForBrowser_1;
var warning$21 = warning_1;

var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty$4.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty$4.ATTRIBUTE_NAME_CHAR + ']*$');
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};

function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  warning$21(false, 'Invalid attribute name: `%s`', attributeName);
  return false;
}

function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

/**
 * Operations for dealing with DOM properties.
 */
var DOMPropertyOperations$1 = {

  /**
   * Creates markup for the ID property.
   *
   * @param {string} id Unescaped ID.
   * @return {string} Markup string.
   */
  createMarkupForID: function (id) {
    return DOMProperty$4.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
  },

  setAttributeForID: function (node, id) {
    node.setAttribute(DOMProperty$4.ID_ATTRIBUTE_NAME, id);
  },

  createMarkupForRoot: function () {
    return DOMProperty$4.ROOT_ATTRIBUTE_NAME + '=""';
  },

  setAttributeForRoot: function (node) {
    node.setAttribute(DOMProperty$4.ROOT_ATTRIBUTE_NAME, '');
  },

  /**
   * Creates markup for a property.
   *
   * @param {string} name
   * @param {*} value
   * @return {?string} Markup string, or null if the property was invalid.
   */
  createMarkupForProperty: function (name, value) {
    var propertyInfo = DOMProperty$4.properties.hasOwnProperty(name) ? DOMProperty$4.properties[name] : null;
    if (propertyInfo) {
      if (shouldIgnoreValue(propertyInfo, value)) {
        return '';
      }
      var attributeName = propertyInfo.attributeName;
      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        return attributeName + '=""';
      }
      return attributeName + '=' + quoteAttributeValueForBrowser(value);
    } else if (DOMProperty$4.isCustomAttribute(name)) {
      if (value == null) {
        return '';
      }
      return name + '=' + quoteAttributeValueForBrowser(value);
    }
    return null;
  },

  /**
   * Creates markup for a custom property.
   *
   * @param {string} name
   * @param {*} value
   * @return {string} Markup string, or empty string if the property was invalid.
   */
  createMarkupForCustomAttribute: function (name, value) {
    if (!isAttributeNameSafe(name) || value == null) {
      return '';
    }
    return name + '=' + quoteAttributeValueForBrowser(value);
  },

  /**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */
  setValueForProperty: function (node, name, value) {
    var propertyInfo = DOMProperty$4.properties.hasOwnProperty(name) ? DOMProperty$4.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, value);
      } else if (shouldIgnoreValue(propertyInfo, value)) {
        this.deleteValueForProperty(node, name);
        return;
      } else if (propertyInfo.mustUseProperty) {
        // Contrary to `setAttribute`, object properties are properly
        // `toString`ed by IE8/9.
        node[propertyInfo.propertyName] = value;
      } else {
        var attributeName = propertyInfo.attributeName;
        var namespace = propertyInfo.attributeNamespace;
        // `setAttribute` with objects becomes only `[object]` in IE8/9,
        // ('' + value) makes it output the correct toString()-value.
        if (namespace) {
          node.setAttributeNS(namespace, attributeName, '' + value);
        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
          node.setAttribute(attributeName, '');
        } else {
          node.setAttribute(attributeName, '' + value);
        }
      }
    } else if (DOMProperty$4.isCustomAttribute(name)) {
      DOMPropertyOperations$1.setValueForAttribute(node, name, value);
      return;
    }

    {
      var payload = {};
      payload[name] = value;
      ReactInstrumentation$7.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree$9.getInstanceFromNode(node)._debugID,
        type: 'update attribute',
        payload: payload
      });
    }
  },

  setValueForAttribute: function (node, name, value) {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (value == null) {
      node.removeAttribute(name);
    } else {
      node.setAttribute(name, '' + value);
    }

    {
      var payload = {};
      payload[name] = value;
      ReactInstrumentation$7.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree$9.getInstanceFromNode(node)._debugID,
        type: 'update attribute',
        payload: payload
      });
    }
  },

  /**
   * Deletes an attributes from a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForAttribute: function (node, name) {
    node.removeAttribute(name);
    {
      ReactInstrumentation$7.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree$9.getInstanceFromNode(node)._debugID,
        type: 'remove attribute',
        payload: name
      });
    }
  },

  /**
   * Deletes the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForProperty: function (node, name) {
    var propertyInfo = DOMProperty$4.properties.hasOwnProperty(name) ? DOMProperty$4.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, undefined);
      } else if (propertyInfo.mustUseProperty) {
        var propName = propertyInfo.propertyName;
        if (propertyInfo.hasBooleanValue) {
          node[propName] = false;
        } else {
          node[propName] = '';
        }
      } else {
        node.removeAttribute(propertyInfo.attributeName);
      }
    } else if (DOMProperty$4.isCustomAttribute(name)) {
      node.removeAttribute(name);
    }

    {
      ReactInstrumentation$7.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree$9.getInstanceFromNode(node)._debugID,
        type: 'remove attribute',
        payload: name
      });
    }
  }

};

var DOMPropertyOperations_1 = DOMPropertyOperations$1;

var EventPluginHub$4 = EventPluginHub_1;

function runEventQueueInBatch(events) {
  EventPluginHub$4.enqueueEvents(events);
  EventPluginHub$4.processEventQueue(false);
}

var ReactEventEmitterMixin$1 = {

  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   */
  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events = EventPluginHub$4.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
    runEventQueueInBatch(events);
  }
};

var ReactEventEmitterMixin_1 = ReactEventEmitterMixin$1;

var ExecutionEnvironment$14 = ExecutionEnvironment_1;

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};

  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  prefixes['ms' + styleProp] = 'MS' + eventName;
  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

  return prefixes;
}

/**
 * A list of event names to a configurable list of vendor prefixes.
 */
var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};

/**
 * Event names that have already been detected and prefixed (if applicable).
 */
var prefixedEventNames = {};

/**
 * Element to check for prefixes on.
 */
var style = {};

/**
 * Bootstrap if a DOM exists.
 */
if (ExecutionEnvironment$14.canUseDOM) {
  style = document.createElement('div').style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.
  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  }

  // Same as above
  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}

/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */
function getVendorPrefixedEventName$1(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return '';
}

var getVendorPrefixedEventName_1 = getVendorPrefixedEventName$1;

var _assign$8 = index$1;

var EventPluginRegistry$3 = EventPluginRegistry_1;
var ReactEventEmitterMixin = ReactEventEmitterMixin_1;
var ViewportMetrics$2 = ViewportMetrics_1;

var getVendorPrefixedEventName = getVendorPrefixedEventName_1;
var isEventSupported$3 = isEventSupported_1;

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactEventListener, which is injected and can therefore support pluggable
 *    event sources. This is the only work that occurs in the main thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var hasEventPageXY;
var alreadyListeningTo = {};
var isMonitoringScrollValue = false;
var reactTopListenersCounter = 0;

// For events like 'submit' which don't consistently bubble (which we trap at a
// lower node than `document`), binding at `document` would cause duplicate
// events so we don't include them here
var topEventMapping = {
  topAbort: 'abort',
  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
  topBlur: 'blur',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
 *
 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
 *
 * @internal
 */
var ReactBrowserEventEmitter$1 = _assign$8({}, ReactEventEmitterMixin, {

  /**
   * Injectable event backend
   */
  ReactEventListener: null,

  injection: {
    /**
     * @param {object} ReactEventListener
     */
    injectReactEventListener: function (ReactEventListener) {
      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter$1.handleTopLevel);
      ReactBrowserEventEmitter$1.ReactEventListener = ReactEventListener;
    }
  },

  /**
   * Sets whether or not any created callbacks should be enabled.
   *
   * @param {boolean} enabled True if callbacks should be enabled.
   */
  setEnabled: function (enabled) {
    if (ReactBrowserEventEmitter$1.ReactEventListener) {
      ReactBrowserEventEmitter$1.ReactEventListener.setEnabled(enabled);
    }
  },

  /**
   * @return {boolean} True if callbacks are enabled.
   */
  isEnabled: function () {
    return !!(ReactBrowserEventEmitter$1.ReactEventListener && ReactBrowserEventEmitter$1.ReactEventListener.isEnabled());
  },

  /**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} contentDocumentHandle Document which owns the container
   */
  listenTo: function (registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies = EventPluginRegistry$3.registrationNameDependencies[registrationName];

    for (var i = 0; i < dependencies.length; i++) {
      var dependency = dependencies[i];
      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
        if (dependency === 'topWheel') {
          if (isEventSupported$3('wheel')) {
            ReactBrowserEventEmitter$1.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
          } else if (isEventSupported$3('mousewheel')) {
            ReactBrowserEventEmitter$1.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
          } else {
            // Firefox needs to capture a different mouse scroll event.
            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
            ReactBrowserEventEmitter$1.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
          }
        } else if (dependency === 'topScroll') {

          if (isEventSupported$3('scroll', true)) {
            ReactBrowserEventEmitter$1.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
          } else {
            ReactBrowserEventEmitter$1.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter$1.ReactEventListener.WINDOW_HANDLE);
          }
        } else if (dependency === 'topFocus' || dependency === 'topBlur') {

          if (isEventSupported$3('focus', true)) {
            ReactBrowserEventEmitter$1.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
            ReactBrowserEventEmitter$1.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
          } else if (isEventSupported$3('focusin')) {
            // IE has `focusin` and `focusout` events which bubble.
            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
            ReactBrowserEventEmitter$1.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
            ReactBrowserEventEmitter$1.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
          }

          // to make sure blur and focus event listeners are only attached once
          isListening.topBlur = true;
          isListening.topFocus = true;
        } else if (topEventMapping.hasOwnProperty(dependency)) {
          ReactBrowserEventEmitter$1.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
        }

        isListening[dependency] = true;
      }
    }
  },

  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter$1.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
  },

  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter$1.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
  },

  /**
   * Protect against document.createEvent() returning null
   * Some popup blocker extensions appear to do this:
   * https://github.com/facebook/react/issues/6887
   */
  supportsEventPageXY: function () {
    if (!document.createEvent) {
      return false;
    }
    var ev = document.createEvent('MouseEvent');
    return ev != null && 'pageX' in ev;
  },

  /**
   * Listens to window scroll and resize events. We cache scroll values so that
   * application code can access them without triggering reflows.
   *
   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
   * pageX/pageY isn't supported (legacy browsers).
   *
   * NOTE: Scroll events do not bubble.
   *
   * @see http://www.quirksmode.org/dom/events/scroll.html
   */
  ensureScrollValueMonitoring: function () {
    if (hasEventPageXY === undefined) {
      hasEventPageXY = ReactBrowserEventEmitter$1.supportsEventPageXY();
    }
    if (!hasEventPageXY && !isMonitoringScrollValue) {
      var refresh = ViewportMetrics$2.refreshScrollValues;
      ReactBrowserEventEmitter$1.ReactEventListener.monitorScrollValue(refresh);
      isMonitoringScrollValue = true;
    }
  }

});

var ReactBrowserEventEmitter_1 = ReactBrowserEventEmitter$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

var ReactPropTypesSecret$4 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

var ReactPropTypesSecret_1$2 = ReactPropTypesSecret$4;

var React$2 = React_1;
var ReactPropTypesSecret$3 = ReactPropTypesSecret_1$2;

var invariant$25 = invariant_1;
var warning$23 = warning_1;

var hasReadOnlyValue = {
  'button': true,
  'checkbox': true,
  'image': true,
  'hidden': true,
  'radio': true,
  'reset': true,
  'submit': true
};

function _assertSingleLink(inputProps) {
  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? invariant$25(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : void 0;
}
function _assertValueLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.value == null && inputProps.onChange == null) ? invariant$25(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : void 0;
}

function _assertCheckedLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.checked == null && inputProps.onChange == null) ? invariant$25(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : void 0;
}

var propTypes = {
  value: function (props, propName, componentName) {
    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  checked: function (props, propName, componentName) {
    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  onChange: React$2.PropTypes.func
};

var loggedTypeFailures$1 = {};
function getDeclarationErrorAddendum$2(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Provide a linked `value` attribute for controlled forms. You should not use
 * this outside of the ReactDOM controlled form components.
 */
var LinkedValueUtils$1 = {
  checkPropTypes: function (tagName, props, owner) {
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret$3);
      }
      if (error instanceof Error && !(error.message in loggedTypeFailures$1)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures$1[error.message] = true;

        var addendum = getDeclarationErrorAddendum$2(owner);
        warning$23(false, 'Failed form propType: %s%s', error.message, addendum);
      }
    }
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current value of the input either from value prop or link.
   */
  getValue: function (inputProps) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.value;
    }
    return inputProps.value;
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current checked status of the input either from checked prop
   *             or link.
   */
  getChecked: function (inputProps) {
    if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.value;
    }
    return inputProps.checked;
  },

  /**
   * @param {object} inputProps Props for form component
   * @param {SyntheticEvent} event change event to handle
   */
  executeOnChange: function (inputProps, event) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.requestChange(event.target.value);
    } else if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.requestChange(event.target.checked);
    } else if (inputProps.onChange) {
      return inputProps.onChange.call(undefined, event);
    }
  }
};

var LinkedValueUtils_1 = LinkedValueUtils$1;

var _assign$9 = index$1;

var DOMPropertyOperations$2 = DOMPropertyOperations_1;
var LinkedValueUtils = LinkedValueUtils_1;
var ReactDOMComponentTree$10 = ReactDOMComponentTree_1;
var ReactUpdates$3 = ReactUpdates_1;

var invariant$24 = invariant_1;
var warning$22 = warning_1;

var didWarnValueLink = false;
var didWarnCheckedLink = false;
var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMInput$1.updateWrapper(this);
  }
}

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}

/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput$1 = {
  getHostProps: function (inst, props) {
    var value = LinkedValueUtils.getValue(props);
    var checked = LinkedValueUtils.getChecked(props);

    var hostProps = _assign$9({
      // Make sure we set .type before any other properties (setting .value
      // before .type means .value is lost in IE11 and below)
      type: undefined,
      // Make sure we set .step before .value (setting .value before .step
      // means .value is rounded on mount, based upon step precision)
      step: undefined,
      // Make sure we set .min & .max before .value (to ensure proper order
      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
      min: undefined,
      max: undefined
    }, props, {
      defaultChecked: undefined,
      defaultValue: undefined,
      value: value != null ? value : inst._wrapperState.initialValue,
      checked: checked != null ? checked : inst._wrapperState.initialChecked,
      onChange: inst._wrapperState.onChange
    });

    return hostProps;
  },

  mountWrapper: function (inst, props) {
    {
      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);

      var owner = inst._currentElement._owner;

      if (props.valueLink !== undefined && !didWarnValueLink) {
        warning$22(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.');
        didWarnValueLink = true;
      }
      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
        warning$22(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.');
        didWarnCheckedLink = true;
      }
      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
        warning$22(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type);
        didWarnCheckedDefaultChecked = true;
      }
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
        warning$22(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type);
        didWarnValueDefaultValue = true;
      }
    }

    var defaultValue = props.defaultValue;
    inst._wrapperState = {
      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
      initialValue: props.value != null ? props.value : defaultValue,
      listeners: null,
      onChange: _handleChange.bind(inst)
    };

    {
      inst._wrapperState.controlled = isControlled(props);
    }
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    {
      var controlled = isControlled(props);
      var owner = inst._currentElement._owner;

      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
        warning$22(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type);
        didWarnUncontrolledToControlled = true;
      }
      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
        warning$22(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type);
        didWarnControlledToUncontrolled = true;
      }
    }

    // TODO: Shouldn't this be getChecked(props)?
    var checked = props.checked;
    if (checked != null) {
      DOMPropertyOperations$2.setValueForProperty(ReactDOMComponentTree$10.getNodeFromInstance(inst), 'checked', checked || false);
    }

    var node = ReactDOMComponentTree$10.getNodeFromInstance(inst);
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {

      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      var newValue = '' + value;

      // To avoid side effects (such as losing text selection), only set value if changed
      if (newValue !== node.value) {
        node.value = newValue;
      }
    } else {
      if (props.value == null && props.defaultValue != null) {
        node.defaultValue = '' + props.defaultValue;
      }
      if (props.checked == null && props.defaultChecked != null) {
        node.defaultChecked = !!props.defaultChecked;
      }
    }
  },

  postMountWrapper: function (inst) {
    var props = inst._currentElement.props;

    // This is in postMount because we need access to the DOM node, which is not
    // available until after the component has mounted.
    var node = ReactDOMComponentTree$10.getNodeFromInstance(inst);

    // Detach value from defaultValue. We won't do anything if we're working on
    // submit or reset inputs as those values & defaultValues are linked. They
    // are not resetable nodes so this operation doesn't matter and actually
    // removes browser-default values (eg "Submit Query") when no value is
    // provided.

    switch (props.type) {
      case 'submit':
      case 'reset':
        break;
      case 'color':
      case 'date':
      case 'datetime':
      case 'datetime-local':
      case 'month':
      case 'time':
      case 'week':
        // This fixes the no-show issue on iOS Safari and Android Chrome:
        // https://github.com/facebook/react/issues/7233
        node.value = '';
        node.value = node.defaultValue;
        break;
      default:
        node.value = node.value;
        break;
    }

    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
    // this is needed to work around a chrome bug where setting defaultChecked
    // will sometimes influence the value of checked (even after detachment).
    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
    // We need to temporarily unset name to avoid disrupting radio button groups.
    var name = node.name;
    if (name !== '') {
      node.name = '';
    }
    node.defaultChecked = !node.defaultChecked;
    node.defaultChecked = !node.defaultChecked;
    if (name !== '') {
      node.name = name;
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;

  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  // Here we use asap to wait until all updates have propagated, which
  // is important when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  ReactUpdates$3.asap(forceUpdateIfMounted, this);

  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var rootNode = ReactDOMComponentTree$10.getNodeFromInstance(this);
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form, let's just use the global
    // `querySelectorAll` to ensure we don't miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.
      var otherInstance = ReactDOMComponentTree$10.getInstanceFromNode(otherNode);
      !otherInstance ? invariant$24(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0;
      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      ReactUpdates$3.asap(forceUpdateIfMounted, otherInstance);
    }
  }

  return returnValue;
}

var ReactDOMInput_1 = ReactDOMInput$1;

var _assign$11 = index$1;

var LinkedValueUtils$2 = LinkedValueUtils_1;
var ReactDOMComponentTree$12 = ReactDOMComponentTree_1;
var ReactUpdates$4 = ReactUpdates_1;

var warning$25 = warning_1;

var didWarnValueLink$1 = false;
var didWarnValueDefaultValue$1 = false;

function updateOptionsIfPendingUpdateAndMounted() {
  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
    this._wrapperState.pendingUpdate = false;

    var props = this._currentElement.props;
    var value = LinkedValueUtils$2.getValue(props);

    if (value != null) {
      updateOptions(this, Boolean(props.multiple), value);
    }
  }
}

function getDeclarationErrorAddendum$3(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 * @private
 */
function checkSelectPropTypes(inst, props) {
  var owner = inst._currentElement._owner;
  LinkedValueUtils$2.checkPropTypes('select', props, owner);

  if (props.valueLink !== undefined && !didWarnValueLink$1) {
    warning$25(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.');
    didWarnValueLink$1 = true;
  }

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    var isArray = Array.isArray(props[propName]);
    if (props.multiple && !isArray) {
      warning$25(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum$3(owner));
    } else if (!props.multiple && isArray) {
      warning$25(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum$3(owner));
    }
  }
}

/**
 * @param {ReactDOMComponent} inst
 * @param {boolean} multiple
 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
 * @private
 */
function updateOptions(inst, multiple, propValue) {
  var selectedValue, i;
  var options = ReactDOMComponentTree$12.getNodeFromInstance(inst).options;

  if (multiple) {
    selectedValue = {};
    for (i = 0; i < propValue.length; i++) {
      selectedValue['' + propValue[i]] = true;
    }
    for (i = 0; i < options.length; i++) {
      var selected = selectedValue.hasOwnProperty(options[i].value);
      if (options[i].selected !== selected) {
        options[i].selected = selected;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    selectedValue = '' + propValue;
    for (i = 0; i < options.length; i++) {
      if (options[i].value === selectedValue) {
        options[i].selected = true;
        return;
      }
    }
    if (options.length) {
      options[0].selected = true;
    }
  }
}

/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */
var ReactDOMSelect$2 = {
  getHostProps: function (inst, props) {
    return _assign$11({}, props, {
      onChange: inst._wrapperState.onChange,
      value: undefined
    });
  },

  mountWrapper: function (inst, props) {
    {
      checkSelectPropTypes(inst, props);
    }

    var value = LinkedValueUtils$2.getValue(props);
    inst._wrapperState = {
      pendingUpdate: false,
      initialValue: value != null ? value : props.defaultValue,
      listeners: null,
      onChange: _handleChange$1.bind(inst),
      wasMultiple: Boolean(props.multiple)
    };

    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
      warning$25(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
      didWarnValueDefaultValue$1 = true;
    }
  },

  getSelectValueContext: function (inst) {
    // ReactDOMOption looks at this initial value so the initial generated
    // markup has correct `selected` attributes
    return inst._wrapperState.initialValue;
  },

  postUpdateWrapper: function (inst) {
    var props = inst._currentElement.props;

    // After the initial mount, we control selected-ness manually so don't pass
    // this value down
    inst._wrapperState.initialValue = undefined;

    var wasMultiple = inst._wrapperState.wasMultiple;
    inst._wrapperState.wasMultiple = Boolean(props.multiple);

    var value = LinkedValueUtils$2.getValue(props);
    if (value != null) {
      inst._wrapperState.pendingUpdate = false;
      updateOptions(inst, Boolean(props.multiple), value);
    } else if (wasMultiple !== Boolean(props.multiple)) {
      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
      if (props.defaultValue != null) {
        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
      } else {
        // Revert the select back to its default unselected state.
        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
      }
    }
  }
};

function _handleChange$1(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils$2.executeOnChange(props, event);

  if (this._rootNodeID) {
    this._wrapperState.pendingUpdate = true;
  }
  ReactUpdates$4.asap(updateOptionsIfPendingUpdateAndMounted, this);
  return returnValue;
}

var ReactDOMSelect_1 = ReactDOMSelect$2;

var _assign$10 = index$1;

var React$3 = React_1;
var ReactDOMComponentTree$11 = ReactDOMComponentTree_1;
var ReactDOMSelect$1 = ReactDOMSelect_1;

var warning$24 = warning_1;
var didWarnInvalidOptionChildren = false;

function flattenChildren(children) {
  var content = '';

  // Flatten children and warn if they aren't strings or numbers;
  // invalid types are ignored.
  React$3.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }
    if (typeof child === 'string' || typeof child === 'number') {
      content += child;
    } else if (!didWarnInvalidOptionChildren) {
      didWarnInvalidOptionChildren = true;
      warning$24(false, 'Only strings and numbers are supported as <option> children.');
    }
  });

  return content;
}

/**
 * Implements an <option> host component that warns when `selected` is set.
 */
var ReactDOMOption$1 = {
  mountWrapper: function (inst, props, hostParent) {
    // TODO (yungsters): Remove support for `selected` in <option>.
    {
      warning$24(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');
    }

    // Look up whether this option is 'selected'
    var selectValue = null;
    if (hostParent != null) {
      var selectParent = hostParent;

      if (selectParent._tag === 'optgroup') {
        selectParent = selectParent._hostParent;
      }

      if (selectParent != null && selectParent._tag === 'select') {
        selectValue = ReactDOMSelect$1.getSelectValueContext(selectParent);
      }
    }

    // If the value is null (e.g., no specified value or after initial mount)
    // or missing (e.g., for <datalist>), we don't change props.selected
    var selected = null;
    if (selectValue != null) {
      var value;
      if (props.value != null) {
        value = props.value + '';
      } else {
        value = flattenChildren(props.children);
      }
      selected = false;
      if (Array.isArray(selectValue)) {
        // multiple
        for (var i = 0; i < selectValue.length; i++) {
          if ('' + selectValue[i] === value) {
            selected = true;
            break;
          }
        }
      } else {
        selected = '' + selectValue === value;
      }
    }

    inst._wrapperState = { selected: selected };
  },

  postMountWrapper: function (inst) {
    // value="" should make a value attribute (#6219)
    var props = inst._currentElement.props;
    if (props.value != null) {
      var node = ReactDOMComponentTree$11.getNodeFromInstance(inst);
      node.setAttribute('value', props.value);
    }
  },

  getHostProps: function (inst, props) {
    var hostProps = _assign$10({ selected: undefined, children: undefined }, props);

    // Read state only from initial mount because <select> updates value
    // manually; we need the initial state only for server rendering
    if (inst._wrapperState.selected != null) {
      hostProps.selected = inst._wrapperState.selected;
    }

    var content = flattenChildren(props.children);

    if (content) {
      hostProps.children = content;
    }

    return hostProps;
  }

};

var ReactDOMOption_1 = ReactDOMOption$1;

var _assign$12 = index$1;

var LinkedValueUtils$3 = LinkedValueUtils_1;
var ReactDOMComponentTree$13 = ReactDOMComponentTree_1;
var ReactUpdates$5 = ReactUpdates_1;

var invariant$26 = invariant_1;
var warning$26 = warning_1;

var didWarnValueLink$2 = false;
var didWarnValDefaultVal = false;

function forceUpdateIfMounted$1() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMTextarea$1.updateWrapper(this);
  }
}

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
var ReactDOMTextarea$1 = {
  getHostProps: function (inst, props) {
    !(props.dangerouslySetInnerHTML == null) ? invariant$26(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0;

    // Always set children to the same thing. In IE9, the selection range will
    // get reset if `textContent` is mutated.  We could add a check in setTextContent
    // to only set the value if/when the value differs from the node value (which would
    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
    // The value can be a boolean or object so that's why it's forced to be a string.
    var hostProps = _assign$12({}, props, {
      value: undefined,
      defaultValue: undefined,
      children: '' + inst._wrapperState.initialValue,
      onChange: inst._wrapperState.onChange
    });

    return hostProps;
  },

  mountWrapper: function (inst, props) {
    {
      LinkedValueUtils$3.checkPropTypes('textarea', props, inst._currentElement._owner);
      if (props.valueLink !== undefined && !didWarnValueLink$2) {
        warning$26(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.');
        didWarnValueLink$2 = true;
      }
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
        warning$26(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
        didWarnValDefaultVal = true;
      }
    }

    var value = LinkedValueUtils$3.getValue(props);
    var initialValue = value;

    // Only bother fetching default value if we're going to use it
    if (value == null) {
      var defaultValue = props.defaultValue;
      // TODO (yungsters): Remove support for children content in <textarea>.
      var children = props.children;
      if (children != null) {
        {
          warning$26(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
        }
        !(defaultValue == null) ? invariant$26(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;
        if (Array.isArray(children)) {
          !(children.length <= 1) ? invariant$26(false, '<textarea> can only have at most one child.') : void 0;
          children = children[0];
        }

        defaultValue = '' + children;
      }
      if (defaultValue == null) {
        defaultValue = '';
      }
      initialValue = defaultValue;
    }

    inst._wrapperState = {
      initialValue: '' + initialValue,
      listeners: null,
      onChange: _handleChange$2.bind(inst)
    };
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    var node = ReactDOMComponentTree$13.getNodeFromInstance(inst);
    var value = LinkedValueUtils$3.getValue(props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      var newValue = '' + value;

      // To avoid side effects (such as losing text selection), only set value if changed
      if (newValue !== node.value) {
        node.value = newValue;
      }
      if (props.defaultValue == null) {
        node.defaultValue = newValue;
      }
    }
    if (props.defaultValue != null) {
      node.defaultValue = props.defaultValue;
    }
  },

  postMountWrapper: function (inst) {
    // This is in postMount because we need access to the DOM node, which is not
    // available until after the component has mounted.
    var node = ReactDOMComponentTree$13.getNodeFromInstance(inst);

    // Warning: node.value may be the empty string at this point (IE11) if placeholder is set.
    node.value = node.textContent; // Detach value from defaultValue
  }
};

function _handleChange$2(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils$3.executeOnChange(props, event);
  ReactUpdates$5.asap(forceUpdateIfMounted$1, this);
  return returnValue;
}

var ReactDOMTextarea_1 = ReactDOMTextarea$1;

var invariant$28 = invariant_1;

var injected = false;

var ReactComponentEnvironment$1 = {

  /**
   * Optionally injectable hook for swapping out mount images in the middle of
   * the tree.
   */
  replaceNodeWithMarkup: null,

  /**
   * Optionally injectable hook for processing a queue of child updates. Will
   * later move into MultiChildComponents.
   */
  processChildrenUpdates: null,

  injection: {
    injectEnvironment: function (environment) {
      !!injected ? invariant$28(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : void 0;
      ReactComponentEnvironment$1.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
      ReactComponentEnvironment$1.processChildrenUpdates = environment.processChildrenUpdates;
      injected = true;
    }
  }

};

var ReactComponentEnvironment_1 = ReactComponentEnvironment$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 */

// TODO: Replace this with ES6: var ReactInstanceMap = new Map();

var ReactInstanceMap$1 = {

  /**
   * This API should be called `delete` but we'd have to make sure to always
   * transform these to strings for IE support. When this transform is fully
   * supported we can rename it.
   */
  remove: function (key) {
    key._reactInternalInstance = undefined;
  },

  get: function (key) {
    return key._reactInternalInstance;
  },

  has: function (key) {
    return key._reactInternalInstance !== undefined;
  },

  set: function (key, value) {
    key._reactInternalInstance = value;
  }

};

var ReactInstanceMap_1 = ReactInstanceMap$1;

var React$5 = React_1;

var invariant$31 = invariant_1;

var ReactNodeTypes$1 = {
  HOST: 0,
  COMPOSITE: 1,
  EMPTY: 2,

  getType: function (node) {
    if (node === null || node === false) {
      return ReactNodeTypes$1.EMPTY;
    } else if (React$5.isValidElement(node)) {
      if (typeof node.type === 'function') {
        return ReactNodeTypes$1.COMPOSITE;
      } else {
        return ReactNodeTypes$1.HOST;
      }
    }
    invariant$31(false, 'Unexpected node: %s', node);
  }
};

var ReactNodeTypes_1 = ReactNodeTypes$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

var ReactPropTypeLocationNames$5 = {};

{
  ReactPropTypeLocationNames$5 = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

var ReactPropTypeLocationNames_1$2 = ReactPropTypeLocationNames$5;

var ReactPropTypeLocationNames$4 = ReactPropTypeLocationNames_1$2;
var ReactPropTypesSecret$5 = ReactPropTypesSecret_1$2;

var invariant$32 = invariant_1;
var warning$30 = warning_1;

var ReactComponentTreeHook$5;

if (typeof process !== 'undefined' && process.env && "development" === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook$5 = ReactComponentTreeHook_1;
}

var loggedTypeFailures$2 = {};

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?object} element The React element that is being type-checked
 * @param {?number} debugID The React component instance that is being type-checked
 * @private
 */
function checkReactTypeSpec$3(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof typeSpecs[typeSpecName] === 'function') ? invariant$32(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames$4[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$5);
      } catch (ex) {
        error = ex;
      }
      warning$30(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames$4[location], typeSpecName, typeof error);
      if (error instanceof Error && !(error.message in loggedTypeFailures$2)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures$2[error.message] = true;

        var componentStackInfo = '';

        {
          if (!ReactComponentTreeHook$5) {
            ReactComponentTreeHook$5 = ReactComponentTreeHook_1;
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook$5.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook$5.getCurrentStackAddendum(element);
          }
        }

        warning$30(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo);
      }
    }
  }
}

var checkReactTypeSpec_1$2 = checkReactTypeSpec$3;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */

var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is$1(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual$2(objA, objB) {
  if (is$1(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty$3.call(objB, keysA[i]) || !is$1(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

var shallowEqual_1 = shallowEqual$2;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * Given a `prevElement` and `nextElement`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are elements. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevElement
 * @param {?object} nextElement
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */

function shouldUpdateReactComponent$2(prevElement, nextElement) {
  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;
  if (prevEmpty || nextEmpty) {
    return prevEmpty === nextEmpty;
  }

  var prevType = typeof prevElement;
  var nextType = typeof nextElement;
  if (prevType === 'string' || prevType === 'number') {
    return nextType === 'string' || nextType === 'number';
  } else {
    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
  }
}

var shouldUpdateReactComponent_1 = shouldUpdateReactComponent$2;

var _assign$14 = index$1;

var React$4 = React_1;
var ReactComponentEnvironment$2 = ReactComponentEnvironment_1;
var ReactCurrentOwner$6 = ReactCurrentOwner_1;
var ReactErrorUtils$3 = ReactErrorUtils_1;
var ReactInstanceMap$2 = ReactInstanceMap_1;
var ReactInstrumentation$9 = ReactInstrumentation$2;
var ReactNodeTypes = ReactNodeTypes_1;
var ReactReconciler$5 = ReactReconciler_1;

{
  var checkReactTypeSpec$2 = checkReactTypeSpec_1$2;
}

var emptyObject$4 = emptyObject_1;
var invariant$30 = invariant_1;
var shallowEqual$1 = shallowEqual_1;
var shouldUpdateReactComponent$1 = shouldUpdateReactComponent_1;
var warning$29 = warning_1;

var CompositeTypes = {
  ImpureClass: 0,
  PureClass: 1,
  StatelessFunctional: 2
};

function StatelessComponent(Component) {}
StatelessComponent.prototype.render = function () {
  var Component = ReactInstanceMap$2.get(this)._currentElement.type;
  var element = Component(this.props, this.context, this.updater);
  warnIfInvalidElement(Component, element);
  return element;
};

function warnIfInvalidElement(Component, element) {
  {
    warning$29(element === null || element === false || React$4.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component');
    warning$29(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');
  }
}

function shouldConstruct(Component) {
  return !!(Component.prototype && Component.prototype.isReactComponent);
}

function isPureComponent(Component) {
  return !!(Component.prototype && Component.prototype.isPureReactComponent);
}

// Separated into a function to contain deoptimizations caused by try/finally.
function measureLifeCyclePerf(fn, debugID, timerType) {
  if (debugID === 0) {
    // Top-level wrappers (see ReactMount) and empty components (see
    // ReactDOMEmptyComponent) are invisible to hooks and devtools.
    // Both are implementation details that should go away in the future.
    return fn();
  }

  ReactInstrumentation$9.debugTool.onBeginLifeCycleTimer(debugID, timerType);
  try {
    return fn();
  } finally {
    ReactInstrumentation$9.debugTool.onEndLifeCycleTimer(debugID, timerType);
  }
}

/**
 * ------------------ The Life-Cycle of a Composite Component ------------------
 *
 * - constructor: Initialization of state. The instance is now retained.
 *   - componentWillMount
 *   - render
 *   - [children's constructors]
 *     - [children's componentWillMount and render]
 *     - [children's componentDidMount]
 *     - componentDidMount
 *
 *       Update Phases:
 *       - componentWillReceiveProps (only called if parent updated)
 *       - shouldComponentUpdate
 *         - componentWillUpdate
 *           - render
 *           - [children's constructors or receive props phases]
 *         - componentDidUpdate
 *
 *     - componentWillUnmount
 *     - [children's componentWillUnmount]
 *   - [children destroyed]
 * - (destroyed): The instance is now blank, released by React and ready for GC.
 *
 * -----------------------------------------------------------------------------
 */

/**
 * An incrementing ID assigned to each component when it is mounted. This is
 * used to enforce the order in which `ReactUpdates` updates dirty components.
 *
 * @private
 */
var nextMountID = 1;

/**
 * @lends {ReactCompositeComponent.prototype}
 */
var ReactCompositeComponent$1 = {

  /**
   * Base constructor for all composite component.
   *
   * @param {ReactElement} element
   * @final
   * @internal
   */
  construct: function (element) {
    this._currentElement = element;
    this._rootNodeID = 0;
    this._compositeType = null;
    this._instance = null;
    this._hostParent = null;
    this._hostContainerInfo = null;

    // See ReactUpdateQueue
    this._updateBatchNumber = null;
    this._pendingElement = null;
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    this._renderedNodeType = null;
    this._renderedComponent = null;
    this._context = null;
    this._mountOrder = 0;
    this._topLevelWrapper = null;

    // See ReactUpdates and ReactUpdateQueue.
    this._pendingCallbacks = null;

    // ComponentWillUnmount shall only be called once
    this._calledComponentWillUnmount = false;

    {
      this._warnedAboutRefsInRender = false;
    }
  },

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} hostParent
   * @param {?object} hostContainerInfo
   * @param {?object} context
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    var _this = this;

    this._context = context;
    this._mountOrder = nextMountID++;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var publicProps = this._currentElement.props;
    var publicContext = this._processContext(context);

    var Component = this._currentElement.type;

    var updateQueue = transaction.getUpdateQueue();

    // Initialize the public class
    var doConstruct = shouldConstruct(Component);
    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
    var renderedElement;

    // Support functional components
    if (!doConstruct && (inst == null || inst.render == null)) {
      renderedElement = inst;
      warnIfInvalidElement(Component, renderedElement);
      !(inst === null || inst === false || React$4.isValidElement(inst)) ? invariant$30(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
      inst = new StatelessComponent(Component);
      this._compositeType = CompositeTypes.StatelessFunctional;
    } else {
      if (isPureComponent(Component)) {
        this._compositeType = CompositeTypes.PureClass;
      } else {
        this._compositeType = CompositeTypes.ImpureClass;
      }
    }

    {
      // This will throw later in _renderValidatedComponent, but add an early
      // warning now to help debugging
      if (inst.render == null) {
        warning$29(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component');
      }

      var propsMutated = inst.props !== publicProps;
      var componentName = Component.displayName || Component.name || 'Component';

      warning$29(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName);
    }

    // These should be set up in the constructor, but as a convenience for
    // simpler class abstractions, we set them up after the fact.
    inst.props = publicProps;
    inst.context = publicContext;
    inst.refs = emptyObject$4;
    inst.updater = updateQueue;

    this._instance = inst;

    // Store a reference from the instance back to the internal representation
    ReactInstanceMap$2.set(inst, this);

    {
      // Since plain JS classes are defined without any special initialization
      // logic, we can not catch common errors early. Therefore, we have to
      // catch them here, at initialization time, instead.
      warning$29(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component');
      warning$29(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component');
      warning$29(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component');
      warning$29(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component');
      warning$29(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component');
      warning$29(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component');
      warning$29(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component');
    }

    var initialState = inst.state;
    if (initialState === undefined) {
      inst.state = initialState = null;
    }
    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? invariant$30(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : void 0;

    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    var markup;
    if (inst.unstable_handleError) {
      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } else {
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    }

    if (inst.componentDidMount) {
      {
        transaction.getReactMountReady().enqueue(function () {
          measureLifeCyclePerf(function () {
            return inst.componentDidMount();
          }, _this._debugID, 'componentDidMount');
        });
      }
    }

    return markup;
  },

  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
    {
      ReactCurrentOwner$6.current = this;
      try {
        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
      } finally {
        ReactCurrentOwner$6.current = null;
      }
    }
  },

  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
    var Component = this._currentElement.type;

    if (doConstruct) {
      {
        return measureLifeCyclePerf(function () {
          return new Component(publicProps, publicContext, updateQueue);
        }, this._debugID, 'ctor');
      }
    }

    // This can still be an instance in case of factory components
    // but we'll count this as time spent rendering as the more common case.
    {
      return measureLifeCyclePerf(function () {
        return Component(publicProps, publicContext, updateQueue);
      }, this._debugID, 'render');
    }
  },

  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var markup;
    var checkpoint = transaction.checkpoint();
    try {
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } catch (e) {
      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
      transaction.rollback(checkpoint);
      this._instance.unstable_handleError(e);
      if (this._pendingStateQueue) {
        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
      }
      checkpoint = transaction.checkpoint();

      this._renderedComponent.unmountComponent(true);
      transaction.rollback(checkpoint);

      // Try again - we've informed the component about the error, so they can render an error message this time.
      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    }
    return markup;
  },

  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var inst = this._instance;

    var debugID = 0;
    {
      debugID = this._debugID;
    }

    if (inst.componentWillMount) {
      {
        measureLifeCyclePerf(function () {
          return inst.componentWillMount();
        }, debugID, 'componentWillMount');
      }
      // When mounting, calls to `setState` by `componentWillMount` will set
      // `this._pendingStateQueue` without triggering a re-render.
      if (this._pendingStateQueue) {
        inst.state = this._processPendingState(inst.props, inst.context);
      }
    }

    // If not a stateless component, we now render
    if (renderedElement === undefined) {
      renderedElement = this._renderValidatedComponent();
    }

    var nodeType = ReactNodeTypes.getType(renderedElement);
    this._renderedNodeType = nodeType;
    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
    );
    this._renderedComponent = child;

    var markup = ReactReconciler$5.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);

    {
      if (debugID !== 0) {
        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
        ReactInstrumentation$9.debugTool.onSetChildren(debugID, childDebugIDs);
      }
    }

    return markup;
  },

  getHostNode: function () {
    return ReactReconciler$5.getHostNode(this._renderedComponent);
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (safely) {
    if (!this._renderedComponent) {
      return;
    }

    var inst = this._instance;

    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
      inst._calledComponentWillUnmount = true;

      if (safely) {
        var name = this.getName() + '.componentWillUnmount()';
        ReactErrorUtils$3.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
      } else {
        {
          measureLifeCyclePerf(function () {
            return inst.componentWillUnmount();
          }, this._debugID, 'componentWillUnmount');
        }
      }
    }

    if (this._renderedComponent) {
      ReactReconciler$5.unmountComponent(this._renderedComponent, safely);
      this._renderedNodeType = null;
      this._renderedComponent = null;
      this._instance = null;
    }

    // Reset pending fields
    // Even if this component is scheduled for another update in ReactUpdates,
    // it would still be ignored because these fields are reset.
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;
    this._pendingCallbacks = null;
    this._pendingElement = null;

    // These fields do not really need to be reset since this object is no
    // longer accessible.
    this._context = null;
    this._rootNodeID = 0;
    this._topLevelWrapper = null;

    // Delete the reference from the instance to this internal representation
    // which allow the internals to be properly cleaned up even if the user
    // leaks a reference to the public instance.
    ReactInstanceMap$2.remove(inst);

    // Some existing components rely on inst.props even after they've been
    // destroyed (in event handlers).
    // TODO: inst.props = null;
    // TODO: inst.state = null;
    // TODO: inst.context = null;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _maskContext: function (context) {
    var Component = this._currentElement.type;
    var contextTypes = Component.contextTypes;
    if (!contextTypes) {
      return emptyObject$4;
    }
    var maskedContext = {};
    for (var contextName in contextTypes) {
      maskedContext[contextName] = context[contextName];
    }
    return maskedContext;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`, and asserts that they are valid.
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _processContext: function (context) {
    var maskedContext = this._maskContext(context);
    {
      var Component = this._currentElement.type;
      if (Component.contextTypes) {
        this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
      }
    }
    return maskedContext;
  },

  /**
   * @param {object} currentContext
   * @return {object}
   * @private
   */
  _processChildContext: function (currentContext) {
    var Component = this._currentElement.type;
    var inst = this._instance;
    var childContext;

    if (inst.getChildContext) {
      {
        ReactInstrumentation$9.debugTool.onBeginProcessingChildContext();
        try {
          childContext = inst.getChildContext();
        } finally {
          ReactInstrumentation$9.debugTool.onEndProcessingChildContext();
        }
      }
    }

    if (childContext) {
      !(typeof Component.childContextTypes === 'object') ? invariant$30(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : void 0;
      {
        this._checkContextTypes(Component.childContextTypes, childContext, 'childContext');
      }
      for (var name in childContext) {
        !(name in Component.childContextTypes) ? invariant$30(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : void 0;
      }
      return _assign$14({}, currentContext, childContext);
    }
    return currentContext;
  },

  /**
   * Assert that the context types are valid
   *
   * @param {object} typeSpecs Map of context field to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @private
   */
  _checkContextTypes: function (typeSpecs, values, location) {
    {
      checkReactTypeSpec$2(typeSpecs, values, location, this.getName(), null, this._debugID);
    }
  },

  receiveComponent: function (nextElement, transaction, nextContext) {
    var prevElement = this._currentElement;
    var prevContext = this._context;

    this._pendingElement = null;

    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
  },

  /**
   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
   * is set, update the component.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (transaction) {
    if (this._pendingElement != null) {
      ReactReconciler$5.receiveComponent(this, this._pendingElement, transaction, this._context);
    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
    } else {
      this._updateBatchNumber = null;
    }
  },

  /**
   * Perform an update to a mounted component. The componentWillReceiveProps and
   * shouldComponentUpdate methods are called, then (assuming the update isn't
   * skipped) the remaining update lifecycle methods are called and the DOM
   * representation is updated.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevParentElement
   * @param {ReactElement} nextParentElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
    var inst = this._instance;
    !(inst != null) ? invariant$30(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : void 0;

    var willReceive = false;
    var nextContext;

    // Determine if the context has changed or not
    if (this._context === nextUnmaskedContext) {
      nextContext = inst.context;
    } else {
      nextContext = this._processContext(nextUnmaskedContext);
      willReceive = true;
    }

    var prevProps = prevParentElement.props;
    var nextProps = nextParentElement.props;

    // Not a simple state update but a props update
    if (prevParentElement !== nextParentElement) {
      willReceive = true;
    }

    // An update here will schedule an update but immediately set
    // _pendingStateQueue which will ensure that any state updates gets
    // immediately reconciled instead of waiting for the next batch.
    if (willReceive && inst.componentWillReceiveProps) {
      {
        measureLifeCyclePerf(function () {
          return inst.componentWillReceiveProps(nextProps, nextContext);
        }, this._debugID, 'componentWillReceiveProps');
      }
    }

    var nextState = this._processPendingState(nextProps, nextContext);
    var shouldUpdate = true;

    if (!this._pendingForceUpdate) {
      if (inst.shouldComponentUpdate) {
        {
          shouldUpdate = measureLifeCyclePerf(function () {
            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
          }, this._debugID, 'shouldComponentUpdate');
        }
      } else {
        if (this._compositeType === CompositeTypes.PureClass) {
          shouldUpdate = !shallowEqual$1(prevProps, nextProps) || !shallowEqual$1(inst.state, nextState);
        }
      }
    }

    {
      warning$29(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent');
    }

    this._updateBatchNumber = null;
    if (shouldUpdate) {
      this._pendingForceUpdate = false;
      // Will set `this.props`, `this.state` and `this.context`.
      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
    } else {
      // If it's determined that a component should not update, we still want
      // to set props and state but we shortcut the rest of the update.
      this._currentElement = nextParentElement;
      this._context = nextUnmaskedContext;
      inst.props = nextProps;
      inst.state = nextState;
      inst.context = nextContext;
    }
  },

  _processPendingState: function (props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;

    if (!queue) {
      return inst.state;
    }

    if (replace && queue.length === 1) {
      return queue[0];
    }

    var nextState = _assign$14({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
      var partial = queue[i];
      _assign$14(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }

    return nextState;
  },

  /**
   * Merges new props and state, notifies delegate methods of update and
   * performs update.
   *
   * @param {ReactElement} nextElement Next element
   * @param {object} nextProps Next public object to set as properties.
   * @param {?object} nextState Next object to set as state.
   * @param {?object} nextContext Next public object to set as context.
   * @param {ReactReconcileTransaction} transaction
   * @param {?object} unmaskedContext
   * @private
   */
  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
    var _this2 = this;

    var inst = this._instance;

    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
    var prevProps;
    var prevState;
    var prevContext;
    if (hasComponentDidUpdate) {
      prevProps = inst.props;
      prevState = inst.state;
      prevContext = inst.context;
    }

    if (inst.componentWillUpdate) {
      {
        measureLifeCyclePerf(function () {
          return inst.componentWillUpdate(nextProps, nextState, nextContext);
        }, this._debugID, 'componentWillUpdate');
      }
    }

    this._currentElement = nextElement;
    this._context = unmaskedContext;
    inst.props = nextProps;
    inst.state = nextState;
    inst.context = nextContext;

    this._updateRenderedComponent(transaction, unmaskedContext);

    if (hasComponentDidUpdate) {
      {
        transaction.getReactMountReady().enqueue(function () {
          measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
        });
      }
    }
  },

  /**
   * Call the component's `render` method and update the DOM accordingly.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  _updateRenderedComponent: function (transaction, context) {
    var prevComponentInstance = this._renderedComponent;
    var prevRenderedElement = prevComponentInstance._currentElement;
    var nextRenderedElement = this._renderValidatedComponent();

    var debugID = 0;
    {
      debugID = this._debugID;
    }

    if (shouldUpdateReactComponent$1(prevRenderedElement, nextRenderedElement)) {
      ReactReconciler$5.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
    } else {
      var oldHostNode = ReactReconciler$5.getHostNode(prevComponentInstance);
      ReactReconciler$5.unmountComponent(prevComponentInstance, false);

      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
      this._renderedNodeType = nodeType;
      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
      );
      this._renderedComponent = child;

      var nextMarkup = ReactReconciler$5.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);

      {
        if (debugID !== 0) {
          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
          ReactInstrumentation$9.debugTool.onSetChildren(debugID, childDebugIDs);
        }
      }

      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
    }
  },

  /**
   * Overridden in shallow rendering.
   *
   * @protected
   */
  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
    ReactComponentEnvironment$2.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
  },

  /**
   * @protected
   */
  _renderValidatedComponentWithoutOwnerOrContext: function () {
    var inst = this._instance;
    var renderedElement;

    {
      renderedElement = measureLifeCyclePerf(function () {
        return inst.render();
      }, this._debugID, 'render');
    }

    {
      // We allow auto-mocks to proceed as if they're returning null.
      if (renderedElement === undefined && inst.render._isMockFunction) {
        // This is probably bad practice. Consider warning here and
        // deprecating this convenience.
        renderedElement = null;
      }
    }

    return renderedElement;
  },

  /**
   * @private
   */
  _renderValidatedComponent: function () {
    var renderedElement;
    if ("development" !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
      ReactCurrentOwner$6.current = this;
      try {
        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
      } finally {
        ReactCurrentOwner$6.current = null;
      }
    } else {
      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
    }
    !(
    // TODO: An `isValidNode` function would probably be more appropriate
    renderedElement === null || renderedElement === false || React$4.isValidElement(renderedElement)) ? invariant$30(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : void 0;

    return renderedElement;
  },

  /**
   * Lazily allocates the refs object and stores `component` as `ref`.
   *
   * @param {string} ref Reference name.
   * @param {component} component Component to store as `ref`.
   * @final
   * @private
   */
  attachRef: function (ref, component) {
    var inst = this.getPublicInstance();
    !(inst != null) ? invariant$30(false, 'Stateless function components cannot have refs.') : void 0;
    var publicComponentInstance = component.getPublicInstance();
    {
      var componentName = component && component.getName ? component.getName() : 'a component';
      warning$29(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName());
    }
    var refs = inst.refs === emptyObject$4 ? inst.refs = {} : inst.refs;
    refs[ref] = publicComponentInstance;
  },

  /**
   * Detaches a reference name.
   *
   * @param {string} ref Name to dereference.
   * @final
   * @private
   */
  detachRef: function (ref) {
    var refs = this.getPublicInstance().refs;
    delete refs[ref];
  },

  /**
   * Get a text description of the component that can be used to identify it
   * in error messages.
   * @return {string} The name or null.
   * @internal
   */
  getName: function () {
    var type = this._currentElement.type;
    var constructor = this._instance && this._instance.constructor;
    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
  },

  /**
   * Get the publicly accessible representation of this component - i.e. what
   * is exposed by refs and returned by render. Can be null for stateless
   * components.
   *
   * @return {ReactComponent} the public component instance.
   * @internal
   */
  getPublicInstance: function () {
    var inst = this._instance;
    if (this._compositeType === CompositeTypes.StatelessFunctional) {
      return null;
    }
    return inst;
  },

  // Stub
  _instantiateReactComponent: null

};

var ReactCompositeComponent_1 = ReactCompositeComponent$1;

/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

var emptyComponentFactory;

var ReactEmptyComponentInjection = {
  injectEmptyComponentFactory: function (factory) {
    emptyComponentFactory = factory;
  }
};

var ReactEmptyComponent$1 = {
  create: function (instantiate) {
    return emptyComponentFactory(instantiate);
  }
};

ReactEmptyComponent$1.injection = ReactEmptyComponentInjection;

var ReactEmptyComponent_1 = ReactEmptyComponent$1;

var _assign$15 = index$1;

var invariant$33 = invariant_1;

var genericComponentClass = null;
// This registry keeps track of wrapper classes around host tags.
var tagToComponentClass = {};
var textComponentClass = null;

var ReactHostComponentInjection = {
  // This accepts a class that receives the tag string. This is a catch all
  // that can render any kind of tag.
  injectGenericComponentClass: function (componentClass) {
    genericComponentClass = componentClass;
  },
  // This accepts a text component class that takes the text string to be
  // rendered as props.
  injectTextComponentClass: function (componentClass) {
    textComponentClass = componentClass;
  },
  // This accepts a keyed object with classes as values. Each key represents a
  // tag. That particular tag will use this class instead of the generic one.
  injectComponentClasses: function (componentClasses) {
    _assign$15(tagToComponentClass, componentClasses);
  }
};

/**
 * Get a host internal component class for a specific tag.
 *
 * @param {ReactElement} element The element to create.
 * @return {function} The internal class constructor function.
 */
function createInternalComponent(element) {
  !genericComponentClass ? invariant$33(false, 'There is no registered component for the tag %s', element.type) : void 0;
  return new genericComponentClass(element);
}

/**
 * @param {ReactText} text
 * @return {ReactComponent}
 */
function createInstanceForText(text) {
  return new textComponentClass(text);
}

/**
 * @param {ReactComponent} component
 * @return {boolean}
 */
function isTextComponent(component) {
  return component instanceof textComponentClass;
}

var ReactHostComponent$1 = {
  createInternalComponent: createInternalComponent,
  createInstanceForText: createInstanceForText,
  isTextComponent: isTextComponent,
  injection: ReactHostComponentInjection
};

var ReactHostComponent_1 = ReactHostComponent$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

var nextDebugID = 1;

function getNextDebugID$1() {
  return nextDebugID++;
}

var getNextDebugID_1 = getNextDebugID$1;

var _assign$13 = index$1;

var ReactCompositeComponent = ReactCompositeComponent_1;
var ReactEmptyComponent = ReactEmptyComponent_1;
var ReactHostComponent = ReactHostComponent_1;

var getNextDebugID = getNextDebugID_1;
var invariant$29 = invariant_1;
var warning$28 = warning_1;

// To avoid a cyclic dependency, we create the final class in this module
var ReactCompositeComponentWrapper = function (element) {
  this.construct(element);
};
_assign$13(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
  _instantiateReactComponent: instantiateReactComponent$1
});

function getDeclarationErrorAddendum$4(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Check if the type reference is a known internal type. I.e. not a user
 * provided composite type.
 *
 * @param {function} type
 * @return {boolean} Returns true if this is a valid internal type.
 */
function isInternalComponentType(type) {
  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
}

/**
 * Given a ReactNode, create an instance that will actually be mounted.
 *
 * @param {ReactNode} node
 * @param {boolean} shouldHaveDebugID
 * @return {object} A new instance of the element's constructor.
 * @protected
 */
function instantiateReactComponent$1(node, shouldHaveDebugID) {
  var instance;

  if (node === null || node === false) {
    instance = ReactEmptyComponent.create(instantiateReactComponent$1);
  } else if (typeof node === 'object') {
    var element = node;
    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? invariant$29(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum$4(element._owner)) : void 0;

    // Special case string values
    if (typeof element.type === 'string') {
      instance = ReactHostComponent.createInternalComponent(element);
    } else if (isInternalComponentType(element.type)) {
      // This is temporarily available for custom components that are not string
      // representations. I.e. ART. Once those are updated to use the string
      // representation, we can drop this code path.
      instance = new element.type(element);

      // We renamed this. Allow the old name for compat. :(
      if (!instance.getHostNode) {
        instance.getHostNode = instance.getNativeNode;
      }
    } else {
      instance = new ReactCompositeComponentWrapper(element);
    }
  } else if (typeof node === 'string' || typeof node === 'number') {
    instance = ReactHostComponent.createInstanceForText(node);
  } else {
    invariant$29(false, 'Encountered invalid React node of type %s', typeof node);
  }

  {
    warning$28(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.');
  }

  // These two fields are used by the DOM and ART diffing algorithms
  // respectively. Instead of using expandos on components, we should be
  // storing the state needed by the diffing algorithms elsewhere.
  instance._mountIndex = 0;
  instance._mountImage = null;

  {
    instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
  }

  // Internal instances should fully constructed at this point, so they should
  // not get any new fields added to them at this point.
  {
    if (Object.preventExtensions) {
      Object.preventExtensions(instance);
    }
  }

  return instance;
}

var instantiateReactComponent_1 = instantiateReactComponent$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape$1(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * Unescape and unwrap key for human-readable display
 *
 * @param {string} key to unescape.
 * @return {string} the unescaped key.
 */
function unescape$1(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}

var KeyEscapeUtils$3 = {
  escape: escape$1,
  unescape: unescape$1
};

var KeyEscapeUtils_1$2 = KeyEscapeUtils$3;

/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.

var REACT_ELEMENT_TYPE$4 = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

var ReactElementSymbol$2 = REACT_ELEMENT_TYPE$4;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

/* global Symbol */

var ITERATOR_SYMBOL$1 = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL$1 = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn$5(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL$1 && maybeIterable[ITERATOR_SYMBOL$1] || maybeIterable[FAUX_ITERATOR_SYMBOL$1]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

var getIteratorFn_1$2 = getIteratorFn$5;

var ReactCurrentOwner$7 = ReactCurrentOwner_1;
var REACT_ELEMENT_TYPE$3 = ReactElementSymbol$2;

var getIteratorFn$4 = getIteratorFn_1$2;
var invariant$34 = invariant_1;
var KeyEscapeUtils$4 = KeyEscapeUtils_1$2;
var warning$31 = warning_1;

var SEPARATOR$1 = '.';
var SUBSEPARATOR$1 = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps$1 = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey$1(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils$4.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl$1(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE$3) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR$1 + getComponentKey$1(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR$1 : nameSoFar + SUBSEPARATOR$1;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey$1(child, i);
      subtreeCount += traverseAllChildrenImpl$1(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn$4(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey$1(child, ii++);
          subtreeCount += traverseAllChildrenImpl$1(child, nextName, callback, traverseContext);
        }
      } else {
        {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner$7.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner$7.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          warning$31(didWarnAboutMaps$1, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum);
          didWarnAboutMaps$1 = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils$4.escape(entry[0]) + SUBSEPARATOR$1 + getComponentKey$1(child, 0);
            subtreeCount += traverseAllChildrenImpl$1(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner$7.current) {
          var name = ReactCurrentOwner$7.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
      invariant$34(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren$3(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl$1(children, '', callback, traverseContext);
}

var traverseAllChildren_1$2 = traverseAllChildren$3;

var ReactReconciler$4 = ReactReconciler_1;

var instantiateReactComponent = instantiateReactComponent_1;
var KeyEscapeUtils$2 = KeyEscapeUtils_1$2;
var shouldUpdateReactComponent = shouldUpdateReactComponent_1;
var traverseAllChildren$2 = traverseAllChildren_1$2;
var warning$27 = warning_1;

var ReactComponentTreeHook$4;

if (typeof process !== 'undefined' && process.env && "development" === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook$4 = ReactComponentTreeHook_1;
}

function instantiateChild(childInstances, child, name, selfDebugID) {
  // We found a component instance.
  var keyUnique = childInstances[name] === undefined;
  {
    if (!ReactComponentTreeHook$4) {
      ReactComponentTreeHook$4 = ReactComponentTreeHook_1;
    }
    if (!keyUnique) {
      warning$27(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils$2.unescape(name), ReactComponentTreeHook$4.getStackAddendumByID(selfDebugID));
    }
  }
  if (child != null && keyUnique) {
    childInstances[name] = instantiateReactComponent(child, true);
  }
}

/**
 * ReactChildReconciler provides helpers for initializing or updating a set of
 * children. Its output is suitable for passing it onto ReactMultiChild which
 * does diffed reordering and insertion.
 */
var ReactChildReconciler$1 = {
  /**
   * Generates a "mount image" for each of the supplied children. In the case
   * of `ReactDOMComponent`, a mount image is a string of markup.
   *
   * @param {?object} nestedChildNodes Nested child maps.
   * @return {?object} A set of child instances.
   * @internal
   */
  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots
  ) {
    if (nestedChildNodes == null) {
      return null;
    }
    var childInstances = {};

    {
      traverseAllChildren$2(nestedChildNodes, function (childInsts, child, name) {
        return instantiateChild(childInsts, child, name, selfDebugID);
      }, childInstances);
    }
    return childInstances;
  },

  /**
   * Updates the rendered children and returns a new set of children.
   *
   * @param {?object} prevChildren Previously initialized set of children.
   * @param {?object} nextChildren Flat child element maps.
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @return {?object} A new set of child instances.
   * @internal
   */
  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots
  ) {
    // We currently don't have a way to track moves here but if we use iterators
    // instead of for..in we can zip the iterators and check if an item has
    // moved.
    // TODO: If nothing has changed, return the prevChildren object so that we
    // can quickly bailout if nothing has changed.
    if (!nextChildren && !prevChildren) {
      return;
    }
    var name;
    var prevChild;
    for (name in nextChildren) {
      if (!nextChildren.hasOwnProperty(name)) {
        continue;
      }
      prevChild = prevChildren && prevChildren[name];
      var prevElement = prevChild && prevChild._currentElement;
      var nextElement = nextChildren[name];
      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
        ReactReconciler$4.receiveComponent(prevChild, nextElement, transaction, context);
        nextChildren[name] = prevChild;
      } else {
        if (prevChild) {
          removedNodes[name] = ReactReconciler$4.getHostNode(prevChild);
          ReactReconciler$4.unmountComponent(prevChild, false);
        }
        // The child must be instantiated before it's mounted.
        var nextChildInstance = instantiateReactComponent(nextElement, true);
        nextChildren[name] = nextChildInstance;
        // Creating mount image now ensures refs are resolved in right order
        // (see https://github.com/facebook/react/pull/7101 for explanation).
        var nextChildMountImage = ReactReconciler$4.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
        mountImages.push(nextChildMountImage);
      }
    }
    // Unmount children that are no longer present.
    for (name in prevChildren) {
      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
        prevChild = prevChildren[name];
        removedNodes[name] = ReactReconciler$4.getHostNode(prevChild);
        ReactReconciler$4.unmountComponent(prevChild, false);
      }
    }
  },

  /**
   * Unmounts all rendered children. This should be used to clean up children
   * when this component is unmounted.
   *
   * @param {?object} renderedChildren Previously initialized set of children.
   * @internal
   */
  unmountChildren: function (renderedChildren, safely) {
    for (var name in renderedChildren) {
      if (renderedChildren.hasOwnProperty(name)) {
        var renderedChild = renderedChildren[name];
        ReactReconciler$4.unmountComponent(renderedChild, safely);
      }
    }
  }

};

var ReactChildReconciler_1 = ReactChildReconciler$1;

var KeyEscapeUtils$5 = KeyEscapeUtils_1$2;
var traverseAllChildren$4 = traverseAllChildren_1$2;
var warning$32 = warning_1;

var ReactComponentTreeHook$6;

if (typeof process !== 'undefined' && process.env && "development" === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook$6 = ReactComponentTreeHook_1;
}

/**
 * @param {function} traverseContext Context passed through traversal.
 * @param {?ReactComponent} child React child component.
 * @param {!string} name String name of key path to child.
 * @param {number=} selfDebugID Optional debugID of the current internal instance.
 */
function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
  // We found a component instance.
  if (traverseContext && typeof traverseContext === 'object') {
    var result = traverseContext;
    var keyUnique = result[name] === undefined;
    {
      if (!ReactComponentTreeHook$6) {
        ReactComponentTreeHook$6 = ReactComponentTreeHook_1;
      }
      if (!keyUnique) {
        warning$32(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils$5.unescape(name), ReactComponentTreeHook$6.getStackAddendumByID(selfDebugID));
      }
    }
    if (keyUnique && child != null) {
      result[name] = child;
    }
  }
}

/**
 * Flattens children that are typically specified as `props.children`. Any null
 * children will not be included in the resulting object.
 * @return {!object} flattened children keyed by name.
 */
function flattenChildren$2(children, selfDebugID) {
  if (children == null) {
    return children;
  }
  var result = {};

  {
    traverseAllChildren$4(children, function (traverseContext, child, name) {
      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
    }, result);
  }
  return result;
}

var flattenChildren_1 = flattenChildren$2;

var ReactComponentEnvironment = ReactComponentEnvironment_1;
var ReactInstanceMap = ReactInstanceMap_1;
var ReactInstrumentation$8 = ReactInstrumentation$2;

var ReactCurrentOwner$5 = ReactCurrentOwner_1;
var ReactReconciler$3 = ReactReconciler_1;
var ReactChildReconciler = ReactChildReconciler_1;

var emptyFunction$7 = emptyFunction_1;
var flattenChildren$1 = flattenChildren_1;
var invariant$27 = invariant_1;

/**
 * Make an update for markup to be rendered and inserted at a supplied index.
 *
 * @param {string} markup Markup that renders into an element.
 * @param {number} toIndex Destination index.
 * @private
 */
function makeInsertMarkup(markup, afterNode, toIndex) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'INSERT_MARKUP',
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: toIndex,
    afterNode: afterNode
  };
}

/**
 * Make an update for moving an existing element to another index.
 *
 * @param {number} fromIndex Source index of the existing element.
 * @param {number} toIndex Destination index of the element.
 * @private
 */
function makeMove(child, afterNode, toIndex) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'MOVE_EXISTING',
    content: null,
    fromIndex: child._mountIndex,
    fromNode: ReactReconciler$3.getHostNode(child),
    toIndex: toIndex,
    afterNode: afterNode
  };
}

/**
 * Make an update for removing an element at an index.
 *
 * @param {number} fromIndex Index of the element to remove.
 * @private
 */
function makeRemove(child, node) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'REMOVE_NODE',
    content: null,
    fromIndex: child._mountIndex,
    fromNode: node,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Make an update for setting the markup of a node.
 *
 * @param {string} markup Markup that renders into an element.
 * @private
 */
function makeSetMarkup(markup) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'SET_MARKUP',
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Make an update for setting the text content.
 *
 * @param {string} textContent Text content to set.
 * @private
 */
function makeTextContent(textContent) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'TEXT_CONTENT',
    content: textContent,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Push an update, if any, onto the queue. Creates a new queue if none is
 * passed and always returns the queue. Mutative.
 */
function enqueue$1(queue, update) {
  if (update) {
    queue = queue || [];
    queue.push(update);
  }
  return queue;
}

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue(inst, updateQueue) {
  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
}

var setChildrenForInstrumentation = emptyFunction$7;
{
  var getDebugID = function (inst) {
    if (!inst._debugID) {
      // Check for ART-like instances. TODO: This is silly/gross.
      var internal;
      if (internal = ReactInstanceMap.get(inst)) {
        inst = internal;
      }
    }
    return inst._debugID;
  };
  setChildrenForInstrumentation = function (children) {
    var debugID = getDebugID(this);
    // TODO: React Native empty components are also multichild.
    // This means they still get into this method but don't have _debugID.
    if (debugID !== 0) {
      ReactInstrumentation$8.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
        return children[key]._debugID;
      }) : []);
    }
  };
}

/**
 * ReactMultiChild are capable of reconciling multiple children.
 *
 * @class ReactMultiChild
 * @internal
 */
var ReactMultiChild$1 = {

  /**
   * Provides common functionality for components that must reconcile multiple
   * children. This is used by `ReactDOMComponent` to mount, update, and
   * unmount child components.
   *
   * @lends {ReactMultiChild.prototype}
   */
  Mixin: {

    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
      {
        var selfDebugID = getDebugID(this);
        if (this._currentElement) {
          try {
            ReactCurrentOwner$5.current = this._currentElement._owner;
            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
          } finally {
            ReactCurrentOwner$5.current = null;
          }
        }
      }
      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
    },

    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
      var nextChildren;
      var selfDebugID = 0;
      {
        selfDebugID = getDebugID(this);
        if (this._currentElement) {
          try {
            ReactCurrentOwner$5.current = this._currentElement._owner;
            nextChildren = flattenChildren$1(nextNestedChildrenElements, selfDebugID);
          } finally {
            ReactCurrentOwner$5.current = null;
          }
          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
          return nextChildren;
        }
      }
      nextChildren = flattenChildren$1(nextNestedChildrenElements, selfDebugID);
      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
      return nextChildren;
    },

    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function (nestedChildren, transaction, context) {
      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
      this._renderedChildren = children;

      var mountImages = [];
      var index = 0;
      for (var name in children) {
        if (children.hasOwnProperty(name)) {
          var child = children[name];
          var selfDebugID = 0;
          {
            selfDebugID = getDebugID(this);
          }
          var mountImage = ReactReconciler$3.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
          child._mountIndex = index++;
          mountImages.push(mountImage);
        }
      }

      {
        setChildrenForInstrumentation.call(this, children);
      }

      return mountImages;
    },

    /**
     * Replaces any rendered children with a text content string.
     *
     * @param {string} nextContent String of content.
     * @internal
     */
    updateTextContent: function (nextContent) {
      var prevChildren = this._renderedChildren;
      // Remove any rendered children.
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
          invariant$27(false, 'updateTextContent called on non-empty component.');
        }
      }
      // Set new text content.
      var updates = [makeTextContent(nextContent)];
      processQueue(this, updates);
    },

    /**
     * Replaces any rendered children with a markup string.
     *
     * @param {string} nextMarkup String of markup.
     * @internal
     */
    updateMarkup: function (nextMarkup) {
      var prevChildren = this._renderedChildren;
      // Remove any rendered children.
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
          invariant$27(false, 'updateTextContent called on non-empty component.');
        }
      }
      var updates = [makeSetMarkup(nextMarkup)];
      processQueue(this, updates);
    },

    /**
     * Updates the rendered children with new children.
     *
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    updateChildren: function (nextNestedChildrenElements, transaction, context) {
      // Hook used by React ART
      this._updateChildren(nextNestedChildrenElements, transaction, context);
    },

    /**
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @final
     * @protected
     */
    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
      var prevChildren = this._renderedChildren;
      var removedNodes = {};
      var mountImages = [];
      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
      if (!nextChildren && !prevChildren) {
        return;
      }
      var updates = null;
      var name;
      // `nextIndex` will increment for each child in `nextChildren`, but
      // `lastIndex` will be the last index visited in `prevChildren`.
      var nextIndex = 0;
      var lastIndex = 0;
      // `nextMountIndex` will increment for each newly mounted child.
      var nextMountIndex = 0;
      var lastPlacedNode = null;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var nextChild = nextChildren[name];
        if (prevChild === nextChild) {
          updates = enqueue$1(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            // The `removedNodes` loop below will actually remove the child.
          }
          // The child must be instantiated before it's mounted.
          updates = enqueue$1(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
          nextMountIndex++;
        }
        nextIndex++;
        lastPlacedNode = ReactReconciler$3.getHostNode(nextChild);
      }
      // Remove children that are no longer present.
      for (name in removedNodes) {
        if (removedNodes.hasOwnProperty(name)) {
          updates = enqueue$1(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
        }
      }
      if (updates) {
        processQueue(this, updates);
      }
      this._renderedChildren = nextChildren;

      {
        setChildrenForInstrumentation.call(this, nextChildren);
      }
    },

    /**
     * Unmounts all rendered children. This should be used to clean up children
     * when this component is unmounted. It does not actually perform any
     * backend operations.
     *
     * @internal
     */
    unmountChildren: function (safely) {
      var renderedChildren = this._renderedChildren;
      ReactChildReconciler.unmountChildren(renderedChildren, safely);
      this._renderedChildren = null;
    },

    /**
     * Moves a child component to the supplied index.
     *
     * @param {ReactComponent} child Component to move.
     * @param {number} toIndex Destination index of the element.
     * @param {number} lastIndex Last index visited of the siblings of `child`.
     * @protected
     */
    moveChild: function (child, afterNode, toIndex, lastIndex) {
      // If the index of `child` is less than `lastIndex`, then it needs to
      // be moved. Otherwise, we do not need to move it because a child will be
      // inserted or moved before `child`.
      if (child._mountIndex < lastIndex) {
        return makeMove(child, afterNode, toIndex);
      }
    },

    /**
     * Creates a child component.
     *
     * @param {ReactComponent} child Component to create.
     * @param {string} mountImage Markup to insert.
     * @protected
     */
    createChild: function (child, afterNode, mountImage) {
      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
    },

    /**
     * Removes a child component.
     *
     * @param {ReactComponent} child Child to remove.
     * @protected
     */
    removeChild: function (child, node) {
      return makeRemove(child, node);
    },

    /**
     * Mounts a child with the supplied name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to mount.
     * @param {string} name Name of the child.
     * @param {number} index Index at which to insert the child.
     * @param {ReactReconcileTransaction} transaction
     * @private
     */
    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
      child._mountIndex = index;
      return this.createChild(child, afterNode, mountImage);
    },

    /**
     * Unmounts a rendered child.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to unmount.
     * @private
     */
    _unmountChild: function (child, node) {
      var update = this.removeChild(child, node);
      child._mountIndex = null;
      return update;
    }

  }

};

var ReactMultiChild_1 = ReactMultiChild$1;

var ReactCurrentOwner$8 = ReactCurrentOwner_1;
var ReactInstanceMap$3 = ReactInstanceMap_1;
var ReactInstrumentation$11 = ReactInstrumentation$2;
var ReactUpdates$6 = ReactUpdates_1;

var invariant$35 = invariant_1;
var warning$34 = warning_1;

function enqueueUpdate$1(internalInstance) {
  ReactUpdates$6.enqueueUpdate(internalInstance);
}

function formatUnexpectedArgument(arg) {
  var type = typeof arg;
  if (type !== 'object') {
    return type;
  }
  var displayName = arg.constructor && arg.constructor.name || type;
  var keys = Object.keys(arg);
  if (keys.length > 0 && keys.length < 20) {
    return displayName + ' (keys: ' + keys.join(', ') + ')';
  }
  return displayName;
}

function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
  var internalInstance = ReactInstanceMap$3.get(publicInstance);
  if (!internalInstance) {
    {
      var ctor = publicInstance.constructor;
      // Only warn when we have a callerName. Otherwise we should be silent.
      // We're probably calling from enqueueCallback. We don't want to warn
      // there because we already warned for the corresponding lifecycle method.
      warning$34(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass');
    }
    return null;
  }

  {
    warning$34(ReactCurrentOwner$8.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName);
  }

  return internalInstance;
}

/**
 * ReactUpdateQueue allows for state updates to be scheduled into a later
 * reconciliation step.
 */
var ReactUpdateQueue$1 = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    {
      var owner = ReactCurrentOwner$8.current;
      if (owner !== null) {
        warning$34(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component');
        owner._warnedAboutRefsInRender = true;
      }
    }
    var internalInstance = ReactInstanceMap$3.get(publicInstance);
    if (internalInstance) {
      // During componentWillMount and render this will still be null but after
      // that will always render to something. At least for now. So we can use
      // this hack.
      return !!internalInstance._renderedComponent;
    } else {
      return false;
    }
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @param {string} callerName Name of the calling function in the public API.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback, callerName) {
    ReactUpdateQueue$1.validateCallback(callback, callerName);
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

    // Previously we would throw an error if we didn't have an internal
    // instance. Since we want to make it a no-op instead, we mirror the same
    // behavior we have in other enqueue* methods.
    // We also need to ignore callbacks in componentWillMount. See
    // enqueueUpdates.
    if (!internalInstance) {
      return null;
    }

    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    // TODO: The callback here is ignored when setState is called from
    // componentWillMount. Either fix it or disallow doing so completely in
    // favor of getInitialState. Alternatively, we can disallow
    // componentWillMount during server-side rendering.
    enqueueUpdate$1(internalInstance);
  },

  enqueueCallbackInternal: function (internalInstance, callback) {
    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    enqueueUpdate$1(internalInstance);
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingForceUpdate = true;

    enqueueUpdate$1(internalInstance);
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingStateQueue = [completeState];
    internalInstance._pendingReplaceState = true;

    enqueueUpdate$1(internalInstance);
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    {
      ReactInstrumentation$11.debugTool.onSetState();
      warning$34(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().');
    }

    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

    if (!internalInstance) {
      return;
    }

    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
    queue.push(partialState);

    enqueueUpdate$1(internalInstance);
  },

  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
    internalInstance._pendingElement = nextElement;
    // TODO: introduce _pendingContext instead of setting it directly.
    internalInstance._context = nextContext;
    enqueueUpdate$1(internalInstance);
  },

  validateCallback: function (callback, callerName) {
    !(!callback || typeof callback === 'function') ? invariant$35(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : void 0;
  }

};

var ReactUpdateQueue_1 = ReactUpdateQueue$1;

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ReactUpdateQueue = ReactUpdateQueue_1;

var warning$33 = warning_1;

function warnNoop$1(publicInstance, callerName) {
  {
    var constructor = publicInstance.constructor;
    warning$33(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass');
  }
}

/**
 * This is the update queue used for server rendering.
 * It delegates to ReactUpdateQueue while server rendering is in progress and
 * switches to ReactNoopUpdateQueue after the transaction has completed.
 * @class ReactServerUpdateQueue
 * @param {Transaction} transaction
 */

var ReactServerUpdateQueue$1 = function () {
  function ReactServerUpdateQueue(transaction) {
    _classCallCheck$1(this, ReactServerUpdateQueue);

    this.transaction = transaction;
  }

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */


  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
    return false;
  };

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
    }
  };

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
    } else {
      warnNoop$1(publicInstance, 'forceUpdate');
    }
  };

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object|function} completeState Next state.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
    } else {
      warnNoop$1(publicInstance, 'replaceState');
    }
  };

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object|function} partialState Next partial state to be merged with state.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
    } else {
      warnNoop$1(publicInstance, 'setState');
    }
  };

  return ReactServerUpdateQueue;
}();

var ReactServerUpdateQueue_1 = ReactServerUpdateQueue$1;

var _assign$16 = index$1;

var PooledClass$7 = PooledClass_1$2;
var Transaction$3 = Transaction$1;
var ReactInstrumentation$10 = ReactInstrumentation$2;
var ReactServerUpdateQueue = ReactServerUpdateQueue_1;

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS$1 = [];

{
  TRANSACTION_WRAPPERS$1.push({
    initialize: ReactInstrumentation$10.debugTool.onBeginFlush,
    close: ReactInstrumentation$10.debugTool.onEndFlush
  });
}

var noopCallbackQueue = {
  enqueue: function () {}
};

/**
 * @class ReactServerRenderingTransaction
 * @param {boolean} renderToStaticMarkup
 */
function ReactServerRenderingTransaction$1(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.useCreateElement = false;
  this.updateQueue = new ReactServerUpdateQueue(this);
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array} Empty list of operation wrap procedures.
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS$1;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return noopCallbackQueue;
  },

  /**
   * @return {object} The queue to collect React async events.
   */
  getUpdateQueue: function () {
    return this.updateQueue;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {},

  checkpoint: function () {},

  rollback: function () {}
};

_assign$16(ReactServerRenderingTransaction$1.prototype, Transaction$3, Mixin);

PooledClass$7.addPoolingTo(ReactServerRenderingTransaction$1);

var ReactServerRenderingTransaction_1 = ReactServerRenderingTransaction$1;

var _assign$17 = index$1;

var emptyFunction$8 = emptyFunction_1;
var warning$35 = warning_1;

var validateDOMNesting$1 = emptyFunction$8;

{
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    current: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo = function (oldInfo, tag, instance) {
    var ancestorInfo = _assign$17({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
      case '#document':
        return tag === 'html';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':

      case 'pre':
      case 'listing':

      case 'table':

      case 'hr':

      case 'xmp':

      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  /**
   * Given a ReactCompositeComponent instance, return a list of its recursive
   * owners, starting at the root and ending with the instance itself.
   */
  var findOwnerStack = function (instance) {
    if (!instance) {
      return [];
    }

    var stack = [];
    do {
      stack.push(instance);
    } while (instance = instance._currentElement._owner);
    stack.reverse();
    return stack;
  };

  var didWarn = {};

  validateDOMNesting$1 = function (childTag, childText, childInstance, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      warning$35(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null');
      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var problematic = invalidParent || invalidAncestor;

    if (problematic) {
      var ancestorTag = problematic.tag;
      var ancestorInstance = problematic.instance;

      var childOwner = childInstance && childInstance._currentElement._owner;
      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

      var childOwners = findOwnerStack(childOwner);
      var ancestorOwners = findOwnerStack(ancestorOwner);

      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
      var i;

      var deepestCommon = -1;
      for (i = 0; i < minStackLen; i++) {
        if (childOwners[i] === ancestorOwners[i]) {
          deepestCommon = i;
        } else {
          break;
        }
      }

      var UNKNOWN = '(unknown)';
      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ownerInfo = [].concat(
      // If the parent and child instances have a common owner ancestor, start
      // with that -- otherwise we just start with the parent's owners.
      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
      // If we're warning about an invalid (non-parent) ancestry, add '...'
      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
      if (didWarn[warnKey]) {
        return;
      }
      didWarn[warnKey] = true;

      var tagDisplayName = childTag;
      var whitespaceInfo = '';
      if (childTag === '#text') {
        if (/\S/.test(childText)) {
          tagDisplayName = 'Text nodes';
        } else {
          tagDisplayName = 'Whitespace text nodes';
          whitespaceInfo = ' Make sure you don\'t have any extra whitespace between tags on ' + 'each line of your source code.';
        }
      } else {
        tagDisplayName = '<' + childTag + '>';
      }

      if (invalidParent) {
        var info = '';
        if (ancestorTag === 'table' && childTag === 'tr') {
          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
        }
        warning$35(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info);
      } else {
        warning$35(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo);
      }
    }
  };

  validateDOMNesting$1.updatedAncestorInfo = updatedAncestorInfo;

  // For testing
  validateDOMNesting$1.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

var validateDOMNesting_1 = validateDOMNesting$1;

var _assign$7 = index$1;

var AutoFocusUtils = AutoFocusUtils_1;
var CSSPropertyOperations = CSSPropertyOperations_1;
var DOMLazyTree$3 = DOMLazyTree_1;
var DOMNamespaces$3 = DOMNamespaces_1;
var DOMProperty$3 = DOMProperty_1;
var DOMPropertyOperations = DOMPropertyOperations_1;
var EventPluginHub$3 = EventPluginHub_1;
var EventPluginRegistry$2 = EventPluginRegistry_1;
var ReactBrowserEventEmitter = ReactBrowserEventEmitter_1;
var ReactDOMComponentFlags$2 = ReactDOMComponentFlags_1;
var ReactDOMComponentTree$7 = ReactDOMComponentTree_1;
var ReactDOMInput = ReactDOMInput_1;
var ReactDOMOption = ReactDOMOption_1;
var ReactDOMSelect = ReactDOMSelect_1;
var ReactDOMTextarea = ReactDOMTextarea_1;
var ReactInstrumentation$5 = ReactInstrumentation$2;
var ReactMultiChild = ReactMultiChild_1;
var ReactServerRenderingTransaction = ReactServerRenderingTransaction_1;

var emptyFunction$6 = emptyFunction_1;
var escapeTextContentForBrowser$2 = escapeTextContentForBrowser_1;
var invariant$23 = invariant_1;
var isEventSupported$2 = isEventSupported_1;
var shallowEqual = shallowEqual_1;
var validateDOMNesting = validateDOMNesting_1;
var warning$18 = warning_1;

var Flags$1 = ReactDOMComponentFlags$2;
var deleteListener = EventPluginHub$3.deleteListener;
var getNode = ReactDOMComponentTree$7.getNodeFromInstance;
var listenTo = ReactBrowserEventEmitter.listenTo;
var registrationNameModules = EventPluginRegistry$2.registrationNameModules;

// For quickly matching children type, to test if can be treated as content.
var CONTENT_TYPES = { 'string': true, 'number': true };

var STYLE = 'style';
var HTML = '__html';
var RESERVED_PROPS$1 = {
  children: null,
  dangerouslySetInnerHTML: null,
  suppressContentEditableWarning: null
};

// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
var DOC_FRAGMENT_TYPE = 11;

function getDeclarationErrorAddendum$1(internalInstance) {
  if (internalInstance) {
    var owner = internalInstance._currentElement._owner || null;
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' This DOM node was rendered by `' + name + '`.';
      }
    }
  }
  return '';
}

function friendlyStringify(obj) {
  if (typeof obj === 'object') {
    if (Array.isArray(obj)) {
      return '[' + obj.map(friendlyStringify).join(', ') + ']';
    } else {
      var pairs = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
        }
      }
      return '{' + pairs.join(', ') + '}';
    }
  } else if (typeof obj === 'string') {
    return JSON.stringify(obj);
  } else if (typeof obj === 'function') {
    return '[function object]';
  }
  // Differs from JSON.stringify in that undefined because undefined and that
  // inf and nan don't become null
  return String(obj);
}

var styleMutationWarning = {};

function checkAndWarnForMutatedStyle(style1, style2, component) {
  if (style1 == null || style2 == null) {
    return;
  }
  if (shallowEqual(style1, style2)) {
    return;
  }

  var componentName = component._tag;
  var owner = component._currentElement._owner;
  var ownerName;
  if (owner) {
    ownerName = owner.getName();
  }

  var hash = ownerName + '|' + componentName;

  if (styleMutationWarning.hasOwnProperty(hash)) {
    return;
  }

  styleMutationWarning[hash] = true;

  warning$18(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2));
}

/**
 * @param {object} component
 * @param {?object} props
 */
function assertValidProps(component, props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (voidElementTags[component._tag]) {
    !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant$23(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? invariant$23(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;
    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? invariant$23(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;
  }
  {
    warning$18(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');
    warning$18(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.');
    warning$18(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');
  }
  !(props.style == null || typeof props.style === 'object') ? invariant$23(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum$1(component)) : void 0;
}

function enqueuePutListener(inst, registrationName, listener, transaction) {
  if (transaction instanceof ReactServerRenderingTransaction) {
    return;
  }
  {
    // IE8 has no API for event capturing and the `onScroll` event doesn't
    // bubble.
    warning$18(registrationName !== 'onScroll' || isEventSupported$2('scroll', true), 'This browser doesn\'t support the `onScroll` event');
  }
  var containerInfo = inst._hostContainerInfo;
  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
  listenTo(registrationName, doc);
  transaction.getReactMountReady().enqueue(putListener, {
    inst: inst,
    registrationName: registrationName,
    listener: listener
  });
}

function putListener() {
  var listenerToPut = this;
  EventPluginHub$3.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
}

function inputPostMount() {
  var inst = this;
  ReactDOMInput.postMountWrapper(inst);
}

function textareaPostMount() {
  var inst = this;
  ReactDOMTextarea.postMountWrapper(inst);
}

function optionPostMount() {
  var inst = this;
  ReactDOMOption.postMountWrapper(inst);
}

var setAndValidateContentChildDev = emptyFunction$6;
{
  setAndValidateContentChildDev = function (content) {
    var hasExistingContent = this._contentDebugID != null;
    var debugID = this._debugID;
    // This ID represents the inlined child that has no backing instance:
    var contentDebugID = -debugID;

    if (content == null) {
      if (hasExistingContent) {
        ReactInstrumentation$5.debugTool.onUnmountComponent(this._contentDebugID);
      }
      this._contentDebugID = null;
      return;
    }

    validateDOMNesting(null, String(content), this, this._ancestorInfo);
    this._contentDebugID = contentDebugID;
    if (hasExistingContent) {
      ReactInstrumentation$5.debugTool.onBeforeUpdateComponent(contentDebugID, content);
      ReactInstrumentation$5.debugTool.onUpdateComponent(contentDebugID);
    } else {
      ReactInstrumentation$5.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
      ReactInstrumentation$5.debugTool.onMountComponent(contentDebugID);
      ReactInstrumentation$5.debugTool.onSetChildren(debugID, [contentDebugID]);
    }
  };
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trapBubbledEventsLocal() {
  var inst = this;
  // If a component renders to null or if another component fatals and causes
  // the state of the tree to be corrupted, `node` here can be null.
  !inst._rootNodeID ? invariant$23(false, 'Must be mounted to trap events') : void 0;
  var node = getNode(inst);
  !node ? invariant$23(false, 'trapBubbledEvent(...): Requires node to be rendered.') : void 0;

  switch (inst._tag) {
    case 'iframe':
    case 'object':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
      break;
    case 'video':
    case 'audio':

      inst._wrapperState.listeners = [];
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
        }
      }
      break;
    case 'source':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
      break;
    case 'img':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
      break;
    case 'form':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
      break;
    case 'input':
    case 'select':
    case 'textarea':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
      break;
  }
}

function postUpdateSelectWrapper() {
  ReactDOMSelect.postUpdateWrapper(this);
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
  'area': true,
  'base': true,
  'br': true,
  'col': true,
  'embed': true,
  'hr': true,
  'img': true,
  'input': true,
  'keygen': true,
  'link': true,
  'meta': true,
  'param': true,
  'source': true,
  'track': true,
  'wbr': true
};

var newlineEatingTags = {
  'listing': true,
  'pre': true,
  'textarea': true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign$7({
  'menuitem': true
}, omittedCloseTags);

// We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
var validatedTagCache = {};
var hasOwnProperty$2 = {}.hasOwnProperty;

function validateDangerousTag(tag) {
  if (!hasOwnProperty$2.call(validatedTagCache, tag)) {
    !VALID_TAG_REGEX.test(tag) ? invariant$23(false, 'Invalid tag: %s', tag) : void 0;
    validatedTagCache[tag] = true;
  }
}

function isCustomComponent(tagName, props) {
  return tagName.indexOf('-') >= 0 || props.is != null;
}

var globalIdCounter = 1;

/**
 * Creates a new React class that is idempotent and capable of containing other
 * React components. It accepts event listeners and DOM properties that are
 * valid according to `DOMProperty`.
 *
 *  - Event listeners: `onClick`, `onMouseDown`, etc.
 *  - DOM properties: `className`, `name`, `title`, etc.
 *
 * The `style` property functions differently from the DOM API. It accepts an
 * object mapping of style properties to values.
 *
 * @constructor ReactDOMComponent
 * @extends ReactMultiChild
 */
function ReactDOMComponent$1(element) {
  var tag = element.type;
  validateDangerousTag(tag);
  this._currentElement = element;
  this._tag = tag.toLowerCase();
  this._namespaceURI = null;
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._hostNode = null;
  this._hostParent = null;
  this._rootNodeID = 0;
  this._domID = 0;
  this._hostContainerInfo = null;
  this._wrapperState = null;
  this._topLevelWrapper = null;
  this._flags = 0;
  {
    this._ancestorInfo = null;
    setAndValidateContentChildDev.call(this, null);
  }
}

ReactDOMComponent$1.displayName = 'ReactDOMComponent';

ReactDOMComponent$1.Mixin = {

  /**
   * Generates root tag markup then recurses. This method has side effects and
   * is not idempotent.
   *
   * @internal
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?ReactDOMComponent} the parent component instance
   * @param {?object} info about the host container
   * @param {object} context
   * @return {string} The computed markup.
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    this._rootNodeID = globalIdCounter++;
    this._domID = hostContainerInfo._idCounter++;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var props = this._currentElement.props;

    switch (this._tag) {
      case 'audio':
      case 'form':
      case 'iframe':
      case 'img':
      case 'link':
      case 'object':
      case 'source':
      case 'video':
        this._wrapperState = {
          listeners: null
        };
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'input':
        ReactDOMInput.mountWrapper(this, props, hostParent);
        props = ReactDOMInput.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'option':
        ReactDOMOption.mountWrapper(this, props, hostParent);
        props = ReactDOMOption.getHostProps(this, props);
        break;
      case 'select':
        ReactDOMSelect.mountWrapper(this, props, hostParent);
        props = ReactDOMSelect.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'textarea':
        ReactDOMTextarea.mountWrapper(this, props, hostParent);
        props = ReactDOMTextarea.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
    }

    assertValidProps(this, props);

    // We create tags in the namespace of their parent container, except HTML
    // tags get no namespace.
    var namespaceURI;
    var parentTag;
    if (hostParent != null) {
      namespaceURI = hostParent._namespaceURI;
      parentTag = hostParent._tag;
    } else if (hostContainerInfo._tag) {
      namespaceURI = hostContainerInfo._namespaceURI;
      parentTag = hostContainerInfo._tag;
    }
    if (namespaceURI == null || namespaceURI === DOMNamespaces$3.svg && parentTag === 'foreignobject') {
      namespaceURI = DOMNamespaces$3.html;
    }
    if (namespaceURI === DOMNamespaces$3.html) {
      if (this._tag === 'svg') {
        namespaceURI = DOMNamespaces$3.svg;
      } else if (this._tag === 'math') {
        namespaceURI = DOMNamespaces$3.mathml;
      }
    }
    this._namespaceURI = namespaceURI;

    {
      var parentInfo;
      if (hostParent != null) {
        parentInfo = hostParent._ancestorInfo;
      } else if (hostContainerInfo._tag) {
        parentInfo = hostContainerInfo._ancestorInfo;
      }
      if (parentInfo) {
        // parentInfo should always be present except for the top-level
        // component when server rendering
        validateDOMNesting(this._tag, null, this, parentInfo);
      }
      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
    }

    var mountImage;
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var el;
      if (namespaceURI === DOMNamespaces$3.html) {
        if (this._tag === 'script') {
          // Create the script via .innerHTML so its "parser-inserted" flag is
          // set to true and it does not execute
          var div = ownerDocument.createElement('div');
          var type = this._currentElement.type;
          div.innerHTML = '<' + type + '></' + type + '>';
          el = div.removeChild(div.firstChild);
        } else if (props.is) {
          el = ownerDocument.createElement(this._currentElement.type, props.is);
        } else {
          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
          // See discussion in https://github.com/facebook/react/pull/6896
          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
          el = ownerDocument.createElement(this._currentElement.type);
        }
      } else {
        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
      }
      ReactDOMComponentTree$7.precacheNode(this, el);
      this._flags |= Flags$1.hasCachedChildNodes;
      if (!this._hostParent) {
        DOMPropertyOperations.setAttributeForRoot(el);
      }
      this._updateDOMProperties(null, props, transaction);
      var lazyTree = DOMLazyTree$3(el);
      this._createInitialChildren(transaction, props, context, lazyTree);
      mountImage = lazyTree;
    } else {
      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
      var tagContent = this._createContentMarkup(transaction, props, context);
      if (!tagContent && omittedCloseTags[this._tag]) {
        mountImage = tagOpen + '/>';
      } else {
        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
      }
    }

    switch (this._tag) {
      case 'input':
        transaction.getReactMountReady().enqueue(inputPostMount, this);
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'textarea':
        transaction.getReactMountReady().enqueue(textareaPostMount, this);
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'select':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'button':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'option':
        transaction.getReactMountReady().enqueue(optionPostMount, this);
        break;
    }

    return mountImage;
  },

  /**
   * Creates markup for the open tag and all attributes.
   *
   * This method has side effects because events get registered.
   *
   * Iterating over object properties is faster than iterating over arrays.
   * @see http://jsperf.com/obj-vs-arr-iteration
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @return {string} Markup of opening tag.
   */
  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
    var ret = '<' + this._currentElement.type;

    for (var propKey in props) {
      if (!props.hasOwnProperty(propKey)) {
        continue;
      }
      var propValue = props[propKey];
      if (propValue == null) {
        continue;
      }
      if (registrationNameModules.hasOwnProperty(propKey)) {
        if (propValue) {
          enqueuePutListener(this, propKey, propValue, transaction);
        }
      } else {
        if (propKey === STYLE) {
          if (propValue) {
            {
              // See `_updateDOMProperties`. style block
              this._previousStyle = propValue;
            }
            propValue = this._previousStyleCopy = _assign$7({}, props.style);
          }
          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
        }
        var markup = null;
        if (this._tag != null && isCustomComponent(this._tag, props)) {
          if (!RESERVED_PROPS$1.hasOwnProperty(propKey)) {
            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
          }
        } else {
          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
        }
        if (markup) {
          ret += ' ' + markup;
        }
      }
    }

    // For static pages, no need to put React ID and checksum. Saves lots of
    // bytes.
    if (transaction.renderToStaticMarkup) {
      return ret;
    }

    if (!this._hostParent) {
      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
    }
    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
    return ret;
  },

  /**
   * Creates markup for the content between the tags.
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @param {object} context
   * @return {string} Content markup.
   */
  _createContentMarkup: function (transaction, props, context) {
    var ret = '';

    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        ret = innerHTML.__html;
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        ret = escapeTextContentForBrowser$2(contentToUse);
        {
          setAndValidateContentChildDev.call(this, contentToUse);
        }
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        ret = mountImages.join('');
      }
    }
    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
      // text/html ignores the first character in these tags if it's a newline
      // Prefer to break application/xml over text/html (for now) by adding
      // a newline specifically to get eaten by the parser. (Alternately for
      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
      // \r is normalized out by HTMLTextAreaElement#value.)
      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
      // See: Parsing of "textarea" "listing" and "pre" elements
      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
      return '\n' + ret;
    } else {
      return ret;
    }
  },

  _createInitialChildren: function (transaction, props, context, lazyTree) {
    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        DOMLazyTree$3.queueHTML(lazyTree, innerHTML.__html);
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        {
          setAndValidateContentChildDev.call(this, contentToUse);
        }
        DOMLazyTree$3.queueText(lazyTree, contentToUse);
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        for (var i = 0; i < mountImages.length; i++) {
          DOMLazyTree$3.queueChild(lazyTree, mountImages[i]);
        }
      }
    }
  },

  /**
   * Receives a next element and updates the component.
   *
   * @internal
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   */
  receiveComponent: function (nextElement, transaction, context) {
    var prevElement = this._currentElement;
    this._currentElement = nextElement;
    this.updateComponent(transaction, prevElement, nextElement, context);
  },

  /**
   * Updates a DOM component after it has already been allocated and
   * attached to the DOM. Reconciles the root DOM node, then recurses.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevElement
   * @param {ReactElement} nextElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevElement, nextElement, context) {
    var lastProps = prevElement.props;
    var nextProps = this._currentElement.props;

    switch (this._tag) {
      case 'input':
        lastProps = ReactDOMInput.getHostProps(this, lastProps);
        nextProps = ReactDOMInput.getHostProps(this, nextProps);
        break;
      case 'option':
        lastProps = ReactDOMOption.getHostProps(this, lastProps);
        nextProps = ReactDOMOption.getHostProps(this, nextProps);
        break;
      case 'select':
        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
        break;
      case 'textarea':
        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
        break;
    }

    assertValidProps(this, nextProps);
    this._updateDOMProperties(lastProps, nextProps, transaction);
    this._updateDOMChildren(lastProps, nextProps, transaction, context);

    switch (this._tag) {
      case 'input':
        // Update the wrapper around inputs *after* updating props. This has to
        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
        // raise warnings and prevent the new value from being assigned.
        ReactDOMInput.updateWrapper(this);
        break;
      case 'textarea':
        ReactDOMTextarea.updateWrapper(this);
        break;
      case 'select':
        // <select> value update needs to occur after <option> children
        // reconciliation
        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
        break;
    }
  },

  /**
   * Reconciles the properties by detecting differences in property values and
   * updating the DOM as necessary. This function is probably the single most
   * critical path for performance optimization.
   *
   * TODO: Benchmark whether checking for changed values in memory actually
   *       improves performance (especially statically positioned elements).
   * TODO: Benchmark the effects of putting this at the top since 99% of props
   *       do not change for a given reconciliation.
   * TODO: Benchmark areas that can be improved with caching.
   *
   * @private
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {?DOMElement} node
   */
  _updateDOMProperties: function (lastProps, nextProps, transaction) {
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = this._previousStyleCopy;
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
        this._previousStyleCopy = null;
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (lastProps[propKey]) {
          // Only call deleteListener if there was a listener previously or
          // else willDeleteListener gets called when there wasn't actually a
          // listener (e.g., onClick={null})
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, lastProps)) {
        if (!RESERVED_PROPS$1.hasOwnProperty(propKey)) {
          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
        }
      } else if (DOMProperty$3.properties[propKey] || DOMProperty$3.isCustomAttribute(propKey)) {
        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          {
            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
            this._previousStyle = nextProp;
          }
          nextProp = this._previousStyleCopy = _assign$7({}, nextProp);
        } else {
          this._previousStyleCopy = null;
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp) {
          enqueuePutListener(this, propKey, nextProp, transaction);
        } else if (lastProp) {
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, nextProps)) {
        if (!RESERVED_PROPS$1.hasOwnProperty(propKey)) {
          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
        }
      } else if (DOMProperty$3.properties[propKey] || DOMProperty$3.isCustomAttribute(propKey)) {
        var node = getNode(this);
        // If we're updating to null or undefined, we should remove the property
        // from the DOM node instead of inadvertently setting to a string. This
        // brings us in line with the same behavior we have on initial render.
        if (nextProp != null) {
          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, propKey);
        }
      }
    }
    if (styleUpdates) {
      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
    }
  },

  /**
   * Reconciles the children with the various properties that affect the
   * children content.
   *
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   */
  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

    // Note the use of `!=` which checks for null or undefined.
    var lastChildren = lastContent != null ? null : lastProps.children;
    var nextChildren = nextContent != null ? null : nextProps.children;

    // If we're switching from children to content/html or vice versa, remove
    // the old content
    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
    if (lastChildren != null && nextChildren == null) {
      this.updateChildren(null, transaction, context);
    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
      this.updateTextContent('');
      {
        ReactInstrumentation$5.debugTool.onSetChildren(this._debugID, []);
      }
    }

    if (nextContent != null) {
      if (lastContent !== nextContent) {
        this.updateTextContent('' + nextContent);
        {
          setAndValidateContentChildDev.call(this, nextContent);
        }
      }
    } else if (nextHtml != null) {
      if (lastHtml !== nextHtml) {
        this.updateMarkup('' + nextHtml);
      }
      {
        ReactInstrumentation$5.debugTool.onSetChildren(this._debugID, []);
      }
    } else if (nextChildren != null) {
      {
        setAndValidateContentChildDev.call(this, null);
      }

      this.updateChildren(nextChildren, transaction, context);
    }
  },

  getHostNode: function () {
    return getNode(this);
  },

  /**
   * Destroys all event registrations for this instance. Does not remove from
   * the DOM. That must be done by the parent.
   *
   * @internal
   */
  unmountComponent: function (safely) {
    switch (this._tag) {
      case 'audio':
      case 'form':
      case 'iframe':
      case 'img':
      case 'link':
      case 'object':
      case 'source':
      case 'video':
        var listeners = this._wrapperState.listeners;
        if (listeners) {
          for (var i = 0; i < listeners.length; i++) {
            listeners[i].remove();
          }
        }
        break;
      case 'html':
      case 'head':
      case 'body':
        /**
         * Components like <html> <head> and <body> can't be removed or added
         * easily in a cross-browser way, however it's valuable to be able to
         * take advantage of React's reconciliation for styling and <title>
         * management. So we just document it and throw in dangerous cases.
         */
        invariant$23(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag);
        break;
    }

    this.unmountChildren(safely);
    ReactDOMComponentTree$7.uncacheNode(this);
    EventPluginHub$3.deleteAllListeners(this);
    this._rootNodeID = 0;
    this._domID = 0;
    this._wrapperState = null;

    {
      setAndValidateContentChildDev.call(this, null);
    }
  },

  getPublicInstance: function () {
    return getNode(this);
  }

};

_assign$7(ReactDOMComponent$1.prototype, ReactDOMComponent$1.Mixin, ReactMultiChild.Mixin);

var ReactDOMComponent_1 = ReactDOMComponent$1;

var _assign$18 = index$1;

var DOMLazyTree$4 = DOMLazyTree_1;
var ReactDOMComponentTree$14 = ReactDOMComponentTree_1;

var ReactDOMEmptyComponent$1 = function (instantiate) {
  // ReactCompositeComponent uses this:
  this._currentElement = null;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;
  this._hostContainerInfo = null;
  this._domID = 0;
};
_assign$18(ReactDOMEmptyComponent$1.prototype, {
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    var domID = hostContainerInfo._idCounter++;
    this._domID = domID;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var nodeValue = ' react-empty: ' + this._domID + ' ';
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var node = ownerDocument.createComment(nodeValue);
      ReactDOMComponentTree$14.precacheNode(this, node);
      return DOMLazyTree$4(node);
    } else {
      if (transaction.renderToStaticMarkup) {
        // Normally we'd insert a comment node, but since this is a situation
        // where React won't take over (static pages), we can simply return
        // nothing.
        return '';
      }
      return '<!--' + nodeValue + '-->';
    }
  },
  receiveComponent: function () {},
  getHostNode: function () {
    return ReactDOMComponentTree$14.getNodeFromInstance(this);
  },
  unmountComponent: function () {
    ReactDOMComponentTree$14.uncacheNode(this);
  }
});

var ReactDOMEmptyComponent_1 = ReactDOMEmptyComponent$1;

var invariant$36 = invariant_1;

/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */
function getLowestCommonAncestor(instA, instB) {
  !('_hostNode' in instA) ? invariant$36(false, 'getNodeFromInstance: Invalid argument.') : void 0;
  !('_hostNode' in instB) ? invariant$36(false, 'getNodeFromInstance: Invalid argument.') : void 0;

  var depthA = 0;
  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB > 0) {
    instA = instA._hostParent;
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA > 0) {
    instB = instB._hostParent;
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB) {
      return instA;
    }
    instA = instA._hostParent;
    instB = instB._hostParent;
  }
  return null;
}

/**
 * Return if A is an ancestor of B.
 */
function isAncestor(instA, instB) {
  !('_hostNode' in instA) ? invariant$36(false, 'isAncestor: Invalid argument.') : void 0;
  !('_hostNode' in instB) ? invariant$36(false, 'isAncestor: Invalid argument.') : void 0;

  while (instB) {
    if (instB === instA) {
      return true;
    }
    instB = instB._hostParent;
  }
  return false;
}

/**
 * Return the parent instance of the passed-in instance.
 */
function getParentInstance(inst) {
  !('_hostNode' in inst) ? invariant$36(false, 'getParentInstance: Invalid argument.') : void 0;

  return inst._hostParent;
}

/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */
function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = inst._hostParent;
  }
  var i;
  for (i = path.length; i-- > 0;) {
    fn(path[i], 'captured', arg);
  }
  for (i = 0; i < path.length; i++) {
    fn(path[i], 'bubbled', arg);
  }
}

/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */
function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (from && from !== common) {
    pathFrom.push(from);
    from = from._hostParent;
  }
  var pathTo = [];
  while (to && to !== common) {
    pathTo.push(to);
    to = to._hostParent;
  }
  var i;
  for (i = 0; i < pathFrom.length; i++) {
    fn(pathFrom[i], 'bubbled', argFrom);
  }
  for (i = pathTo.length; i-- > 0;) {
    fn(pathTo[i], 'captured', argTo);
  }
}

var ReactDOMTreeTraversal$1 = {
  isAncestor: isAncestor,
  getLowestCommonAncestor: getLowestCommonAncestor,
  getParentInstance: getParentInstance,
  traverseTwoPhase: traverseTwoPhase,
  traverseEnterLeave: traverseEnterLeave
};

var _assign$19 = index$1;

var DOMChildrenOperations$3 = DOMChildrenOperations_1;
var DOMLazyTree$5 = DOMLazyTree_1;
var ReactDOMComponentTree$15 = ReactDOMComponentTree_1;

var escapeTextContentForBrowser$4 = escapeTextContentForBrowser_1;
var invariant$37 = invariant_1;
var validateDOMNesting$2 = validateDOMNesting_1;

/**
 * Text nodes violate a couple assumptions that React makes about components:
 *
 *  - When mounting text into the DOM, adjacent text nodes are merged.
 *  - Text nodes cannot be assigned a React root ID.
 *
 * This component is used to wrap strings between comment nodes so that they
 * can undergo the same reconciliation that is applied to elements.
 *
 * TODO: Investigate representing React components in the DOM with text nodes.
 *
 * @class ReactDOMTextComponent
 * @extends ReactComponent
 * @internal
 */
var ReactDOMTextComponent$1 = function (text) {
  // TODO: This is really a ReactText (ReactNode), not a ReactElement
  this._currentElement = text;
  this._stringText = '' + text;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;

  // Properties
  this._domID = 0;
  this._mountIndex = 0;
  this._closingComment = null;
  this._commentNodes = null;
};

_assign$19(ReactDOMTextComponent$1.prototype, {

  /**
   * Creates the markup for this text node. This node is not intended to have
   * any features besides containing text content.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup for this text node.
   * @internal
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    {
      var parentInfo;
      if (hostParent != null) {
        parentInfo = hostParent._ancestorInfo;
      } else if (hostContainerInfo != null) {
        parentInfo = hostContainerInfo._ancestorInfo;
      }
      if (parentInfo) {
        // parentInfo should always be present except for the top-level
        // component when server rendering
        validateDOMNesting$2(null, this._stringText, this, parentInfo);
      }
    }

    var domID = hostContainerInfo._idCounter++;
    var openingValue = ' react-text: ' + domID + ' ';
    var closingValue = ' /react-text ';
    this._domID = domID;
    this._hostParent = hostParent;
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var openingComment = ownerDocument.createComment(openingValue);
      var closingComment = ownerDocument.createComment(closingValue);
      var lazyTree = DOMLazyTree$5(ownerDocument.createDocumentFragment());
      DOMLazyTree$5.queueChild(lazyTree, DOMLazyTree$5(openingComment));
      if (this._stringText) {
        DOMLazyTree$5.queueChild(lazyTree, DOMLazyTree$5(ownerDocument.createTextNode(this._stringText)));
      }
      DOMLazyTree$5.queueChild(lazyTree, DOMLazyTree$5(closingComment));
      ReactDOMComponentTree$15.precacheNode(this, openingComment);
      this._closingComment = closingComment;
      return lazyTree;
    } else {
      var escapedText = escapeTextContentForBrowser$4(this._stringText);

      if (transaction.renderToStaticMarkup) {
        // Normally we'd wrap this between comment nodes for the reasons stated
        // above, but since this is a situation where React won't take over
        // (static pages), we can simply return the text as it is.
        return escapedText;
      }

      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
    }
  },

  /**
   * Updates this component by updating the text content.
   *
   * @param {ReactText} nextText The next text content
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  receiveComponent: function (nextText, transaction) {
    if (nextText !== this._currentElement) {
      this._currentElement = nextText;
      var nextStringText = '' + nextText;
      if (nextStringText !== this._stringText) {
        // TODO: Save this as pending props and use performUpdateIfNecessary
        // and/or updateComponent to do the actual update for consistency with
        // other component types?
        this._stringText = nextStringText;
        var commentNodes = this.getHostNode();
        DOMChildrenOperations$3.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
      }
    }
  },

  getHostNode: function () {
    var hostNode = this._commentNodes;
    if (hostNode) {
      return hostNode;
    }
    if (!this._closingComment) {
      var openingComment = ReactDOMComponentTree$15.getNodeFromInstance(this);
      var node = openingComment.nextSibling;
      while (true) {
        !(node != null) ? invariant$37(false, 'Missing closing comment for text component %s', this._domID) : void 0;
        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
          this._closingComment = node;
          break;
        }
        node = node.nextSibling;
      }
    }
    hostNode = [this._hostNode, this._closingComment];
    this._commentNodes = hostNode;
    return hostNode;
  },

  unmountComponent: function () {
    this._closingComment = null;
    this._commentNodes = null;
    ReactDOMComponentTree$15.uncacheNode(this);
  }

});

var ReactDOMTextComponent_1 = ReactDOMTextComponent$1;

var _assign$20 = index$1;

var ReactUpdates$7 = ReactUpdates_1;
var Transaction$4 = Transaction$1;

var emptyFunction$9 = emptyFunction_1;

var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction$9,
  close: function () {
    ReactDefaultBatchingStrategy$1.isBatchingUpdates = false;
  }
};

var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction$9,
  close: ReactUpdates$7.flushBatchedUpdates.bind(ReactUpdates$7)
};

var TRANSACTION_WRAPPERS$2 = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}

_assign$20(ReactDefaultBatchingStrategyTransaction.prototype, Transaction$4, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS$2;
  }
});

var transaction = new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy$1 = {
  isBatchingUpdates: false,

  /**
   * Call the provided function in a context within which calls to `setState`
   * and friends are batched such that components aren't updated unnecessarily.
   */
  batchedUpdates: function (callback, a, b, c, d, e) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy$1.isBatchingUpdates;

    ReactDefaultBatchingStrategy$1.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      return callback(a, b, c, d, e);
    } else {
      return transaction.perform(callback, null, a, b, c, d, e);
    }
  }
};

var ReactDefaultBatchingStrategy_1 = ReactDefaultBatchingStrategy$1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @typechecks
 */

var emptyFunction$10 = emptyFunction_1;

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener$1 = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction$10
      };
    }
  },

  registerDefault: function registerDefault() {}
};

var EventListener_1 = EventListener$1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */

function getUnboundedScrollPosition$1(scrollable) {
  if (scrollable === window) {
    return {
      x: window.pageXOffset || document.documentElement.scrollLeft,
      y: window.pageYOffset || document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

var getUnboundedScrollPosition_1 = getUnboundedScrollPosition$1;

var _assign$21 = index$1;

var EventListener = EventListener_1;
var ExecutionEnvironment$15 = ExecutionEnvironment_1;
var PooledClass$8 = PooledClass_1$2;
var ReactDOMComponentTree$16 = ReactDOMComponentTree_1;
var ReactUpdates$8 = ReactUpdates_1;

var getEventTarget$3 = getEventTarget_1;
var getUnboundedScrollPosition = getUnboundedScrollPosition_1;

/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */
function findParent(inst) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  while (inst._hostParent) {
    inst = inst._hostParent;
  }
  var rootNode = ReactDOMComponentTree$16.getNodeFromInstance(inst);
  var container = rootNode.parentNode;
  return ReactDOMComponentTree$16.getClosestInstanceFromNode(container);
}

// Used to store ancestor hierarchy in top level callback
function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
  this.topLevelType = topLevelType;
  this.nativeEvent = nativeEvent;
  this.ancestors = [];
}
_assign$21(TopLevelCallbackBookKeeping.prototype, {
  destructor: function () {
    this.topLevelType = null;
    this.nativeEvent = null;
    this.ancestors.length = 0;
  }
});
PooledClass$8.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass$8.twoArgumentPooler);

function handleTopLevelImpl(bookKeeping) {
  var nativeEventTarget = getEventTarget$3(bookKeeping.nativeEvent);
  var targetInst = ReactDOMComponentTree$16.getClosestInstanceFromNode(nativeEventTarget);

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = targetInst;
  do {
    bookKeeping.ancestors.push(ancestor);
    ancestor = ancestor && findParent(ancestor);
  } while (ancestor);

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    ReactEventListener$1._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget$3(bookKeeping.nativeEvent));
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}

var ReactEventListener$1 = {
  _enabled: true,
  _handleTopLevel: null,

  WINDOW_HANDLE: ExecutionEnvironment$15.canUseDOM ? window : null,

  setHandleTopLevel: function (handleTopLevel) {
    ReactEventListener$1._handleTopLevel = handleTopLevel;
  },

  setEnabled: function (enabled) {
    ReactEventListener$1._enabled = !!enabled;
  },

  isEnabled: function () {
    return ReactEventListener$1._enabled;
  },

  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} element Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapBubbledEvent: function (topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.listen(element, handlerBaseName, ReactEventListener$1.dispatchEvent.bind(null, topLevelType));
  },

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} element Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapCapturedEvent: function (topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.capture(element, handlerBaseName, ReactEventListener$1.dispatchEvent.bind(null, topLevelType));
  },

  monitorScrollValue: function (refresh) {
    var callback = scrollValueMonitor.bind(null, refresh);
    EventListener.listen(window, 'scroll', callback);
  },

  dispatchEvent: function (topLevelType, nativeEvent) {
    if (!ReactEventListener$1._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      ReactUpdates$8.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  }
};

var ReactEventListener_1 = ReactEventListener$1;

var DOMProperty$5 = DOMProperty_1;
var EventPluginHub$5 = EventPluginHub_1;
var EventPluginUtils$3 = EventPluginUtils_1;
var ReactComponentEnvironment$3 = ReactComponentEnvironment_1;
var ReactEmptyComponent$2 = ReactEmptyComponent_1;
var ReactBrowserEventEmitter$2 = ReactBrowserEventEmitter_1;
var ReactHostComponent$2 = ReactHostComponent_1;
var ReactUpdates$9 = ReactUpdates_1;

var ReactInjection$1 = {
  Component: ReactComponentEnvironment$3.injection,
  DOMProperty: DOMProperty$5.injection,
  EmptyComponent: ReactEmptyComponent$2.injection,
  EventPluginHub: EventPluginHub$5.injection,
  EventPluginUtils: EventPluginUtils$3.injection,
  EventEmitter: ReactBrowserEventEmitter$2.injection,
  HostComponent: ReactHostComponent$2.injection,
  Updates: ReactUpdates$9.injection
};

var ReactInjection_1 = ReactInjection$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */

function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset$1(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === 3) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

var getNodeForCharacterOffset_1 = getNodeForCharacterOffset$1;

var ExecutionEnvironment$16 = ExecutionEnvironment_1;

var getNodeForCharacterOffset = getNodeForCharacterOffset_1;
var getTextContentAccessor$2 = getTextContentAccessor_1;

/**
 * While `isCollapsed` is available on the Selection object and `collapsed`
 * is available on the Range object, IE11 sometimes gets them wrong.
 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
 */
function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
  return anchorNode === focusNode && anchorOffset === focusOffset;
}

/**
 * Get the appropriate anchor and focus node/offset pairs for IE.
 *
 * The catch here is that IE's selection API doesn't provide information
 * about whether the selection is forward or backward, so we have to
 * behave as though it's always forward.
 *
 * IE text differs from modern selection in that it behaves as though
 * block elements end with a new line. This means character offsets will
 * differ between the two APIs.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getIEOffsets(node) {
  var selection = document.selection;
  var selectedRange = selection.createRange();
  var selectedLength = selectedRange.text.length;

  // Duplicate selection so we can move range without breaking user selection.
  var fromStart = selectedRange.duplicate();
  fromStart.moveToElementText(node);
  fromStart.setEndPoint('EndToStart', selectedRange);

  var startOffset = fromStart.text.length;
  var endOffset = startOffset + selectedLength;

  return {
    start: startOffset,
    end: endOffset
  };
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // In Firefox, range.startContainer and range.endContainer can be "anonymous
  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
  // divs do not seem to expose properties, triggering a "Permission denied
  // error" if any of its properties are accessed. The only seemingly possible
  // way to avoid erroring is to access a property that typically works for
  // non-anonymous divs and catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
  try {
    /* eslint-disable no-unused-expressions */
    currentRange.startContainer.nodeType;
    currentRange.endContainer.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}

/**
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setIEOffsets(node, offsets) {
  var range = document.selection.createRange().duplicate();
  var start, end;

  if (offsets.end === undefined) {
    start = offsets.start;
    end = start;
  } else if (offsets.start > offsets.end) {
    start = offsets.end;
    end = offsets.start;
  } else {
    start = offsets.start;
    end = offsets.end;
  }

  range.moveToElementText(node);
  range.moveStart('character', start);
  range.setEndPoint('EndToStart', range);
  range.moveEnd('character', end - start);
  range.select();
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setModernOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor$2()].length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

var useIEOffsets = ExecutionEnvironment$16.canUseDOM && 'selection' in document && !('getSelection' in window);

var ReactDOMSelection$1 = {
  /**
   * @param {DOMElement} node
   */
  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

  /**
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
};

var ReactDOMSelection_1 = ReactDOMSelection$1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
function isNode$2(object) {
  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

var isNode_1 = isNode$2;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var isNode$1 = isNode_1;

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode$1(object) {
  return isNode$1(object) && object.nodeType == 3;
}

var isTextNode_1 = isTextNode$1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

var isTextNode = isTextNode_1;

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode$1(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode$1(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

var containsNode_1 = containsNode$1;

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 */
function getActiveElement$1() /*?DOMElement*/{
  if (typeof document === 'undefined') {
    return null;
  }
  try {
    return document.activeElement || document.body;
  } catch (e) {
    return document.body;
  }
}

var getActiveElement_1 = getActiveElement$1;

var ReactDOMSelection = ReactDOMSelection_1;

var containsNode = containsNode_1;
var focusNode$2 = focusNode_1;
var getActiveElement = getActiveElement_1;

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */
var ReactInputSelection$1 = {

  hasSelectionCapabilities: function (elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
  },

  getSelectionInformation: function () {
    var focusedElem = getActiveElement();
    return {
      focusedElem: focusedElem,
      selectionRange: ReactInputSelection$1.hasSelectionCapabilities(focusedElem) ? ReactInputSelection$1.getSelection(focusedElem) : null
    };
  },

  /**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */
  restoreSelection: function (priorSelectionInformation) {
    var curFocusedElem = getActiveElement();
    var priorFocusedElem = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
      if (ReactInputSelection$1.hasSelectionCapabilities(priorFocusedElem)) {
        ReactInputSelection$1.setSelection(priorFocusedElem, priorSelectionRange);
      }
      focusNode$2(priorFocusedElem);
    }
  },

  /**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */
  getSelection: function (input) {
    var selection;

    if ('selectionStart' in input) {
      // Modern browser with input or textarea.
      selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      };
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      // IE8 input.
      var range = document.selection.createRange();
      // There can only be one selection per document in IE, so it must
      // be in our element.
      if (range.parentElement() === input) {
        selection = {
          start: -range.moveStart('character', -input.value.length),
          end: -range.moveEnd('character', -input.value.length)
        };
      }
    } else {
      // Content editable or old IE textarea.
      selection = ReactDOMSelection.getOffsets(input);
    }

    return selection || { start: 0, end: 0 };
  },

  /**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */
  setSelection: function (input, offsets) {
    var start = offsets.start;
    var end = offsets.end;
    if (end === undefined) {
      end = start;
    }

    if ('selectionStart' in input) {
      input.selectionStart = start;
      input.selectionEnd = Math.min(end, input.value.length);
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart('character', start);
      range.moveEnd('character', end - start);
      range.select();
    } else {
      ReactDOMSelection.setOffsets(input, offsets);
    }
  }
};

var ReactInputSelection_1 = ReactInputSelection$1;

var _assign$22 = index$1;

var CallbackQueue$2 = CallbackQueue_1;
var PooledClass$9 = PooledClass_1$2;
var ReactBrowserEventEmitter$3 = ReactBrowserEventEmitter_1;
var ReactInputSelection = ReactInputSelection_1;
var ReactInstrumentation$12 = ReactInstrumentation$2;
var Transaction$5 = Transaction$1;
var ReactUpdateQueue$2 = ReactUpdateQueue_1;

/**
 * Ensures that, when possible, the selection range (currently selected text
 * input) is not disturbed by performing the transaction.
 */
var SELECTION_RESTORATION = {
  /**
   * @return {Selection} Selection information.
   */
  initialize: ReactInputSelection.getSelectionInformation,
  /**
   * @param {Selection} sel Selection information returned from `initialize`.
   */
  close: ReactInputSelection.restoreSelection
};

/**
 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
 * high level DOM manipulations (like temporarily removing a text input from the
 * DOM).
 */
var EVENT_SUPPRESSION = {
  /**
   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
   * the reconciliation.
   */
  initialize: function () {
    var currentlyEnabled = ReactBrowserEventEmitter$3.isEnabled();
    ReactBrowserEventEmitter$3.setEnabled(false);
    return currentlyEnabled;
  },

  /**
   * @param {boolean} previouslyEnabled Enabled status of
   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
   *   restores the previous value.
   */
  close: function (previouslyEnabled) {
    ReactBrowserEventEmitter$3.setEnabled(previouslyEnabled);
  }
};

/**
 * Provides a queue for collecting `componentDidMount` and
 * `componentDidUpdate` callbacks during the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function () {
    this.reactMountReady.reset();
  },

  /**
   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
   */
  close: function () {
    this.reactMountReady.notifyAll();
  }
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS$3 = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

{
  TRANSACTION_WRAPPERS$3.push({
    initialize: ReactInstrumentation$12.debugTool.onBeginFlush,
    close: ReactInstrumentation$12.debugTool.onEndFlush
  });
}

/**
 * Currently:
 * - The order that these are listed in the transaction is critical:
 * - Suppresses events.
 * - Restores selection range.
 *
 * Future:
 * - Restore document/overflow scroll positions that were unintentionally
 *   modified via DOM insertions above the top viewport boundary.
 * - Implement/integrate with customized constraint based layout system and keep
 *   track of which dimensions must be remeasured.
 *
 * @class ReactReconcileTransaction
 */
function ReactReconcileTransaction$1(useCreateElement) {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactDOMTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue$2.getPooled(null);
  this.useCreateElement = useCreateElement;
}

var Mixin$1 = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array<object>} List of operation wrap procedures.
   *   TODO: convert to array<TransactionWrapper>
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS$3;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return this.reactMountReady;
  },

  /**
   * @return {object} The queue to collect React async events.
   */
  getUpdateQueue: function () {
    return ReactUpdateQueue$2;
  },

  /**
   * Save current transaction state -- if the return value from this method is
   * passed to `rollback`, the transaction will be reset to that state.
   */
  checkpoint: function () {
    // reactMountReady is the our only stateful wrapper
    return this.reactMountReady.checkpoint();
  },

  rollback: function (checkpoint) {
    this.reactMountReady.rollback(checkpoint);
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {
    CallbackQueue$2.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

_assign$22(ReactReconcileTransaction$1.prototype, Transaction$5, Mixin$1);

PooledClass$9.addPoolingTo(ReactReconcileTransaction$1);

var ReactReconcileTransaction_1 = ReactReconcileTransaction$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

// We use attributes for everything SVG so let's avoid some duplication and run
// code instead.
// The following are all specified in the HTML config already so we exclude here.
// - class (as className)
// - color
// - height
// - id
// - lang
// - max
// - media
// - method
// - min
// - name
// - style
// - target
// - type
// - width
var ATTRS = {
  accentHeight: 'accent-height',
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 'alignment-baseline',
  allowReorder: 'allowReorder',
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 'arabic-form',
  ascent: 0,
  attributeName: 'attributeName',
  attributeType: 'attributeType',
  autoReverse: 'autoReverse',
  azimuth: 0,
  baseFrequency: 'baseFrequency',
  baseProfile: 'baseProfile',
  baselineShift: 'baseline-shift',
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 'calcMode',
  capHeight: 'cap-height',
  clip: 0,
  clipPath: 'clip-path',
  clipRule: 'clip-rule',
  clipPathUnits: 'clipPathUnits',
  colorInterpolation: 'color-interpolation',
  colorInterpolationFilters: 'color-interpolation-filters',
  colorProfile: 'color-profile',
  colorRendering: 'color-rendering',
  contentScriptType: 'contentScriptType',
  contentStyleType: 'contentStyleType',
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 'diffuseConstant',
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 'dominant-baseline',
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 'edgeMode',
  elevation: 0,
  enableBackground: 'enable-background',
  end: 0,
  exponent: 0,
  externalResourcesRequired: 'externalResourcesRequired',
  fill: 0,
  fillOpacity: 'fill-opacity',
  fillRule: 'fill-rule',
  filter: 0,
  filterRes: 'filterRes',
  filterUnits: 'filterUnits',
  floodColor: 'flood-color',
  floodOpacity: 'flood-opacity',
  focusable: 0,
  fontFamily: 'font-family',
  fontSize: 'font-size',
  fontSizeAdjust: 'font-size-adjust',
  fontStretch: 'font-stretch',
  fontStyle: 'font-style',
  fontVariant: 'font-variant',
  fontWeight: 'font-weight',
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 'glyph-name',
  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
  glyphOrientationVertical: 'glyph-orientation-vertical',
  glyphRef: 'glyphRef',
  gradientTransform: 'gradientTransform',
  gradientUnits: 'gradientUnits',
  hanging: 0,
  horizAdvX: 'horiz-adv-x',
  horizOriginX: 'horiz-origin-x',
  ideographic: 0,
  imageRendering: 'image-rendering',
  'in': 0,
  in2: 0,
  intercept: 0,
  k: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  kernelMatrix: 'kernelMatrix',
  kernelUnitLength: 'kernelUnitLength',
  kerning: 0,
  keyPoints: 'keyPoints',
  keySplines: 'keySplines',
  keyTimes: 'keyTimes',
  lengthAdjust: 'lengthAdjust',
  letterSpacing: 'letter-spacing',
  lightingColor: 'lighting-color',
  limitingConeAngle: 'limitingConeAngle',
  local: 0,
  markerEnd: 'marker-end',
  markerMid: 'marker-mid',
  markerStart: 'marker-start',
  markerHeight: 'markerHeight',
  markerUnits: 'markerUnits',
  markerWidth: 'markerWidth',
  mask: 0,
  maskContentUnits: 'maskContentUnits',
  maskUnits: 'maskUnits',
  mathematical: 0,
  mode: 0,
  numOctaves: 'numOctaves',
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 'overline-position',
  overlineThickness: 'overline-thickness',
  paintOrder: 'paint-order',
  panose1: 'panose-1',
  pathLength: 'pathLength',
  patternContentUnits: 'patternContentUnits',
  patternTransform: 'patternTransform',
  patternUnits: 'patternUnits',
  pointerEvents: 'pointer-events',
  points: 0,
  pointsAtX: 'pointsAtX',
  pointsAtY: 'pointsAtY',
  pointsAtZ: 'pointsAtZ',
  preserveAlpha: 'preserveAlpha',
  preserveAspectRatio: 'preserveAspectRatio',
  primitiveUnits: 'primitiveUnits',
  r: 0,
  radius: 0,
  refX: 'refX',
  refY: 'refY',
  renderingIntent: 'rendering-intent',
  repeatCount: 'repeatCount',
  repeatDur: 'repeatDur',
  requiredExtensions: 'requiredExtensions',
  requiredFeatures: 'requiredFeatures',
  restart: 0,
  result: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  seed: 0,
  shapeRendering: 'shape-rendering',
  slope: 0,
  spacing: 0,
  specularConstant: 'specularConstant',
  specularExponent: 'specularExponent',
  speed: 0,
  spreadMethod: 'spreadMethod',
  startOffset: 'startOffset',
  stdDeviation: 'stdDeviation',
  stemh: 0,
  stemv: 0,
  stitchTiles: 'stitchTiles',
  stopColor: 'stop-color',
  stopOpacity: 'stop-opacity',
  strikethroughPosition: 'strikethrough-position',
  strikethroughThickness: 'strikethrough-thickness',
  string: 0,
  stroke: 0,
  strokeDasharray: 'stroke-dasharray',
  strokeDashoffset: 'stroke-dashoffset',
  strokeLinecap: 'stroke-linecap',
  strokeLinejoin: 'stroke-linejoin',
  strokeMiterlimit: 'stroke-miterlimit',
  strokeOpacity: 'stroke-opacity',
  strokeWidth: 'stroke-width',
  surfaceScale: 'surfaceScale',
  systemLanguage: 'systemLanguage',
  tableValues: 'tableValues',
  targetX: 'targetX',
  targetY: 'targetY',
  textAnchor: 'text-anchor',
  textDecoration: 'text-decoration',
  textRendering: 'text-rendering',
  textLength: 'textLength',
  to: 0,
  transform: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 'underline-position',
  underlineThickness: 'underline-thickness',
  unicode: 0,
  unicodeBidi: 'unicode-bidi',
  unicodeRange: 'unicode-range',
  unitsPerEm: 'units-per-em',
  vAlphabetic: 'v-alphabetic',
  vHanging: 'v-hanging',
  vIdeographic: 'v-ideographic',
  vMathematical: 'v-mathematical',
  values: 0,
  vectorEffect: 'vector-effect',
  version: 0,
  vertAdvY: 'vert-adv-y',
  vertOriginX: 'vert-origin-x',
  vertOriginY: 'vert-origin-y',
  viewBox: 'viewBox',
  viewTarget: 'viewTarget',
  visibility: 0,
  widths: 0,
  wordSpacing: 'word-spacing',
  writingMode: 'writing-mode',
  x: 0,
  xHeight: 'x-height',
  x1: 0,
  x2: 0,
  xChannelSelector: 'xChannelSelector',
  xlinkActuate: 'xlink:actuate',
  xlinkArcrole: 'xlink:arcrole',
  xlinkHref: 'xlink:href',
  xlinkRole: 'xlink:role',
  xlinkShow: 'xlink:show',
  xlinkTitle: 'xlink:title',
  xlinkType: 'xlink:type',
  xmlBase: 'xml:base',
  xmlns: 0,
  xmlnsXlink: 'xmlns:xlink',
  xmlLang: 'xml:lang',
  xmlSpace: 'xml:space',
  y: 0,
  y1: 0,
  y2: 0,
  yChannelSelector: 'yChannelSelector',
  z: 0,
  zoomAndPan: 'zoomAndPan'
};

var SVGDOMPropertyConfig$1 = {
  Properties: {},
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  },
  DOMAttributeNames: {}
};

Object.keys(ATTRS).forEach(function (key) {
  SVGDOMPropertyConfig$1.Properties[key] = 0;
  if (ATTRS[key]) {
    SVGDOMPropertyConfig$1.DOMAttributeNames[key] = ATTRS[key];
  }
});

var SVGDOMPropertyConfig_1 = SVGDOMPropertyConfig$1;

var EventPropagators$4 = EventPropagators_1;
var ExecutionEnvironment$17 = ExecutionEnvironment_1;
var ReactDOMComponentTree$17 = ReactDOMComponentTree_1;
var ReactInputSelection$2 = ReactInputSelection_1;
var SyntheticEvent$5 = SyntheticEvent_1;

var getActiveElement$2 = getActiveElement_1;
var isTextInputElement$2 = isTextInputElement_1;
var shallowEqual$3 = shallowEqual_1;

var skipSelectionChangeEvent = ExecutionEnvironment$17.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes$3 = {
  select: {
    phasedRegistrationNames: {
      bubbled: 'onSelect',
      captured: 'onSelectCapture'
    },
    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
  }
};

var activeElement$1 = null;
var activeElementInst$1 = null;
var lastSelection = null;
var mouseDown = false;

// Track whether a listener exists for this plugin. If none exist, we do
// not extract events. See #3639.
var hasListener = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && ReactInputSelection$2.hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  } else if (document.selection) {
    var range = document.selection.createRange();
    return {
      parentElement: range.parentElement(),
      text: range.text,
      top: range.boundingTop,
      left: range.boundingLeft
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement$2()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement$1);
  if (!lastSelection || !shallowEqual$3(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent$5.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement$1;

    EventPropagators$4.accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin$1 = {

  eventTypes: eventTypes$3,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (!hasListener) {
      return null;
    }

    var targetNode = targetInst ? ReactDOMComponentTree$17.getNodeFromInstance(targetInst) : window;

    switch (topLevelType) {
      // Track the input node that has focus.
      case 'topFocus':
        if (isTextInputElement$2(targetNode) || targetNode.contentEditable === 'true') {
          activeElement$1 = targetNode;
          activeElementInst$1 = targetInst;
          lastSelection = null;
        }
        break;
      case 'topBlur':
        activeElement$1 = null;
        activeElementInst$1 = null;
        lastSelection = null;
        break;

      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case 'topMouseDown':
        mouseDown = true;
        break;
      case 'topContextMenu':
      case 'topMouseUp':
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);

      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case 'topSelectionChange':
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case 'topKeyDown':
      case 'topKeyUp':
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  },

  didPutListener: function (inst, registrationName, listener) {
    if (registrationName === 'onSelect') {
      hasListener = true;
    }
  }
};

var SelectEventPlugin_1 = SelectEventPlugin$1;

var SyntheticEvent$7 = SyntheticEvent_1;

/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */
var AnimationEventInterface = {
  animationName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticAnimationEvent$1(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$7.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$7.augmentClass(SyntheticAnimationEvent$1, AnimationEventInterface);

var SyntheticAnimationEvent_1 = SyntheticAnimationEvent$1;

var SyntheticEvent$8 = SyntheticEvent_1;

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticClipboardEvent$1(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$8.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$8.augmentClass(SyntheticClipboardEvent$1, ClipboardEventInterface);

var SyntheticClipboardEvent_1 = SyntheticClipboardEvent$1;

var SyntheticUIEvent$3 = SyntheticUIEvent_1;

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent$1(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent$3.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent$3.augmentClass(SyntheticFocusEvent$1, FocusEventInterface);

var SyntheticFocusEvent_1 = SyntheticFocusEvent$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */

function getEventCharCode$2(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

var getEventCharCode_1 = getEventCharCode$2;

var getEventCharCode$3 = getEventCharCode_1;

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  'Esc': 'Escape',
  'Spacebar': ' ',
  'Left': 'ArrowLeft',
  'Up': 'ArrowUp',
  'Right': 'ArrowRight',
  'Down': 'ArrowDown',
  'Del': 'Delete',
  'Win': 'OS',
  'Menu': 'ContextMenu',
  'Apps': 'ContextMenu',
  'Scroll': 'ScrollLock',
  'MozPrintableKey': 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  8: 'Backspace',
  9: 'Tab',
  12: 'Clear',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  19: 'Pause',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  45: 'Insert',
  46: 'Delete',
  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
  144: 'NumLock',
  145: 'ScrollLock',
  224: 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey$1(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode$3(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

var getEventKey_1 = getEventKey$1;

var SyntheticUIEvent$4 = SyntheticUIEvent_1;

var getEventCharCode$1 = getEventCharCode_1;
var getEventKey = getEventKey_1;
var getEventModifierState$2 = getEventModifierState_1;

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState$2,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode$1(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode$1(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent$1(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent$4.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent$4.augmentClass(SyntheticKeyboardEvent$1, KeyboardEventInterface);

var SyntheticKeyboardEvent_1 = SyntheticKeyboardEvent$1;

var SyntheticMouseEvent$3 = SyntheticMouseEvent_1;

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticDragEvent$1(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent$3.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent$3.augmentClass(SyntheticDragEvent$1, DragEventInterface);

var SyntheticDragEvent_1 = SyntheticDragEvent$1;

var SyntheticUIEvent$5 = SyntheticUIEvent_1;

var getEventModifierState$3 = getEventModifierState_1;

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState$3
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent$1(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent$5.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent$5.augmentClass(SyntheticTouchEvent$1, TouchEventInterface);

var SyntheticTouchEvent_1 = SyntheticTouchEvent$1;

var SyntheticEvent$9 = SyntheticEvent_1;

/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */
var TransitionEventInterface = {
  propertyName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticTransitionEvent$1(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$9.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$9.augmentClass(SyntheticTransitionEvent$1, TransitionEventInterface);

var SyntheticTransitionEvent_1 = SyntheticTransitionEvent$1;

var SyntheticMouseEvent$4 = SyntheticMouseEvent_1;

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX :
    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY :
    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY :
    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent$1(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent$4.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent$4.augmentClass(SyntheticWheelEvent$1, WheelEventInterface);

var SyntheticWheelEvent_1 = SyntheticWheelEvent$1;

var EventListener$2 = EventListener_1;
var EventPropagators$5 = EventPropagators_1;
var ReactDOMComponentTree$18 = ReactDOMComponentTree_1;
var SyntheticAnimationEvent = SyntheticAnimationEvent_1;
var SyntheticClipboardEvent = SyntheticClipboardEvent_1;
var SyntheticEvent$6 = SyntheticEvent_1;
var SyntheticFocusEvent = SyntheticFocusEvent_1;
var SyntheticKeyboardEvent = SyntheticKeyboardEvent_1;
var SyntheticMouseEvent$2 = SyntheticMouseEvent_1;
var SyntheticDragEvent = SyntheticDragEvent_1;
var SyntheticTouchEvent = SyntheticTouchEvent_1;
var SyntheticTransitionEvent = SyntheticTransitionEvent_1;
var SyntheticUIEvent$2 = SyntheticUIEvent_1;
var SyntheticWheelEvent = SyntheticWheelEvent_1;

var emptyFunction$11 = emptyFunction_1;
var getEventCharCode = getEventCharCode_1;
var invariant$38 = invariant_1;

/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */
var eventTypes$4 = {};
var topLevelEventsToDispatchConfig = {};
['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
  var onEvent = 'on' + capitalizedEvent;
  var topEvent = 'top' + capitalizedEvent;

  var type = {
    phasedRegistrationNames: {
      bubbled: onEvent,
      captured: onEvent + 'Capture'
    },
    dependencies: [topEvent]
  };
  eventTypes$4[event] = type;
  topLevelEventsToDispatchConfig[topEvent] = type;
});

var onClickListeners = {};

function getDictionaryKey$1(inst) {
  // Prevents V8 performance issue:
  // https://github.com/facebook/react/pull/7232
  return '.' + inst._rootNodeID;
}

function isInteractive$1(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

var SimpleEventPlugin$1 = {

  eventTypes: eventTypes$4,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case 'topAbort':
      case 'topCanPlay':
      case 'topCanPlayThrough':
      case 'topDurationChange':
      case 'topEmptied':
      case 'topEncrypted':
      case 'topEnded':
      case 'topError':
      case 'topInput':
      case 'topInvalid':
      case 'topLoad':
      case 'topLoadedData':
      case 'topLoadedMetadata':
      case 'topLoadStart':
      case 'topPause':
      case 'topPlay':
      case 'topPlaying':
      case 'topProgress':
      case 'topRateChange':
      case 'topReset':
      case 'topSeeked':
      case 'topSeeking':
      case 'topStalled':
      case 'topSubmit':
      case 'topSuspend':
      case 'topTimeUpdate':
      case 'topVolumeChange':
      case 'topWaiting':
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent$6;
        break;
      case 'topKeyPress':
        // Firefox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case 'topKeyDown':
      case 'topKeyUp':
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case 'topBlur':
      case 'topFocus':
        EventConstructor = SyntheticFocusEvent;
        break;
      case 'topClick':
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case 'topDoubleClick':
      case 'topMouseDown':
      case 'topMouseMove':
      case 'topMouseUp':
      // TODO: Disabled elements should not respond to mouse events
      /* falls through */
      case 'topMouseOut':
      case 'topMouseOver':
      case 'topContextMenu':
        EventConstructor = SyntheticMouseEvent$2;
        break;
      case 'topDrag':
      case 'topDragEnd':
      case 'topDragEnter':
      case 'topDragExit':
      case 'topDragLeave':
      case 'topDragOver':
      case 'topDragStart':
      case 'topDrop':
        EventConstructor = SyntheticDragEvent;
        break;
      case 'topTouchCancel':
      case 'topTouchEnd':
      case 'topTouchMove':
      case 'topTouchStart':
        EventConstructor = SyntheticTouchEvent;
        break;
      case 'topAnimationEnd':
      case 'topAnimationIteration':
      case 'topAnimationStart':
        EventConstructor = SyntheticAnimationEvent;
        break;
      case 'topTransitionEnd':
        EventConstructor = SyntheticTransitionEvent;
        break;
      case 'topScroll':
        EventConstructor = SyntheticUIEvent$2;
        break;
      case 'topWheel':
        EventConstructor = SyntheticWheelEvent;
        break;
      case 'topCopy':
      case 'topCut':
      case 'topPaste':
        EventConstructor = SyntheticClipboardEvent;
        break;
    }
    !EventConstructor ? invariant$38(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : void 0;
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    EventPropagators$5.accumulateTwoPhaseDispatches(event);
    return event;
  },

  didPutListener: function (inst, registrationName, listener) {
    // Mobile Safari does not fire properly bubble click events on
    // non-interactive elements, which means delegated click listeners do not
    // fire. The workaround for this bug involves attaching an empty click
    // listener on the target node.
    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
    if (registrationName === 'onClick' && !isInteractive$1(inst._tag)) {
      var key = getDictionaryKey$1(inst);
      var node = ReactDOMComponentTree$18.getNodeFromInstance(inst);
      if (!onClickListeners[key]) {
        onClickListeners[key] = EventListener$2.listen(node, 'click', emptyFunction$11);
      }
    }
  },

  willDeleteListener: function (inst, registrationName) {
    if (registrationName === 'onClick' && !isInteractive$1(inst._tag)) {
      var key = getDictionaryKey$1(inst);
      onClickListeners[key].remove();
      delete onClickListeners[key];
    }
  }

};

var SimpleEventPlugin_1 = SimpleEventPlugin$1;

var ARIADOMPropertyConfig = ARIADOMPropertyConfig_1;
var BeforeInputEventPlugin = BeforeInputEventPlugin_1;
var ChangeEventPlugin = ChangeEventPlugin_1;
var DefaultEventPluginOrder = DefaultEventPluginOrder_1;
var EnterLeaveEventPlugin = EnterLeaveEventPlugin_1;
var HTMLDOMPropertyConfig = HTMLDOMPropertyConfig_1;
var ReactComponentBrowserEnvironment = ReactComponentBrowserEnvironment_1;
var ReactDOMComponent = ReactDOMComponent_1;
var ReactDOMComponentTree$2 = ReactDOMComponentTree_1;
var ReactDOMEmptyComponent = ReactDOMEmptyComponent_1;
var ReactDOMTreeTraversal = ReactDOMTreeTraversal$1;
var ReactDOMTextComponent = ReactDOMTextComponent_1;
var ReactDefaultBatchingStrategy = ReactDefaultBatchingStrategy_1;
var ReactEventListener = ReactEventListener_1;
var ReactInjection = ReactInjection_1;
var ReactReconcileTransaction = ReactReconcileTransaction_1;
var SVGDOMPropertyConfig = SVGDOMPropertyConfig_1;
var SelectEventPlugin = SelectEventPlugin_1;
var SimpleEventPlugin = SimpleEventPlugin_1;

var alreadyInjected = false;

function inject() {
  if (alreadyInjected) {
    // TODO: This is currently true because these injections are shared between
    // the client and the server package. They should be built independently
    // and not share any injection state. Then this problem will be solved.
    return;
  }
  alreadyInjected = true;

  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree$2);
  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);

  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);

  ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
    return new ReactDOMEmptyComponent(instantiate);
  });

  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
}

var ReactDefaultInjection$1 = {
  inject: inject
};

var validateDOMNesting$3 = validateDOMNesting_1;

var DOC_NODE_TYPE$1 = 9;

function ReactDOMContainerInfo$1(topLevelWrapper, node) {
  var info = {
    _topLevelWrapper: topLevelWrapper,
    _idCounter: 1,
    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE$1 ? node : node.ownerDocument : null,
    _node: node,
    _tag: node ? node.nodeName.toLowerCase() : null,
    _namespaceURI: node ? node.namespaceURI : null
  };
  {
    info._ancestorInfo = node ? validateDOMNesting$3.updatedAncestorInfo(null, info._tag, null) : null;
  }
  return info;
}

var ReactDOMContainerInfo_1 = ReactDOMContainerInfo$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

var ReactDOMFeatureFlags$1 = {
  useCreateElement: true,
  useFiber: false
};

var ReactDOMFeatureFlags_1 = ReactDOMFeatureFlags$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

var MOD = 65521;

// adler32 is not cryptographically strong, and is only used to sanity check that
// markup generated on the server matches the markup generated on the client.
// This implementation (a modified version of the SheetJS version) has been optimized
// for our use case, at the expense of conforming to the adler32 specification
// for non-ascii inputs.
function adler32$1(data) {
  var a = 1;
  var b = 0;
  var i = 0;
  var l = data.length;
  var m = l & ~0x3;
  while (i < m) {
    var n = Math.min(i + 4096, m);
    for (; i < n; i += 4) {
      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
    }
    a %= MOD;
    b %= MOD;
  }
  for (; i < l; i++) {
    b += a += data.charCodeAt(i);
  }
  a %= MOD;
  b %= MOD;
  return a | b << 16;
}

var adler32_1 = adler32$1;

var adler32 = adler32_1;

var TAG_END = /\/?>/;
var COMMENT_START = /^<\!\-\-/;

var ReactMarkupChecksum$1 = {
  CHECKSUM_ATTR_NAME: 'data-react-checksum',

  /**
   * @param {string} markup Markup string
   * @return {string} Markup string with checksum attribute attached
   */
  addChecksumToMarkup: function (markup) {
    var checksum = adler32(markup);

    // Add checksum (handle both parent tags, comments and self-closing tags)
    if (COMMENT_START.test(markup)) {
      return markup;
    } else {
      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum$1.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
    }
  },

  /**
   * @param {string} markup to use
   * @param {DOMElement} element root React element
   * @returns {boolean} whether or not the markup is the same
   */
  canReuseMarkup: function (markup, element) {
    var existingChecksum = element.getAttribute(ReactMarkupChecksum$1.CHECKSUM_ATTR_NAME);
    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
    var markupChecksum = adler32(markup);
    return markupChecksum === existingChecksum;
  }
};

var ReactMarkupChecksum_1 = ReactMarkupChecksum$1;

var DOMLazyTree$6 = DOMLazyTree_1;
var DOMProperty$6 = DOMProperty_1;
var React$6 = React_1;
var ReactBrowserEventEmitter$4 = ReactBrowserEventEmitter_1;
var ReactCurrentOwner$9 = ReactCurrentOwner_1;
var ReactDOMComponentTree$19 = ReactDOMComponentTree_1;
var ReactDOMContainerInfo = ReactDOMContainerInfo_1;
var ReactDOMFeatureFlags = ReactDOMFeatureFlags_1;
var ReactFeatureFlags$2 = ReactFeatureFlags_1;
var ReactInstanceMap$4 = ReactInstanceMap_1;
var ReactInstrumentation$13 = ReactInstrumentation$2;
var ReactMarkupChecksum = ReactMarkupChecksum_1;
var ReactReconciler$6 = ReactReconciler_1;
var ReactUpdateQueue$3 = ReactUpdateQueue_1;
var ReactUpdates$10 = ReactUpdates_1;

var emptyObject$5 = emptyObject_1;
var instantiateReactComponent$2 = instantiateReactComponent_1;
var invariant$39 = invariant_1;
var setInnerHTML$4 = setInnerHTML_1;
var shouldUpdateReactComponent$3 = shouldUpdateReactComponent_1;
var warning$36 = warning_1;

var ATTR_NAME$1 = DOMProperty$6.ID_ATTRIBUTE_NAME;
var ROOT_ATTR_NAME = DOMProperty$6.ROOT_ATTRIBUTE_NAME;

var ELEMENT_NODE_TYPE$1 = 1;
var DOC_NODE_TYPE = 9;
var DOCUMENT_FRAGMENT_NODE_TYPE$1 = 11;

var instancesByReactRootID = {};

/**
 * Finds the index of the first character
 * that's not common between the two given strings.
 *
 * @return {number} the index of the character where the strings diverge
 */
function firstDifferenceIndex(string1, string2) {
  var minLen = Math.min(string1.length, string2.length);
  for (var i = 0; i < minLen; i++) {
    if (string1.charAt(i) !== string2.charAt(i)) {
      return i;
    }
  }
  return string1.length === string2.length ? -1 : minLen;
}

/**
 * @param {DOMElement|DOMDocument} container DOM element that may contain
 * a React component
 * @return {?*} DOM element that may have the reactRoot ID, or null.
 */
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function internalGetID(node) {
  // If node is something like a window, document, or text node, none of
  // which support attributes or a .getAttribute method, gracefully return
  // the empty string, as if the attribute were missing.
  return node.getAttribute && node.getAttribute(ATTR_NAME$1) || '';
}

/**
 * Mounts this component and inserts it into the DOM.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {ReactReconcileTransaction} transaction
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
  var markerName;
  if (ReactFeatureFlags$2.logTopLevelRenders) {
    var wrappedElement = wrapperInstance._currentElement.props.child;
    var type = wrappedElement.type;
    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
    console.time(markerName);
  }

  var markup = ReactReconciler$6.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
  );

  if (markerName) {
    console.timeEnd(markerName);
  }

  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
  ReactMount$1._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
}

/**
 * Batched mount.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
  var transaction = ReactUpdates$10.ReactReconcileTransaction.getPooled(
  /* useCreateElement */
  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
  ReactUpdates$10.ReactReconcileTransaction.release(transaction);
}

/**
 * Unmounts a component and removes it from the DOM.
 *
 * @param {ReactComponent} instance React component instance.
 * @param {DOMElement} container DOM element to unmount from.
 * @final
 * @internal
 * @see {ReactMount.unmountComponentAtNode}
 */
function unmountComponentFromNode(instance, container, safely) {
  {
    ReactInstrumentation$13.debugTool.onBeginFlush();
  }
  ReactReconciler$6.unmountComponent(instance, safely);
  {
    ReactInstrumentation$13.debugTool.onEndFlush();
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    container = container.documentElement;
  }

  // http://jsperf.com/emptying-a-node
  while (container.lastChild) {
    container.removeChild(container.lastChild);
  }
}

/**
 * True if the supplied DOM node has a direct React-rendered child that is
 * not a React root element. Useful for warning in `render`,
 * `unmountComponentAtNode`, etc.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM element contains a direct child that was
 * rendered by React but is not a root element.
 * @internal
 */
function hasNonRootReactChild(container) {
  var rootEl = getReactRootElementInContainer(container);
  if (rootEl) {
    var inst = ReactDOMComponentTree$19.getInstanceFromNode(rootEl);
    return !!(inst && inst._hostParent);
  }
}

/**
 * True if the supplied DOM node is a React DOM element and
 * it has been rendered by another copy of React.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM has been rendered by another copy of React
 * @internal
 */
function nodeIsRenderedByOtherInstance(container) {
  var rootEl = getReactRootElementInContainer(container);
  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree$19.getInstanceFromNode(rootEl));
}

/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE$1 || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE$1));
}

/**
 * True if the supplied DOM node is a valid React node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid React DOM node.
 * @internal
 */
function isReactNode(node) {
  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME$1));
}

function getHostRootInstanceInContainer(container) {
  var rootEl = getReactRootElementInContainer(container);
  var prevHostInstance = rootEl && ReactDOMComponentTree$19.getInstanceFromNode(rootEl);
  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
}

function getTopLevelWrapperInContainer(container) {
  var root = getHostRootInstanceInContainer(container);
  return root ? root._hostContainerInfo._topLevelWrapper : null;
}

/**
 * Temporary (?) hack so that we can store all top-level pending updates on
 * composites instead of having to worry about different types of components
 * here.
 */
var topLevelRootCounter = 1;
var TopLevelWrapper = function () {
  this.rootID = topLevelRootCounter++;
};
TopLevelWrapper.prototype.isReactComponent = {};
{
  TopLevelWrapper.displayName = 'TopLevelWrapper';
}
TopLevelWrapper.prototype.render = function () {
  return this.props.child;
};
TopLevelWrapper.isReactTopLevelWrapper = true;

/**
 * Mounting is the process of initializing a React component by creating its
 * representative DOM elements and inserting them into a supplied `container`.
 * Any prior content inside `container` is destroyed in the process.
 *
 *   ReactMount.render(
 *     component,
 *     document.getElementById('container')
 *   );
 *
 *   <div id="container">                   <-- Supplied `container`.
 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
 *       // ...                                 component.
 *     </div>
 *   </div>
 *
 * Inside of `container`, the first element rendered is the "reactRoot".
 */
var ReactMount$1 = {

  TopLevelWrapper: TopLevelWrapper,

  /**
   * Used by devtools. The keys are not important.
   */
  _instancesByReactRootID: instancesByReactRootID,

  /**
   * This is a hook provided to support rendering React components while
   * ensuring that the apparent scroll position of its `container` does not
   * change.
   *
   * @param {DOMElement} container The `container` being rendered into.
   * @param {function} renderCallback This must be called once to do the render.
   */
  scrollMonitor: function (container, renderCallback) {
    renderCallback();
  },

  /**
   * Take a component that's already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactElement} nextElement component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
    ReactMount$1.scrollMonitor(container, function () {
      ReactUpdateQueue$3.enqueueElementInternal(prevComponent, nextElement, nextContext);
      if (callback) {
        ReactUpdateQueue$3.enqueueCallbackInternal(prevComponent, callback);
      }
    });

    return prevComponent;
  },

  /**
   * Render a new component into the DOM. Hooked by hooks!
   *
   * @param {ReactElement} nextElement element to render
   * @param {DOMElement} container container to render into
   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
   * @return {ReactComponent} nextComponent
   */
  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case.
    warning$36(ReactCurrentOwner$9.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner$9.current && ReactCurrentOwner$9.current.getName() || 'ReactCompositeComponent');

    !isValidContainer(container) ? invariant$39(false, '_registerComponent(...): Target container is not a DOM element.') : void 0;

    ReactBrowserEventEmitter$4.ensureScrollValueMonitoring();
    var componentInstance = instantiateReactComponent$2(nextElement, false);

    // The initial render is synchronous but any updates that happen during
    // rendering, in componentWillMount or componentDidMount, will be batched
    // according to the current batching strategy.

    ReactUpdates$10.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);

    var wrapperID = componentInstance._instance.rootID;
    instancesByReactRootID[wrapperID] = componentInstance;

    return componentInstance;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    !(parentComponent != null && ReactInstanceMap$4.has(parentComponent)) ? invariant$39(false, 'parentComponent must be a valid React Component') : void 0;
    return ReactMount$1._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
  },

  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    ReactUpdateQueue$3.validateCallback(callback, 'ReactDOM.render');
    !React$6.isValidElement(nextElement) ? invariant$39(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :
    // Check if it quacks like an element
    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;

    warning$36(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');

    var nextWrappedElement = React$6.createElement(TopLevelWrapper, { child: nextElement });

    var nextContext;
    if (parentComponent) {
      var parentInst = ReactInstanceMap$4.get(parentComponent);
      nextContext = parentInst._processChildContext(parentInst._context);
    } else {
      nextContext = emptyObject$5;
    }

    var prevComponent = getTopLevelWrapperInContainer(container);

    if (prevComponent) {
      var prevWrappedElement = prevComponent._currentElement;
      var prevElement = prevWrappedElement.props.child;
      if (shouldUpdateReactComponent$3(prevElement, nextElement)) {
        var publicInst = prevComponent._renderedComponent.getPublicInstance();
        var updatedCallback = callback && function () {
          callback.call(publicInst);
        };
        ReactMount$1._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
        return publicInst;
      } else {
        ReactMount$1.unmountComponentAtNode(container);
      }
    }

    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    {
      warning$36(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');

      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
        var rootElementSibling = reactRootElement;
        while (rootElementSibling) {
          if (internalGetID(rootElementSibling)) {
            warning$36(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');
            break;
          }
          rootElementSibling = rootElementSibling.nextSibling;
        }
      }
    }

    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
    var component = ReactMount$1._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
    if (callback) {
      callback.call(component);
    }
    return component;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  render: function (nextElement, container, callback) {
    return ReactMount$1._renderSubtreeIntoContainer(null, nextElement, container, callback);
  },

  /**
   * Unmounts and destroys the React component rendered in the `container`.
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
   *
   * @param {DOMElement} container DOM element containing a React component.
   * @return {boolean} True if a component was found in and unmounted from
   *                   `container`
   */
  unmountComponentAtNode: function (container) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case. (Strictly speaking, unmounting won't cause a
    // render but we still don't expect to be in a render call here.)
    warning$36(ReactCurrentOwner$9.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner$9.current && ReactCurrentOwner$9.current.getName() || 'ReactCompositeComponent');

    !isValidContainer(container) ? invariant$39(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;

    {
      warning$36(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.');
    }

    var prevComponent = getTopLevelWrapperInContainer(container);
    if (!prevComponent) {
      // Check if the node being unmounted was rendered by React, but isn't a
      // root node.
      var containerHasNonRootReactChild = hasNonRootReactChild(container);

      // Check if the container itself is a React root node.
      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);

      {
        warning$36(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');
      }

      return false;
    }
    delete instancesByReactRootID[prevComponent._instance.rootID];
    ReactUpdates$10.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
    return true;
  },

  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
    !isValidContainer(container) ? invariant$39(false, 'mountComponentIntoNode(...): Target container is not valid.') : void 0;

    if (shouldReuseMarkup) {
      var rootElement = getReactRootElementInContainer(container);
      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
        ReactDOMComponentTree$19.precacheNode(instance, rootElement);
        return;
      } else {
        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

        var rootMarkup = rootElement.outerHTML;
        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

        var normalizedMarkup = markup;
        {
          // because rootMarkup is retrieved from the DOM, various normalizations
          // will have occurred which will not be present in `markup`. Here,
          // insert markup into a <div> or <iframe> depending on the container
          // type to perform the same normalizations before comparing.
          var normalizer;
          if (container.nodeType === ELEMENT_NODE_TYPE$1) {
            normalizer = document.createElement('div');
            normalizer.innerHTML = markup;
            normalizedMarkup = normalizer.innerHTML;
          } else {
            normalizer = document.createElement('iframe');
            document.body.appendChild(normalizer);
            normalizer.contentDocument.write(markup);
            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
            document.body.removeChild(normalizer);
          }
        }

        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

        !(container.nodeType !== DOC_NODE_TYPE) ? invariant$39(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : void 0;

        {
          warning$36(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference);
        }
      }
    }

    !(container.nodeType !== DOC_NODE_TYPE) ? invariant$39(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : void 0;

    if (transaction.useCreateElement) {
      while (container.lastChild) {
        container.removeChild(container.lastChild);
      }
      DOMLazyTree$6.insertTreeBefore(container, markup, null);
    } else {
      setInnerHTML$4(container, markup);
      ReactDOMComponentTree$19.precacheNode(instance, container.firstChild);
    }

    {
      var hostNode = ReactDOMComponentTree$19.getInstanceFromNode(container.firstChild);
      if (hostNode._debugID !== 0) {
        ReactInstrumentation$13.debugTool.onHostOperation({
          instanceID: hostNode._debugID,
          type: 'mount',
          payload: markup.toString()
        });
      }
    }
  }
};

var ReactMount_1 = ReactMount$1;

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

var ReactVersion$4 = '15.4.1';

var ReactNodeTypes$2 = ReactNodeTypes_1;

function getHostComponentFromComposite$2(inst) {
  var type;

  while ((type = inst._renderedNodeType) === ReactNodeTypes$2.COMPOSITE) {
    inst = inst._renderedComponent;
  }

  if (type === ReactNodeTypes$2.HOST) {
    return inst._renderedComponent;
  } else if (type === ReactNodeTypes$2.EMPTY) {
    return null;
  }
}

var getHostComponentFromComposite_1 = getHostComponentFromComposite$2;

var ReactCurrentOwner$10 = ReactCurrentOwner_1;
var ReactDOMComponentTree$20 = ReactDOMComponentTree_1;
var ReactInstanceMap$5 = ReactInstanceMap_1;

var getHostComponentFromComposite$1 = getHostComponentFromComposite_1;
var invariant$40 = invariant_1;
var warning$37 = warning_1;

/**
 * Returns the DOM node rendered by this element.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
 *
 * @param {ReactComponent|DOMElement} componentOrElement
 * @return {?DOMElement} The root node of this element.
 */
function findDOMNode$1(componentOrElement) {
  {
    var owner = ReactCurrentOwner$10.current;
    if (owner !== null) {
      warning$37(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component');
      owner._warnedAboutRefsInRender = true;
    }
  }
  if (componentOrElement == null) {
    return null;
  }
  if (componentOrElement.nodeType === 1) {
    return componentOrElement;
  }

  var inst = ReactInstanceMap$5.get(componentOrElement);
  if (inst) {
    inst = getHostComponentFromComposite$1(inst);
    return inst ? ReactDOMComponentTree$20.getNodeFromInstance(inst) : null;
  }

  if (typeof componentOrElement.render === 'function') {
    invariant$40(false, 'findDOMNode was called on an unmounted component.');
  } else {
    invariant$40(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement));
  }
}

var findDOMNode_1 = findDOMNode$1;

var ReactMount$2 = ReactMount_1;

var renderSubtreeIntoContainer$1 = ReactMount$2.renderSubtreeIntoContainer;

var DOMProperty$7 = DOMProperty_1;
var EventPluginRegistry$4 = EventPluginRegistry_1;
var ReactComponentTreeHook$7 = ReactComponentTreeHook_1;

var warning$38 = warning_1;

{
  var reactProps = {
    children: true,
    dangerouslySetInnerHTML: true,
    key: true,
    ref: true,

    autoFocus: true,
    defaultValue: true,
    valueLink: true,
    defaultChecked: true,
    checkedLink: true,
    innerHTML: true,
    suppressContentEditableWarning: true,
    onFocusIn: true,
    onFocusOut: true
  };
  var warnedProperties = {};

  var validateProperty = function (tagName, name, debugID) {
    if (DOMProperty$7.properties.hasOwnProperty(name) || DOMProperty$7.isCustomAttribute(name)) {
      return true;
    }
    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
      return true;
    }
    if (EventPluginRegistry$4.registrationNameModules.hasOwnProperty(name)) {
      return true;
    }
    warnedProperties[name] = true;
    var lowerCasedName = name.toLowerCase();

    // data-* attributes should be lowercase; suggest the lowercase version
    var standardName = DOMProperty$7.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty$7.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty$7.getPossibleStandardName[lowerCasedName] : null;

    var registrationName = EventPluginRegistry$4.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry$4.possibleRegistrationNames[lowerCasedName] : null;

    if (standardName != null) {
      warning$38(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook$7.getStackAddendumByID(debugID));
      return true;
    } else if (registrationName != null) {
      warning$38(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook$7.getStackAddendumByID(debugID));
      return true;
    } else {
      // We were unable to guess which prop the user intended.
      // It is likely that the user was just blindly spreading/forwarding props
      // Components should be careful to only render valid props/attributes.
      // Warning will be invoked in warnUnknownProperties to allow grouping.
      return false;
    }
  };
}

var warnUnknownProperties = function (debugID, element) {
  var unknownProps = [];
  for (var key in element.props) {
    var isValid = validateProperty(element.type, key, debugID);
    if (!isValid) {
      unknownProps.push(key);
    }
  }

  var unknownPropString = unknownProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (unknownProps.length === 1) {
    warning$38(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook$7.getStackAddendumByID(debugID));
  } else if (unknownProps.length > 1) {
    warning$38(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook$7.getStackAddendumByID(debugID));
  }
};

function handleElement(debugID, element) {
  if (element == null || typeof element.type !== 'string') {
    return;
  }
  if (element.type.indexOf('-') >= 0 || element.props.is) {
    return;
  }
  warnUnknownProperties(debugID, element);
}

var ReactDOMUnknownPropertyHook$1 = {
  onBeforeMountComponent: function (debugID, element) {
    handleElement(debugID, element);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    handleElement(debugID, element);
  }
};

var ReactDOMUnknownPropertyHook_1 = ReactDOMUnknownPropertyHook$1;

var ReactComponentTreeHook$8 = ReactComponentTreeHook_1;

var warning$39 = warning_1;

var didWarnValueNull = false;

function handleElement$1(debugID, element) {
  if (element == null) {
    return;
  }
  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
    return;
  }
  if (element.props != null && element.props.value === null && !didWarnValueNull) {
    warning$39(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook$8.getStackAddendumByID(debugID));

    didWarnValueNull = true;
  }
}

var ReactDOMNullInputValuePropHook$1 = {
  onBeforeMountComponent: function (debugID, element) {
    handleElement$1(debugID, element);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    handleElement$1(debugID, element);
  }
};

var ReactDOMNullInputValuePropHook_1 = ReactDOMNullInputValuePropHook$1;

var DOMProperty$8 = DOMProperty_1;
var ReactComponentTreeHook$9 = ReactComponentTreeHook_1;

var warning$40 = warning_1;

var warnedProperties$1 = {};
var rARIA = new RegExp('^(aria)-[' + DOMProperty$8.ATTRIBUTE_NAME_CHAR + ']*$');

function validateProperty$1(tagName, name, debugID) {
  if (warnedProperties$1.hasOwnProperty(name) && warnedProperties$1[name]) {
    return true;
  }

  if (rARIA.test(name)) {
    var lowerCasedName = name.toLowerCase();
    var standardName = DOMProperty$8.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty$8.getPossibleStandardName[lowerCasedName] : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (standardName == null) {
      warnedProperties$1[name] = true;
      return false;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== standardName) {
      warning$40(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook$9.getStackAddendumByID(debugID));
      warnedProperties$1[name] = true;
      return true;
    }
  }

  return true;
}

function warnInvalidARIAProps(debugID, element) {
  var invalidProps = [];

  for (var key in element.props) {
    var isValid = validateProperty$1(element.type, key, debugID);
    if (!isValid) {
      invalidProps.push(key);
    }
  }

  var unknownPropString = invalidProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (invalidProps.length === 1) {
    warning$40(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook$9.getStackAddendumByID(debugID));
  } else if (invalidProps.length > 1) {
    warning$40(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook$9.getStackAddendumByID(debugID));
  }
}

function handleElement$2(debugID, element) {
  if (element == null || typeof element.type !== 'string') {
    return;
  }
  if (element.type.indexOf('-') >= 0 || element.props.is) {
    return;
  }

  warnInvalidARIAProps(debugID, element);
}

var ReactDOMInvalidARIAHook$1 = {
  onBeforeMountComponent: function (debugID, element) {
    {
      handleElement$2(debugID, element);
    }
  },
  onBeforeUpdateComponent: function (debugID, element) {
    {
      handleElement$2(debugID, element);
    }
  }
};

var ReactDOMInvalidARIAHook_1 = ReactDOMInvalidARIAHook$1;

var ReactDOMComponentTree = ReactDOMComponentTree_1;
var ReactDefaultInjection = ReactDefaultInjection$1;
var ReactMount = ReactMount_1;
var ReactReconciler = ReactReconciler_1;
var ReactUpdates = ReactUpdates_1;
var ReactVersion$3 = ReactVersion$4;

var findDOMNode = findDOMNode_1;
var getHostComponentFromComposite = getHostComponentFromComposite_1;
var renderSubtreeIntoContainer = renderSubtreeIntoContainer$1;
var warning$11 = warning_1;

ReactDefaultInjection.inject();

var ReactDOM$1 = {
  findDOMNode: findDOMNode,
  render: ReactMount.render,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
  version: ReactVersion$3,

  /* eslint-disable camelcase */
  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
};

// Inject the runtime into a devtools global hook regardless of browser.
// Allows for debugging when the hook is injected on the page.
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
    ComponentTree: {
      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
      getNodeFromInstance: function (inst) {
        // inst is an internal instance (but could be a composite)
        if (inst._renderedComponent) {
          inst = getHostComponentFromComposite(inst);
        }
        if (inst) {
          return ReactDOMComponentTree.getNodeFromInstance(inst);
        } else {
          return null;
        }
      }
    },
    Mount: ReactMount,
    Reconciler: ReactReconciler
  });
}

{
  var ExecutionEnvironment = ExecutionEnvironment_1;
  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {

    // First check if devtools is not installed
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
      // If we're in Chrome or Firefox, provide a download link if not installed.
      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
        // Firefox does not have the issue with devtools loaded over file://
        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
      }
    }

    var testFunc = function testFn() {};
    warning$11((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.');

    // If we're in IE8, check to see if we are in compatibility mode and provide
    // information on preventing compatibility mode
    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

    warning$11(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />');

    var expectedFeatures = [
    // shims
    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim];

    for (var i = 0; i < expectedFeatures.length; i++) {
      if (!expectedFeatures[i]) {
        warning$11(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
        break;
      }
    }
  }
}

{
  var ReactInstrumentation = ReactInstrumentation$2;
  var ReactDOMUnknownPropertyHook = ReactDOMUnknownPropertyHook_1;
  var ReactDOMNullInputValuePropHook = ReactDOMNullInputValuePropHook_1;
  var ReactDOMInvalidARIAHook = ReactDOMInvalidARIAHook_1;

  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
  ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
}

var ReactDOM_1 = ReactDOM$1;

var index$3 = ReactDOM_1;

var _isPlaceholder$2 = function _isPlaceholder$2(a) {
  return a != null &&
         typeof a === 'object' &&
         a['@@functional/placeholder'] === true;
};

var _isPlaceholder$1 = _isPlaceholder$2;


/**
 * Optimized internal one-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
var _curry1$1 = function _curry1$1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder$1(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
};

var _curry1 = _curry1$1;
var _isPlaceholder = _isPlaceholder$2;


/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
var _curry2$1 = function _curry2$1(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;
      case 1:
        return _isPlaceholder(a) ? f2
             : _curry1(function(_b) { return fn(a, _b); });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f2
             : _isPlaceholder(a) ? _curry1(function(_a) { return fn(_a, b); })
             : _isPlaceholder(b) ? _curry1(function(_b) { return fn(a, _b); })
             : fn(a, b);
    }
  };
};

/**
 * An optimized, private array `slice` implementation.
 *
 * @private
 * @param {Arguments|Array} args The array or arguments object to consider.
 * @param {Number} [from=0] The array index to slice from, inclusive.
 * @param {Number} [to=args.length] The array index to slice to, exclusive.
 * @return {Array} A new, sliced array.
 * @example
 *
 *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
 *
 *      var firstThreeArgs = function(a, b, c, d) {
 *        return _slice(arguments, 0, 3);
 *      };
 *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
 */
var _slice$1 = function _slice$1(args, from, to) {
  switch (arguments.length) {
    case 1: return _slice$1(args, 0, args.length);
    case 2: return _slice$1(args, from, args.length);
    default:
      var list = [];
      var idx = 0;
      var len = Math.max(0, Math.min(args.length, to) - from);
      while (idx < len) {
        list[idx] = args[from + idx];
        idx += 1;
      }
      return list;
  }
};

var _curry2 = _curry2$1;
var _slice = _slice$1;


/**
 * Sorts the list according to the supplied function.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord b => (a -> b) -> [a] -> [a]
 * @param {Function} fn
 * @param {Array} list The list to sort.
 * @return {Array} A new list sorted by the keys generated by `fn`.
 * @example
 *
 *      var sortByFirstItem = R.sortBy(R.prop(0));
 *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
 *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
 *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
 *      var alice = {
 *        name: 'ALICE',
 *        age: 101
 *      };
 *      var bob = {
 *        name: 'Bob',
 *        age: -10
 *      };
 *      var clara = {
 *        name: 'clara',
 *        age: 314.159
 *      };
 *      var people = [clara, bob, alice];
 *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
 */
var sortBy = _curry2(function sortBy(fn, list) {
  return _slice(list).sort(function(a, b) {
    var aa = fn(a);
    var bb = fn(b);
    return aa < bb ? -1 : aa > bb ? 1 : 0;
  });
});

/**
 * Tests whether or not an object is an array.
 *
 * @private
 * @param {*} val The object to test.
 * @return {Boolean} `true` if `val` is an array, `false` otherwise.
 * @example
 *
 *      _isArray([]); //=> true
 *      _isArray(null); //=> false
 *      _isArray({}); //=> false
 */
var _isArray$1 = Array.isArray || function _isArray$1(val) {
  return (val != null &&
          val.length >= 0 &&
          Object.prototype.toString.call(val) === '[object Array]');
};

var _isTransformer$1 = function _isTransformer$1(obj) {
  return typeof obj['@@transducer/step'] === 'function';
};

var _isArray = _isArray$1;
var _isTransformer = _isTransformer$1;
var _slice$3 = _slice$1;


/**
 * Returns a function that dispatches with different strategies based on the
 * object in list position (last argument). If it is an array, executes [fn].
 * Otherwise, if it has a function with [methodname], it will execute that
 * function (functor case). Otherwise, if it is a transformer, uses transducer
 * [xf] to return a new transformer (transducer case). Otherwise, it will
 * default to executing [fn].
 *
 * @private
 * @param {String} methodname property to check for a custom implementation
 * @param {Function} xf transducer to initialize if object is transformer
 * @param {Function} fn default ramda implementation
 * @return {Function} A function that dispatches on object in list position
 */
var _dispatchable$1 = function _dispatchable$1(methodname, xf, fn) {
  return function() {
    var length = arguments.length;
    if (length === 0) {
      return fn();
    }
    var obj = arguments[length - 1];
    if (!_isArray(obj)) {
      var args = _slice$3(arguments, 0, length - 1);
      if (typeof obj[methodname] === 'function') {
        return obj[methodname].apply(obj, args);
      }
      if (_isTransformer(obj)) {
        var transducer = xf.apply(null, args);
        return transducer(obj);
      }
    }
    return fn.apply(this, arguments);
  };
};

var _filter$1 = function _filter$1(fn, list) {
  var idx = 0;
  var len = list.length;
  var result = [];

  while (idx < len) {
    if (fn(list[idx])) {
      result[result.length] = list[idx];
    }
    idx += 1;
  }
  return result;
};

var _isObject$1 = function _isObject$1(x) {
  return Object.prototype.toString.call(x) === '[object Object]';
};

var _xwrap$1 = (function() {
  function XWrap(fn) {
    this.f = fn;
  }
  XWrap.prototype['@@transducer/init'] = function() {
    throw new Error('init not implemented on XWrap');
  };
  XWrap.prototype['@@transducer/result'] = function(acc) { return acc; };
  XWrap.prototype['@@transducer/step'] = function(acc, x) {
    return this.f(acc, x);
  };

  return function _xwrap$1(fn) { return new XWrap(fn); };
}());

var _arity$1 = function _arity$1(n, fn) {
  /* eslint-disable no-unused-vars */
  switch (n) {
    case 0: return function() { return fn.apply(this, arguments); };
    case 1: return function(a0) { return fn.apply(this, arguments); };
    case 2: return function(a0, a1) { return fn.apply(this, arguments); };
    case 3: return function(a0, a1, a2) { return fn.apply(this, arguments); };
    case 4: return function(a0, a1, a2, a3) { return fn.apply(this, arguments); };
    case 5: return function(a0, a1, a2, a3, a4) { return fn.apply(this, arguments); };
    case 6: return function(a0, a1, a2, a3, a4, a5) { return fn.apply(this, arguments); };
    case 7: return function(a0, a1, a2, a3, a4, a5, a6) { return fn.apply(this, arguments); };
    case 8: return function(a0, a1, a2, a3, a4, a5, a6, a7) { return fn.apply(this, arguments); };
    case 9: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) { return fn.apply(this, arguments); };
    case 10: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) { return fn.apply(this, arguments); };
    default: throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
  }
};

var _arity = _arity$1;
var _curry2$4 = _curry2$1;


/**
 * Creates a function that is bound to a context.
 * Note: `R.bind` does not provide the additional argument-binding capabilities of
 * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Function
 * @category Object
 * @sig (* -> *) -> {*} -> (* -> *)
 * @param {Function} fn The function to bind to context
 * @param {Object} thisObj The context to bind `fn` to
 * @return {Function} A function that will execute in the context of `thisObj`.
 * @see R.partial
 * @example
 *
 *      var log = R.bind(console.log, console);
 *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
 *      // logs {a: 2}
 */
var bind$1 = _curry2$4(function bind$1(fn, thisObj) {
  return _arity(fn.length, function() {
    return fn.apply(thisObj, arguments);
  });
});

var _isString$1 = function _isString$1(x) {
  return Object.prototype.toString.call(x) === '[object String]';
};

var _curry1$3 = _curry1$1;
var _isArray$3 = _isArray$1;
var _isString = _isString$1;


/**
 * Tests whether or not an object is similar to an array.
 *
 * @func
 * @memberOf R
 * @since v0.5.0
 * @category Type
 * @category List
 * @sig * -> Boolean
 * @param {*} x The object to test.
 * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
 * @example
 *
 *      R.isArrayLike([]); //=> true
 *      R.isArrayLike(true); //=> false
 *      R.isArrayLike({}); //=> false
 *      R.isArrayLike({length: 10}); //=> false
 *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
 */
var isArrayLike$1 = _curry1$3(function isArrayLike$1(x) {
  if (_isArray$3(x)) { return true; }
  if (!x) { return false; }
  if (typeof x !== 'object') { return false; }
  if (_isString(x)) { return false; }
  if (x.nodeType === 1) { return !!x.length; }
  if (x.length === 0) { return true; }
  if (x.length > 0) {
    return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
  }
  return false;
});

var _xwrap = _xwrap$1;
var bind = bind$1;
var isArrayLike = isArrayLike$1;


var _reduce$1 = (function() {
  function _arrayReduce(xf, acc, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      acc = xf['@@transducer/step'](acc, list[idx]);
      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }
      idx += 1;
    }
    return xf['@@transducer/result'](acc);
  }

  function _iterableReduce(xf, acc, iter) {
    var step = iter.next();
    while (!step.done) {
      acc = xf['@@transducer/step'](acc, step.value);
      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }
      step = iter.next();
    }
    return xf['@@transducer/result'](acc);
  }

  function _methodReduce(xf, acc, obj) {
    return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
  }

  var symIterator = (typeof Symbol !== 'undefined') ? Symbol.iterator : '@@iterator';
  return function _reduce$1(fn, acc, list) {
    if (typeof fn === 'function') {
      fn = _xwrap(fn);
    }
    if (isArrayLike(list)) {
      return _arrayReduce(fn, acc, list);
    }
    if (typeof list.reduce === 'function') {
      return _methodReduce(fn, acc, list);
    }
    if (list[symIterator] != null) {
      return _iterableReduce(fn, acc, list[symIterator]());
    }
    if (typeof list.next === 'function') {
      return _iterableReduce(fn, acc, list);
    }
    throw new TypeError('reduce: list must be array or iterable');
  };
}());

var _xfBase$1 = {
  init: function() {
    return this.xf['@@transducer/init']();
  },
  result: function(result) {
    return this.xf['@@transducer/result'](result);
  }
};

var _curry2$5 = _curry2$1;
var _xfBase = _xfBase$1;


var _xfilter$1 = (function() {
  function XFilter(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XFilter.prototype['@@transducer/init'] = _xfBase.init;
  XFilter.prototype['@@transducer/result'] = _xfBase.result;
  XFilter.prototype['@@transducer/step'] = function(result, input) {
    return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
  };

  return _curry2$5(function _xfilter$1(f, xf) { return new XFilter(f, xf); });
}());

var _has$1 = function _has$1(prop, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};

var _has$3 = _has$1;


var _isArguments$1 = (function() {
  var toString = Object.prototype.toString;
  return toString.call(arguments) === '[object Arguments]' ?
    function _isArguments$1(x) { return toString.call(x) === '[object Arguments]'; } :
    function _isArguments$1(x) { return _has$3('callee', x); };
}());

var _curry1$4 = _curry1$1;
var _has = _has$1;
var _isArguments = _isArguments$1;


/**
 * Returns a list containing the names of all the enumerable own properties of
 * the supplied object.
 * Note that the order of the output array is not guaranteed to be consistent
 * across different JS platforms.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig {k: v} -> [k]
 * @param {Object} obj The object to extract properties from
 * @return {Array} An array of the object's own properties.
 * @example
 *
 *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
 */
var keys$1 = (function() {
  // cover IE < 9 keys issues
  var hasEnumBug = !({toString: null}).propertyIsEnumerable('toString');
  var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString',
                            'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
  // Safari bug
  var hasArgsEnumBug = (function() {
    'use strict';
    return arguments.propertyIsEnumerable('length');
  }());

  var contains = function contains(list, item) {
    var idx = 0;
    while (idx < list.length) {
      if (list[idx] === item) {
        return true;
      }
      idx += 1;
    }
    return false;
  };

  return typeof Object.keys === 'function' && !hasArgsEnumBug ?
    _curry1$4(function keys$1(obj) {
      return Object(obj) !== obj ? [] : Object.keys(obj);
    }) :
    _curry1$4(function keys$1(obj) {
      if (Object(obj) !== obj) {
        return [];
      }
      var prop, nIdx;
      var ks = [];
      var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
      for (prop in obj) {
        if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
          ks[ks.length] = prop;
        }
      }
      if (hasEnumBug) {
        nIdx = nonEnumerableProps.length - 1;
        while (nIdx >= 0) {
          prop = nonEnumerableProps[nIdx];
          if (_has(prop, obj) && !contains(ks, prop)) {
            ks[ks.length] = prop;
          }
          nIdx -= 1;
        }
      }
      return ks;
    });
}());

var _curry2$3 = _curry2$1;
var _dispatchable = _dispatchable$1;
var _filter = _filter$1;
var _isObject = _isObject$1;
var _reduce = _reduce$1;
var _xfilter = _xfilter$1;
var keys = keys$1;


/**
 * Takes a predicate and a "filterable", and returns a new filterable of the
 * same type containing the members of the given filterable which satisfy the
 * given predicate.
 *
 * Dispatches to the `filter` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> f a
 * @param {Function} pred
 * @param {Array} filterable
 * @return {Array}
 * @see R.reject, R.transduce, R.addIndex
 * @example
 *
 *      var isEven = n => n % 2 === 0;
 *
 *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
 *
 *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
 */
var filter = _curry2$3(_dispatchable('filter', _xfilter, function(pred, filterable) {
  return (
    _isObject(filterable) ?
      _reduce(function(acc, key) {
        if (pred(filterable[key])) {
          acc[key] = filterable[key];
        }
        return acc;
      }, {}, keys(filterable)) :
    // else
      _filter(pred, filterable)
  );
}));

var _curry2$6 = _curry2$1;


/**
 * Returns a function that when supplied an object returns the indicated
 * property of that object, if it exists.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Object
 * @sig s -> {s: a} -> a | Undefined
 * @param {String} p The property name
 * @param {Object} obj The object to query
 * @return {*} The value at `obj.p`.
 * @see R.path
 * @example
 *
 *      R.prop('x', {x: 100}); //=> 100
 *      R.prop('x', {}); //=> undefined
 */
var prop = _curry2$6(function prop(p, obj) { return obj[p]; });

var _map$1 = function _map$1(fn, functor) {
  var idx = 0;
  var len = functor.length;
  var result = Array(len);
  while (idx < len) {
    result[idx] = fn(functor[idx]);
    idx += 1;
  }
  return result;
};

var _curry2$8 = _curry2$1;
var _xfBase$3 = _xfBase$1;


var _xmap$1 = (function() {
  function XMap(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XMap.prototype['@@transducer/init'] = _xfBase$3.init;
  XMap.prototype['@@transducer/result'] = _xfBase$3.result;
  XMap.prototype['@@transducer/step'] = function(result, input) {
    return this.xf['@@transducer/step'](result, this.f(input));
  };

  return _curry2$8(function _xmap$1(f, xf) { return new XMap(f, xf); });
}());

var _arity$4 = _arity$1;
var _isPlaceholder$4 = _isPlaceholder$2;


/**
 * Internal curryN function.
 *
 * @private
 * @category Function
 * @param {Number} length The arity of the curried function.
 * @param {Array} received An array of arguments received thus far.
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
var _curryN$1 = function _curryN$1(length, received, fn) {
  return function() {
    var combined = [];
    var argsIdx = 0;
    var left = length;
    var combinedIdx = 0;
    while (combinedIdx < received.length || argsIdx < arguments.length) {
      var result;
      if (combinedIdx < received.length &&
          (!_isPlaceholder$4(received[combinedIdx]) ||
           argsIdx >= arguments.length)) {
        result = received[combinedIdx];
      } else {
        result = arguments[argsIdx];
        argsIdx += 1;
      }
      combined[combinedIdx] = result;
      if (!_isPlaceholder$4(result)) {
        left -= 1;
      }
      combinedIdx += 1;
    }
    return left <= 0 ? fn.apply(this, combined)
                     : _arity$4(left, _curryN$1(length, combined, fn));
  };
};

var _arity$3 = _arity$1;
var _curry1$5 = _curry1$1;
var _curry2$9 = _curry2$1;
var _curryN = _curryN$1;


/**
 * Returns a curried equivalent of the provided function, with the specified
 * arity. The curried function has two unusual capabilities. First, its
 * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value `R.__` may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is `R.__`, the
 * following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.5.0
 * @category Function
 * @sig Number -> (* -> a) -> (* -> a)
 * @param {Number} length The arity for the returned function.
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curry
 * @example
 *
 *      var sumArgs = (...args) => R.sum(args);
 *
 *      var curriedAddFourNumbers = R.curryN(4, sumArgs);
 *      var f = curriedAddFourNumbers(1, 2);
 *      var g = f(3);
 *      g(4); //=> 10
 */
var curryN$1 = _curry2$9(function curryN$1(length, fn) {
  if (length === 1) {
    return _curry1$5(fn);
  }
  return _arity$3(length, _curryN(length, [], fn));
});

var _curry2$7 = _curry2$1;
var _dispatchable$3 = _dispatchable$1;
var _map = _map$1;
var _reduce$3 = _reduce$1;
var _xmap = _xmap$1;
var curryN = curryN$1;
var keys$3 = keys$1;


/**
 * Takes a function and
 * a [functor](https://github.com/fantasyland/fantasy-land#functor),
 * applies the function to each of the functor's values, and returns
 * a functor of the same shape.
 *
 * Ramda provides suitable `map` implementations for `Array` and `Object`,
 * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
 *
 * Dispatches to the `map` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * Also treats functions as functors and will compose them together.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Functor f => (a -> b) -> f a -> f b
 * @param {Function} fn The function to be called on every element of the input `list`.
 * @param {Array} list The list to be iterated over.
 * @return {Array} The new list.
 * @see R.transduce, R.addIndex
 * @example
 *
 *      var double = x => x * 2;
 *
 *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
 *
 *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
 */
var map$1 = _curry2$7(_dispatchable$3('map', _xmap, function map$1(fn, functor) {
  switch (Object.prototype.toString.call(functor)) {
    case '[object Function]':
      return curryN(functor.length, function() {
        return fn.call(this, functor.apply(this, arguments));
      });
    case '[object Object]':
      return _reduce$3(function(acc, key) {
        acc[key] = fn(functor[key]);
        return acc;
      }, {}, keys$3(functor));
    default:
      return _map(fn, functor);
  }
}));

var _curry1$6 = _curry1$1;
var _curry2$10 = _curry2$1;
var _isPlaceholder$5 = _isPlaceholder$2;


/**
 * Optimized internal three-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
var _curry3$1 = function _curry3$1(fn) {
  return function f3(a, b, c) {
    switch (arguments.length) {
      case 0:
        return f3;
      case 1:
        return _isPlaceholder$5(a) ? f3
             : _curry2$10(function(_b, _c) { return fn(a, _b, _c); });
      case 2:
        return _isPlaceholder$5(a) && _isPlaceholder$5(b) ? f3
             : _isPlaceholder$5(a) ? _curry2$10(function(_a, _c) { return fn(_a, b, _c); })
             : _isPlaceholder$5(b) ? _curry2$10(function(_b, _c) { return fn(a, _b, _c); })
             : _curry1$6(function(_c) { return fn(a, b, _c); });
      default:
        return _isPlaceholder$5(a) && _isPlaceholder$5(b) && _isPlaceholder$5(c) ? f3
             : _isPlaceholder$5(a) && _isPlaceholder$5(b) ? _curry2$10(function(_a, _b) { return fn(_a, _b, c); })
             : _isPlaceholder$5(a) && _isPlaceholder$5(c) ? _curry2$10(function(_a, _c) { return fn(_a, b, _c); })
             : _isPlaceholder$5(b) && _isPlaceholder$5(c) ? _curry2$10(function(_b, _c) { return fn(a, _b, _c); })
             : _isPlaceholder$5(a) ? _curry1$6(function(_a) { return fn(_a, b, c); })
             : _isPlaceholder$5(b) ? _curry1$6(function(_b) { return fn(a, _b, c); })
             : _isPlaceholder$5(c) ? _curry1$6(function(_c) { return fn(a, b, _c); })
             : fn(a, b, c);
    }
  };
};

var _arrayFromIterator$1 = function _arrayFromIterator$1(iter) {
  var list = [];
  var next;
  while (!(next = iter.next()).done) {
    list.push(next.value);
  }
  return list;
};

var _functionName$1 = function _functionName$1(f) {
  // String(x => x) evaluates to "x => x", so the pattern may not match.
  var match = String(f).match(/^function (\w*)/);
  return match == null ? '' : match[1];
};

var _curry2$12 = _curry2$1;


/**
 * Returns true if its arguments are identical, false otherwise. Values are
 * identical if they reference the same memory. `NaN` is identical to `NaN`;
 * `0` and `-0` are not identical.
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Relation
 * @sig a -> a -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      var o = {};
 *      R.identical(o, o); //=> true
 *      R.identical(1, 1); //=> true
 *      R.identical(1, '1'); //=> false
 *      R.identical([], []); //=> false
 *      R.identical(0, -0); //=> false
 *      R.identical(NaN, NaN); //=> true
 */
var identical$1 = _curry2$12(function identical$1(a, b) {
  // SameValue algorithm
  if (a === b) { // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return a !== 0 || 1 / a === 1 / b;
  } else {
    // Step 6.a: NaN == NaN
    return a !== a && b !== b;
  }
});

var _curry1$7 = _curry1$1;


/**
 * Gives a single-word string description of the (native) type of a value,
 * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
 * attempt to distinguish user Object types any further, reporting them all as
 * 'Object'.
 *
 * @func
 * @memberOf R
 * @since v0.8.0
 * @category Type
 * @sig (* -> {*}) -> String
 * @param {*} val The value to test
 * @return {String}
 * @example
 *
 *      R.type({}); //=> "Object"
 *      R.type(1); //=> "Number"
 *      R.type(false); //=> "Boolean"
 *      R.type('s'); //=> "String"
 *      R.type(null); //=> "Null"
 *      R.type([]); //=> "Array"
 *      R.type(/[A-z]/); //=> "RegExp"
 */
var type$1 = _curry1$7(function type$1(val) {
  return val === null      ? 'Null'      :
         val === undefined ? 'Undefined' :
         Object.prototype.toString.call(val).slice(8, -1);
});

var _arrayFromIterator = _arrayFromIterator$1;
var _functionName = _functionName$1;
var _has$4 = _has$1;
var identical = identical$1;
var keys$4 = keys$1;
var type = type$1;


var _equals$1 = function _equals$1(a, b, stackA, stackB) {
  if (identical(a, b)) {
    return true;
  }

  if (type(a) !== type(b)) {
    return false;
  }

  if (a == null || b == null) {
    return false;
  }

  if (typeof a.equals === 'function' || typeof b.equals === 'function') {
    return typeof a.equals === 'function' && a.equals(b) &&
           typeof b.equals === 'function' && b.equals(a);
  }

  switch (type(a)) {
    case 'Arguments':
    case 'Array':
    case 'Object':
      if (typeof a.constructor === 'function' &&
          _functionName(a.constructor) === 'Promise') {
        return a === b;
      }
      break;
    case 'Boolean':
    case 'Number':
    case 'String':
      if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
        return false;
      }
      break;
    case 'Date':
      if (!identical(a.valueOf(), b.valueOf())) {
        return false;
      }
      break;
    case 'Error':
      return a.name === b.name && a.message === b.message;
    case 'RegExp':
      if (!(a.source === b.source &&
            a.global === b.global &&
            a.ignoreCase === b.ignoreCase &&
            a.multiline === b.multiline &&
            a.sticky === b.sticky &&
            a.unicode === b.unicode)) {
        return false;
      }
      break;
    case 'Map':
    case 'Set':
      if (!_equals$1(_arrayFromIterator(a.entries()), _arrayFromIterator(b.entries()), stackA, stackB)) {
        return false;
      }
      break;
    case 'Int8Array':
    case 'Uint8Array':
    case 'Uint8ClampedArray':
    case 'Int16Array':
    case 'Uint16Array':
    case 'Int32Array':
    case 'Uint32Array':
    case 'Float32Array':
    case 'Float64Array':
      break;
    case 'ArrayBuffer':
      break;
    default:
      // Values of other types are only equal if identical.
      return false;
  }

  var keysA = keys$4(a);
  if (keysA.length !== keys$4(b).length) {
    return false;
  }

  var idx = stackA.length - 1;
  while (idx >= 0) {
    if (stackA[idx] === a) {
      return stackB[idx] === b;
    }
    idx -= 1;
  }

  stackA.push(a);
  stackB.push(b);
  idx = keysA.length - 1;
  while (idx >= 0) {
    var key = keysA[idx];
    if (!(_has$4(key, b) && _equals$1(b[key], a[key], stackA, stackB))) {
      return false;
    }
    idx -= 1;
  }
  stackA.pop();
  stackB.pop();
  return true;
};

var _curry2$11 = _curry2$1;
var _equals = _equals$1;


/**
 * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
 * cyclical data structures.
 *
 * Dispatches symmetrically to the `equals` methods of both arguments, if
 * present.
 *
 * @func
 * @memberOf R
 * @since v0.15.0
 * @category Relation
 * @sig a -> b -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      R.equals(1, 1); //=> true
 *      R.equals(1, '1'); //=> false
 *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
 *
 *      var a = {}; a.v = a;
 *      var b = {}; b.v = b;
 *      R.equals(a, b); //=> true
 */
var equals$1 = _curry2$11(function equals$1(a, b) {
  return _equals(a, b, [], []);
});

var _curry3 = _curry3$1;
var equals = equals$1;


/**
 * Returns `true` if the specified object property is equal, in `R.equals`
 * terms, to the given value; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig String -> a -> Object -> Boolean
 * @param {String} name
 * @param {*} val
 * @param {*} obj
 * @return {Boolean}
 * @see R.equals, R.propSatisfies
 * @example
 *
 *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
 *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
 *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
 *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
 *      var kids = [abby, fred, rusty, alois];
 *      var hasBrownHair = R.propEq('hair', 'brown');
 *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
 */
var propEq$1 = _curry3(function propEq$1(name, val, obj) {
  return equals(val, obj[name]);
});

var _reduced$1 = function _reduced$1(x) {
  return x && x['@@transducer/reduced'] ? x :
    {
      '@@transducer/value': x,
      '@@transducer/reduced': true
    };
};

var _curry2$14 = _curry2$1;
var _reduced = _reduced$1;
var _xfBase$4 = _xfBase$1;


var _xfind$1 = (function() {
  function XFind(f, xf) {
    this.xf = xf;
    this.f = f;
    this.found = false;
  }
  XFind.prototype['@@transducer/init'] = _xfBase$4.init;
  XFind.prototype['@@transducer/result'] = function(result) {
    if (!this.found) {
      result = this.xf['@@transducer/step'](result, void 0);
    }
    return this.xf['@@transducer/result'](result);
  };
  XFind.prototype['@@transducer/step'] = function(result, input) {
    if (this.f(input)) {
      this.found = true;
      result = _reduced(this.xf['@@transducer/step'](result, input));
    }
    return result;
  };

  return _curry2$14(function _xfind$1(f, xf) { return new XFind(f, xf); });
}());

var _curry2$13 = _curry2$1;
var _dispatchable$4 = _dispatchable$1;
var _xfind = _xfind$1;


/**
 * Returns the first element of the list which matches the predicate, or
 * `undefined` if no element matches.
 *
 * Dispatches to the `find` method of the second argument, if present.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig (a -> Boolean) -> [a] -> a | undefined
 * @param {Function} fn The predicate function used to determine if the element is the
 *        desired one.
 * @param {Array} list The array to consider.
 * @return {Object} The element found, or `undefined`.
 * @see R.transduce
 * @example
 *
 *      var xs = [{a: 1}, {a: 2}, {a: 3}];
 *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
 *      R.find(R.propEq('a', 4))(xs); //=> undefined
 */
var find = _curry2$13(_dispatchable$4('find', _xfind, function find(fn, list) {
  var idx = 0;
  var len = list.length;
  while (idx < len) {
    if (fn(list[idx])) {
      return list[idx];
    }
    idx += 1;
  }
}));

var _curry3$3 = _curry3$1;
var _has$5 = _has$1;


/**
 * If the given, non-null object has an own property with the specified name,
 * returns the value of that property. Otherwise returns the provided default
 * value.
 *
 * @func
 * @memberOf R
 * @since v0.6.0
 * @category Object
 * @sig a -> String -> Object -> a
 * @param {*} val The default value.
 * @param {String} p The name of the property to return.
 * @param {Object} obj The object to query.
 * @return {*} The value of given property of the supplied object or the default value.
 * @example
 *
 *      var alice = {
 *        name: 'ALICE',
 *        age: 101
 *      };
 *      var favorite = R.prop('favoriteLibrary');
 *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
 *
 *      favorite(alice);  //=> undefined
 *      favoriteWithDefault(alice);  //=> 'Ramda'
 */
var propOr$1 = _curry3$3(function propOr$1(val, p, obj) {
  return (obj != null && _has$5(p, obj)) ? obj[p] : val;
});

var _pipe$1 = function _pipe$1(f, g) {
  return function() {
    return g.call(this, f.apply(this, arguments));
  };
};

var _curry3$4 = _curry3$1;
var _reduce$4 = _reduce$1;


/**
 * Returns a single item by iterating through the list, successively calling
 * the iterator function and passing it an accumulator value and the current
 * value from the array, and then passing the result to the next call.
 *
 * The iterator function receives two values: *(acc, value)*. It may use
 * `R.reduced` to shortcut the iteration.
 *
 * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
 * arrays), unlike the native `Array.prototype.reduce` method. For more details
 * on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
 *
 * Dispatches to the `reduce` method of the third argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig ((a, b) -> a) -> a -> [b] -> a
 * @param {Function} fn The iterator function. Receives two values, the accumulator and the
 *        current element from the array.
 * @param {*} acc The accumulator value.
 * @param {Array} list The list to iterate over.
 * @return {*} The final, accumulated value.
 * @see R.reduced, R.addIndex
 * @example
 *
 *      var numbers = [1, 2, 3];
 *      var plus = (a, b) => a + b;
 *
 *      R.reduce(plus, 10, numbers); //=> 16
 */
var reduce$1 = _curry3$4(_reduce$4);

var _isArray$4 = _isArray$1;
var _slice$4 = _slice$1;


/**
 * Similar to hasMethod, this checks whether a function has a [methodname]
 * function. If it isn't an array it will execute that function otherwise it
 * will default to the ramda implementation.
 *
 * @private
 * @param {Function} fn ramda implemtation
 * @param {String} methodname property to check for a custom implementation
 * @return {Object} Whatever the return value of the method is.
 */
var _checkForMethod$1 = function _checkForMethod$1(methodname, fn) {
  return function() {
    var length = arguments.length;
    if (length === 0) {
      return fn();
    }
    var obj = arguments[length - 1];
    return (_isArray$4(obj) || typeof obj[methodname] !== 'function') ?
      fn.apply(this, arguments) :
      obj[methodname].apply(obj, _slice$4(arguments, 0, length - 1));
  };
};

var _checkForMethod$3 = _checkForMethod$1;
var _curry3$5 = _curry3$1;


/**
 * Returns the elements of the given list or string (or object with a `slice`
 * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
 *
 * Dispatches to the `slice` method of the third argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.4
 * @category List
 * @sig Number -> Number -> [a] -> [a]
 * @sig Number -> Number -> String -> String
 * @param {Number} fromIndex The start index (inclusive).
 * @param {Number} toIndex The end index (exclusive).
 * @param {*} list
 * @return {*}
 * @example
 *
 *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
 *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
 *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
 *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
 *      R.slice(0, 3, 'ramda');                     //=> 'ram'
 */
var slice$1 = _curry3$5(_checkForMethod$3('slice', function slice$1(fromIndex, toIndex, list) {
  return Array.prototype.slice.call(list, fromIndex, toIndex);
}));

var _checkForMethod = _checkForMethod$1;
var slice = slice$1;


/**
 * Returns all but the first element of the given list or string (or object
 * with a `tail` method).
 *
 * Dispatches to the `slice` method of the first argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a]
 * @sig String -> String
 * @param {*} list
 * @return {*}
 * @see R.head, R.init, R.last
 * @example
 *
 *      R.tail([1, 2, 3]);  //=> [2, 3]
 *      R.tail([1, 2]);     //=> [2]
 *      R.tail([1]);        //=> []
 *      R.tail([]);         //=> []
 *
 *      R.tail('abc');  //=> 'bc'
 *      R.tail('ab');   //=> 'b'
 *      R.tail('a');    //=> ''
 *      R.tail('');     //=> ''
 */
var tail$1 = _checkForMethod('tail', slice(1, Infinity));

var _arity$5 = _arity$1;
var _pipe = _pipe$1;
var reduce = reduce$1;
var tail = tail$1;


/**
 * Performs left-to-right function composition. The leftmost function may have
 * any arity; the remaining functions must be unary.
 *
 * In some libraries this function is named `sequence`.
 *
 * **Note:** The result of pipe is not automatically curried.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
 * @param {...Function} functions
 * @return {Function}
 * @see R.compose
 * @example
 *
 *      var f = R.pipe(Math.pow, R.negate, R.inc);
 *
 *      f(3, 4); // -(3^4) + 1
 */
var pipe$1 = function pipe$1() {
  if (arguments.length === 0) {
    throw new Error('pipe requires at least one argument');
  }
  return _arity$5(arguments[0].length,
                reduce(_pipe, arguments[0], tail(arguments)));
};

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};



function unwrapExports (x) {
	return x && x.__esModule ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var React$7 = react;

var sizerStyle = { position: 'absolute', top: 0, left: 0, visibility: 'hidden', height: 0, overflow: 'scroll', whiteSpace: 'pre' };

var AutosizeInput = React$7.createClass({
	displayName: 'AutosizeInput',

	propTypes: {
		className: React$7.PropTypes.string, // className for the outer element
		defaultValue: React$7.PropTypes.any, // default field value
		inputClassName: React$7.PropTypes.string, // className for the input element
		inputStyle: React$7.PropTypes.object, // css styles for the input element
		minWidth: React$7.PropTypes.oneOfType([// minimum width for input element
		React$7.PropTypes.number, React$7.PropTypes.string]),
		onChange: React$7.PropTypes.func, // onChange handler: function(newValue) {}
		placeholder: React$7.PropTypes.string, // placeholder text
		placeholderIsMinWidth: React$7.PropTypes.bool, // don't collapse size to less than the placeholder
		style: React$7.PropTypes.object, // css styles for the outer element
		value: React$7.PropTypes.any },
	// field value
	getDefaultProps: function getDefaultProps() {
		return {
			minWidth: 1
		};
	},
	getInitialState: function getInitialState() {
		return {
			inputWidth: this.props.minWidth
		};
	},
	componentDidMount: function componentDidMount() {
		this.copyInputStyles();
		this.updateInputWidth();
	},
	componentDidUpdate: function componentDidUpdate() {
		this.updateInputWidth();
	},
	copyInputStyles: function copyInputStyles() {
		if (!this.isMounted() || !window.getComputedStyle) {
			return;
		}
		var inputStyle = window.getComputedStyle(this.refs.input);
		if (!inputStyle) {
			return;
		}
		var widthNode = this.refs.sizer;
		widthNode.style.fontSize = inputStyle.fontSize;
		widthNode.style.fontFamily = inputStyle.fontFamily;
		widthNode.style.fontWeight = inputStyle.fontWeight;
		widthNode.style.fontStyle = inputStyle.fontStyle;
		widthNode.style.letterSpacing = inputStyle.letterSpacing;
		if (this.props.placeholder) {
			var placeholderNode = this.refs.placeholderSizer;
			placeholderNode.style.fontSize = inputStyle.fontSize;
			placeholderNode.style.fontFamily = inputStyle.fontFamily;
			placeholderNode.style.fontWeight = inputStyle.fontWeight;
			placeholderNode.style.fontStyle = inputStyle.fontStyle;
			placeholderNode.style.letterSpacing = inputStyle.letterSpacing;
		}
	},
	updateInputWidth: function updateInputWidth() {
		if (!this.isMounted() || typeof this.refs.sizer.scrollWidth === 'undefined') {
			return;
		}
		var newInputWidth = undefined;
		if (this.props.placeholder && (!this.props.value || this.props.value && this.props.placeholderIsMinWidth)) {
			newInputWidth = Math.max(this.refs.sizer.scrollWidth, this.refs.placeholderSizer.scrollWidth) + 2;
		} else {
			newInputWidth = this.refs.sizer.scrollWidth + 2;
		}
		if (newInputWidth < this.props.minWidth) {
			newInputWidth = this.props.minWidth;
		}
		if (newInputWidth !== this.state.inputWidth) {
			this.setState({
				inputWidth: newInputWidth
			});
		}
	},
	getInput: function getInput() {
		return this.refs.input;
	},
	focus: function focus() {
		this.refs.input.focus();
	},
	blur: function blur() {
		this.refs.input.blur();
	},
	select: function select() {
		this.refs.input.select();
	},
	render: function render() {
		var sizerValue = this.props.defaultValue || this.props.value || '';
		var wrapperStyle = this.props.style || {};
		if (!wrapperStyle.display) wrapperStyle.display = 'inline-block';
		var inputStyle = _extends$1({}, this.props.inputStyle);
		inputStyle.width = this.state.inputWidth + 'px';
		inputStyle.boxSizing = 'content-box';
		var inputProps = _extends$1({}, this.props);
		inputProps.className = this.props.inputClassName;
		inputProps.style = inputStyle;
		// ensure props meant for `AutosizeInput` don't end up on the `input`
		delete inputProps.inputClassName;
		delete inputProps.inputStyle;
		delete inputProps.minWidth;
		delete inputProps.placeholderIsMinWidth;
		return React$7.createElement(
			'div',
			{ className: this.props.className, style: wrapperStyle },
			React$7.createElement('input', _extends$1({}, inputProps, { ref: 'input' })),
			React$7.createElement(
				'div',
				{ ref: 'sizer', style: sizerStyle },
				sizerValue
			),
			this.props.placeholder ? React$7.createElement(
				'div',
				{ ref: 'placeholderSizer', style: sizerStyle },
				this.props.placeholder
			) : null
		);
	}
});

var AutosizeInput_1 = AutosizeInput;

var index$4 = createCommonjsModule(function (module) {
/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// register as 'classnames', consistent with npm package name
		define('classnames', [], function () {
			return classNames;
		});
	} else {
		window.classNames = classNames;
	}
}());
});

var defaultArrowRenderer = createCommonjsModule(function (module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports["default"] = arrowRenderer;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _react = react;

var _react2 = _interopRequireDefault(_react);

function arrowRenderer(_ref) {
	var onMouseDown = _ref.onMouseDown;

	return _react2["default"].createElement("span", {
		className: "Select-arrow",
		onMouseDown: onMouseDown
	});
}


module.exports = exports["default"];
});

var map$2 = [{ 'base': 'A', 'letters': /[\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F]/g }, { 'base': 'AA', 'letters': /[\uA732]/g }, { 'base': 'AE', 'letters': /[\u00C6\u01FC\u01E2]/g }, { 'base': 'AO', 'letters': /[\uA734]/g }, { 'base': 'AU', 'letters': /[\uA736]/g }, { 'base': 'AV', 'letters': /[\uA738\uA73A]/g }, { 'base': 'AY', 'letters': /[\uA73C]/g }, { 'base': 'B', 'letters': /[\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181]/g }, { 'base': 'C', 'letters': /[\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E]/g }, { 'base': 'D', 'letters': /[\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779]/g }, { 'base': 'DZ', 'letters': /[\u01F1\u01C4]/g }, { 'base': 'Dz', 'letters': /[\u01F2\u01C5]/g }, { 'base': 'E', 'letters': /[\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E]/g }, { 'base': 'F', 'letters': /[\u0046\u24BB\uFF26\u1E1E\u0191\uA77B]/g }, { 'base': 'G', 'letters': /[\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E]/g }, { 'base': 'H', 'letters': /[\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D]/g }, { 'base': 'I', 'letters': /[\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197]/g }, { 'base': 'J', 'letters': /[\u004A\u24BF\uFF2A\u0134\u0248]/g }, { 'base': 'K', 'letters': /[\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2]/g }, { 'base': 'L', 'letters': /[\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780]/g }, { 'base': 'LJ', 'letters': /[\u01C7]/g }, { 'base': 'Lj', 'letters': /[\u01C8]/g }, { 'base': 'M', 'letters': /[\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C]/g }, { 'base': 'N', 'letters': /[\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4]/g }, { 'base': 'NJ', 'letters': /[\u01CA]/g }, { 'base': 'Nj', 'letters': /[\u01CB]/g }, { 'base': 'O', 'letters': /[\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C]/g }, { 'base': 'OI', 'letters': /[\u01A2]/g }, { 'base': 'OO', 'letters': /[\uA74E]/g }, { 'base': 'OU', 'letters': /[\u0222]/g }, { 'base': 'P', 'letters': /[\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754]/g }, { 'base': 'Q', 'letters': /[\u0051\u24C6\uFF31\uA756\uA758\u024A]/g }, { 'base': 'R', 'letters': /[\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782]/g }, { 'base': 'S', 'letters': /[\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784]/g }, { 'base': 'T', 'letters': /[\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786]/g }, { 'base': 'TZ', 'letters': /[\uA728]/g }, { 'base': 'U', 'letters': /[\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244]/g }, { 'base': 'V', 'letters': /[\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245]/g }, { 'base': 'VY', 'letters': /[\uA760]/g }, { 'base': 'W', 'letters': /[\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72]/g }, { 'base': 'X', 'letters': /[\u0058\u24CD\uFF38\u1E8A\u1E8C]/g }, { 'base': 'Y', 'letters': /[\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE]/g }, { 'base': 'Z', 'letters': /[\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762]/g }, { 'base': 'a', 'letters': /[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g }, { 'base': 'aa', 'letters': /[\uA733]/g }, { 'base': 'ae', 'letters': /[\u00E6\u01FD\u01E3]/g }, { 'base': 'ao', 'letters': /[\uA735]/g }, { 'base': 'au', 'letters': /[\uA737]/g }, { 'base': 'av', 'letters': /[\uA739\uA73B]/g }, { 'base': 'ay', 'letters': /[\uA73D]/g }, { 'base': 'b', 'letters': /[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g }, { 'base': 'c', 'letters': /[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g }, { 'base': 'd', 'letters': /[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g }, { 'base': 'dz', 'letters': /[\u01F3\u01C6]/g }, { 'base': 'e', 'letters': /[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g }, { 'base': 'f', 'letters': /[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g }, { 'base': 'g', 'letters': /[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g }, { 'base': 'h', 'letters': /[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g }, { 'base': 'hv', 'letters': /[\u0195]/g }, { 'base': 'i', 'letters': /[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g }, { 'base': 'j', 'letters': /[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g }, { 'base': 'k', 'letters': /[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g }, { 'base': 'l', 'letters': /[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g }, { 'base': 'lj', 'letters': /[\u01C9]/g }, { 'base': 'm', 'letters': /[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g }, { 'base': 'n', 'letters': /[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g }, { 'base': 'nj', 'letters': /[\u01CC]/g }, { 'base': 'o', 'letters': /[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g }, { 'base': 'oi', 'letters': /[\u01A3]/g }, { 'base': 'ou', 'letters': /[\u0223]/g }, { 'base': 'oo', 'letters': /[\uA74F]/g }, { 'base': 'p', 'letters': /[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g }, { 'base': 'q', 'letters': /[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g }, { 'base': 'r', 'letters': /[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g }, { 'base': 's', 'letters': /[\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g }, { 'base': 't', 'letters': /[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g }, { 'base': 'tz', 'letters': /[\uA729]/g }, { 'base': 'u', 'letters': /[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g }, { 'base': 'v', 'letters': /[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g }, { 'base': 'vy', 'letters': /[\uA761]/g }, { 'base': 'w', 'letters': /[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g }, { 'base': 'x', 'letters': /[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g }, { 'base': 'y', 'letters': /[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g }, { 'base': 'z', 'letters': /[\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763]/g }];

var stripDiacritics = function stripDiacritics(str) {
	for (var i = 0; i < map$2.length; i++) {
		str = str.replace(map$2[i].letters, map$2[i].base);
	}
	return str;
};

var defaultFilterOptions = createCommonjsModule(function (module) {
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _stripDiacritics = stripDiacritics;

var _stripDiacritics2 = _interopRequireDefault(_stripDiacritics);

function filterOptions(options, filterValue, excludeOptions, props) {
	var _this = this;

	if (props.ignoreAccents) {
		filterValue = (0, _stripDiacritics2['default'])(filterValue);
	}

	if (props.ignoreCase) {
		filterValue = filterValue.toLowerCase();
	}

	if (excludeOptions) excludeOptions = excludeOptions.map(function (i) {
		return i[props.valueKey];
	});

	return options.filter(function (option) {
		if (excludeOptions && excludeOptions.indexOf(option[props.valueKey]) > -1) return false;
		if (props.filterOption) return props.filterOption.call(_this, option, filterValue);
		if (!filterValue) return true;
		var valueTest = String(option[props.valueKey]);
		var labelTest = String(option[props.labelKey]);
		if (props.ignoreAccents) {
			if (props.matchProp !== 'label') valueTest = (0, _stripDiacritics2['default'])(valueTest);
			if (props.matchProp !== 'value') labelTest = (0, _stripDiacritics2['default'])(labelTest);
		}
		if (props.ignoreCase) {
			if (props.matchProp !== 'label') valueTest = valueTest.toLowerCase();
			if (props.matchProp !== 'value') labelTest = labelTest.toLowerCase();
		}
		return props.matchPos === 'start' ? props.matchProp !== 'label' && valueTest.substr(0, filterValue.length) === filterValue || props.matchProp !== 'value' && labelTest.substr(0, filterValue.length) === filterValue : props.matchProp !== 'label' && valueTest.indexOf(filterValue) >= 0 || props.matchProp !== 'value' && labelTest.indexOf(filterValue) >= 0;
	});
}

module.exports = filterOptions;
});

var defaultMenuRenderer = createCommonjsModule(function (module) {
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _classnames = index$4;

var _classnames2 = _interopRequireDefault(_classnames);

var _react = react;

var _react2 = _interopRequireDefault(_react);

function menuRenderer(_ref) {
	var focusedOption = _ref.focusedOption;
	var instancePrefix = _ref.instancePrefix;
	var labelKey = _ref.labelKey;
	var onFocus = _ref.onFocus;
	var onSelect = _ref.onSelect;
	var optionClassName = _ref.optionClassName;
	var optionComponent = _ref.optionComponent;
	var optionRenderer = _ref.optionRenderer;
	var options = _ref.options;
	var valueArray = _ref.valueArray;
	var valueKey = _ref.valueKey;
	var onOptionRef = _ref.onOptionRef;

	var Option = optionComponent;

	return options.map(function (option, i) {
		var isSelected = valueArray && valueArray.indexOf(option) > -1;
		var isFocused = option === focusedOption;
		var optionClass = (0, _classnames2['default'])(optionClassName, {
			'Select-option': true,
			'is-selected': isSelected,
			'is-focused': isFocused,
			'is-disabled': option.disabled
		});

		return _react2['default'].createElement(
			Option,
			{
				className: optionClass,
				instancePrefix: instancePrefix,
				isDisabled: option.disabled,
				isFocused: isFocused,
				isSelected: isSelected,
				key: 'option-' + i + '-' + option[valueKey],
				onFocus: onFocus,
				onSelect: onSelect,
				option: option,
				optionIndex: i,
				ref: function (ref) {
					onOptionRef(ref, isFocused);
				}
			},
			optionRenderer(option, i)
		);
	});
}

module.exports = menuRenderer;
});

var Async_1 = createCommonjsModule(function (module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = react;

var _react2 = _interopRequireDefault(_react);

var _Select = Select_1;

var _Select2 = _interopRequireDefault(_Select);

var _utilsStripDiacritics = stripDiacritics;

var _utilsStripDiacritics2 = _interopRequireDefault(_utilsStripDiacritics);

var propTypes = {
	autoload: _react2['default'].PropTypes.bool.isRequired, // automatically call the `loadOptions` prop on-mount; defaults to true
	cache: _react2['default'].PropTypes.any, // object to use to cache results; set to null/false to disable caching
	children: _react2['default'].PropTypes.func.isRequired, // Child function responsible for creating the inner Select component; (props: Object): PropTypes.element
	ignoreAccents: _react2['default'].PropTypes.bool, // strip diacritics when filtering; defaults to true
	ignoreCase: _react2['default'].PropTypes.bool, // perform case-insensitive filtering; defaults to true
	loadingPlaceholder: _react.PropTypes.string.isRequired, // replaces the placeholder while options are loading
	loadOptions: _react2['default'].PropTypes.func.isRequired, // callback to load options asynchronously; (inputValue: string, callback: Function): ?Promise
	options: _react.PropTypes.array.isRequired, // array of options
	placeholder: _react2['default'].PropTypes.oneOfType([// field placeholder, displayed when there's no value (shared with Select)
	_react2['default'].PropTypes.string, _react2['default'].PropTypes.node]),
	searchPromptText: _react2['default'].PropTypes.oneOfType([// label to prompt for search input
	_react2['default'].PropTypes.string, _react2['default'].PropTypes.node])
};

var defaultProps = {
	autoload: true,
	cache: {},
	children: defaultChildren,
	ignoreAccents: true,
	ignoreCase: true,
	loadingPlaceholder: 'Loading...',
	options: [],
	searchPromptText: 'Type to search'
};

var Async = (function (_Component) {
	_inherits(Async, _Component);

	function Async(props, context) {
		_classCallCheck(this, Async);

		_get(Object.getPrototypeOf(Async.prototype), 'constructor', this).call(this, props, context);

		this.state = {
			isLoading: false,
			options: props.options
		};

		this._onInputChange = this._onInputChange.bind(this);
	}

	_createClass(Async, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var autoload = this.props.autoload;

			if (autoload) {
				this.loadOptions('');
			}
		}
	}, {
		key: 'componentWillUpdate',
		value: function componentWillUpdate(nextProps, nextState) {
			var _this = this;

			var propertiesToSync = ['options'];
			propertiesToSync.forEach(function (prop) {
				if (_this.props[prop] !== nextProps[prop]) {
					_this.setState(_defineProperty({}, prop, nextProps[prop]));
				}
			});
		}
	}, {
		key: 'loadOptions',
		value: function loadOptions(inputValue) {
			var _this2 = this;

			var _props = this.props;
			var cache = _props.cache;
			var loadOptions = _props.loadOptions;

			if (cache && cache.hasOwnProperty(inputValue)) {
				this.setState({
					options: cache[inputValue]
				});

				return;
			}

			var callback = function callback(error, data) {
				if (callback === _this2._callback) {
					_this2._callback = null;

					var options = data && data.options || [];

					if (cache) {
						cache[inputValue] = options;
					}

					_this2.setState({
						isLoading: false,
						options: options
					});
				}
			};

			// Ignore all but the most recent request
			this._callback = callback;

			var promise = loadOptions(inputValue, callback);
			if (promise) {
				promise.then(function (data) {
					return callback(null, data);
				}, function (error) {
					return callback(error);
				});
			}

			if (this._callback && !this.state.isLoading) {
				this.setState({
					isLoading: true
				});
			}

			return inputValue;
		}
	}, {
		key: '_onInputChange',
		value: function _onInputChange(inputValue) {
			var _props2 = this.props;
			var ignoreAccents = _props2.ignoreAccents;
			var ignoreCase = _props2.ignoreCase;

			if (ignoreAccents) {
				inputValue = (0, _utilsStripDiacritics2['default'])(inputValue);
			}

			if (ignoreCase) {
				inputValue = inputValue.toLowerCase();
			}

			return this.loadOptions(inputValue);
		}
	}, {
		key: 'render',
		value: function render() {
			var _props3 = this.props;
			var children = _props3.children;
			var loadingPlaceholder = _props3.loadingPlaceholder;
			var placeholder = _props3.placeholder;
			var searchPromptText = _props3.searchPromptText;
			var _state = this.state;
			var isLoading = _state.isLoading;
			var options = _state.options;

			var props = {
				noResultsText: isLoading ? loadingPlaceholder : searchPromptText,
				placeholder: isLoading ? loadingPlaceholder : placeholder,
				options: isLoading ? [] : options
			};

			return children(_extends({}, this.props, props, {
				isLoading: isLoading,
				onInputChange: this._onInputChange
			}));
		}
	}]);

	return Async;
})(_react.Component);

exports['default'] = Async;

Async.propTypes = propTypes;
Async.defaultProps = defaultProps;

function defaultChildren(props) {
	return _react2['default'].createElement(_Select2['default'], props);
}
module.exports = exports['default'];
});

var AsyncCreatable_1 = createCommonjsModule(function (module) {
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _react = react;

var _react2 = _interopRequireDefault(_react);

var _Select = Select_1;

var _Select2 = _interopRequireDefault(_Select);

var AsyncCreatable = _react2['default'].createClass({
	displayName: 'AsyncCreatableSelect',

	render: function render() {
		var _this = this;

		return _react2['default'].createElement(
			_Select2['default'].Async,
			this.props,
			function (asyncProps) {
				return _react2['default'].createElement(
					_Select2['default'].Creatable,
					_this.props,
					function (creatableProps) {
						return _react2['default'].createElement(_Select2['default'], _extends({}, asyncProps, creatableProps, {
							onInputChange: function (input) {
								creatableProps.onInputChange(input);
								return asyncProps.onInputChange(input);
							}
						}));
					}
				);
			}
		);
	}
});

module.exports = AsyncCreatable;
});

var Creatable_1 = createCommonjsModule(function (module) {
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var _react = react;

var _react2 = _interopRequireDefault(_react);

var _Select = Select_1;

var _Select2 = _interopRequireDefault(_Select);

var _utilsDefaultFilterOptions = defaultFilterOptions;

var _utilsDefaultFilterOptions2 = _interopRequireDefault(_utilsDefaultFilterOptions);

var _utilsDefaultMenuRenderer = defaultMenuRenderer;

var _utilsDefaultMenuRenderer2 = _interopRequireDefault(_utilsDefaultMenuRenderer);

var Creatable = _react2['default'].createClass({
	displayName: 'CreatableSelect',

	propTypes: {
		// Child function responsible for creating the inner Select component
		// This component can be used to compose HOCs (eg Creatable and Async)
		// (props: Object): PropTypes.element
		children: _react2['default'].PropTypes.func,

		// See Select.propTypes.filterOptions
		filterOptions: _react2['default'].PropTypes.any,

		// Searches for any matching option within the set of options.
		// This function prevents duplicate options from being created.
		// ({ option: Object, options: Array, labelKey: string, valueKey: string }): boolean
		isOptionUnique: _react2['default'].PropTypes.func,

		// Determines if the current input text represents a valid option.
		// ({ label: string }): boolean
		isValidNewOption: _react2['default'].PropTypes.func,

		// See Select.propTypes.menuRenderer
		menuRenderer: _react2['default'].PropTypes.any,

		// Factory to create new option.
		// ({ label: string, labelKey: string, valueKey: string }): Object
		newOptionCreator: _react2['default'].PropTypes.func,

		// See Select.propTypes.options
		options: _react2['default'].PropTypes.array,

		// Creates prompt/placeholder option text.
		// (filterText: string): string
		promptTextCreator: _react2['default'].PropTypes.func,

		// Decides if a keyDown event (eg its `keyCode`) should result in the creation of a new option.
		shouldKeyDownEventCreateNewOption: _react2['default'].PropTypes.func
	},

	// Default prop methods
	statics: {
		isOptionUnique: isOptionUnique,
		isValidNewOption: isValidNewOption,
		newOptionCreator: newOptionCreator,
		promptTextCreator: promptTextCreator,
		shouldKeyDownEventCreateNewOption: shouldKeyDownEventCreateNewOption
	},

	getDefaultProps: function getDefaultProps() {
		return {
			filterOptions: _utilsDefaultFilterOptions2['default'],
			isOptionUnique: isOptionUnique,
			isValidNewOption: isValidNewOption,
			menuRenderer: _utilsDefaultMenuRenderer2['default'],
			newOptionCreator: newOptionCreator,
			promptTextCreator: promptTextCreator,
			shouldKeyDownEventCreateNewOption: shouldKeyDownEventCreateNewOption
		};
	},

	createNewOption: function createNewOption() {
		var _props = this.props;
		var isValidNewOption = _props.isValidNewOption;
		var newOptionCreator = _props.newOptionCreator;
		var _props$options = _props.options;
		var options = _props$options === undefined ? [] : _props$options;
		var shouldKeyDownEventCreateNewOption = _props.shouldKeyDownEventCreateNewOption;

		if (isValidNewOption({ label: this.inputValue })) {
			var option = newOptionCreator({ label: this.inputValue, labelKey: this.labelKey, valueKey: this.valueKey });
			var _isOptionUnique = this.isOptionUnique({ option: option });

			// Don't add the same option twice.
			if (_isOptionUnique) {
				options.unshift(option);

				this.select.selectValue(option);
			}
		}
	},

	filterOptions: function filterOptions() {
		var _props2 = this.props;
		var filterOptions = _props2.filterOptions;
		var isValidNewOption = _props2.isValidNewOption;
		var options = _props2.options;
		var promptTextCreator = _props2.promptTextCreator;

		// TRICKY Check currently selected options as well.
		// Don't display a create-prompt for a value that's selected.
		// This covers async edge-cases where a newly-created Option isn't yet in the async-loaded array.
		var excludeOptions = arguments[2] || [];

		var filteredOptions = filterOptions.apply(undefined, arguments) || [];

		if (isValidNewOption({ label: this.inputValue })) {
			var _newOptionCreator = this.props.newOptionCreator;

			var option = _newOptionCreator({
				label: this.inputValue,
				labelKey: this.labelKey,
				valueKey: this.valueKey
			});

			// TRICKY Compare to all options (not just filtered options) in case option has already been selected).
			// For multi-selects, this would remove it from the filtered list.
			var _isOptionUnique2 = this.isOptionUnique({
				option: option,
				options: excludeOptions.concat(filteredOptions)
			});

			if (_isOptionUnique2) {
				var _prompt = promptTextCreator(this.inputValue);

				this._createPlaceholderOption = _newOptionCreator({
					label: _prompt,
					labelKey: this.labelKey,
					valueKey: this.valueKey
				});

				filteredOptions.unshift(this._createPlaceholderOption);
			}
		}

		return filteredOptions;
	},

	isOptionUnique: function isOptionUnique(_ref2) {
		var option = _ref2.option;
		var options = _ref2.options;
		var isOptionUnique = this.props.isOptionUnique;

		options = options || this.select.filterOptions();

		return isOptionUnique({
			labelKey: this.labelKey,
			option: option,
			options: options,
			valueKey: this.valueKey
		});
	},

	menuRenderer: function menuRenderer(params) {
		var menuRenderer = this.props.menuRenderer;

		return menuRenderer(_extends({}, params, {
			onSelect: this.onOptionSelect
		}));
	},

	onInputChange: function onInputChange(input) {
		// This value may be needed in between Select mounts (when this.select is null)
		this.inputValue = input;
	},

	onInputKeyDown: function onInputKeyDown(event) {
		var shouldKeyDownEventCreateNewOption = this.props.shouldKeyDownEventCreateNewOption;

		var focusedOption = this.select.getFocusedOption();

		if (focusedOption && focusedOption === this._createPlaceholderOption && shouldKeyDownEventCreateNewOption({ keyCode: event.keyCode })) {
			this.createNewOption();

			// Prevent decorated Select from doing anything additional with this keyDown event
			event.preventDefault();
		}
	},

	onOptionSelect: function onOptionSelect(option, event) {
		if (option === this._createPlaceholderOption) {
			this.createNewOption();
		} else {
			this.select.selectValue(option);
		}
	},

	render: function render() {
		var _this = this;

		var _props3 = this.props;
		var _props3$children = _props3.children;
		var children = _props3$children === undefined ? defaultChildren : _props3$children;
		var newOptionCreator = _props3.newOptionCreator;
		var shouldKeyDownEventCreateNewOption = _props3.shouldKeyDownEventCreateNewOption;

		var restProps = _objectWithoutProperties(_props3, ['children', 'newOptionCreator', 'shouldKeyDownEventCreateNewOption']);

		var props = _extends({}, restProps, {
			allowCreate: true,
			filterOptions: this.filterOptions,
			menuRenderer: this.menuRenderer,
			onInputChange: this.onInputChange,
			onInputKeyDown: this.onInputKeyDown,
			ref: function ref(_ref) {
				_this.select = _ref;

				// These values may be needed in between Select mounts (when this.select is null)
				if (_ref) {
					_this.labelKey = _ref.props.labelKey;
					_this.valueKey = _ref.props.valueKey;
				}
			}
		});

		return children(props);
	}
});

function defaultChildren(props) {
	return _react2['default'].createElement(_Select2['default'], props);
}

function isOptionUnique(_ref3) {
	var option = _ref3.option;
	var options = _ref3.options;
	var labelKey = _ref3.labelKey;
	var valueKey = _ref3.valueKey;

	return options.filter(function (existingOption) {
		return existingOption[labelKey] === option[labelKey] || existingOption[valueKey] === option[valueKey];
	}).length === 0;
}

function isValidNewOption(_ref4) {
	var label = _ref4.label;

	return !!label;
}

function newOptionCreator(_ref5) {
	var label = _ref5.label;
	var labelKey = _ref5.labelKey;
	var valueKey = _ref5.valueKey;

	var option = {};
	option[valueKey] = label;
	option[labelKey] = label;
	option.className = 'Select-create-option-placeholder';
	return option;
}

function promptTextCreator(label) {
	return 'Create option "' + label + '"';
}

function shouldKeyDownEventCreateNewOption(_ref6) {
	var keyCode = _ref6.keyCode;

	switch (keyCode) {
		case 9: // TAB
		case 13: // ENTER
		case 188:
			// COMMA
			return true;
	}

	return false;
}

module.exports = Creatable;
});

var Option_1 = createCommonjsModule(function (module) {
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _react = react;

var _react2 = _interopRequireDefault(_react);

var _classnames = index$4;

var _classnames2 = _interopRequireDefault(_classnames);

var Option = _react2['default'].createClass({
	displayName: 'Option',

	propTypes: {
		children: _react2['default'].PropTypes.node,
		className: _react2['default'].PropTypes.string, // className (based on mouse position)
		instancePrefix: _react2['default'].PropTypes.string.isRequired, // unique prefix for the ids (used for aria)
		isDisabled: _react2['default'].PropTypes.bool, // the option is disabled
		isFocused: _react2['default'].PropTypes.bool, // the option is focused
		isSelected: _react2['default'].PropTypes.bool, // the option is selected
		onFocus: _react2['default'].PropTypes.func, // method to handle mouseEnter on option element
		onSelect: _react2['default'].PropTypes.func, // method to handle click on option element
		onUnfocus: _react2['default'].PropTypes.func, // method to handle mouseLeave on option element
		option: _react2['default'].PropTypes.object.isRequired, // object that is base for that option
		optionIndex: _react2['default'].PropTypes.number },
	// index of the option, used to generate unique ids for aria
	blockEvent: function blockEvent(event) {
		event.preventDefault();
		event.stopPropagation();
		if (event.target.tagName !== 'A' || !('href' in event.target)) {
			return;
		}
		if (event.target.target) {
			window.open(event.target.href, event.target.target);
		} else {
			window.location.href = event.target.href;
		}
	},

	handleMouseDown: function handleMouseDown(event) {
		event.preventDefault();
		event.stopPropagation();
		this.props.onSelect(this.props.option, event);
	},

	handleMouseEnter: function handleMouseEnter(event) {
		this.onFocus(event);
	},

	handleMouseMove: function handleMouseMove(event) {
		this.onFocus(event);
	},

	handleTouchEnd: function handleTouchEnd(event) {
		// Check if the view is being dragged, In this case
		// we don't want to fire the click event (because the user only wants to scroll)
		if (this.dragging) return;

		this.handleMouseDown(event);
	},

	handleTouchMove: function handleTouchMove(event) {
		// Set a flag that the view is being dragged
		this.dragging = true;
	},

	handleTouchStart: function handleTouchStart(event) {
		// Set a flag that the view is not being dragged
		this.dragging = false;
	},

	onFocus: function onFocus(event) {
		if (!this.props.isFocused) {
			this.props.onFocus(this.props.option, event);
		}
	},
	render: function render() {
		var _props = this.props;
		var option = _props.option;
		var instancePrefix = _props.instancePrefix;
		var optionIndex = _props.optionIndex;

		var className = (0, _classnames2['default'])(this.props.className, option.className);

		return option.disabled ? _react2['default'].createElement(
			'div',
			{ className: className,
				onMouseDown: this.blockEvent,
				onClick: this.blockEvent },
			this.props.children
		) : _react2['default'].createElement(
			'div',
			{ className: className,
				style: option.style,
				role: 'option',
				onMouseDown: this.handleMouseDown,
				onMouseEnter: this.handleMouseEnter,
				onMouseMove: this.handleMouseMove,
				onTouchStart: this.handleTouchStart,
				onTouchMove: this.handleTouchMove,
				onTouchEnd: this.handleTouchEnd,
				id: instancePrefix + '-option-' + optionIndex,
				title: option.title },
			this.props.children
		);
	}
});

module.exports = Option;
});

var Value_1 = createCommonjsModule(function (module) {
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _react = react;

var _react2 = _interopRequireDefault(_react);

var _classnames = index$4;

var _classnames2 = _interopRequireDefault(_classnames);

var Value = _react2['default'].createClass({

	displayName: 'Value',

	propTypes: {
		children: _react2['default'].PropTypes.node,
		disabled: _react2['default'].PropTypes.bool, // disabled prop passed to ReactSelect
		id: _react2['default'].PropTypes.string, // Unique id for the value - used for aria
		onClick: _react2['default'].PropTypes.func, // method to handle click on value label
		onRemove: _react2['default'].PropTypes.func, // method to handle removal of the value
		value: _react2['default'].PropTypes.object.isRequired },

	// the option object for this value
	handleMouseDown: function handleMouseDown(event) {
		if (event.type === 'mousedown' && event.button !== 0) {
			return;
		}
		if (this.props.onClick) {
			event.stopPropagation();
			this.props.onClick(this.props.value, event);
			return;
		}
		if (this.props.value.href) {
			event.stopPropagation();
		}
	},

	onRemove: function onRemove(event) {
		event.preventDefault();
		event.stopPropagation();
		this.props.onRemove(this.props.value);
	},

	handleTouchEndRemove: function handleTouchEndRemove(event) {
		// Check if the view is being dragged, In this case
		// we don't want to fire the click event (because the user only wants to scroll)
		if (this.dragging) return;

		// Fire the mouse events
		this.onRemove(event);
	},

	handleTouchMove: function handleTouchMove(event) {
		// Set a flag that the view is being dragged
		this.dragging = true;
	},

	handleTouchStart: function handleTouchStart(event) {
		// Set a flag that the view is not being dragged
		this.dragging = false;
	},

	renderRemoveIcon: function renderRemoveIcon() {
		if (this.props.disabled || !this.props.onRemove) return;
		return _react2['default'].createElement(
			'span',
			{ className: 'Select-value-icon',
				'aria-hidden': 'true',
				onMouseDown: this.onRemove,
				onTouchEnd: this.handleTouchEndRemove,
				onTouchStart: this.handleTouchStart,
				onTouchMove: this.handleTouchMove },
			'×'
		);
	},

	renderLabel: function renderLabel() {
		var className = 'Select-value-label';
		return this.props.onClick || this.props.value.href ? _react2['default'].createElement(
			'a',
			{ className: className, href: this.props.value.href, target: this.props.value.target, onMouseDown: this.handleMouseDown, onTouchEnd: this.handleMouseDown },
			this.props.children
		) : _react2['default'].createElement(
			'span',
			{ className: className, role: 'option', 'aria-selected': 'true', id: this.props.id },
			this.props.children
		);
	},

	render: function render() {
		return _react2['default'].createElement(
			'div',
			{ className: (0, _classnames2['default'])('Select-value', this.props.value.className),
				style: this.props.value.style,
				title: this.props.value.title
			},
			this.renderRemoveIcon(),
			this.renderLabel()
		);
	}

});

module.exports = Value;
});

var Select_1 = createCommonjsModule(function (module, exports) {
/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/react-select
*/

'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _react = react;

var _react2 = _interopRequireDefault(_react);

var _reactDom = index$3;

var _reactDom2 = _interopRequireDefault(_reactDom);

var _reactInputAutosize = AutosizeInput_1;

var _reactInputAutosize2 = _interopRequireDefault(_reactInputAutosize);

var _classnames = index$4;

var _classnames2 = _interopRequireDefault(_classnames);

var _utilsDefaultArrowRenderer = defaultArrowRenderer;

var _utilsDefaultArrowRenderer2 = _interopRequireDefault(_utilsDefaultArrowRenderer);

var _utilsDefaultFilterOptions = defaultFilterOptions;

var _utilsDefaultFilterOptions2 = _interopRequireDefault(_utilsDefaultFilterOptions);

var _utilsDefaultMenuRenderer = defaultMenuRenderer;

var _utilsDefaultMenuRenderer2 = _interopRequireDefault(_utilsDefaultMenuRenderer);

var _Async = Async_1;

var _Async2 = _interopRequireDefault(_Async);

var _AsyncCreatable = AsyncCreatable_1;

var _AsyncCreatable2 = _interopRequireDefault(_AsyncCreatable);

var _Creatable = Creatable_1;

var _Creatable2 = _interopRequireDefault(_Creatable);

var _Option = Option_1;

var _Option2 = _interopRequireDefault(_Option);

var _Value = Value_1;

var _Value2 = _interopRequireDefault(_Value);

function stringifyValue(value) {
	var valueType = typeof value;
	if (valueType === 'string') {
		return value;
	} else if (valueType === 'object') {
		return JSON.stringify(value);
	} else if (valueType === 'number' || valueType === 'boolean') {
		return String(value);
	} else {
		return '';
	}
}

var stringOrNode = _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.string, _react2['default'].PropTypes.node]);

var instanceId = 1;

var Select = _react2['default'].createClass({

	displayName: 'Select',

	propTypes: {
		addLabelText: _react2['default'].PropTypes.string, // placeholder displayed when you want to add a label on a multi-value input
		'aria-label': _react2['default'].PropTypes.string, // Aria label (for assistive tech)
		'aria-labelledby': _react2['default'].PropTypes.string, // HTML ID of an element that should be used as the label (for assistive tech)
		arrowRenderer: _react2['default'].PropTypes.func, // Create drop-down caret element
		autoBlur: _react2['default'].PropTypes.bool, // automatically blur the component when an option is selected
		autofocus: _react2['default'].PropTypes.bool, // autofocus the component on mount
		autosize: _react2['default'].PropTypes.bool, // whether to enable autosizing or not
		backspaceRemoves: _react2['default'].PropTypes.bool, // whether backspace removes an item if there is no text input
		backspaceToRemoveMessage: _react2['default'].PropTypes.string, // Message to use for screenreaders to press backspace to remove the current item - {label} is replaced with the item label
		className: _react2['default'].PropTypes.string, // className for the outer element
		clearAllText: stringOrNode, // title for the "clear" control when multi: true
		clearValueText: stringOrNode, // title for the "clear" control
		clearable: _react2['default'].PropTypes.bool, // should it be possible to reset value
		delimiter: _react2['default'].PropTypes.string, // delimiter to use to join multiple values for the hidden field value
		disabled: _react2['default'].PropTypes.bool, // whether the Select is disabled or not
		escapeClearsValue: _react2['default'].PropTypes.bool, // whether escape clears the value when the menu is closed
		filterOption: _react2['default'].PropTypes.func, // method to filter a single option (option, filterString)
		filterOptions: _react2['default'].PropTypes.any, // boolean to enable default filtering or function to filter the options array ([options], filterString, [values])
		ignoreAccents: _react2['default'].PropTypes.bool, // whether to strip diacritics when filtering
		ignoreCase: _react2['default'].PropTypes.bool, // whether to perform case-insensitive filtering
		inputProps: _react2['default'].PropTypes.object, // custom attributes for the Input
		inputRenderer: _react2['default'].PropTypes.func, // returns a custom input component
		instanceId: _react2['default'].PropTypes.string, // set the components instanceId
		isLoading: _react2['default'].PropTypes.bool, // whether the Select is loading externally or not (such as options being loaded)
		joinValues: _react2['default'].PropTypes.bool, // joins multiple values into a single form field with the delimiter (legacy mode)
		labelKey: _react2['default'].PropTypes.string, // path of the label value in option objects
		matchPos: _react2['default'].PropTypes.string, // (any|start) match the start or entire string when filtering
		matchProp: _react2['default'].PropTypes.string, // (any|label|value) which option property to filter on
		menuBuffer: _react2['default'].PropTypes.number, // optional buffer (in px) between the bottom of the viewport and the bottom of the menu
		menuContainerStyle: _react2['default'].PropTypes.object, // optional style to apply to the menu container
		menuRenderer: _react2['default'].PropTypes.func, // renders a custom menu with options
		menuStyle: _react2['default'].PropTypes.object, // optional style to apply to the menu
		multi: _react2['default'].PropTypes.bool, // multi-value input
		name: _react2['default'].PropTypes.string, // generates a hidden <input /> tag with this field name for html forms
		noResultsText: stringOrNode, // placeholder displayed when there are no matching search results
		onBlur: _react2['default'].PropTypes.func, // onBlur handler: function (event) {}
		onBlurResetsInput: _react2['default'].PropTypes.bool, // whether input is cleared on blur
		onChange: _react2['default'].PropTypes.func, // onChange handler: function (newValue) {}
		onClose: _react2['default'].PropTypes.func, // fires when the menu is closed
		onCloseResetsInput: _react2['default'].PropTypes.bool, // whether input is cleared when menu is closed through the arrow
		onFocus: _react2['default'].PropTypes.func, // onFocus handler: function (event) {}
		onInputChange: _react2['default'].PropTypes.func, // onInputChange handler: function (inputValue) {}
		onInputKeyDown: _react2['default'].PropTypes.func, // input keyDown handler: function (event) {}
		onMenuScrollToBottom: _react2['default'].PropTypes.func, // fires when the menu is scrolled to the bottom; can be used to paginate options
		onOpen: _react2['default'].PropTypes.func, // fires when the menu is opened
		onValueClick: _react2['default'].PropTypes.func, // onClick handler for value labels: function (value, event) {}
		openAfterFocus: _react2['default'].PropTypes.bool, // boolean to enable opening dropdown when focused
		openOnFocus: _react2['default'].PropTypes.bool, // always open options menu on focus
		optionClassName: _react2['default'].PropTypes.string, // additional class(es) to apply to the <Option /> elements
		optionComponent: _react2['default'].PropTypes.func, // option component to render in dropdown
		optionRenderer: _react2['default'].PropTypes.func, // optionRenderer: function (option) {}
		options: _react2['default'].PropTypes.array, // array of options
		pageSize: _react2['default'].PropTypes.number, // number of entries to page when using page up/down keys
		placeholder: stringOrNode, // field placeholder, displayed when there's no value
		required: _react2['default'].PropTypes.bool, // applies HTML5 required attribute when needed
		resetValue: _react2['default'].PropTypes.any, // value to use when you clear the control
		scrollMenuIntoView: _react2['default'].PropTypes.bool, // boolean to enable the viewport to shift so that the full menu fully visible when engaged
		searchable: _react2['default'].PropTypes.bool, // whether to enable searching feature or not
		simpleValue: _react2['default'].PropTypes.bool, // pass the value to onChange as a simple value (legacy pre 1.0 mode), defaults to false
		style: _react2['default'].PropTypes.object, // optional style to apply to the control
		tabIndex: _react2['default'].PropTypes.string, // optional tab index of the control
		tabSelectsValue: _react2['default'].PropTypes.bool, // whether to treat tabbing out while focused to be value selection
		value: _react2['default'].PropTypes.any, // initial field value
		valueComponent: _react2['default'].PropTypes.func, // value component to render
		valueKey: _react2['default'].PropTypes.string, // path of the label value in option objects
		valueRenderer: _react2['default'].PropTypes.func, // valueRenderer: function (option) {}
		wrapperStyle: _react2['default'].PropTypes.object },

	// optional style to apply to the component wrapper
	statics: { Async: _Async2['default'], AsyncCreatable: _AsyncCreatable2['default'], Creatable: _Creatable2['default'] },

	getDefaultProps: function getDefaultProps() {
		return {
			addLabelText: 'Add "{label}"?',
			arrowRenderer: _utilsDefaultArrowRenderer2['default'],
			autosize: true,
			backspaceRemoves: true,
			backspaceToRemoveMessage: 'Press backspace to remove {label}',
			clearable: true,
			clearAllText: 'Clear all',
			clearValueText: 'Clear value',
			delimiter: ',',
			disabled: false,
			escapeClearsValue: true,
			filterOptions: _utilsDefaultFilterOptions2['default'],
			ignoreAccents: true,
			ignoreCase: true,
			inputProps: {},
			isLoading: false,
			joinValues: false,
			labelKey: 'label',
			matchPos: 'any',
			matchProp: 'any',
			menuBuffer: 0,
			menuRenderer: _utilsDefaultMenuRenderer2['default'],
			multi: false,
			noResultsText: 'No results found',
			onBlurResetsInput: true,
			onCloseResetsInput: true,
			openAfterFocus: false,
			optionComponent: _Option2['default'],
			pageSize: 5,
			placeholder: 'Select...',
			required: false,
			scrollMenuIntoView: true,
			searchable: true,
			simpleValue: false,
			tabSelectsValue: true,
			valueComponent: _Value2['default'],
			valueKey: 'value'
		};
	},

	getInitialState: function getInitialState() {
		return {
			inputValue: '',
			isFocused: false,
			isOpen: false,
			isPseudoFocused: false,
			required: false
		};
	},

	componentWillMount: function componentWillMount() {
		this._instancePrefix = 'react-select-' + (this.props.instanceId || ++instanceId) + '-';
		var valueArray = this.getValueArray(this.props.value);

		if (this.props.required) {
			this.setState({
				required: this.handleRequired(valueArray[0], this.props.multi)
			});
		}
	},

	componentDidMount: function componentDidMount() {
		if (this.props.autofocus) {
			this.focus();
		}
	},

	componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
		var valueArray = this.getValueArray(nextProps.value, nextProps);

		if (nextProps.required) {
			this.setState({
				required: this.handleRequired(valueArray[0], nextProps.multi)
			});
		}
	},

	componentWillUpdate: function componentWillUpdate(nextProps, nextState) {
		if (nextState.isOpen !== this.state.isOpen) {
			this.toggleTouchOutsideEvent(nextState.isOpen);
			var handler = nextState.isOpen ? nextProps.onOpen : nextProps.onClose;
			handler && handler();
		}
	},

	componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
		// focus to the selected option
		if (this.menu && this.focused && this.state.isOpen && !this.hasScrolledToOption) {
			var focusedOptionNode = _reactDom2['default'].findDOMNode(this.focused);
			var menuNode = _reactDom2['default'].findDOMNode(this.menu);
			menuNode.scrollTop = focusedOptionNode.offsetTop;
			this.hasScrolledToOption = true;
		} else if (!this.state.isOpen) {
			this.hasScrolledToOption = false;
		}

		if (this._scrollToFocusedOptionOnUpdate && this.focused && this.menu) {
			this._scrollToFocusedOptionOnUpdate = false;
			var focusedDOM = _reactDom2['default'].findDOMNode(this.focused);
			var menuDOM = _reactDom2['default'].findDOMNode(this.menu);
			var focusedRect = focusedDOM.getBoundingClientRect();
			var menuRect = menuDOM.getBoundingClientRect();
			if (focusedRect.bottom > menuRect.bottom || focusedRect.top < menuRect.top) {
				menuDOM.scrollTop = focusedDOM.offsetTop + focusedDOM.clientHeight - menuDOM.offsetHeight;
			}
		}
		if (this.props.scrollMenuIntoView && this.menuContainer) {
			var menuContainerRect = this.menuContainer.getBoundingClientRect();
			if (window.innerHeight < menuContainerRect.bottom + this.props.menuBuffer) {
				window.scrollBy(0, menuContainerRect.bottom + this.props.menuBuffer - window.innerHeight);
			}
		}
		if (prevProps.disabled !== this.props.disabled) {
			this.setState({ isFocused: false }); // eslint-disable-line react/no-did-update-set-state
			this.closeMenu();
		}
	},

	componentWillUnmount: function componentWillUnmount() {
		document.removeEventListener('touchstart', this.handleTouchOutside);
	},

	toggleTouchOutsideEvent: function toggleTouchOutsideEvent(enabled) {
		if (enabled) {
			document.addEventListener('touchstart', this.handleTouchOutside);
		} else {
			document.removeEventListener('touchstart', this.handleTouchOutside);
		}
	},

	handleTouchOutside: function handleTouchOutside(event) {
		// handle touch outside on ios to dismiss menu
		if (this.wrapper && !this.wrapper.contains(event.target)) {
			this.closeMenu();
		}
	},

	focus: function focus() {
		if (!this.input) return;
		this.input.focus();

		if (this.props.openAfterFocus) {
			this.setState({
				isOpen: true
			});
		}
	},

	blurInput: function blurInput() {
		if (!this.input) return;
		this.input.blur();
	},

	handleTouchMove: function handleTouchMove(event) {
		// Set a flag that the view is being dragged
		this.dragging = true;
	},

	handleTouchStart: function handleTouchStart(event) {
		// Set a flag that the view is not being dragged
		this.dragging = false;
	},

	handleTouchEnd: function handleTouchEnd(event) {
		// Check if the view is being dragged, In this case
		// we don't want to fire the click event (because the user only wants to scroll)
		if (this.dragging) return;

		// Fire the mouse events
		this.handleMouseDown(event);
	},

	handleTouchEndClearValue: function handleTouchEndClearValue(event) {
		// Check if the view is being dragged, In this case
		// we don't want to fire the click event (because the user only wants to scroll)
		if (this.dragging) return;

		// Clear the value
		this.clearValue(event);
	},

	handleMouseDown: function handleMouseDown(event) {
		// if the event was triggered by a mousedown and not the primary
		// button, or if the component is disabled, ignore it.
		if (this.props.disabled || event.type === 'mousedown' && event.button !== 0) {
			return;
		}

		if (event.target.tagName === 'INPUT') {
			return;
		}

		// prevent default event handlers
		event.stopPropagation();
		event.preventDefault();

		// for the non-searchable select, toggle the menu
		if (!this.props.searchable) {
			this.focus();
			return this.setState({
				isOpen: !this.state.isOpen
			});
		}

		if (this.state.isFocused) {
			// On iOS, we can get into a state where we think the input is focused but it isn't really,
			// since iOS ignores programmatic calls to input.focus() that weren't triggered by a click event.
			// Call focus() again here to be safe.
			this.focus();

			var input = this.input;
			if (typeof input.getInput === 'function') {
				// Get the actual DOM input if the ref is an <AutosizeInput /> component
				input = input.getInput();
			}

			// clears the value so that the cursor will be at the end of input when the component re-renders
			input.value = '';

			// if the input is focused, ensure the menu is open
			this.setState({
				isOpen: true,
				isPseudoFocused: false
			});
		} else {
			// otherwise, focus the input and open the menu
			this._openAfterFocus = true;
			this.focus();
		}
	},

	handleMouseDownOnArrow: function handleMouseDownOnArrow(event) {
		// if the event was triggered by a mousedown and not the primary
		// button, or if the component is disabled, ignore it.
		if (this.props.disabled || event.type === 'mousedown' && event.button !== 0) {
			return;
		}
		// If the menu isn't open, let the event bubble to the main handleMouseDown
		if (!this.state.isOpen) {
			return;
		}
		// prevent default event handlers
		event.stopPropagation();
		event.preventDefault();
		// close the menu
		this.closeMenu();
	},

	handleMouseDownOnMenu: function handleMouseDownOnMenu(event) {
		// if the event was triggered by a mousedown and not the primary
		// button, or if the component is disabled, ignore it.
		if (this.props.disabled || event.type === 'mousedown' && event.button !== 0) {
			return;
		}
		event.stopPropagation();
		event.preventDefault();

		this._openAfterFocus = true;
		this.focus();
	},

	closeMenu: function closeMenu() {
		if (this.props.onCloseResetsInput) {
			this.setState({
				isOpen: false,
				isPseudoFocused: this.state.isFocused && !this.props.multi,
				inputValue: ''
			});
		} else {
			this.setState({
				isOpen: false,
				isPseudoFocused: this.state.isFocused && !this.props.multi,
				inputValue: this.state.inputValue
			});
		}
		this.hasScrolledToOption = false;
	},

	handleInputFocus: function handleInputFocus(event) {
		if (this.props.disabled) return;
		var isOpen = this.state.isOpen || this._openAfterFocus || this.props.openOnFocus;
		if (this.props.onFocus) {
			this.props.onFocus(event);
		}
		this.setState({
			isFocused: true,
			isOpen: isOpen
		});
		this._openAfterFocus = false;
	},

	handleInputBlur: function handleInputBlur(event) {
		// The check for menu.contains(activeElement) is necessary to prevent IE11's scrollbar from closing the menu in certain contexts.
		if (this.menu && (this.menu === document.activeElement || this.menu.contains(document.activeElement))) {
			this.focus();
			return;
		}

		if (this.props.onBlur) {
			this.props.onBlur(event);
		}
		var onBlurredState = {
			isFocused: false,
			isOpen: false,
			isPseudoFocused: false
		};
		if (this.props.onBlurResetsInput) {
			onBlurredState.inputValue = '';
		}
		this.setState(onBlurredState);
	},

	handleInputChange: function handleInputChange(event) {
		var newInputValue = event.target.value;

		if (this.state.inputValue !== event.target.value && this.props.onInputChange) {
			var nextState = this.props.onInputChange(newInputValue);
			// Note: != used deliberately here to catch undefined and null
			if (nextState != null && typeof nextState !== 'object') {
				newInputValue = '' + nextState;
			}
		}

		this.setState({
			isOpen: true,
			isPseudoFocused: false,
			inputValue: newInputValue
		});
	},

	handleKeyDown: function handleKeyDown(event) {
		if (this.props.disabled) return;

		if (typeof this.props.onInputKeyDown === 'function') {
			this.props.onInputKeyDown(event);
			if (event.defaultPrevented) {
				return;
			}
		}

		switch (event.keyCode) {
			case 8:
				// backspace
				if (!this.state.inputValue && this.props.backspaceRemoves) {
					event.preventDefault();
					this.popValue();
				}
				return;
			case 9:
				// tab
				if (event.shiftKey || !this.state.isOpen || !this.props.tabSelectsValue) {
					return;
				}
				this.selectFocusedOption();
				return;
			case 13:
				// enter
				if (!this.state.isOpen) return;
				event.stopPropagation();
				this.selectFocusedOption();
				break;
			case 27:
				// escape
				if (this.state.isOpen) {
					this.closeMenu();
					event.stopPropagation();
				} else if (this.props.clearable && this.props.escapeClearsValue) {
					this.clearValue(event);
					event.stopPropagation();
				}
				break;
			case 38:
				// up
				this.focusPreviousOption();
				break;
			case 40:
				// down
				this.focusNextOption();
				break;
			case 33:
				// page up
				this.focusPageUpOption();
				break;
			case 34:
				// page down
				this.focusPageDownOption();
				break;
			case 35:
				// end key
				if (event.shiftKey) {
					return;
				}
				this.focusEndOption();
				break;
			case 36:
				// home key
				if (event.shiftKey) {
					return;
				}
				this.focusStartOption();
				break;
			default:
				return;
		}
		event.preventDefault();
	},

	handleValueClick: function handleValueClick(option, event) {
		if (!this.props.onValueClick) return;
		this.props.onValueClick(option, event);
	},

	handleMenuScroll: function handleMenuScroll(event) {
		if (!this.props.onMenuScrollToBottom) return;
		var target = event.target;

		if (target.scrollHeight > target.offsetHeight && !(target.scrollHeight - target.offsetHeight - target.scrollTop)) {
			this.props.onMenuScrollToBottom();
		}
	},

	handleRequired: function handleRequired(value, multi) {
		if (!value) return true;
		return multi ? value.length === 0 : Object.keys(value).length === 0;
	},

	getOptionLabel: function getOptionLabel(op) {
		return op[this.props.labelKey];
	},

	/**
  * Turns a value into an array from the given options
  * @param	{String|Number|Array}	value		- the value of the select input
  * @param	{Object}		nextProps	- optionally specify the nextProps so the returned array uses the latest configuration
  * @returns	{Array}	the value of the select represented in an array
  */
	getValueArray: function getValueArray(value, nextProps) {
		var _this = this;

		/** support optionally passing in the `nextProps` so `componentWillReceiveProps` updates will function as expected */
		var props = typeof nextProps === 'object' ? nextProps : this.props;
		if (props.multi) {
			if (typeof value === 'string') value = value.split(props.delimiter);
			if (!Array.isArray(value)) {
				if (value === null || value === undefined) return [];
				value = [value];
			}
			return value.map(function (value) {
				return _this.expandValue(value, props);
			}).filter(function (i) {
				return i;
			});
		}
		var expandedValue = this.expandValue(value, props);
		return expandedValue ? [expandedValue] : [];
	},

	/**
  * Retrieve a value from the given options and valueKey
  * @param	{String|Number|Array}	value	- the selected value(s)
  * @param	{Object}		props	- the Select component's props (or nextProps)
  */
	expandValue: function expandValue(value, props) {
		var valueType = typeof value;
		if (valueType !== 'string' && valueType !== 'number' && valueType !== 'boolean') return value;
		var options = props.options;
		var valueKey = props.valueKey;

		if (!options) return;
		for (var i = 0; i < options.length; i++) {
			if (options[i][valueKey] === value) return options[i];
		}
	},

	setValue: function setValue(value) {
		var _this2 = this;

		if (this.props.autoBlur) {
			this.blurInput();
		}
		if (!this.props.onChange) return;
		if (this.props.required) {
			var required = this.handleRequired(value, this.props.multi);
			this.setState({ required: required });
		}
		if (this.props.simpleValue && value) {
			value = this.props.multi ? value.map(function (i) {
				return i[_this2.props.valueKey];
			}).join(this.props.delimiter) : value[this.props.valueKey];
		}
		this.props.onChange(value);
	},

	selectValue: function selectValue(value) {
		var _this3 = this;

		//NOTE: update value in the callback to make sure the input value is empty so that there are no styling issues (Chrome had issue otherwise)
		this.hasScrolledToOption = false;
		if (this.props.multi) {
			this.setState({
				inputValue: '',
				focusedIndex: null
			}, function () {
				_this3.addValue(value);
			});
		} else {
			this.setState({
				isOpen: false,
				inputValue: '',
				isPseudoFocused: this.state.isFocused
			}, function () {
				_this3.setValue(value);
			});
		}
	},

	addValue: function addValue(value) {
		var valueArray = this.getValueArray(this.props.value);
		this.setValue(valueArray.concat(value));
	},

	popValue: function popValue() {
		var valueArray = this.getValueArray(this.props.value);
		if (!valueArray.length) return;
		if (valueArray[valueArray.length - 1].clearableValue === false) return;
		this.setValue(valueArray.slice(0, valueArray.length - 1));
	},

	removeValue: function removeValue(value) {
		var valueArray = this.getValueArray(this.props.value);
		this.setValue(valueArray.filter(function (i) {
			return i !== value;
		}));
		this.focus();
	},

	clearValue: function clearValue(event) {
		// if the event was triggered by a mousedown and not the primary
		// button, ignore it.
		if (event && event.type === 'mousedown' && event.button !== 0) {
			return;
		}
		event.stopPropagation();
		event.preventDefault();
		this.setValue(this.getResetValue());
		this.setState({
			isOpen: false,
			inputValue: ''
		}, this.focus);
	},

	getResetValue: function getResetValue() {
		if (this.props.resetValue !== undefined) {
			return this.props.resetValue;
		} else if (this.props.multi) {
			return [];
		} else {
			return null;
		}
	},

	focusOption: function focusOption(option) {
		this.setState({
			focusedOption: option
		});
	},

	focusNextOption: function focusNextOption() {
		this.focusAdjacentOption('next');
	},

	focusPreviousOption: function focusPreviousOption() {
		this.focusAdjacentOption('previous');
	},

	focusPageUpOption: function focusPageUpOption() {
		this.focusAdjacentOption('page_up');
	},

	focusPageDownOption: function focusPageDownOption() {
		this.focusAdjacentOption('page_down');
	},

	focusStartOption: function focusStartOption() {
		this.focusAdjacentOption('start');
	},

	focusEndOption: function focusEndOption() {
		this.focusAdjacentOption('end');
	},

	focusAdjacentOption: function focusAdjacentOption(dir) {
		var options = this._visibleOptions.map(function (option, index) {
			return { option: option, index: index };
		}).filter(function (option) {
			return !option.option.disabled;
		});
		this._scrollToFocusedOptionOnUpdate = true;
		if (!this.state.isOpen) {
			this.setState({
				isOpen: true,
				inputValue: '',
				focusedOption: this._focusedOption || options[dir === 'next' ? 0 : options.length - 1].option
			});
			return;
		}
		if (!options.length) return;
		var focusedIndex = -1;
		for (var i = 0; i < options.length; i++) {
			if (this._focusedOption === options[i].option) {
				focusedIndex = i;
				break;
			}
		}
		if (dir === 'next' && focusedIndex !== -1) {
			focusedIndex = (focusedIndex + 1) % options.length;
		} else if (dir === 'previous') {
			if (focusedIndex > 0) {
				focusedIndex = focusedIndex - 1;
			} else {
				focusedIndex = options.length - 1;
			}
		} else if (dir === 'start') {
			focusedIndex = 0;
		} else if (dir === 'end') {
			focusedIndex = options.length - 1;
		} else if (dir === 'page_up') {
			var potentialIndex = focusedIndex - this.props.pageSize;
			if (potentialIndex < 0) {
				focusedIndex = 0;
			} else {
				focusedIndex = potentialIndex;
			}
		} else if (dir === 'page_down') {
			var potentialIndex = focusedIndex + this.props.pageSize;
			if (potentialIndex > options.length - 1) {
				focusedIndex = options.length - 1;
			} else {
				focusedIndex = potentialIndex;
			}
		}

		if (focusedIndex === -1) {
			focusedIndex = 0;
		}

		this.setState({
			focusedIndex: options[focusedIndex].index,
			focusedOption: options[focusedIndex].option
		});
	},

	getFocusedOption: function getFocusedOption() {
		return this._focusedOption;
	},

	getInputValue: function getInputValue() {
		return this.state.inputValue;
	},

	selectFocusedOption: function selectFocusedOption() {
		if (this._focusedOption) {
			return this.selectValue(this._focusedOption);
		}
	},

	renderLoading: function renderLoading() {
		if (!this.props.isLoading) return;
		return _react2['default'].createElement(
			'span',
			{ className: 'Select-loading-zone', 'aria-hidden': 'true' },
			_react2['default'].createElement('span', { className: 'Select-loading' })
		);
	},

	renderValue: function renderValue(valueArray, isOpen) {
		var _this4 = this;

		var renderLabel = this.props.valueRenderer || this.getOptionLabel;
		var ValueComponent = this.props.valueComponent;
		if (!valueArray.length) {
			return !this.state.inputValue ? _react2['default'].createElement(
				'div',
				{ className: 'Select-placeholder' },
				this.props.placeholder
			) : null;
		}
		var onClick = this.props.onValueClick ? this.handleValueClick : null;
		if (this.props.multi) {
			return valueArray.map(function (value, i) {
				return _react2['default'].createElement(
					ValueComponent,
					{
						id: _this4._instancePrefix + '-value-' + i,
						instancePrefix: _this4._instancePrefix,
						disabled: _this4.props.disabled || value.clearableValue === false,
						key: 'value-' + i + '-' + value[_this4.props.valueKey],
						onClick: onClick,
						onRemove: _this4.removeValue,
						value: value
					},
					renderLabel(value, i),
					_react2['default'].createElement(
						'span',
						{ className: 'Select-aria-only' },
						' '
					)
				);
			});
		} else if (!this.state.inputValue) {
			if (isOpen) onClick = null;
			return _react2['default'].createElement(
				ValueComponent,
				{
					id: this._instancePrefix + '-value-item',
					disabled: this.props.disabled,
					instancePrefix: this._instancePrefix,
					onClick: onClick,
					value: valueArray[0]
				},
				renderLabel(valueArray[0])
			);
		}
	},

	renderInput: function renderInput(valueArray, focusedOptionIndex) {
		var _this5 = this;

		if (this.props.inputRenderer) {
			return this.props.inputRenderer();
		} else {
			var _classNames;

			var className = (0, _classnames2['default'])('Select-input', this.props.inputProps.className);
			var isOpen = !!this.state.isOpen;

			var ariaOwns = (0, _classnames2['default'])((_classNames = {}, _defineProperty(_classNames, this._instancePrefix + '-list', isOpen), _defineProperty(_classNames, this._instancePrefix + '-backspace-remove-message', this.props.multi && !this.props.disabled && this.state.isFocused && !this.state.inputValue), _classNames));

			// TODO: Check how this project includes Object.assign()
			var inputProps = _extends({}, this.props.inputProps, {
				role: 'combobox',
				'aria-expanded': '' + isOpen,
				'aria-owns': ariaOwns,
				'aria-haspopup': '' + isOpen,
				'aria-activedescendant': isOpen ? this._instancePrefix + '-option-' + focusedOptionIndex : this._instancePrefix + '-value',
				'aria-labelledby': this.props['aria-labelledby'],
				'aria-label': this.props['aria-label'],
				className: className,
				tabIndex: this.props.tabIndex,
				onBlur: this.handleInputBlur,
				onChange: this.handleInputChange,
				onFocus: this.handleInputFocus,
				ref: function ref(_ref) {
					return _this5.input = _ref;
				},
				required: this.state.required,
				value: this.state.inputValue
			});

			if (this.props.disabled || !this.props.searchable) {
				var _props$inputProps = this.props.inputProps;
				var inputClassName = _props$inputProps.inputClassName;

				var divProps = _objectWithoutProperties(_props$inputProps, ['inputClassName']);

				return _react2['default'].createElement('div', _extends({}, divProps, {
					role: 'combobox',
					'aria-expanded': isOpen,
					'aria-owns': isOpen ? this._instancePrefix + '-list' : this._instancePrefix + '-value',
					'aria-activedescendant': isOpen ? this._instancePrefix + '-option-' + focusedOptionIndex : this._instancePrefix + '-value',
					className: className,
					tabIndex: this.props.tabIndex || 0,
					onBlur: this.handleInputBlur,
					onFocus: this.handleInputFocus,
					ref: function (ref) {
						return _this5.input = ref;
					},
					'aria-readonly': '' + !!this.props.disabled,
					style: { border: 0, width: 1, display: 'inline-block' } }));
			}

			if (this.props.autosize) {
				return _react2['default'].createElement(_reactInputAutosize2['default'], _extends({}, inputProps, { minWidth: '5px' }));
			}
			return _react2['default'].createElement(
				'div',
				{ className: className },
				_react2['default'].createElement('input', inputProps)
			);
		}
	},

	renderClear: function renderClear() {
		if (!this.props.clearable || !this.props.value || this.props.value === 0 || this.props.multi && !this.props.value.length || this.props.disabled || this.props.isLoading) return;
		return _react2['default'].createElement(
			'span',
			{ className: 'Select-clear-zone', title: this.props.multi ? this.props.clearAllText : this.props.clearValueText,
				'aria-label': this.props.multi ? this.props.clearAllText : this.props.clearValueText,
				onMouseDown: this.clearValue,
				onTouchStart: this.handleTouchStart,
				onTouchMove: this.handleTouchMove,
				onTouchEnd: this.handleTouchEndClearValue
			},
			_react2['default'].createElement('span', { className: 'Select-clear', dangerouslySetInnerHTML: { __html: '&times;' } })
		);
	},

	renderArrow: function renderArrow() {
		var onMouseDown = this.handleMouseDownOnArrow;
		var arrow = this.props.arrowRenderer({ onMouseDown: onMouseDown });

		return _react2['default'].createElement(
			'span',
			{
				className: 'Select-arrow-zone',
				onMouseDown: onMouseDown
			},
			arrow
		);
	},

	filterOptions: function filterOptions(excludeOptions) {
		var filterValue = this.state.inputValue;
		var options = this.props.options || [];
		if (this.props.filterOptions) {
			// Maintain backwards compatibility with boolean attribute
			var filterOptions = typeof this.props.filterOptions === 'function' ? this.props.filterOptions : _utilsDefaultFilterOptions2['default'];

			return filterOptions(options, filterValue, excludeOptions, {
				filterOption: this.props.filterOption,
				ignoreAccents: this.props.ignoreAccents,
				ignoreCase: this.props.ignoreCase,
				labelKey: this.props.labelKey,
				matchPos: this.props.matchPos,
				matchProp: this.props.matchProp,
				valueKey: this.props.valueKey
			});
		} else {
			return options;
		}
	},

	onOptionRef: function onOptionRef(ref, isFocused) {
		if (isFocused) {
			this.focused = ref;
		}
	},

	renderMenu: function renderMenu(options, valueArray, focusedOption) {
		if (options && options.length) {
			return this.props.menuRenderer({
				focusedOption: focusedOption,
				focusOption: this.focusOption,
				instancePrefix: this._instancePrefix,
				labelKey: this.props.labelKey,
				onFocus: this.focusOption,
				onSelect: this.selectValue,
				optionClassName: this.props.optionClassName,
				optionComponent: this.props.optionComponent,
				optionRenderer: this.props.optionRenderer || this.getOptionLabel,
				options: options,
				selectValue: this.selectValue,
				valueArray: valueArray,
				valueKey: this.props.valueKey,
				onOptionRef: this.onOptionRef
			});
		} else if (this.props.noResultsText) {
			return _react2['default'].createElement(
				'div',
				{ className: 'Select-noresults' },
				this.props.noResultsText
			);
		} else {
			return null;
		}
	},

	renderHiddenField: function renderHiddenField(valueArray) {
		var _this6 = this;

		if (!this.props.name) return;
		if (this.props.joinValues) {
			var value = valueArray.map(function (i) {
				return stringifyValue(i[_this6.props.valueKey]);
			}).join(this.props.delimiter);
			return _react2['default'].createElement('input', {
				type: 'hidden',
				ref: function (ref) {
					return _this6.value = ref;
				},
				name: this.props.name,
				value: value,
				disabled: this.props.disabled });
		}
		return valueArray.map(function (item, index) {
			return _react2['default'].createElement('input', { key: 'hidden.' + index,
				type: 'hidden',
				ref: 'value' + index,
				name: _this6.props.name,
				value: stringifyValue(item[_this6.props.valueKey]),
				disabled: _this6.props.disabled });
		});
	},

	getFocusableOptionIndex: function getFocusableOptionIndex(selectedOption) {
		var options = this._visibleOptions;
		if (!options.length) return null;

		var focusedOption = this.state.focusedOption || selectedOption;
		if (focusedOption && !focusedOption.disabled) {
			var focusedOptionIndex = options.indexOf(focusedOption);
			if (focusedOptionIndex !== -1) {
				return focusedOptionIndex;
			}
		}

		for (var i = 0; i < options.length; i++) {
			if (!options[i].disabled) return i;
		}
		return null;
	},

	renderOuter: function renderOuter(options, valueArray, focusedOption) {
		var _this7 = this;

		var menu = this.renderMenu(options, valueArray, focusedOption);
		if (!menu) {
			return null;
		}

		return _react2['default'].createElement(
			'div',
			{ ref: function (ref) {
					return _this7.menuContainer = ref;
				}, className: 'Select-menu-outer', style: this.props.menuContainerStyle },
			_react2['default'].createElement(
				'div',
				{ ref: function (ref) {
						return _this7.menu = ref;
					}, role: 'listbox', className: 'Select-menu', id: this._instancePrefix + '-list',
					style: this.props.menuStyle,
					onScroll: this.handleMenuScroll,
					onMouseDown: this.handleMouseDownOnMenu },
				menu
			)
		);
	},

	render: function render() {
		var _this8 = this;

		var valueArray = this.getValueArray(this.props.value);
		var options = this._visibleOptions = this.filterOptions(this.props.multi ? this.getValueArray(this.props.value) : null);
		var isOpen = this.state.isOpen;
		if (this.props.multi && !options.length && valueArray.length && !this.state.inputValue) isOpen = false;
		var focusedOptionIndex = this.getFocusableOptionIndex(valueArray[0]);

		var focusedOption = null;
		if (focusedOptionIndex !== null) {
			focusedOption = this._focusedOption = options[focusedOptionIndex];
		} else {
			focusedOption = this._focusedOption = null;
		}
		var className = (0, _classnames2['default'])('Select', this.props.className, {
			'Select--multi': this.props.multi,
			'Select--single': !this.props.multi,
			'is-disabled': this.props.disabled,
			'is-focused': this.state.isFocused,
			'is-loading': this.props.isLoading,
			'is-open': isOpen,
			'is-pseudo-focused': this.state.isPseudoFocused,
			'is-searchable': this.props.searchable,
			'has-value': valueArray.length
		});

		var removeMessage = null;
		if (this.props.multi && !this.props.disabled && valueArray.length && !this.state.inputValue && this.state.isFocused && this.props.backspaceRemoves) {
			removeMessage = _react2['default'].createElement(
				'span',
				{ id: this._instancePrefix + '-backspace-remove-message', className: 'Select-aria-only', 'aria-live': 'assertive' },
				this.props.backspaceToRemoveMessage.replace('{label}', valueArray[valueArray.length - 1][this.props.labelKey])
			);
		}

		return _react2['default'].createElement(
			'div',
			{ ref: function (ref) {
					return _this8.wrapper = ref;
				},
				className: className,
				style: this.props.wrapperStyle },
			this.renderHiddenField(valueArray),
			_react2['default'].createElement(
				'div',
				{ ref: function (ref) {
						return _this8.control = ref;
					},
					className: 'Select-control',
					style: this.props.style,
					onKeyDown: this.handleKeyDown,
					onMouseDown: this.handleMouseDown,
					onTouchEnd: this.handleTouchEnd,
					onTouchStart: this.handleTouchStart,
					onTouchMove: this.handleTouchMove
				},
				_react2['default'].createElement(
					'span',
					{ className: 'Select-multi-value-wrapper', id: this._instancePrefix + '-value' },
					this.renderValue(valueArray, isOpen),
					this.renderInput(valueArray, focusedOptionIndex)
				),
				removeMessage,
				this.renderLoading(),
				this.renderClear(),
				this.renderArrow()
			),
			isOpen ? this.renderOuter(options, !this.props.multi ? valueArray : null, focusedOption) : null
		);
	}

});

exports['default'] = Select;
module.exports = exports['default'];
});

var Select = unwrapExports(Select_1);

var _curry1$8 = _curry1$1;
var curryN$3 = curryN$1;


/**
 * Returns a curried equivalent of the provided function. The curried function
 * has two unusual capabilities. First, its arguments needn't be provided one
 * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value `R.__` may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is `R.__`, the
 * following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (* -> a) -> (* -> a)
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curryN
 * @example
 *
 *      var addFourNumbers = (a, b, c, d) => a + b + c + d;
 *
 *      var curriedAddFourNumbers = R.curry(addFourNumbers);
 *      var f = curriedAddFourNumbers(1, 2);
 *      var g = f(3);
 *      g(4); //=> 10
 */
var curry$1 = _curry1$8(function curry$1(fn) {
  return curryN$3(fn.length, fn);
});

/**
  type Validation
    = Success a
    | Failure b
 */

const types = {
  Just: Math.random(),
  Nothing: Math.random()
}; /* eslint-disable new-cap */


function Maybe$1(value, type) {
  // Check that a valid type is being used
  const isJust = value !== null && value !== undefined && type === types.Just;
  this.isJust = isJust;
  this.isNothing = !isJust;
  this.withDefault = defaultVal => isJust ? value : defaultVal;
  this.map = f => isJust ? Maybe$1.of(f(value)) : Maybe$1.Nothing();
  this.chain = f => this.map(f).withDefault(Maybe$1.Nothing());
}

// Static functions
Maybe$1.Just = v => new Maybe$1(v, types.Just);
Maybe$1.Nothing = _ => new Maybe$1(null, types.Nothing);
Maybe$1.of = Maybe$1.Just; // the function itself will take care of nulls and undefineds

Maybe$1.isJust = v => v.isJust;
Maybe$1.isNothing = v => v.isNothing;
Maybe$1.withDefault = curry$1((defaultVal, v) => v.withDefault(defaultVal));
Maybe$1.map = curry$1((f, v) => v.map(f));
Maybe$1.map2 = curry$1((f, v1, v2) => Maybe$1.isJust(v1) && Maybe$1.isJust(v2) ? Maybe$1.of(f(Maybe$1.withDefault(null, v1), Maybe$1.withDefault(null, v2))) : Maybe$1.Nothing());
Maybe$1.chain = curry$1((v, f) => v.chain(f));

const types$1 = {
  NotAsked: Math.random(),
  Loading: Math.random(),
  Failure: Math.random(),
  Success: Math.random()
};

const mapIf = curry$1((condition, value, f) => condition ? f(value) : value);

// =========================================
// INSTANCE FUNCTIONS
// =========================================
function RemoteData$1(value, type) {
  const isSuccess = type === types$1.Success;
  const isFailure = type === types$1.Failure;
  const isLoading = type === types$1.Loading;
  if (isFailure) {
    console.log('Failing with reason:', value);
  }

  this.isSuccess = isSuccess;
  this.isFailure = isFailure;
  this.isLoading = isLoading;
  this.isNotAsked = type === types$1.NotAsked;
  this.withDefault = elseVal => isSuccess ? value : elseVal;
  this.map = f => new RemoteData$1(mapIf(isSuccess, value, f), type);
  this.mapSuccess = f => new RemoteData$1(mapIf(isSuccess, value, f), type);
  this.mapLoading = f => new RemoteData$1(mapIf(isLoading, value, f), type);
  this.mapFailure = f => new RemoteData$1(mapIf(isFailure, value, f), type);
  this.toMaybe = _ => isSuccess ? Maybe$1.Just(value) : Maybe$1.Nothing(); // eslint-disable-line max-len, new-cap
  this._value = value; // JUST FOR DEBUGGING PURPOSES. DO NOT USE
}

// =========================================
// STATIC FUNCTIONS
// =========================================
RemoteData$1.NotAsked = _ => new RemoteData$1(null, types$1.NotAsked);
RemoteData$1.Loading = v => new RemoteData$1(v, types$1.Loading);
RemoteData$1.Failure = v => new RemoteData$1(v, types$1.Failure);
RemoteData$1.Success = v => new RemoteData$1(v, types$1.Success);

RemoteData$1.isNotAsked = v => v.isNotAsked;
RemoteData$1.isLoading = v => v.isLoading;
RemoteData$1.isFailure = v => v.isFailure;
RemoteData$1.isSuccess = v => v.isSuccess;
RemoteData$1.withDefault = curry$1((elseVal, v) => v.withDefault(elseVal));
RemoteData$1.map = curry$1((f, v) => v.map(f));
RemoteData$1.mapSuccess = curry$1((f, v) => v.mapSuccess(f));
RemoteData$1.mapLoading = curry$1((f, v) => v.mapLoading(f));
RemoteData$1.mapFailure = curry$1((f, v) => v.mapFailure(f));
RemoteData$1.toMaybe = v => v.toMaybe();

// Bug checking function that will throw an error whenever
// the condition sent to it is evaluated to false
/**
 * Processes the message and outputs the correct message if the condition
 * is false. Otherwise it outputs null.
 * @api private
 * @method processCondition
 * @param  {Boolean} condition - Result of the evaluated condition
 * @param  {String} errorMessage - Message explainig the error in case it is thrown
 * @return {String | null}  - Error message if there is an error, nul otherwise.
 */
function processCondition(condition, errorMessage) {
  if (!condition) {
    var completeErrorMessage = '';
    var re = /at ([^\s]+)\s\(/g;
    var stackTrace = new Error().stack;
    var stackFunctions = [];

    var funcName = re.exec(stackTrace);
    while (funcName && funcName[1]) {
      stackFunctions.push(funcName[1]);
      funcName = re.exec(stackTrace);
    }

    // Number 0 is processCondition itself,
    // Number 1 is assert,
    // Number 2 is the caller function.
    if (stackFunctions[2]) {
      completeErrorMessage = stackFunctions[2] + ': ' + completeErrorMessage;
    }

    completeErrorMessage += errorMessage;
    return completeErrorMessage;
  }

  return null;
}

/**
 * Throws an error if the boolean passed to it evaluates to false.
 * To be used like this:
 * 		assert(myDate !== undefined, "Date cannot be undefined.");
 * @api public
 * @method assert
 * @param  {Boolean} condition - Result of the evaluated condition
 * @param  {String} errorMessage - Message explainig the error in case it is thrown
 * @return void
 */
function assert(condition, errorMessage) {
  var error = processCondition(condition, errorMessage);
  if (typeof error === 'string') {
    throw new Error(error);
  }
}

/**
 * Logs a warning if the boolean passed to it evaluates to false.
 * To be used like this:
 * 		assert.warn(myDate !== undefined, "No date provided.");
 * @api public
 * @method warn
 * @param  {Boolean} condition - Result of the evaluated condition
 * @param  {String} errorMessage - Message explainig the error in case it is thrown
 * @return void
 */
assert.warn = function warn(condition, errorMessage) {
  var error = processCondition(condition, errorMessage);
  if (typeof error === 'string') {
    console.warn(error);
  }
};

/**
  type Validation
    = Success a
    | Failure b
 */

const types$2 = {
  Success: Math.random(),
  Failure: Math.random()
};

const mapIf$1 = curry$1((condition, value, f) => condition ? f(value) : value);

// This function should never be called by anyone other than this file.
function Validation$1(value, type) {
  // Check that a valid type is being used
  const isSuccess = type === types$2.Success;

  this.isSuccess = isSuccess;
  this.isFailure = !isSuccess;
  this.withDefault = defaultVal => isSuccess ? value : defaultVal;
  this.map = f => new Validation$1(mapIf$1(isSuccess, value, f), type);
  this.mapSuccess = f => new Validation$1(mapIf$1(isSuccess, value, f), type);
  this.mapFailure = f => new Validation$1(mapIf$1(!isSuccess, value, f), type);
  this.throwFailure = _ => !isSuccess ? assert(false, value) : this;
  this.andThen = f => {
    if (!isSuccess) {
      return this;
    }

    const val = f(value);
    assert(val instanceof Validation$1, 'Value returned by Validation.andThen is not of type Validation');
    return val;
  };
  // Validation -> Validation
  this.chain = v => {
    if (!isSuccess) {
      return this;
    }

    assert(v instanceof Validation$1, 'Value passed to Validation.chain is not of type Validation');

    return v;
  };
  // JUST FOR DEBUGGING PURPOSES. DO NOT USE
  this._value = value; // eslint-disable-line no-underscore-dangle
}

// Static functions
Validation$1.Success = v => new Validation$1(v, types$2.Success);
Validation$1.Failure = v => new Validation$1(v, types$2.Failure);

Validation$1.isSuccess = v => v.isSuccess;
Validation$1.isFailure = v => v.isFailure;
Validation$1.withDefault = curry$1((defaultVal, v) => v.withDefault(defaultVal));
Validation$1.map = curry$1((f, v) => v.map(f));
Validation$1.mapSuccess = curry$1((f, v) => v.mapSuccess(f));
Validation$1.mapFailure = curry$1((f, v) => v.mapFailure(f));
Validation$1.throwFailure = v => v.throwFailure();
Validation$1.andThen = curry$1((f, v) => v.andThen(f));
Validation$1.chain = curry$1((v1, v2) => v1.chain(v2));

var _curry1$9 = _curry1$1;


/**
 * Checks if the input value is `null` or `undefined`.
 *
 * @func
 * @memberOf R
 * @since v0.9.0
 * @category Type
 * @sig * -> Boolean
 * @param {*} x The value to test.
 * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
 * @example
 *
 *      R.isNil(null); //=> true
 *      R.isNil(undefined); //=> true
 *      R.isNil(0); //=> false
 *      R.isNil([]); //=> false
 */
var isNil = _curry1$9(function isNil(x) { return x == null; });

/* eslint-disable new-cap */
const errMsg = curry$1((prop, errorMessage) => `Invalid property value for ${ prop }. ${ errorMessage }`);

// All type checks return a Validation object.
// ===================================================================
//  General Type checkers
// ===================================================================

const int = v => typeof v === 'number' && v % 1 === 0 ? Validation$1.Success(v) : Validation$1.Failure(`${ v } is not an integer`);

const float = v => typeof v === 'number' ? Validation$1.Success(v) : Validation$1.Failure(`${ v } is not a float`);

const string = v => typeof v === 'string' ? Validation$1.Success(v) : Validation$1.Failure(`${ v } is not a string`);

const bool = v => typeof v === 'boolean' ? Validation$1.Success(v) : Validation$1.Failure(`${ v } is not a boolean`);

const nullType = v => typeof v === 'object' && v === null ? Validation$1.Success(v) : Validation$1.Failure(`${ v } is not null`);

const array = curry$1((subType, v) => {
  if (v instanceof Validation$1) {
    return Validation$1.andThen(array, v);
  }

  if (!Array.isArray(v)) {
    return Validation$1.Failure(`${ v } is not an array`);
  }

  const subTypesValidation = v.map(subType).reduce(Validation$1.chain, Validation$1.Success(v));

  if (Validation$1.isSuccess(subTypesValidation)) {
    return Validation$1.Success(v);
  }
  return Validation$1.mapFailure(errMsg('array'), subTypesValidation);
});

const date = v => v !== undefined && v instanceof Date ? Validation$1.Success(v) : Validation$1.Failure(`${ v } is not a Date`);

const nullable = curry$1((subType, v) => v === null ? Validation$1.Success(v) : subType(v));

const maybe = curry$1((subType, v) => typeof v === 'object' && Validation$1.isSuccess(bool(v.isNothing)) ? pipe$1(Maybe$1.map(subType), Maybe$1.map(Validation$1.map(_ => Validation$1.Success(v))), Maybe$1.withDefault(Validation$1.Success(v)))(v) : Validation$1.Failure(`${ v } is not of type Maybe`));

const remoteData = v => typeof v === 'object' && Validation$1.isSuccess(bool(v.isNotAsked)) ? Validation$1.Success(v) : Validation$1.Failure(`${ v } is not of type RemoteData.`);

const request = v => typeof v === 'object' && v instanceof Request ? Validation$1.Success(v) : Validation$1.Failure(`${ v } is not of type Request.`);

const response = v => typeof v === 'object' && v instanceof Response ? Validation$1.Success(v) : Validation$1.Failure(`${ v } is not of type Response.`);

const haveSameKeys = (o1, o2) => {
  const k1 = Object.keys(o1);
  const k2 = Object.keys(o2);
  return k1.reduce((out, key) => out && k2.includes(key), true);
};

const object = curry$1((typeSignature, v) => {
  if (isNil(v)) {
    return Validation$1.Failure(`${ v } is not of type object.`);
  }
  if (!haveSameKeys(typeSignature, v)) {
    return Validation$1.Failure(`Object does not have same keys as its type signature:
      Keys present: ${ Object.keys(v) }
      Keys expected: ${ Object.keys(typeSignature) }
      ${ v }`);
  }

  return Object.keys(typeSignature).reduce((outcome, key) => Validation$1.chain(outcome, pipe$1(typeSignature[key], Validation$1.mapFailure(errMsg(key)), Validation$1.mapSuccess(_ => v))(v[key])), Validation$1.Success(v));
});

var _typeCheckers = {
  int,
  float,
  string,
  bool,
  nullType,
  nullable,
  array,
  date,
  maybe,
  remoteData,
  request,
  response,
  object
};

var seamlessImmutable = createCommonjsModule(function (module, exports) {
(function() {
  "use strict";

  // https://github.com/facebook/react/blob/v15.0.1/src/isomorphic/classic/element/ReactElement.js#L21
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element');
  var REACT_ELEMENT_TYPE_FALLBACK = 0xeac7;

  function addPropertyTo(target, methodName, value) {
    Object.defineProperty(target, methodName, {
      enumerable: false,
      configurable: false,
      writable: false,
      value: value
    });
  }

  function banProperty(target, methodName) {
    addPropertyTo(target, methodName, function() {
      throw new ImmutableError("The " + methodName +
        " method cannot be invoked on an Immutable data structure.");
    });
  }

  var immutabilityTag = "__immutable_invariants_hold";

  function addImmutabilityTag(target) {
    addPropertyTo(target, immutabilityTag, true);
  }

  function isImmutable(target) {
    if (typeof target === "object") {
      return target === null || Boolean(
        Object.getOwnPropertyDescriptor(target, immutabilityTag)
      );
    } else {
      // In JavaScript, only objects are even potentially mutable.
      // strings, numbers, null, and undefined are all naturally immutable.
      return true;
    }
  }

  function isEqual(a, b) {
    // Avoid false positives due to (NaN !== NaN) evaluating to true
    return (a === b || (a !== a && b !== b));
  }

  function isMergableObject(target) {
    return target !== null && typeof target === "object" && !(Array.isArray(target)) && !(target instanceof Date);
  }

  var mutatingObjectMethods = [
    "setPrototypeOf"
  ];

  var nonMutatingObjectMethods = [
    "keys"
  ];

  var mutatingArrayMethods = mutatingObjectMethods.concat([
    "push", "pop", "sort", "splice", "shift", "unshift", "reverse"
  ]);

  var nonMutatingArrayMethods = nonMutatingObjectMethods.concat([
    "map", "filter", "slice", "concat", "reduce", "reduceRight"
  ]);

  var mutatingDateMethods = mutatingObjectMethods.concat([
    "setDate", "setFullYear", "setHours", "setMilliseconds", "setMinutes", "setMonth", "setSeconds",
    "setTime", "setUTCDate", "setUTCFullYear", "setUTCHours", "setUTCMilliseconds", "setUTCMinutes",
    "setUTCMonth", "setUTCSeconds", "setYear"
  ]);

  function ImmutableError(message) {
    var err       = new Error(message);
    // TODO: Consider `Object.setPrototypeOf(err, ImmutableError);`
    err.__proto__ = ImmutableError;

    return err;
  }
  ImmutableError.prototype = Error.prototype;

  function makeImmutable(obj, bannedMethods) {
    // Tag it so we can quickly tell it's immutable later.
    addImmutabilityTag(obj);

    {
      // Make all mutating methods throw exceptions.
      for (var index in bannedMethods) {
        if (bannedMethods.hasOwnProperty(index)) {
          banProperty(obj, bannedMethods[index]);
        }
      }

      // Freeze it and return it.
      Object.freeze(obj);
    }

    return obj;
  }

  function makeMethodReturnImmutable(obj, methodName) {
    var currentMethod = obj[methodName];

    addPropertyTo(obj, methodName, function() {
      return Immutable(currentMethod.apply(obj, arguments));
    });
  }

  function arraySet(idx, value, config) {
    var deep          = config && config.deep;

    if (idx in this) {
      if (deep && this[idx] !== value && isMergableObject(value) && isMergableObject(this[idx])) {
        value = this[idx].merge(value, {deep: true, mode: 'replace'});
      }
      if (isEqual(this[idx], value)) {
        return this;
      }
    }

    var mutable = asMutableArray.call(this);
    mutable[idx] = Immutable(value);
    return makeImmutableArray(mutable);
  }

  var immutableEmptyArray = Immutable([]);

  function arraySetIn(pth, value, config) {
    var head = pth[0];

    if (pth.length === 1) {
      return arraySet.call(this, head, value, config);
    } else {
      var tail = pth.slice(1);
      var thisHead = this[head];
      var newValue;

      if (typeof(thisHead) === "object" && thisHead !== null && typeof(thisHead.setIn) === "function") {
        // Might (validly) be object or array
        newValue = thisHead.setIn(tail, value);
      } else {
        var nextHead = tail[0];
        // If the next path part is a number, then we are setting into an array, else an object.
        if (nextHead !== '' && isFinite(nextHead)) {
          newValue = arraySetIn.call(immutableEmptyArray, tail, value);
        } else {
          newValue = objectSetIn.call(immutableEmptyObject, tail, value);
        }
      }

      if (head in this && thisHead === newValue) {
        return this;
      }

      var mutable = asMutableArray.call(this);
      mutable[head] = newValue;
      return makeImmutableArray(mutable);
    }
  }

  function makeImmutableArray(array) {
    // Don't change their implementations, but wrap these functions to make sure
    // they always return an immutable value.
    for (var index in nonMutatingArrayMethods) {
      if (nonMutatingArrayMethods.hasOwnProperty(index)) {
        var methodName = nonMutatingArrayMethods[index];
        makeMethodReturnImmutable(array, methodName);
      }
    }

    addPropertyTo(array, "flatMap",  flatMap);
    addPropertyTo(array, "asObject", asObject);
    addPropertyTo(array, "asMutable", asMutableArray);
    addPropertyTo(array, "set", arraySet);
    addPropertyTo(array, "setIn", arraySetIn);
    addPropertyTo(array, "update", update);
    addPropertyTo(array, "updateIn", updateIn);

    for(var i = 0, length = array.length; i < length; i++) {
      array[i] = Immutable(array[i]);
    }

    return makeImmutable(array, mutatingArrayMethods);
  }

  function makeImmutableDate(date) {
    addPropertyTo(date, "asMutable", asMutableDate);

    return makeImmutable(date, mutatingDateMethods);
  }

  function asMutableDate() {
    return new Date(this.getTime());
  }

  /**
   * Effectively performs a map() over the elements in the array, using the
   * provided iterator, except that whenever the iterator returns an array, that
   * array's elements are added to the final result instead of the array itself.
   *
   * @param {function} iterator - The iterator function that will be invoked on each element in the array. It will receive three arguments: the current value, the current index, and the current object.
   */
  function flatMap(iterator) {
    // Calling .flatMap() with no arguments is a no-op. Don't bother cloning.
    if (arguments.length === 0) {
      return this;
    }

    var result = [],
        length = this.length,
        index;

    for (index = 0; index < length; index++) {
      var iteratorResult = iterator(this[index], index, this);

      if (Array.isArray(iteratorResult)) {
        // Concatenate Array results into the return value we're building up.
        result.push.apply(result, iteratorResult);
      } else {
        // Handle non-Array results the same way map() does.
        result.push(iteratorResult);
      }
    }

    return makeImmutableArray(result);
  }

  /**
   * Returns an Immutable copy of the object without the given keys included.
   *
   * @param {array} keysToRemove - A list of strings representing the keys to exclude in the return value. Instead of providing a single array, this method can also be called by passing multiple strings as separate arguments.
   */
  function without(remove) {
    // Calling .without() with no arguments is a no-op. Don't bother cloning.
    if (typeof remove === "undefined" && arguments.length === 0) {
      return this;
    }

    if (typeof remove !== "function") {
      // If we weren't given an array, use the arguments list.
      var keysToRemoveArray = (Array.isArray(remove)) ?
         remove.slice() : Array.prototype.slice.call(arguments);

      // Convert numeric keys to strings since that's how they'll
      // come from the enumeration of the object.
      keysToRemoveArray.forEach(function(el, idx, arr) {
        if(typeof(el) === "number") {
          arr[idx] = el.toString();
        }
      });

      remove = function(val, key) {
        return keysToRemoveArray.indexOf(key) !== -1;
      };
    }

    var result = this.instantiateEmptyObject();

    for (var key in this) {
      if (this.hasOwnProperty(key) && remove(this[key], key) === false) {
        result[key] = this[key];
      }
    }

    return makeImmutableObject(result,
      {instantiateEmptyObject: this.instantiateEmptyObject});
  }

  function asMutableArray(opts) {
    var result = [], i, length;

    if(opts && opts.deep) {
      for(i = 0, length = this.length; i < length; i++) {
        result.push(asDeepMutable(this[i]));
      }
    } else {
      for(i = 0, length = this.length; i < length; i++) {
        result.push(this[i]);
      }
    }

    return result;
  }

  /**
   * Effectively performs a [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) over the elements in the array, expecting that the iterator function
   * will return an array of two elements - the first representing a key, the other
   * a value. Then returns an Immutable Object constructed of those keys and values.
   *
   * @param {function} iterator - A function which should return an array of two elements - the first representing the desired key, the other the desired value.
   */
  function asObject(iterator) {
    // If no iterator was provided, assume the identity function
    // (suggesting this array is already a list of key/value pairs.)
    if (typeof iterator !== "function") {
      iterator = function(value) { return value; };
    }

    var result = {},
        length = this.length,
        index;

    for (index = 0; index < length; index++) {
      var pair  = iterator(this[index], index, this),
          key   = pair[0],
          value = pair[1];

      result[key] = value;
    }

    return makeImmutableObject(result);
  }

  function asDeepMutable(obj) {
    if (
      (!obj) ||
      (typeof obj !== 'object') ||
      (!Object.getOwnPropertyDescriptor(obj, immutabilityTag)) ||
      (obj instanceof Date)
    ) { return obj; }
    return obj.asMutable({deep: true});
  }

  function quickCopy(src, dest) {
    for (var key in src) {
      if (Object.getOwnPropertyDescriptor(src, key)) {
        dest[key] = src[key];
      }
    }

    return dest;
  }

  /**
   * Returns an Immutable Object containing the properties and values of both
   * this object and the provided object, prioritizing the provided object's
   * values whenever the same key is present in both objects.
   *
   * @param {object} other - The other object to merge. Multiple objects can be passed as an array. In such a case, the later an object appears in that list, the higher its priority.
   * @param {object} config - Optional config object that contains settings. Supported settings are: {deep: true} for deep merge and {merger: mergerFunc} where mergerFunc is a function
   *                          that takes a property from both objects. If anything is returned it overrides the normal merge behaviour.
   */
  function merge(other, config) {
    // Calling .merge() with no arguments is a no-op. Don't bother cloning.
    if (arguments.length === 0) {
      return this;
    }

    if (other === null || (typeof other !== "object")) {
      throw new TypeError("Immutable#merge can only be invoked with objects or arrays, not " + JSON.stringify(other));
    }

    var receivedArray = (Array.isArray(other)),
        deep          = config && config.deep,
        mode          = config && config.mode || 'merge',
        merger        = config && config.merger,
        result;

    // Use the given key to extract a value from the given object, then place
    // that value in the result object under the same key. If that resulted
    // in a change from this object's value at that key, set anyChanges = true.
    function addToResult(currentObj, otherObj, key) {
      var immutableValue = Immutable(otherObj[key]);
      var mergerResult = merger && merger(currentObj[key], immutableValue, config);
      var currentValue = currentObj[key];

      if ((result !== undefined) ||
        (mergerResult !== undefined) ||
        (!currentObj.hasOwnProperty(key)) ||
        !isEqual(immutableValue, currentValue)) {

        var newValue;

        if (mergerResult) {
          newValue = mergerResult;
        } else if (deep && isMergableObject(currentValue) && isMergableObject(immutableValue)) {
          newValue = currentValue.merge(immutableValue, config);
        } else {
          newValue = immutableValue;
        }

        if (!isEqual(currentValue, newValue) || !currentObj.hasOwnProperty(key)) {
          if (result === undefined) {
            // Make a shallow clone of the current object.
            result = quickCopy(currentObj, currentObj.instantiateEmptyObject());
          }

          result[key] = newValue;
        }
      }
    }

    function clearDroppedKeys(currentObj, otherObj) {
      for (var key in currentObj) {
        if (!otherObj.hasOwnProperty(key)) {
          if (result === undefined) {
            // Make a shallow clone of the current object.
            result = quickCopy(currentObj, currentObj.instantiateEmptyObject());
          }
          delete result[key];
        }
      }
    }

    var key;

    // Achieve prioritization by overriding previous values that get in the way.
    if (!receivedArray) {
      // The most common use case: just merge one object into the existing one.
      for (key in other) {
        if (Object.getOwnPropertyDescriptor(other, key)) {
          addToResult(this, other, key);
        }
      }
      if (mode === 'replace') {
        clearDroppedKeys(this, other);
      }
    } else {
      // We also accept an Array
      for (var index = 0, length = other.length; index < length; index++) {
        var otherFromArray = other[index];

        for (key in otherFromArray) {
          if (otherFromArray.hasOwnProperty(key)) {
            addToResult(result !== undefined ? result : this, otherFromArray, key);
          }
        }
      }
    }

    if (result === undefined) {
      return this;
    } else {
      return makeImmutableObject(result,
        {instantiateEmptyObject: this.instantiateEmptyObject});
    }
  }

  function objectReplace(value, config) {
    var deep          = config && config.deep;

    // Calling .replace() with no arguments is a no-op. Don't bother cloning.
    if (arguments.length === 0) {
      return this;
    }

    if (value === null || typeof value !== "object") {
      throw new TypeError("Immutable#replace can only be invoked with objects or arrays, not " + JSON.stringify(value));
    }

    return this.merge(value, {deep: deep, mode: 'replace'});
  }

  var immutableEmptyObject = Immutable({});

  function objectSetIn(path, value, config) {
    var head = path[0];
    if (path.length === 1) {
      return objectSet.call(this, head, value, config);
    }

    var tail = path.slice(1);
    var newValue;
    var thisHead = this[head];

    if (this.hasOwnProperty(head) && typeof(thisHead) === "object" && thisHead !== null && typeof(thisHead.setIn) === "function") {
      // Might (validly) be object or array
      newValue = thisHead.setIn(tail, value);
    } else {
      newValue = objectSetIn.call(immutableEmptyObject, tail, value);
    }

    if (this.hasOwnProperty(head) && thisHead === newValue) {
      return this;
    }

    var mutable = quickCopy(this, this.instantiateEmptyObject());
    mutable[head] = newValue;
    return makeImmutableObject(mutable, this);
  }

  function objectSet(property, value, config) {
    var deep          = config && config.deep;

    if (this.hasOwnProperty(property)) {
      if (deep && this[property] !== value && isMergableObject(value) && isMergableObject(this[property])) {
        value = this[property].merge(value, {deep: true, mode: 'replace'});
      }
      if (isEqual(this[property], value)) {
        return this;
      }
    }

    var mutable = quickCopy(this, this.instantiateEmptyObject());
    mutable[property] = Immutable(value);
    return makeImmutableObject(mutable, this);
  }

  function update(property, updater) {
    var restArgs = Array.prototype.slice.call(arguments, 2);
    var initialVal = this[property];
    return this.set(property, updater.apply(initialVal, [initialVal].concat(restArgs)));
  }

  function getInPath(obj, path) {
    /*jshint eqnull:true */
    for (var i = 0, l = path.length; obj != null && i < l; i++) {
      obj = obj[path[i]];
    }

    return (i && i == l) ? obj : undefined;
  }

  function updateIn(path, updater) {
    var restArgs = Array.prototype.slice.call(arguments, 2);
    var initialVal = getInPath(this, path);

    return this.setIn(path, updater.apply(initialVal, [initialVal].concat(restArgs)));
  }

  function asMutableObject(opts) {
    var result = this.instantiateEmptyObject(), key;

    if(opts && opts.deep) {
      for (key in this) {
        if (this.hasOwnProperty(key)) {
          result[key] = asDeepMutable(this[key]);
        }
      }
    } else {
      for (key in this) {
        if (this.hasOwnProperty(key)) {
          result[key] = this[key];
        }
      }
    }

    return result;
  }

  // Creates plain object to be used for cloning
  function instantiatePlainObject() {
    return {};
  }

  // Finalizes an object with immutable methods, freezes it, and returns it.
  function makeImmutableObject(obj, options) {
    var instantiateEmptyObject =
      (options && options.instantiateEmptyObject) ?
        options.instantiateEmptyObject : instantiatePlainObject;

    addPropertyTo(obj, "merge", merge);
    addPropertyTo(obj, "replace", objectReplace);
    addPropertyTo(obj, "without", without);
    addPropertyTo(obj, "asMutable", asMutableObject);
    addPropertyTo(obj, "instantiateEmptyObject", instantiateEmptyObject);
    addPropertyTo(obj, "set", objectSet);
    addPropertyTo(obj, "setIn", objectSetIn);
    addPropertyTo(obj, "update", update);
    addPropertyTo(obj, "updateIn", updateIn);

    return makeImmutable(obj, mutatingObjectMethods);
  }

  // Returns true if object is a valid react element
  // https://github.com/facebook/react/blob/v15.0.1/src/isomorphic/classic/element/ReactElement.js#L326
  function isReactElement(obj) {
    return typeof obj === 'object' &&
           obj !== null &&
           (obj.$$typeof === REACT_ELEMENT_TYPE_FALLBACK || obj.$$typeof === REACT_ELEMENT_TYPE);
  }

  function Immutable(obj, options, stackRemaining) {
    if (isImmutable(obj) || isReactElement(obj)) {
      return obj;
    } else if (Array.isArray(obj)) {
      return makeImmutableArray(obj.slice());
    } else if (obj instanceof Date) {
      return makeImmutableDate(new Date(obj.getTime()));
    } else {
      // Don't freeze the object we were given; make a clone and use that.
      var prototype = options && options.prototype;
      var instantiateEmptyObject =
        (!prototype || prototype === Object.prototype) ?
          instantiatePlainObject : (function() { return Object.create(prototype); });
      var clone = instantiateEmptyObject();

      {
        /*jshint eqnull:true */
        if (stackRemaining == null) {
          stackRemaining = 64;
        }
        if (stackRemaining <= 0) {
          throw new ImmutableError("Attempt to construct Immutable from a deeply nested object was detected." +
            " Have you tried to wrap an object with circular references (e.g. React element)?" +
            " See https://github.com/rtfeldman/seamless-immutable/wiki/Deeply-nested-object-was-detected for details.");
        }
        stackRemaining -= 1;
      }

      for (var key in obj) {
        if (Object.getOwnPropertyDescriptor(obj, key)) {
          clone[key] = Immutable(obj[key], undefined, stackRemaining);
        }
      }

      return makeImmutableObject(clone,
        {instantiateEmptyObject: instantiateEmptyObject});
    }
  }

  // Wrapper to allow the use of object methods as static methods of Immutable.
  function toStatic(fn) {
    function staticWrapper() {
      var args = [].slice.call(arguments);
      var self = args.shift();
      return fn.apply(self, args);
    }

    return staticWrapper;
  }

  // Wrapper to allow the use of object methods as static methods of Immutable.
  // with the additional condition of choosing which function to call depending
  // if argument is an array or an object.
  function toStaticObjectOrArray(fnObject, fnArray) {
    function staticWrapper() {
      var args = [].slice.call(arguments);
      var self = args.shift();
      if (Array.isArray(self)) {
          return fnArray.apply(self, args);
      } else {
          return fnObject.apply(self, args);
      }
    }

    return staticWrapper;
  }

  // Export the library
  Immutable.from           = Immutable;
  Immutable.isImmutable    = isImmutable;
  Immutable.ImmutableError = ImmutableError;
  Immutable.merge          = toStatic(merge);
  Immutable.replace        = toStatic(objectReplace);
  Immutable.without        = toStatic(without);
  Immutable.asMutable      = toStaticObjectOrArray(asMutableObject, asMutableArray);
  Immutable.set            = toStaticObjectOrArray(objectSet, arraySet);
  Immutable.setIn          = toStaticObjectOrArray(objectSetIn, arraySetIn);
  Immutable.update         = toStatic(update);
  Immutable.updateIn       = toStatic(updateIn);
  Immutable.flatMap        = toStatic(flatMap);
  Immutable.asObject       = toStatic(asObject);

  Object.freeze(Immutable);

  /* istanbul ignore if */
  if (typeof module === "object") {
    module.exports = Immutable;
  } else if (typeof exports === "object") {
    exports.Immutable = Immutable;
  } else if (typeof window === "object") {
    window.Immutable = Immutable;
  } else if (typeof commonjsGlobal === "object") {
    commonjsGlobal.Immutable = Immutable;
  }
})();
});

function immutableConstructor(typeChecker, customCheck = v => v) {
  return {
    of: pipe$1(customCheck, seamlessImmutable)
  };
}

/* eslint-disable no-nested-ternary */
// ========================================================================
//
//     ALL GETTERS AND SETTERS (PUBLIC OR NOT) MUST BE IN THIS FILE
//
// ========================================================================

const typeCheck$1 = object({
  start: date,
  end: date
});

// CONSTRUCTOR
const TimeInterval$1 = immutableConstructor(typeCheck$1);

// PRIVATE GETTERS
const getStart = model => !model ? null : model.start instanceof Date ? model.start : null;

const getEnd = model => !model ? null : model.end instanceof Date ? model.end : null;
// GETTERS
// Returns the time difference betweet start and end in milliseconds
const getValue = model => {
  const maybeStart = pipe$1(Maybe$1.of, Maybe$1.map(getStart), Maybe$1.map(v => v.valueOf()))(model);

  const maybeEnd = pipe$1(Maybe$1.of, Maybe$1.map(getEnd), Maybe$1.map(v => v.valueOf()))(model);
  return pipe$1(Maybe$1.map2((s, e) => e - s), Maybe$1.withDefault(null))(maybeStart, maybeEnd);
};

Object.assign(TimeInterval$1, {
  typeCheck: typeCheck$1,
  getStart,
  getEnd,
  getValue
});

/**
 * Toggles a recording to on or off
 * @params {Project} model
 * @params {Date} time
 * @params {Boolean} on
 */
var _toggleRecording = curry$1(model => {
  if (!isRecording(model)) {
    return setStartTime(model, new Date());
  }

  const newInterval = TimeInterval$1.of({
    start: getStartTime(model),
    end: new Date()
  });

  const withStartTime = setStartTime(model, null);
  return setIntervals(withStartTime, [newInterval, ...getIntervals(model)]);
});

var _curry2$15 = _curry2$1;


/**
 * Adds two values.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Math
 * @sig Number -> Number -> Number
 * @param {Number} a
 * @param {Number} b
 * @return {Number}
 * @see R.subtract
 * @example
 *
 *      R.add(2, 3);       //=>  5
 *      R.add(7)(10);      //=> 17
 */
var add = _curry2$15(function add(a, b) {
  return Number(a) + Number(b);
});

/**
 * @method calculateRunningTime
 * @param  {Date} startTime
 * @param  {Array<TimeInterval>} intervals - Time intervals of type { start: Object, end: Object}
 * @return {Integer}
 */
function calculateRunningTime(startTime, intervals) {
  const intervalsSum = intervals.map(TimeInterval$1.getValue).reduce(add, 0);

  const sumSinceStartTime = !startTime ? 0 : pipe$1(d => ({ start: d, end: new Date() }), TimeInterval$1.of, TimeInterval$1.getValue)(startTime);

  return intervalsSum + sumSinceStartTime;
}

/**
 *
 * @param  {Recording} recording
 * @return {Integer} - Time in milliseconds
 */
var _totalTime = (model => {
  const startTime = getStartTime(model);
  const intervals = getIntervals(model);

  return calculateRunningTime(startTime, intervals);
});

/* eslint-disable new-cap, no-nested-ternary */
// ========================================================================
//
//     ALL GETTERS AND SETTERS (PUBLIC OR NOT) MUST BE IN THIS FILE
//
// ========================================================================

const typeCheck$$1 = object({
  startTime: nullable(date),
  intervals: array(TimeInterval$1.typeCheck)
});

// CONSTRUCTOR
const Recording$1 = immutableConstructor(typeCheck$$1, r => ({
  startTime: r && r.startTime ? r.startTime : null,
  intervals: r && r.intervals ? r.intervals : []
}));

// PRIVATE GETTERS
const getStartTime = propOr$1(null, 'startTime');
const getIntervals = model => isNil(model) ? [] : isNil(model.intervals) ? [] : model.intervals;

// PRIVATE SETTERS
const setStartTime = curry$1((model, v) => {
  const imutableModel = seamlessImmutable(model);
  return !!imutableModel && !!imutableModel.merge ? imutableModel.merge({ startTime: v }, { deep: true }) : null;
});

const setIntervals = curry$1((model, v) => {
  const imutableModel = seamlessImmutable(model);
  return !!imutableModel && !!imutableModel.merge ? imutableModel.merge({ intervals: v }, { deep: true }) : null;
});
// ===========================
// PUBLIC INTERFACE
// BOOLEAN "gettters"
const isRecording = pipe$1(getStartTime, v => !!v);
const toggleRecording = _toggleRecording;
const totalTime = _totalTime;

Object.assign(Recording$1, {
  typeCheck: typeCheck$$1,
  getStartTime,
  getIntervals,
  setStartTime,
  setIntervals,
  isRecording,
  toggleRecording,
  totalTime
});

// ========================================================================
//
//     ALL GETTERS AND SETTERS (PUBLIC OR NOT) MUST BE IN THIS FILE
//
// ========================================================================

const typeCheck$2 = object({
  name: string,
  url: string,
  recording: nullable(Recording$1.typeCheck)
});

const Deliverable$1 = immutableConstructor(typeCheck$2);

const getRecording = deliverable => deliverable ? deliverable.recording || Recording$1.of({}) : null;

const getName = propOr$1(null, 'name');
const getUrl = propOr$1(null, 'url');

// Deliverable -> Recording -> Deliverable
const setRecording = curry$1((model, newRecording) => isNil(model) ? null : seamlessImmutable(model).merge({ recording: newRecording }, { deep: true }));

const isSame = curry$1((d1, d2) => getName(d1) === getName(d2));

Object.assign(Deliverable$1, {
  typeCheck: typeCheck$2,
  getRecording,
  getName,
  getUrl,
  setRecording,
  isSame
});

/* eslint-disable new-cap */
// ========================================================================
//
//     ALL GETTERS AND SETTERS (PUBLIC OR NOT) MUST BE IN THIS FILE
//
// ========================================================================

const typeCheck$3 = object({
  name: string,
  url: string,
  unselectedDeliverables: array(Deliverable$1.typeCheck),
  selectedDeliverable: nullable(Deliverable$1.typeCheck)
});

// unselectedDeliverables and selectedDeliverables together form a ziplist.
const Project$1 = immutableConstructor(typeCheck$3);

// GETTERS
const getName$1 = propOr$1(null, 'name');
const getUrl$1 = propOr$1(null, 'url');
const getSelectedDeliverable = propOr$1(null, 'selectedDeliverable');
const getDeliverables = model => getSelectedDeliverable(model) ? [getSelectedDeliverable(model), ...propOr$1([], 'unselectedDeliverables', model)] : propOr$1([], 'unselectedDeliverables', model);

const setSelectedDeliverable = curry$1((model, newSelected) => {
  const all = getDeliverables(model);
  const newDeliverables = all.filter(d => Deliverable$1.getName(d) !== Deliverable$1.getName(newSelected));

  return seamlessImmutable.merge({
    unselectedDeliverables: newDeliverables,
    selectedDeliverable: newSelected || null
  });
});

const updateDeliverable = curry$1((model, newDeliverable) => {
  // eslint-disable complexity
  if (!model || !newDeliverable) {
    return model;
  }

  const sameName = deliv => deliv ? propEq$1('name', newDeliverable.name, deliv) : false;

  if (sameName(Project$1.getSelectedDeliverable(model))) {
    return seamlessImmutable(model).merge({
      selectedDeliverable: newDeliverable
    });
  } else if (model.unselectedDeliverables.find(sameName)) {
    const newUnselected = model.unselectedDeliverables.map(d => sameName(d) ? newDeliverable : d);

    return seamlessImmutable(model).merge({
      unselectedDeliverables: newUnselected
    });
  }
  return model;
});

const isSame$1 = curry$1((p1, p2) => getName$1(p1) === getName$1(p2));

// NO SETTERS
Object.assign(Project$1, {
  typeCheck: typeCheck$3,
  getName: getName$1,
  getUrl: getUrl$1,
  getDeliverables,
  getSelectedDeliverable,
  setSelectedDeliverable,
  updateDeliverable,
  isSame: isSame$1
});

const Maybe = Maybe$1;

const Validation = Validation$1;
const typeCheckers = _typeCheckers;
const Recording = Recording$1;
const TimeInterval = TimeInterval$1;
const Deliverable = Deliverable$1;
const Project = Project$1;

const pad2 = num => `00${ num }`.slice(-2);

function millisecondsToTimeString(ms) {
  const seconds = Math.floor(ms / 1000) % 60;
  const minutes = Math.floor(ms / (1000 * 60)) % 60;
  const hours = Math.floor(ms / (1000 * 60 * 60)) % 24;

  return hours > 0 ? `${ pad2(hours) }:${ pad2(minutes) }` : `${ pad2(minutes) }:${ pad2(seconds) }`;
}

// We use a class instead of a stateless component because we
// need the `this` keyword to trigger the force-update
class Timer extends react.Component {
  componentWillUnmount() {
    clearTimeout(this.timeout);
  }

  render() {
    const { recording } = this.props;
    const isRecording = Recording.isRecording(recording);
    if (isRecording) {
      this.timeout = setTimeout(_ => this.forceUpdate(), 500);
    }

    const timeString = pipe$1(Recording.totalTime, millisecondsToTimeString)(recording);

    return react.createElement(
      'div',
      {
        className: 'TimeTracker-timer-time',
        style: { minWidth: `${ timeString.length * 0.56 }em` }
      },
      timeString
    );
  }
}

Timer.propTypes = {
  recording: react.PropTypes.object
};

const toggleRecording$1 = curry$1((project, deliverable) => ({
  type: 'WIDGET_toggleRecording',
  project,
  deliverable
})); //
//    ACTION CREATORS
//

const selectDeliverable = curry$1((project, deliverable) => ({
  type: 'WIDGET_selectDeliverable',
  project,
  deliverable
}));
const selectProject = project => ({
  type: 'WIDGET_selectProject',
  project
});
const setProjects = rawProjects => ({
  type: 'WIDGET_setProjects',
  rawProjects
});
const toggleMinimised = minimise => ({
  type: 'WIDGET_toggleMinimised',
  minimise
});

/* eslint-disable react/prop-types */
const RecordingRow = ({ store, project, deliverable, recording }) => react.createElement(
  'div',
  { className: 'TimeTracker-RecordingRow' },
  react.createElement(
    'div',
    { className: 'TimeTracker-RecordingRow-names' },
    react.createElement(
      'span',
      { className: 'TimeTracker-RecordingRow-deliverableName' },
      Deliverable.getName(deliverable)
    ),
    react.createElement(
      'span',
      { className: 'TimeTracker-RecordingRow-projectName' },
      Project.getName(project)
    )
  ),
  react.createElement('button', {
    className: `TimeTracker-RecordingRow-start-stop btn fa ${ Recording.isRecording(recording) ? 'btn-danger fa-pause' : 'btn-info fa-play' }`,
    onClick: _ => store.dispatch(toggleRecording$1(project, deliverable))
  }),
  react.createElement(Timer, { recording: recording })
);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/* eslint-disable no-nested-ternary, react/prop-types */
const toOption = el => el ? pipe$1(propOr$1(null, 'name'), name => ({ label: name, value: name }))(el) : null;

// Option -> [Project] -> Project
const sameNameAsOptionValue = pipe$1(propOr$1(null, 'value'), propEq$1('name'), find);

// Object -> String : This creates a string useful in sorting and identifying
//                    the project deliverable recording
const stringIdentifier = ({ project, deliverable }) => {
  return Project.getName(project) + Deliverable.getName(deliverable);
};

const runningTimer = recordingsInfo => Maybe.of(recordingsInfo).map(map$1(prop('recording'))).map(filter(Recording.isRecording)).map(prop(0)).withDefault(undefined);

const Widget$2 = ({ // eslint-disable-line complexity
  store,
  // props
  selectedProject,
  allProjects,
  recordingsInfo,
  isMinimised
}) => {
  const selectedDeliverable = Project.getSelectedDeliverable(selectedProject);
  const activeRecording = isMinimised ? runningTimer(recordingsInfo) : Deliverable.getRecording(selectedDeliverable);
  const isRecording = Recording.isRecording(activeRecording);
  const projectOptions = allProjects.map(toOption);
  const deliverableOptions = Project.getDeliverables(selectedProject).map(toOption);

  const timeTrackerClick = _ => store.dispatch(toggleRecording$1(selectedProject, selectedDeliverable));

  // { label<String>, value<String>} -> Action
  const changeProject = option => pipe$1(sameNameAsOptionValue(option), selectProject, action => store.dispatch(action))(allProjects);

  // { label<String>, value<String>} -> Action
  const changeDeliverable = option => pipe$1(Project.getDeliverables, sameNameAsOptionValue(option), selectDeliverable(selectedProject), action => store.dispatch(action))(selectedProject);

  return react.createElement(
    'div',
    { className: `TimeTracker ${ isMinimised ? 'TimeTracker--minimised' : '' }` },
    react.createElement(
      'div',
      {
        className: `TimeTracker-timer ${ isRecording ? 'TimeTracker-timer--recording' : '' }`,
        onClick: _ => store.dispatch(toggleMinimised(!isMinimised))
      },
      react.createElement(Timer, { recording: activeRecording })
    ),
    react.createElement(
      'div',
      { className: 'TimeTracker-fields' },
      react.createElement(
        'div',
        { className: 'TimeTracker-projects' },
        react.createElement(Select, {
          name: 'form-field-name',
          value: toOption(selectedProject),
          options: sortBy(propOr$1('', 'label'), projectOptions),
          onChange: changeProject
        }),
        react.createElement(
          'div',
          { className: 'TimeTracker-sideButtons' },
          react.createElement('a', {
            href: Project.getUrl(selectedProject),
            className: `btn btn-${ selectedProject ? 'danger' : 'disabled' } fa fa-link`
          }),
          react.createElement('a', { className: 'btn btn-secondary fa fa-plus' })
        )
      ),
      react.createElement(
        'div',
        { className: 'TimeTracker-deliverables' },
        react.createElement(Select, {
          name: 'form-field-name',
          value: toOption(selectedDeliverable),
          options: sortBy(propOr$1('', 'label'), deliverableOptions),
          onChange: changeDeliverable
        }),
        react.createElement(
          'div',
          { className: 'TimeTracker-sideButtons' },
          react.createElement('a', {
            href: Deliverable.getUrl(selectedDeliverable),
            className: 'btn btn-danger fa fa-link',
            className: `btn btn-${ selectedDeliverable ? 'danger' : 'disabled' } fa fa-link`
          }),
          react.createElement('a', {
            className: 'btn btn-secondary fa fa-plus'
          })
        )
      ),
      react.createElement(
        'button',
        {
          className: `TimeTracker-start-stop btn ${ isRecording ? 'btn-danger' : 'btn-default' }`,
          onClick: timeTrackerClick,
          disabled: !selectedDeliverable
        },
        isRecording ? 'Pause' : 'Start'
      ),
      recordingsInfo.sort((info1, info2) => stringIdentifier(info1) < stringIdentifier(info2)).map(info => react.createElement(RecordingRow, _extends({
        key: stringIdentifier(info),
        store: store
      }, info)))
    )
  );
};

var storeShape = createCommonjsModule(function (module, exports) {
'use strict';

exports.__esModule = true;

var _react = react;

exports["default"] = _react.PropTypes.shape({
  subscribe: _react.PropTypes.func.isRequired,
  dispatch: _react.PropTypes.func.isRequired,
  getState: _react.PropTypes.func.isRequired
});
});

var warning_1$2 = createCommonjsModule(function (module, exports) {
'use strict';

exports.__esModule = true;
exports["default"] = warning;
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}
});

var Provider_1 = createCommonjsModule(function (module, exports) {
'use strict';

exports.__esModule = true;
exports["default"] = undefined;

var _react = react;

var _storeShape = storeShape;

var _storeShape2 = _interopRequireDefault(_storeShape);

var _warning = warning_1$2;

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var didWarnAboutReceivingStore = false;
function warnAboutReceivingStore() {
  if (didWarnAboutReceivingStore) {
    return;
  }
  didWarnAboutReceivingStore = true;

  (0, _warning2["default"])('<Provider> does not support changing `store` on the fly. ' + 'It is most likely that you see this error because you updated to ' + 'Redux 2.x and React Redux 2.x which no longer hot reload reducers ' + 'automatically. See https://github.com/reactjs/react-redux/releases/' + 'tag/v2.0.0 for the migration instructions.');
}

var Provider = function (_Component) {
  _inherits(Provider, _Component);

  Provider.prototype.getChildContext = function getChildContext() {
    return { store: this.store };
  };

  function Provider(props, context) {
    _classCallCheck(this, Provider);

    var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

    _this.store = props.store;
    return _this;
  }

  Provider.prototype.render = function render() {
    return _react.Children.only(this.props.children);
  };

  return Provider;
}(_react.Component);

exports["default"] = Provider;


{
  Provider.prototype.componentWillReceiveProps = function (nextProps) {
    var store = this.store;
    var nextStore = nextProps.store;


    if (store !== nextStore) {
      warnAboutReceivingStore();
    }
  };
}

Provider.propTypes = {
  store: _storeShape2["default"].isRequired,
  children: _react.PropTypes.element.isRequired
};
Provider.childContextTypes = {
  store: _storeShape2["default"].isRequired
};
});

var shallowEqual_1$2 = createCommonjsModule(function (module, exports) {
"use strict";

exports.__esModule = true;
exports["default"] = shallowEqual;
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  var hasOwn = Object.prototype.hasOwnProperty;
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
      return false;
    }
  }

  return true;
}
});

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */
var Symbol$1 = root.Symbol;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$1.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$1.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$5.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$2.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]';
var undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  value = Object(value);
  return (symToStringTag && symToStringTag in value)
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype;
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$4.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
}

/* global window */
var root$2;

if (typeof self !== 'undefined') {
  root$2 = self;
} else if (typeof window !== 'undefined') {
  root$2 = window;
} else if (typeof global !== 'undefined') {
  root$2 = global;
} else if (typeof module !== 'undefined') {
  root$2 = module;
} else {
  root$2 = Function('return this')();
}

var result = symbolObservablePonyfill(root$2);

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = {
  INIT: '@@redux/INIT'
};

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} enhancer The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    return currentState;
  }

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.');
    }

    var isSubscribed = true;

    ensureCanMutateNextListeners();
    nextListeners.push(listener);

    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      isSubscribed = false;

      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      listeners[i]();
    }

    return action;
  }

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({ type: ActionTypes.INIT });
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/zenparsing/es-observable
   */
  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object') {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return { unsubscribe: unsubscribe };
      }
    }, _ref[result] = function () {
      return this;
    }, _ref;
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT });

  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[result] = observable, _ref2;
}

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning$42(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */
  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */
}

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';

  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state.';
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!isPlainObject(inputState)) {
    return 'The ' + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });

  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });

  if (unexpectedKeys.length > 0) {
    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
  }
}

function assertReducerSanity(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, { type: ActionTypes.INIT });

    if (typeof initialState === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined.');
    }

    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
    if (typeof reducer(undefined, { type: type }) === 'undefined') {
      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined.');
    }
  });
}

/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    {
      if (typeof reducers[key] === 'undefined') {
        warning$42('No reducer provided for key "' + key + '"');
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);

  {
    var unexpectedKeyCache = {};
  }

  var sanityError;
  try {
    assertReducerSanity(finalReducers);
  } catch (e) {
    sanityError = e;
  }

  return function combination() {
    var state = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    var action = arguments[1];

    if (sanityError) {
      throw sanityError;
    }

    {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
      if (warningMessage) {
        warning$42(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};
    for (var i = 0; i < finalReducerKeys.length; i++) {
      var key = finalReducerKeys[i];
      var reducer = finalReducers[key];
      var previousStateForKey = state[key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(key, action);
        throw new Error(errorMessage);
      }
      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    return hasChanged ? nextState : state;
  };
}

function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(undefined, arguments));
  };
}

/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass a single function as the first argument,
 * and get a function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
  }

  var keys = Object.keys(actionCreators);
  var boundActionCreators = {};
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */

function compose() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  var last = funcs[funcs.length - 1];
  var rest = funcs.slice(0, -1);
  return function () {
    return rest.reduceRight(function (composed, f) {
      return f(composed);
    }, last.apply(undefined, arguments));
  };
}

var _extends$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function (reducer, preloadedState, enhancer) {
      var store = createStore(reducer, preloadedState, enhancer);
      var _dispatch = store.dispatch;
      var chain = [];

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch(action) {
          return _dispatch(action);
        }
      };
      chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(undefined, chain)(store.dispatch);

      return _extends$2({}, store, {
        dispatch: _dispatch
      });
    };
  };
}

/*
* This is a dummy function to check if the function name has been altered by minification.
* If the function has been minified and NODE_ENV !== 'production', warn the user.
*/
function isCrushed() {}

if ("development" !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  warning$42('You are currently using minified code outside of NODE_ENV === \'production\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');
}



var index$8 = Object.freeze({
	createStore: createStore,
	combineReducers: combineReducers,
	bindActionCreators: bindActionCreators,
	applyMiddleware: applyMiddleware,
	compose: compose
});

var require$$0$50 = ( index$8 && index$8['default'] ) || index$8;

var wrapActionCreators_1 = createCommonjsModule(function (module, exports) {
'use strict';

exports.__esModule = true;
exports["default"] = wrapActionCreators;

var _redux = require$$0$50;

function wrapActionCreators(actionCreators) {
  return function (dispatch) {
    return (0, _redux.bindActionCreators)(actionCreators, dispatch);
  };
}
});

/** Detect free variable `global` from Node.js. */
var freeGlobal$3 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

var _freeGlobal = freeGlobal$3;

var freeGlobal$2 = _freeGlobal;

/** Detect free variable `self`. */
var freeSelf$1 = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root$4 = freeGlobal$2 || freeSelf$1 || Function('return this')();

var _root = root$4;

var root$3 = _root;

/** Built-in value references. */
var Symbol$4 = root$3.Symbol;

var _Symbol = Symbol$4;

var Symbol$5 = _Symbol;

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$4.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$2 = objectProto$4.toString;

/** Built-in value references. */
var symToStringTag$3 = Symbol$5 ? Symbol$5.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag$3(value) {
  var isOwn = hasOwnProperty$7.call(value, symToStringTag$3),
      tag = value[symToStringTag$3];

  try {
    value[symToStringTag$3] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$2.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$3] = tag;
    } else {
      delete value[symToStringTag$3];
    }
  }
  return result;
}

var _getRawTag = getRawTag$3;

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$3 = objectProto$5.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString$3(value) {
  return nativeObjectToString$3.call(value);
}

var _objectToString = objectToString$3;

var Symbol$3 = _Symbol;
var getRawTag$2 = _getRawTag;
var objectToString$2 = _objectToString;

/** `Object#toString` result references. */
var nullTag$1 = '[object Null]';
var undefinedTag$1 = '[object Undefined]';

/** Built-in value references. */
var symToStringTag$2 = Symbol$3 ? Symbol$3.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag$3(value) {
  if (value == null) {
    return value === undefined ? undefinedTag$1 : nullTag$1;
  }
  value = Object(value);
  return (symToStringTag$2 && symToStringTag$2 in value)
    ? getRawTag$2(value)
    : objectToString$2(value);
}

var _baseGetTag = baseGetTag$3;

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg$3(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

var _overArg = overArg$3;

var overArg$2 = _overArg;

/** Built-in value references. */
var getPrototype$3 = overArg$2(Object.getPrototypeOf, Object);

var _getPrototype = getPrototype$3;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike$3(value) {
  return value != null && typeof value == 'object';
}

var isObjectLike_1 = isObjectLike$3;

var baseGetTag$2 = _baseGetTag;
var getPrototype$2 = _getPrototype;
var isObjectLike$2 = isObjectLike_1;

/** `Object#toString` result references. */
var objectTag$1 = '[object Object]';

/** Used for built-in method references. */
var funcProto$1 = Function.prototype;
var objectProto$3 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$3.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString$1 = funcToString$1.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject$2(value) {
  if (!isObjectLike$2(value) || baseGetTag$2(value) != objectTag$1) {
    return false;
  }
  var proto = getPrototype$2(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$6.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString$1.call(Ctor) == objectCtorString$1;
}

var isPlainObject_1 = isPlainObject$2;

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    arguments: true,
    arity: true
};

var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';

var index$9 = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
        var keys = Object.getOwnPropertyNames(sourceComponent);

        /* istanbul ignore else */
        if (isGetOwnPropertySymbolsAvailable) {
            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
                try {
                    targetComponent[keys[i]] = sourceComponent[keys[i]];
                } catch (error) {

                }
            }
        }
    }

    return targetComponent;
};

/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var NODE_ENV = "development";

var invariant$41 = function(condition, format, a, b, c, d, e, f) {
  if (NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

var invariant_1$2 = invariant$41;

var connect_1 = createCommonjsModule(function (module, exports) {
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports["default"] = connect;

var _react = react;

var _storeShape = storeShape;

var _storeShape2 = _interopRequireDefault(_storeShape);

var _shallowEqual = shallowEqual_1$2;

var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

var _wrapActionCreators = wrapActionCreators_1;

var _wrapActionCreators2 = _interopRequireDefault(_wrapActionCreators);

var _warning = warning_1$2;

var _warning2 = _interopRequireDefault(_warning);

var _isPlainObject = isPlainObject_1;

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _hoistNonReactStatics = index$9;

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _invariant = invariant_1$2;

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var defaultMapStateToProps = function defaultMapStateToProps(state) {
  return {};
}; // eslint-disable-line no-unused-vars
var defaultMapDispatchToProps = function defaultMapDispatchToProps(dispatch) {
  return { dispatch: dispatch };
};
var defaultMergeProps = function defaultMergeProps(stateProps, dispatchProps, parentProps) {
  return _extends({}, parentProps, stateProps, dispatchProps);
};

function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
}

var errorObject = { value: null };
function tryCatch(fn, ctx) {
  try {
    return fn.apply(ctx);
  } catch (e) {
    errorObject.value = e;
    return errorObject;
  }
}

// Helps track hot reloading.
var nextVersion = 0;

function connect(mapStateToProps, mapDispatchToProps, mergeProps) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  var shouldSubscribe = Boolean(mapStateToProps);
  var mapState = mapStateToProps || defaultMapStateToProps;

  var mapDispatch = void 0;
  if (typeof mapDispatchToProps === 'function') {
    mapDispatch = mapDispatchToProps;
  } else if (!mapDispatchToProps) {
    mapDispatch = defaultMapDispatchToProps;
  } else {
    mapDispatch = (0, _wrapActionCreators2["default"])(mapDispatchToProps);
  }

  var finalMergeProps = mergeProps || defaultMergeProps;
  var _options$pure = options.pure,
      pure = _options$pure === undefined ? true : _options$pure,
      _options$withRef = options.withRef,
      withRef = _options$withRef === undefined ? false : _options$withRef;

  var checkMergedEquals = pure && finalMergeProps !== defaultMergeProps;

  // Helps track hot reloading.
  var version = nextVersion++;

  return function wrapWithConnect(WrappedComponent) {
    var connectDisplayName = 'Connect(' + getDisplayName(WrappedComponent) + ')';

    function checkStateShape(props, methodName) {
      if (!(0, _isPlainObject2["default"])(props)) {
        (0, _warning2["default"])(methodName + '() in ' + connectDisplayName + ' must return a plain object. ' + ('Instead received ' + props + '.'));
      }
    }

    function computeMergedProps(stateProps, dispatchProps, parentProps) {
      var mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps);
      {
        checkStateShape(mergedProps, 'mergeProps');
      }
      return mergedProps;
    }

    var Connect = function (_Component) {
      _inherits(Connect, _Component);

      Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate() {
        return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged;
      };

      function Connect(props, context) {
        _classCallCheck(this, Connect);

        var _this = _possibleConstructorReturn(this, _Component.call(this, props, context));

        _this.version = version;
        _this.store = props.store || context.store;

        (0, _invariant2["default"])(_this.store, 'Could not find "store" in either the context or ' + ('props of "' + connectDisplayName + '". ') + 'Either wrap the root component in a <Provider>, ' + ('or explicitly pass "store" as a prop to "' + connectDisplayName + '".'));

        var storeState = _this.store.getState();
        _this.state = { storeState: storeState };
        _this.clearCache();
        return _this;
      }

      Connect.prototype.computeStateProps = function computeStateProps(store, props) {
        if (!this.finalMapStateToProps) {
          return this.configureFinalMapState(store, props);
        }

        var state = store.getState();
        var stateProps = this.doStatePropsDependOnOwnProps ? this.finalMapStateToProps(state, props) : this.finalMapStateToProps(state);

        {
          checkStateShape(stateProps, 'mapStateToProps');
        }
        return stateProps;
      };

      Connect.prototype.configureFinalMapState = function configureFinalMapState(store, props) {
        var mappedState = mapState(store.getState(), props);
        var isFactory = typeof mappedState === 'function';

        this.finalMapStateToProps = isFactory ? mappedState : mapState;
        this.doStatePropsDependOnOwnProps = this.finalMapStateToProps.length !== 1;

        if (isFactory) {
          return this.computeStateProps(store, props);
        }

        {
          checkStateShape(mappedState, 'mapStateToProps');
        }
        return mappedState;
      };

      Connect.prototype.computeDispatchProps = function computeDispatchProps(store, props) {
        if (!this.finalMapDispatchToProps) {
          return this.configureFinalMapDispatch(store, props);
        }

        var dispatch = store.dispatch;

        var dispatchProps = this.doDispatchPropsDependOnOwnProps ? this.finalMapDispatchToProps(dispatch, props) : this.finalMapDispatchToProps(dispatch);

        {
          checkStateShape(dispatchProps, 'mapDispatchToProps');
        }
        return dispatchProps;
      };

      Connect.prototype.configureFinalMapDispatch = function configureFinalMapDispatch(store, props) {
        var mappedDispatch = mapDispatch(store.dispatch, props);
        var isFactory = typeof mappedDispatch === 'function';

        this.finalMapDispatchToProps = isFactory ? mappedDispatch : mapDispatch;
        this.doDispatchPropsDependOnOwnProps = this.finalMapDispatchToProps.length !== 1;

        if (isFactory) {
          return this.computeDispatchProps(store, props);
        }

        {
          checkStateShape(mappedDispatch, 'mapDispatchToProps');
        }
        return mappedDispatch;
      };

      Connect.prototype.updateStatePropsIfNeeded = function updateStatePropsIfNeeded() {
        var nextStateProps = this.computeStateProps(this.store, this.props);
        if (this.stateProps && (0, _shallowEqual2["default"])(nextStateProps, this.stateProps)) {
          return false;
        }

        this.stateProps = nextStateProps;
        return true;
      };

      Connect.prototype.updateDispatchPropsIfNeeded = function updateDispatchPropsIfNeeded() {
        var nextDispatchProps = this.computeDispatchProps(this.store, this.props);
        if (this.dispatchProps && (0, _shallowEqual2["default"])(nextDispatchProps, this.dispatchProps)) {
          return false;
        }

        this.dispatchProps = nextDispatchProps;
        return true;
      };

      Connect.prototype.updateMergedPropsIfNeeded = function updateMergedPropsIfNeeded() {
        var nextMergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props);
        if (this.mergedProps && checkMergedEquals && (0, _shallowEqual2["default"])(nextMergedProps, this.mergedProps)) {
          return false;
        }

        this.mergedProps = nextMergedProps;
        return true;
      };

      Connect.prototype.isSubscribed = function isSubscribed() {
        return typeof this.unsubscribe === 'function';
      };

      Connect.prototype.trySubscribe = function trySubscribe() {
        if (shouldSubscribe && !this.unsubscribe) {
          this.unsubscribe = this.store.subscribe(this.handleChange.bind(this));
          this.handleChange();
        }
      };

      Connect.prototype.tryUnsubscribe = function tryUnsubscribe() {
        if (this.unsubscribe) {
          this.unsubscribe();
          this.unsubscribe = null;
        }
      };

      Connect.prototype.componentDidMount = function componentDidMount() {
        this.trySubscribe();
      };

      Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        if (!pure || !(0, _shallowEqual2["default"])(nextProps, this.props)) {
          this.haveOwnPropsChanged = true;
        }
      };

      Connect.prototype.componentWillUnmount = function componentWillUnmount() {
        this.tryUnsubscribe();
        this.clearCache();
      };

      Connect.prototype.clearCache = function clearCache() {
        this.dispatchProps = null;
        this.stateProps = null;
        this.mergedProps = null;
        this.haveOwnPropsChanged = true;
        this.hasStoreStateChanged = true;
        this.haveStatePropsBeenPrecalculated = false;
        this.statePropsPrecalculationError = null;
        this.renderedElement = null;
        this.finalMapDispatchToProps = null;
        this.finalMapStateToProps = null;
      };

      Connect.prototype.handleChange = function handleChange() {
        if (!this.unsubscribe) {
          return;
        }

        var storeState = this.store.getState();
        var prevStoreState = this.state.storeState;
        if (pure && prevStoreState === storeState) {
          return;
        }

        if (pure && !this.doStatePropsDependOnOwnProps) {
          var haveStatePropsChanged = tryCatch(this.updateStatePropsIfNeeded, this);
          if (!haveStatePropsChanged) {
            return;
          }
          if (haveStatePropsChanged === errorObject) {
            this.statePropsPrecalculationError = errorObject.value;
          }
          this.haveStatePropsBeenPrecalculated = true;
        }

        this.hasStoreStateChanged = true;
        this.setState({ storeState: storeState });
      };

      Connect.prototype.getWrappedInstance = function getWrappedInstance() {
        (0, _invariant2["default"])(withRef, 'To access the wrapped instance, you need to specify ' + '{ withRef: true } as the fourth argument of the connect() call.');

        return this.refs.wrappedInstance;
      };

      Connect.prototype.render = function render() {
        var haveOwnPropsChanged = this.haveOwnPropsChanged,
            hasStoreStateChanged = this.hasStoreStateChanged,
            haveStatePropsBeenPrecalculated = this.haveStatePropsBeenPrecalculated,
            statePropsPrecalculationError = this.statePropsPrecalculationError,
            renderedElement = this.renderedElement;


        this.haveOwnPropsChanged = false;
        this.hasStoreStateChanged = false;
        this.haveStatePropsBeenPrecalculated = false;
        this.statePropsPrecalculationError = null;

        if (statePropsPrecalculationError) {
          throw statePropsPrecalculationError;
        }

        var shouldUpdateStateProps = true;
        var shouldUpdateDispatchProps = true;
        if (pure && renderedElement) {
          shouldUpdateStateProps = hasStoreStateChanged || haveOwnPropsChanged && this.doStatePropsDependOnOwnProps;
          shouldUpdateDispatchProps = haveOwnPropsChanged && this.doDispatchPropsDependOnOwnProps;
        }

        var haveStatePropsChanged = false;
        var haveDispatchPropsChanged = false;
        if (haveStatePropsBeenPrecalculated) {
          haveStatePropsChanged = true;
        } else if (shouldUpdateStateProps) {
          haveStatePropsChanged = this.updateStatePropsIfNeeded();
        }
        if (shouldUpdateDispatchProps) {
          haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded();
        }

        var haveMergedPropsChanged = true;
        if (haveStatePropsChanged || haveDispatchPropsChanged || haveOwnPropsChanged) {
          haveMergedPropsChanged = this.updateMergedPropsIfNeeded();
        } else {
          haveMergedPropsChanged = false;
        }

        if (!haveMergedPropsChanged && renderedElement) {
          return renderedElement;
        }

        if (withRef) {
          this.renderedElement = (0, _react.createElement)(WrappedComponent, _extends({}, this.mergedProps, {
            ref: 'wrappedInstance'
          }));
        } else {
          this.renderedElement = (0, _react.createElement)(WrappedComponent, this.mergedProps);
        }

        return this.renderedElement;
      };

      return Connect;
    }(_react.Component);

    Connect.displayName = connectDisplayName;
    Connect.WrappedComponent = WrappedComponent;
    Connect.contextTypes = {
      store: _storeShape2["default"]
    };
    Connect.propTypes = {
      store: _storeShape2["default"]
    };

    {
      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
        if (this.version === version) {
          return;
        }

        // We are hot reloading!
        this.version = version;
        this.trySubscribe();
        this.clearCache();
      };
    }

    return (0, _hoistNonReactStatics2["default"])(Connect, WrappedComponent);
  };
}
});

var index$6 = createCommonjsModule(function (module, exports) {
'use strict';

exports.__esModule = true;
exports.connect = exports.Provider = undefined;

var _Provider = Provider_1;

var _Provider2 = _interopRequireDefault(_Provider);

var _connect = connect_1;

var _connect2 = _interopRequireDefault(_connect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

exports.Provider = _Provider2["default"];
exports.connect = _connect2["default"];
});

var connect = index$6.connect;

var _isFunction$1 = function _isFunction$1(x) {
  return Object.prototype.toString.call(x) === '[object Function]';
};

var equals$3 = equals$1;


var _indexOf$1 = function _indexOf$1(list, a, idx) {
  var inf, item;
  // Array.prototype.indexOf doesn't exist below IE9
  if (typeof list.indexOf === 'function') {
    switch (typeof a) {
      case 'number':
        if (a === 0) {
          // manually crawl the list to distinguish between +0 and -0
          inf = 1 / a;
          while (idx < list.length) {
            item = list[idx];
            if (item === 0 && 1 / item === inf) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        } else if (a !== a) {
          // NaN
          while (idx < list.length) {
            item = list[idx];
            if (typeof item === 'number' && item !== item) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        }
        // non-zero numbers can utilise Set
        return list.indexOf(a, idx);

      // all these types can utilise Set
      case 'string':
      case 'boolean':
      case 'function':
      case 'undefined':
        return list.indexOf(a, idx);

      case 'object':
        if (a === null) {
          // null can utilise Set
          return list.indexOf(a, idx);
        }
    }
  }
  // anything else not covered above, defer to R.equals
  while (idx < list.length) {
    if (equals$3(list[idx], a)) {
      return idx;
    }
    idx += 1;
  }
  return -1;
};

var _indexOf = _indexOf$1;


var _contains$1 = function _contains$1(a, list) {
  return _indexOf(list, a, 0) >= 0;
};

var _quote$1 = function _quote$1(s) {
  var escaped = s
    .replace(/\\/g, '\\\\')
    .replace(/[\b]/g, '\\b')  // \b matches word boundary; [\b] matches backspace
    .replace(/\f/g, '\\f')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/\t/g, '\\t')
    .replace(/\v/g, '\\v')
    .replace(/\0/g, '\\0');

  return '"' + escaped.replace(/"/g, '\\"') + '"';
};

/**
 * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
 */
var _toISOString$1 = (function() {
  var pad = function pad(n) { return (n < 10 ? '0' : '') + n; };

  return typeof Date.prototype.toISOString === 'function' ?
    function _toISOString$1(d) {
      return d.toISOString();
    } :
    function _toISOString$1(d) {
      return (
        d.getUTCFullYear() + '-' +
        pad(d.getUTCMonth() + 1) + '-' +
        pad(d.getUTCDate()) + 'T' +
        pad(d.getUTCHours()) + ':' +
        pad(d.getUTCMinutes()) + ':' +
        pad(d.getUTCSeconds()) + '.' +
        (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z'
      );
    };
}());

var _complement$1 = function _complement$1(f) {
  return function() {
    return !f.apply(this, arguments);
  };
};

var _complement = _complement$1;
var _curry2$17 = _curry2$1;
var filter$1 = filter;


/**
 * The complement of `filter`.
 *
 * Acts as a transducer if a transformer is given in list position.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Filterable f => (a -> Boolean) -> f a -> f a
 * @param {Function} pred
 * @param {Array} filterable
 * @return {Array}
 * @see R.filter, R.transduce, R.addIndex
 * @example
 *
 *      var isOdd = (n) => n % 2 === 1;
 *
 *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
 *
 *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
 */
var reject$1 = _curry2$17(function reject$1(pred, filterable) {
  return filter$1(_complement(pred), filterable);
});

var _contains = _contains$1;
var _map$3 = _map$1;
var _quote = _quote$1;
var _toISOString = _toISOString$1;
var keys$5 = keys$1;
var reject = reject$1;


var _toString$1 = function _toString$1(x, seen) {
  var recur = function recur(y) {
    var xs = seen.concat([x]);
    return _contains(y, xs) ? '<Circular>' : _toString$1(y, xs);
  };

  //  mapPairs :: (Object, [String]) -> [String]
  var mapPairs = function(obj, keys) {
    return _map$3(function(k) { return _quote(k) + ': ' + recur(obj[k]); }, keys.slice().sort());
  };

  switch (Object.prototype.toString.call(x)) {
    case '[object Arguments]':
      return '(function() { return arguments; }(' + _map$3(recur, x).join(', ') + '))';
    case '[object Array]':
      return '[' + _map$3(recur, x).concat(mapPairs(x, reject(function(k) { return /^\d+$/.test(k); }, keys$5(x)))).join(', ') + ']';
    case '[object Boolean]':
      return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
    case '[object Date]':
      return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';
    case '[object Null]':
      return 'null';
    case '[object Number]':
      return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
    case '[object String]':
      return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
    case '[object Undefined]':
      return 'undefined';
    default:
      if (typeof x.toString === 'function') {
        var repr = x.toString();
        if (repr !== '[object Object]') {
          return repr;
        }
      }
      return '{' + mapPairs(x, keys$5(x)).join(', ') + '}';
  }
};

var _curry1$10 = _curry1$1;
var _toString = _toString$1;


/**
 * Returns the string representation of the given value. `eval`'ing the output
 * should result in a value equivalent to the input value. Many of the built-in
 * `toString` methods do not satisfy this requirement.
 *
 * If the given value is an `[object Object]` with a `toString` method other
 * than `Object.prototype.toString`, this method is invoked with no arguments
 * to produce the return value. This means user-defined constructor functions
 * can provide a suitable `toString` method. For example:
 *
 *     function Point(x, y) {
 *       this.x = x;
 *       this.y = y;
 *     }
 *
 *     Point.prototype.toString = function() {
 *       return 'new Point(' + this.x + ', ' + this.y + ')';
 *     };
 *
 *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
 *
 * @func
 * @memberOf R
 * @since v0.14.0
 * @category String
 * @sig * -> String
 * @param {*} val
 * @return {String}
 * @example
 *
 *      R.toString(42); //=> '42'
 *      R.toString('abc'); //=> '"abc"'
 *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
 *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
 *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
 */
var toString$2 = _curry1$10(function toString$2(val) { return _toString(val, []); });

var _curry2$16 = _curry2$1;
var _isArray$5 = _isArray$1;
var _isFunction = _isFunction$1;
var toString$1 = toString$2;


/**
 * Returns the result of concatenating the given lists or strings.
 *
 * Note: `R.concat` expects both arguments to be of the same type,
 * unlike the native `Array.prototype.concat` method. It will throw
 * an error if you `concat` an Array with a non-Array value.
 *
 * Dispatches to the `concat` method of the first argument, if present.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> [a] -> [a]
 * @sig String -> String -> String
 * @param {Array|String} a
 * @param {Array|String} b
 * @return {Array|String}
 *
 * @example
 *
 *      R.concat([], []); //=> []
 *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
 *      R.concat('ABC', 'DEF'); // 'ABCDEF'
 */
var concat = _curry2$16(function concat(a, b) {
  if (a == null || !_isFunction(a.concat)) {
    throw new TypeError(toString$1(a) + ' does not have a method named "concat"');
  }
  if (_isArray$5(a) && !_isArray$5(b)) {
    throw new TypeError(toString$1(b) + ' is not an array');
  }
  return a.concat(b);
});

var _curry2$18 = _curry2$1;


/**
 * Returns `true` if the first argument is less than the second; `false`
 * otherwise.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Relation
 * @sig Ord a => a -> a -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @see R.gt
 * @example
 *
 *      R.lt(2, 1); //=> false
 *      R.lt(2, 2); //=> false
 *      R.lt(2, 3); //=> true
 *      R.lt('a', 'z'); //=> true
 *      R.lt('z', 'a'); //=> false
 */
var lt = _curry2$18(function lt(a, b) { return a < b; });

var _curry2$19 = _curry2$1;


/**
 * Returns the second argument if it is not `null`, `undefined` or `NaN`
 * otherwise the first argument is returned.
 *
 * @func
 * @memberOf R
 * @since v0.10.0
 * @category Logic
 * @sig a -> b -> a | b
 * @param {a} val The default value.
 * @param {b} val The value to return if it is not null or undefined
 * @return {*} The the second value or the default value
 * @example
 *
 *      var defaultTo42 = R.defaultTo(42);
 *
 *      defaultTo42(null);  //=> 42
 *      defaultTo42(undefined);  //=> 42
 *      defaultTo42('Ramda');  //=> 'Ramda'
 *      defaultTo42(parseInt('string')); //=> 42
 */
var defaultTo$1 = _curry2$19(function defaultTo$1(d, v) {
  return v == null || v !== v ? d : v;
});

var _curry2$20 = _curry2$1;


/**
 * Retrieve the value at a given path.
 *
 * @func
 * @memberOf R
 * @since v0.2.0
 * @category Object
 * @sig [String] -> {k: v} -> v | Undefined
 * @param {Array} path The path to use.
 * @param {Object} obj The object to retrieve the nested property from.
 * @return {*} The data at `path`.
 * @see R.prop
 * @example
 *
 *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
 *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
 */
var path$1 = _curry2$20(function path$1(paths, obj) {
  var val = obj;
  var idx = 0;
  while (idx < paths.length) {
    if (val == null) {
      return;
    }
    val = val[paths[idx]];
    idx += 1;
  }
  return val;
});

var _curry3$6 = _curry3$1;
var defaultTo = defaultTo$1;
var path = path$1;


/**
 * If the given, non-null object has a value at the given path, returns the
 * value at that path. Otherwise returns the provided default value.
 *
 * @func
 * @memberOf R
 * @since v0.18.0
 * @category Object
 * @sig a -> [String] -> Object -> a
 * @param {*} d The default value.
 * @param {Array} p The path to use.
 * @param {Object} obj The object to retrieve the nested property from.
 * @return {*} The data at `path` of the supplied object or the default value.
 * @example
 *
 *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
 *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
 */
var pathOr$1 = _curry3$6(function pathOr$1(d, p, obj) {
  return defaultTo(d, path(p, obj));
});

const updateAt = curry$1((keyArray, newVal, obj) => {
  const deepNewVal = keyArray.reduceRight((result, key) => ({ [key]: result }), newVal);

  return seamlessImmutable(obj).merge(deepNewVal, { deep: true });
});

const selectedProject = pathOr$1(null, ['selectedProject']);

// Model -> [Project]
const unselectedProjects = pipe$1(propOr$1(null, 'unselectedProjects'), v => v || []);

const allProjects = model => selectedProject(model) ? unselectedProjects(model).concat(selectedProject(model)) : unselectedProjects(model);

const recordingsInfo = model => {
  const nonZeroRecordingTime = pipe$1(propOr$1(null, 'recording'), Recording.totalTime, lt(0));

  const projectRecordingInfos = project => pipe$1(Project.getDeliverables, map$1(d => ({ project, deliverable: d, recording: Deliverable.getRecording(d) })))(project);

  const all = pipe$1(allProjects, map$1(projectRecordingInfos), reduce$1(concat, []))(model);

  return all.filter(nonZeroRecordingTime);
};

const getProject = curry$1((projectName, model) => pipe$1(allProjects, filter(propEq$1('name', projectName)))(model));

const getDeliverable = curry$1((deliverableName, projectName, model) => pipe$1(getProject(projectName), Project.getDeliverables, filter(propEq$1('name', deliverableName)))(model));

const updateProject = curry$1((project, model, newProject) => {
  const projectName = Project.getName(project);
  if (!(model && projectName && newProject)) {
    return model;
  }

  const sameProjectName = propEq$1('name', projectName);
  const updatingSelectedProject = projectName === propOr$1(null, 'name', model.selectedProject);
  const updatingUnselectedProject = !!unselectedProjects(model).find(sameProjectName);

  if (updatingSelectedProject) {
    return updateAt(['selectedProject'], newProject, model);
  } else if (updatingUnselectedProject) {
    const newUnselectedProjects = unselectedProjects(model).map(p => sameProjectName(p) ? newProject : p);

    return updateAt(['unselectedProjects'], newUnselectedProjects, model);
  }

  return model;
});

/* eslint-disable no-nested-ternary */
// Hook things up here.
const mapStateToProps = model => {
  // eslint-disable-line complexity
  return {
    selectedProject: selectedProject(model),
    allProjects: allProjects(model),
    recordingsInfo: recordingsInfo(model),
    isMinimised: model.minimised
  };
};

const mapDispatchToProps = dispatch => ({ dispatch });

const Widget = connect(mapStateToProps, mapDispatchToProps)(Widget$2);

const {
  string: string$1,
  object: object$1,
  array: array$1,
  nullable: nullable$1,
  bool: bool$1
} = typeCheckers;

const modelType = object$1({
  minimised: bool$1,
  serverURL: string$1,
  unselectedProjects: nullable$1(array$1(Project.typeCheck)),
  selectedProject: nullable$1(Project.typeCheck)
});

var _curry2$21 = _curry2$1;
var _isString$3 = _isString$1;


/**
 * Returns the nth element of the given list or string. If n is negative the
 * element at index length + n is returned.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig Number -> [a] -> a | Undefined
 * @sig Number -> String -> String
 * @param {Number} offset
 * @param {*} list
 * @return {*}
 * @example
 *
 *      var list = ['foo', 'bar', 'baz', 'quux'];
 *      R.nth(1, list); //=> 'bar'
 *      R.nth(-1, list); //=> 'quux'
 *      R.nth(-99, list); //=> undefined
 *
 *      R.nth(2, 'abc'); //=> 'c'
 *      R.nth(3, 'abc'); //=> ''
 */
var nth$1 = _curry2$21(function nth$1(offset, list) {
  var idx = offset < 0 ? list.length + offset : offset;
  return _isString$3(list) ? list.charAt(idx) : list[idx];
});

var nth = nth$1;


/**
 * Returns the first element of the given list or string. In some libraries
 * this function is named `first`.
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category List
 * @sig [a] -> a | Undefined
 * @sig String -> String
 * @param {Array|String} list
 * @return {*}
 * @see R.tail, R.init, R.last
 * @example
 *
 *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
 *      R.head([]); //=> undefined
 *
 *      R.head('abc'); //=> 'a'
 *      R.head(''); //=> ''
 */
var head = nth(0);

// Model -> {Project, Deliverable} -> Model
const toggleDeliverableRecording = curry$1((model, { project, deliverable }) => Maybe.of(deliverable).map(Deliverable.getRecording).map(Recording.toggleRecording).map(Deliverable.setRecording(deliverable)).map(Project.updateDeliverable(project)).map(updateProject(project, model)).withDefault(model));

// Model -> Maybe
const findRecordingDeliverable = model => Maybe.of(model).map(recordingsInfo).map(filter(pipe$1(prop('recording'), Recording.isRecording))).map(head);

// Model -> Model
const stopAllRecordings = model => Maybe.of(model).map(m => console.log('stopping all recordings for', model) || m).chain(findRecordingDeliverable).map(toggleDeliverableRecording(model)).map(stopAllRecordings).withDefault(model);

// Project -> Maybe(Project)
const getUpToDateProject = curry$1((project, model) => Maybe.of(model).map(allProjects).map(find(Project.isSame(project))));

var toggleRecording$2 = ((model, { project, deliverable }) => Maybe.of(model).map(stopAllRecordings).chain(changedModel => getUpToDateProject(project, changedModel).map(p => toggleDeliverableRecording(changedModel, { project: p, deliverable }))).withDefault(model));

var selectProject$1 = ((model, action) => {
  const { project = null } = action;

  const projectName = propOr$1(null, 'name', project);
  const newUnselectedProjects = pipe$1(allProjects, reject$1(propEq$1('name', projectName)))(model);

  return pipe$1(updateAt(['selectedProject'], project), updateAt(['unselectedProjects'], newUnselectedProjects))(model);
});

var selectDeliverable$1 = ((model, action) => {
  const { project, deliverable = null } = action;

  return !project ? model : pipe$1(Project.setSelectedDeliverable(project), updateProject(project, model))(deliverable);
});

const processRawDeliverables = map$1(({ name, url }) => ({
  name,
  url,
  recording: null
}));

const processRawProjects = map$1(({ name, url, deliverables }) => ({
  name,
  url,
  unselectedDeliverables: processRawDeliverables(deliverables),
  selectedDeliverable: null
}));

var setProjects$1 = ((model, action) => {
  const newProjects = processRawProjects(action.rawProjects);
  return pipe$1(updateAt(['unselectedProjects'], newProjects), updateAt(['selectedProject'], null))(model);
});

var toggleMinimised$1 = ((model, action) => {
  const minimise = isNil(action.minimise) ? !model.minimised : !!action.minimise;
  return updateAt(['minimised'], minimise, model);
});

/* eslint-disable new-cap */
const actionHandlers = {
  toggleRecording: toggleRecording$2,
  selectProject: selectProject$1,
  selectDeliverable: selectDeliverable$1,
  setProjects: setProjects$1,
  toggleMinimised: toggleMinimised$1
};

function update(model, action) {
  const actionName = action.type.replace('WIDGET_', '');
  const handler = actionHandlers[actionName];

  if (!handler) {
    console.warn('Invalid action:', actionName);
    return model;
  }

  return pipe$1(handler, v => seamlessImmutable.asMutable(v, { deep: true }), modelType, Validation.throwFailure, Validation.withDefault(null), seamlessImmutable)(model, action);
}

const initialModel = {
  minimised: false,
  serverURL: './data.json',
  unselectedProjects: null,
  selectedProject: null
};

const store = createStore(update, initialModel);

// Perform some async initialisation task

fetch(initialModel.serverURL).then(r => r.json()).then(r => r.projects)
// Set projects is inside a function so that we use this.state.model at the
// time of the response, rather than at the time of the request.
.then(proj => store.dispatch(setProjects(proj)));

/* eslint-env jasmine */
/* eslint-disable new-cap, no-underscore-dangle */
describe('Validation type', () => {
  const successVal = 'success';
  const successVal2 = 'success2';
  const failureVal = 'failure';
  const aSuccess = Validation.Success(successVal);
  const aSuccess2 = Validation.Success(successVal2);
  const aFailure = Validation.Failure(failureVal);

  it('creates a success value with a truthy parameter', () => {
    const a = Validation.Success(123);
    expect(a.isSuccess).toBe(true);
    expect(Validation.isSuccess(a)).toBe(true);
  });

  it('creates a failure with the Failure function even if the value is truthy', () => {
    expect(Validation.Failure('a reason').isSuccess).toBe(false);
  });

  it('returns the default value when Failure with withDefalault', () => {
    expect(Validation.Failure().withDefault('default')).toEqual('default');
    expect(Validation.withDefault('default', Validation.Failure())).toEqual('default');
  });

  it('returns the main value when Success with withDefalault', () => {
    expect(aSuccess.withDefault('error')).toEqual(successVal);
    expect(Validation.withDefault('error', aSuccess)).toEqual(successVal);
  });

  it('maps successes and not failures', () => {
    expect(aSuccess.map(_ => 'r')._value).toEqual('r');
    expect(Validation.map(_ => 'r', aSuccess)._value).toEqual('r');
    expect(Validation.map(_ => 'r')(aSuccess)._value).toEqual('r');

    expect(aFailure.map(_ => 'r')._value).toEqual(failureVal);
    expect(Validation.map(_ => 'r', aFailure)._value).toEqual(failureVal);
    expect(Validation.map(_ => 'r')(aFailure)._value).toEqual(failureVal);
  });

  it('outputs a Validation type when mapping', () => {
    expect(aSuccess.map(_ => 'r') instanceof Validation).toBe(true);
    expect(Validation.map(_ => 'r', aSuccess) instanceof Validation).toBe(true);
    expect(Validation.map(_ => 'r')(aSuccess) instanceof Validation).toBe(true);

    expect(aFailure.map(_ => 'r') instanceof Validation).toBe(true);
    expect(Validation.map(_ => 'r', aFailure) instanceof Validation).toBe(true);
    expect(Validation.map(_ => 'r')(aFailure) instanceof Validation).toBe(true);
  });

  it('maps only successes with mapSuccess', () => {
    expect(aSuccess.mapSuccess(_ => 'r')._value).toEqual('r');
    expect(Validation.mapSuccess(_ => 'r', aSuccess)._value).toEqual('r');
    expect(Validation.mapSuccess(_ => 'r')(aSuccess)._value).toEqual('r');

    expect(aFailure.mapSuccess(_ => 'r')._value).toEqual(failureVal);
    expect(Validation.mapSuccess(_ => 'r', aFailure)._value).toEqual(failureVal);
    expect(Validation.mapSuccess(_ => 'r')(aFailure)._value).toEqual(failureVal);
  });

  it('maps only failures with mapFailure', () => {
    expect(aSuccess.mapFailure(_ => 'r')._value).toEqual(successVal);
    expect(Validation.mapFailure(_ => 'r', aSuccess)._value).toEqual(successVal);
    expect(Validation.mapFailure(_ => 'r')(aSuccess)._value).toEqual(successVal);

    expect(aFailure.mapFailure(_ => 'r')._value).toEqual('r');
    expect(Validation.mapFailure(_ => 'r', aFailure)._value).toEqual('r');
    expect(Validation.mapFailure(_ => 'r')(aFailure)._value).toEqual('r');
  });

  it('throws with throwFailure when Failure and doesn\'t when Success', () => {
    expect(_ => aFailure.throwFailure()).toThrow();
    expect(_ => Validation.throwFailure(aFailure)).toThrow();

    expect(_ => aSuccess.throwFailure()).not.toThrow();
    expect(_ => Validation.throwFailure(aSuccess)).not.toThrow();
  });

  it('calls the callback with andThen only when Success', () => {
    expect(aSuccess.andThen(_ => aSuccess2)).toEqual(aSuccess2);
    expect(Validation.andThen(_ => aSuccess2, aSuccess)).toEqual(aSuccess2);
    expect(Validation.andThen(_ => aSuccess2)(aSuccess)).toEqual(aSuccess2);

    expect(aFailure.andThen(_ => 'r')).toEqual(aFailure);
    expect(Validation.andThen(_ => 'r', aFailure)).toEqual(aFailure);
    expect(Validation.andThen(_ => 'r')(aFailure)).toEqual(aFailure);
  });

  it('throws when andThen callback does not return a validation', () => {
    expect(_ => aSuccess.andThen(_ => 'r')).toThrow();
    expect(_ => Validation.andThen(_ => 'r', aSuccess)).toThrow();
    expect(_ => Validation.andThen(_ => 'r')(aSuccess)).toThrow();
  });

  it('chains only successes', () => {
    const success1 = Validation.Success('1');
    const success2 = Validation.Success('2');

    expect(success1.chain(success2)._value).toEqual('2');
    expect(Validation.chain(success1, success2)._value).toEqual('2');
    expect(Validation.chain(success1)(success2)._value).toEqual('2');

    expect(aFailure.chain(success2)._value).toEqual(failureVal);
    expect(Validation.chain(aFailure, success2)._value).toEqual(failureVal);
    expect(Validation.chain(aFailure)(success2)._value).toEqual(failureVal);
  });
});

/* eslint-disable new-cap, no-underscore-dangle */


describe('Deliverable type', () => {
  const delivName = 'name';
  const delivUrl = 'url';
  const delivRec = Recording.of({ startTime: null, intervals: [] });
  const validObject = { name: delivName, url: delivUrl, recording: delivRec };
  const validDeliv = Deliverable.of(validObject);
  const validObjectNoRec = { name: delivName, url: delivUrl, recording: null };
  const validDelivNoRec = Deliverable.of(validObjectNoRec);

  it('type checks correctly', () => {
    const invalid1 = { name: 'asfd', url: 'adsf', recording: 'asdfa' };
    const invalid2 = { name: null, url: 'adsf', recording: null };
    const invalid3 = { name: 'asdf', url: null, recording: null };

    expect(Validation.isSuccess(Deliverable.typeCheck(invalid1))).toEqual(false);
    expect(Validation.isSuccess(Deliverable.typeCheck(invalid2))).toEqual(false);
    expect(Validation.isSuccess(Deliverable.typeCheck(invalid3))).toEqual(false);
    expect(Validation.isSuccess(Deliverable.typeCheck(validObject))).toEqual(true);
    expect(Validation.isSuccess(Deliverable.typeCheck(validObjectNoRec))).toEqual(true);
  });

  it('retuns a recording even if the Deliverable doesn\'t have one yet', () => {
    expect(pipe$1(Deliverable.getRecording, Recording.typeCheck, Validation.isSuccess)({})).toEqual(true);
    expect(Deliverable.getRecording(null)).toEqual(null);
    expect(Deliverable.getRecording(undefined)).toEqual(null);
    expect(Deliverable.getRecording({ recording: delivRec })).toEqual(delivRec);
  });

  it('returns name and doesn\'t throw with null', () => {
    expect(Deliverable.getName(validDeliv)).toEqual(delivName);
    expect(_ => Deliverable.getName(null)).not.toThrow();
  });

  it('returns url and doesn\'t throw with null', () => {
    expect(Deliverable.getUrl(validDeliv)).toEqual(delivUrl);
    expect(_ => Deliverable.getUrl(null)).not.toThrow();
  });

  it('returns an object with the correct recording when using setRecording', () => {
    const setAndGetRecording = pipe$1(Deliverable.setRecording, Deliverable.getRecording);

    expect(setAndGetRecording(validDelivNoRec, delivRec)).toEqual(delivRec);
    expect(setAndGetRecording(null, validDeliv)).toEqual(null);
    expect(_ => setAndGetRecording(null, null)).not.toThrow();
  });
});

/* eslint-disable new-cap, no-underscore-dangle */


describe('Recording type', () => {
  const now = Date.now();

  const secInterval5 = TimeInterval.of({
    start: new Date(now - 100 * 1000),
    end: new Date(now - 95 * 1000)
  });
  const secInterval10 = TimeInterval.of({
    start: new Date(now - 200 * 1000),
    end: new Date(now - 190 * 1000)
  });

  const valid1 = { startTime: null, intervals: [] };
  const valid1Running = { startTime: new Date(), intervals: [] };
  const valid2 = { startTime: null, intervals: [secInterval5, secInterval10] };
  const valid2Running = { startTime: new Date(), intervals: [secInterval5, secInterval10] };

  it('type checks correctly', () => {
    const invalid1 = {};
    const invalid1Running = { startTime: 'adsf', intervals: [] };
    const invalid2 = { startTime: 'adsf', intervals: null };
    const validates = pipe$1(Recording.typeCheck, Validation.isSuccess);

    expect(validates(invalid1)).toBe(false);
    expect(validates(invalid1Running)).toBe(false);
    expect(validates(invalid2)).toBe(false);

    expect(validates(valid1)).toBe(true);
    expect(validates(valid1Running)).toBe(true);
    expect(validates(valid2)).toBe(true);
    expect(validates(valid2Running)).toBe(true);
  });

  it('returns the startTime and does not break with null', () => {
    const date = new Date();
    expect(Recording.getStartTime({ startTime: date })).toEqual(date);
    expect(Recording.getStartTime({ startTime: null })).toEqual(null);
    expect(Recording.getStartTime({})).toEqual(null);
    expect(_ => Recording.getStartTime(null)).not.toThrow();
  });

  it('always returns an array for getIntervals', () => {
    const intervals = [secInterval10, secInterval5];
    const intervalIsArray = pipe$1(Recording.getIntervals, v => Array.isArray(v));

    expect(intervalIsArray({ intervals })).toEqual(true);
    expect(intervalIsArray({ intervals: null })).toEqual(true);
    expect(intervalIsArray({})).toEqual(true);
    expect(intervalIsArray(null)).toEqual(true);
    expect(_ => Recording.getIntervals(null)).not.toThrow();
  });

  it('sets the interval without throwing with null', () => {
    expect(_ => Recording.setIntervals(null, null)).not.toThrow();
    expect(_ => Recording.setIntervals(null, [])).not.toThrow();
    expect(_ => Recording.setIntervals({ intervals: [] }, null)).not.toThrow();
    expect(_ => Recording.setIntervals({ intervals: [] }, undefined)).not.toThrow();
    expect(_ => Recording.setIntervals({ intervals: [] }, 'asfadsf')).not.toThrow();
    expect(_ => Recording.setIntervals('asasdf', 'asfadsf')).not.toThrow();
    expect(_ => Recording.setIntervals('asasdf', [])).not.toThrow();
  });

  it('setIntervals works', () => {
    const empty = [];
    const intervals = [secInterval10, secInterval5];
    const setAndGetIntervals = pipe$1(Recording.setIntervals, Recording.getIntervals);
    expect(setAndGetIntervals({ intervals: [] }, intervals)).toEqual(intervals);
    expect(setAndGetIntervals({ intervals }, empty)).toEqual(empty);
    expect(setAndGetIntervals({}, empty)).toEqual(empty);
  });

  it('says whether isRecording or not', () => {
    expect(Recording.isRecording(valid1Running)).toEqual(true);
    expect(Recording.isRecording(valid2)).toEqual(false);
    expect(_ => Recording.isRecording(null)).not.toThrow();
  });

  it('sets the correct startTime in toggleRecording', () => {
    const toggledValue = pipe$1(Recording.toggleRecording, Recording.isRecording);
    const toggledStartTime = pipe$1(Recording.toggleRecording, Recording.getStartTime);
    expect(toggledValue(valid1Running)).toEqual(false);
    expect(toggledValue(valid1)).toEqual(true);
    expect(toggledValue(null)).toEqual(false);
    expect(toggledStartTime(valid1Running)).toBe(null);
    expect(toggledStartTime(valid2).valueOf()).toBeLessThanOrEqual(new Date().valueOf());
  });

  it('calculates the total time correctly', () => {
    const sec15 = { startTime: null, intervals: [secInterval10, secInterval5] };
    const sec15Running = { startTime: new Date(), intervals: [secInterval10, secInterval5] };
    const sec0 = { startTime: null, intervals: [] };
    const sec0Running = { startTime: new Date(), intervals: [] };

    expect(Recording.totalTime(sec15)).toEqual(1000 * 15);
    expect(Recording.totalTime(sec0)).toEqual(0);
    expect(Recording.totalTime(sec15Running)).toBeGreaterThan(100 * 15);
    expect(Recording.totalTime(sec0Running)).toBeGreaterThan(0);
  });

  it('does not break when totalTime receives null and always returns a number', () => {
    expect(_ => Recording.totalTime(null)).not.toThrow();
    expect(Recording.totalTime(null)).toEqual(0);
    expect(Recording.totalTime()).toEqual(0);
    expect(Recording.totalTime({})).toEqual(0);
    expect(Recording.totalTime([])).toEqual(0);
  });
});

/* eslint-env jasmine */

describe('Maybe type', () => {
  const createdJustWithOf = pipe$1(Maybe.of, Maybe.isJust);
  const createdJust = pipe$1(Maybe.Just, Maybe.isJust);
  const createdNothing = pipe$1(Maybe.Nothing, Maybe.isNothing);
  const defaultVal = 'default';
  const justVal = 'asfd';

  it('creates a Just when passed truthy and falsy non-null values', () => {
    expect(createdJust('1')).toBe(true);
    expect(createdJust({})).toBe(true);
    expect(createdJust(true)).toBe(true);
    expect(createdJust(false)).toBe(true);
    expect(createdJust([])).toBe(true);
  });

  it('creates a Nothing when passed anything with the Nothing constructor', () => {
    expect(createdNothing('1')).toBe(true);
    expect(createdNothing({})).toBe(true);
    expect(createdNothing(true)).toBe(true);
    expect(createdNothing(false)).toBe(true);
    expect(createdNothing([])).toBe(true);
    expect(createdNothing(null)).toBe(true);
    expect(createdNothing()).toBe(true);
  });

  it('creates a Nothing if null or undefined is passed to the general constructor', () => {
    expect(createdJustWithOf(null)).toBe(false);
    expect(createdJustWithOf()).toBe(false);
  });

  it('creates a Just if something is passed to the general constructor', () => {
    expect(createdJustWithOf('1')).toBe(true);
    expect(createdJustWithOf({})).toBe(true);
    expect(createdJustWithOf(true)).toBe(true);
    expect(createdJustWithOf(false)).toBe(true);
    expect(createdJustWithOf([])).toBe(true);
  });

  it('Retuns default only to Nothing values', () => {
    expect(Maybe.withDefault(defaultVal, Maybe.Just(justVal))).toEqual(justVal);
    expect(Maybe.withDefault(defaultVal, Maybe.Nothing(justVal))).toEqual(defaultVal);
  });

  it('maps Just only values', () => {
    const mappedVal = 'mapped';
    const func = _ => mappedVal;
    const mapAndGetDefault = pipe$1(Maybe.map(func), Maybe.withDefault(defaultVal));
    expect(mapAndGetDefault(Maybe.Just(justVal))).toEqual(mappedVal);
    expect(mapAndGetDefault(Maybe.Nothing(justVal))).toEqual(defaultVal);
  });

  it('doesn\' does not continue mapping when a null value appears', () => {
    expect(Maybe.of(justVal).map(_ => null).map(_ => justVal).withDefault(defaultVal)).toEqual(defaultVal);
  });

  it('maps only two Justs in map2', () => {
    const mappedVal = 'mapped';
    const func = _ => mappedVal;
    const map2AndGetDefault = pipe$1(Maybe.map2(func), Maybe.withDefault(defaultVal));
    expect(map2AndGetDefault(Maybe.Just(justVal), Maybe.Just(justVal))).toEqual(mappedVal);
    expect(map2AndGetDefault(Maybe.Just(justVal), Maybe.Nothing(justVal))).toEqual(defaultVal);
    expect(map2AndGetDefault(Maybe.Nothing(justVal), Maybe.Just(justVal))).toEqual(defaultVal);
    expect(map2AndGetDefault(Maybe.Nothing(justVal), Maybe.Nothing(justVal))).toEqual(defaultVal);
  });

  it('has curried maps', () => {
    const mappedVal = 'mapped';
    expect(Maybe.withDefault(defaultVal, Maybe.map(_ => mappedVal)(Maybe.Just('j')))).toEqual(mappedVal);
  });
});

/* eslint-disable new-cap, no-underscore-dangle */


describe('TimeInterval type', () => {
  const now = Date.now();
  const validObj = { start: new Date(now), end: new Date(now + 5 * 1000) };

  it('checks for types correctly', () => {
    const invalid1 = {};
    const invalid2 = { start: new Date() };
    const invalid3 = { start: new Date(), end: '' };
    const invalid4 = { start: new Date(), end: 123 };
    const invalid5 = { end: new Date() };

    const validates = pipe$1(TimeInterval.typeCheck, Validation.isSuccess);
    expect(validates(invalid1)).toEqual(false);
    expect(validates(invalid2)).toEqual(false);
    expect(validates(invalid3)).toEqual(false);
    expect(validates(invalid4)).toEqual(false);
    expect(validates(invalid5)).toEqual(false);
  });

  it('returns start date without breaking with null', () => {
    expect(TimeInterval.getStart(validObj)).toEqual(validObj.start);
    expect(TimeInterval.getStart({})).toEqual(null);
    expect(TimeInterval.getStart(null)).toEqual(null);
    expect(TimeInterval.getStart(undefined)).toEqual(null);
  });

  it('returns end date without breaking with null', () => {
    expect(TimeInterval.getEnd(validObj)).toEqual(validObj.end);
    expect(TimeInterval.getEnd({})).toEqual(null);
    expect(TimeInterval.getEnd(null)).toEqual(null);
    expect(TimeInterval.getEnd(undefined)).toEqual(null);
  });

  it('calculates the date difference correctly', () => {
    expect(TimeInterval.getValue(validObj)).toEqual(5 * 1000);
  });

  it('returns null if an invalid TimeInterval object is provided in getValue', () => {
    expect(_ => TimeInterval.getValue(null)).not.toThrow();
    expect(TimeInterval.getValue(null)).toEqual(null);
    expect(TimeInterval.getValue(undefined)).toEqual(null);
    expect(TimeInterval.getValue({})).toEqual(null);
    expect(TimeInterval.getValue([])).toEqual(null);
  });
});

/* eslint-disable new-cap, no-underscore-dangle */


describe('Project type', () => {
  const delivRec = Recording.of({ startTime: null, intervals: [] });
  const mockDeliverable = { name: 'aaa', url: 'www', recording: delivRec };
  const validName = 'name';
  const validUrl = 'url';
  const unselectedDeliverables = [mockDeliverable];
  const valid = {
    name: validName,
    url: validUrl,
    unselectedDeliverables,
    selectedDeliverable: mockDeliverable
  };

  it('typeChecks ok', () => {
    const invalid1 = {
      name: validName,
      url: validUrl,
      unselectedDeliverables: null,
      selectedDeliverable: null
    };
    const invalid2 = {
      name: validName,
      url: validUrl,
      unselectedDeliverables: [],
      selectedDeliverable: []
    };
    const invalid3 = {};

    const isValid = pipe$1(Project.typeCheck, Validation.isSuccess);
    expect(isValid(invalid1)).toEqual(false);
    expect(isValid(invalid2)).toEqual(false);
    expect(isValid(invalid3)).toEqual(false);
    expect(isValid(valid)).toEqual(true);
  });

  it('returns name without breaking with null', () => {
    const getName = pipe$1(Project.of, Project.getName);
    expect(getName(valid)).toEqual(validName);
    expect(getName({})).toEqual(null);
    expect(getName()).toEqual(null);
    expect(getName(null)).toEqual(null);
  });

  it('returns url without breaking with null', () => {
    const getUrl = pipe$1(Project.of, Project.getUrl);
    expect(getUrl(valid)).toEqual(validUrl);
    expect(getUrl({})).toEqual(null);
    expect(getUrl()).toEqual(null);
    expect(getUrl(null)).toEqual(null);
  });

  it('returns deliverables without breaking with null', () => {
    const getDeliverables = pipe$1(Project.of, Project.getDeliverables);
    expect(getDeliverables(valid).find(m => m.url === mockDeliverable.url)).toBeTruthy();
    expect(getDeliverables({})).toEqual([]);
    expect(getDeliverables()).toEqual([]);
    expect(getDeliverables(null)).toEqual([]);
  });

  it('returns selectedDeliverable without breaking with null', () => {
    const getSelectedDeliverable = pipe$1(Project.of, Project.getSelectedDeliverable);
    expect(getSelectedDeliverable(valid)).toEqual(mockDeliverable);
    expect(getSelectedDeliverable({})).toEqual(null);
    expect(getSelectedDeliverable()).toEqual(null);
    expect(getSelectedDeliverable(null)).toEqual(null);
  });

  it('updates a deliverable that is selected', () => {
    const mockDeliverableChanged = Object.assign({}, mockDeliverable, { url: 'jjj' });
    const mockProject = {
      name: 'asfd',
      url: 'asdf',
      unselectedDeliverables: [],
      selectedDeliverable: mockDeliverable
    };

    const updateAndGetDeliverables = pipe$1(Project.updateDeliverable, Project.getDeliverables);

    expect(updateAndGetDeliverables(mockProject, mockDeliverableChanged).find(m => m.url === mockDeliverableChanged.url)).toBeTruthy();
    expect(updateAndGetDeliverables(mockProject, mockDeliverableChanged).find(m => m.url === mockDeliverable.url)).toBeFalsy();
  });

  it('updates a deliverable that is not selected', () => {
    const mockDeliverableChanged = Object.assign({}, mockDeliverable, { url: 'jjj' });
    const mockProject = {
      name: 'asfd',
      url: 'asdf',
      unselectedDeliverables: [mockDeliverable],
      selectedDeliverable: null
    };

    const updateAndGetDeliverables = pipe$1(Project.updateDeliverable, Project.getDeliverables);

    expect(updateAndGetDeliverables(mockProject, mockDeliverableChanged).find(m => m.url === mockDeliverableChanged.url)).toBeTruthy();
    expect(updateAndGetDeliverables(mockProject, mockDeliverableChanged).find(m => m.url === mockDeliverable.url)).toBeFalsy();
  });

  it('handles nulls when updating deliverables', () => {
    expect(_ => Project.updateDeliverable(null, null)).not.toThrow();
    expect(_ => Project.updateDeliverable(valid, null)).not.toThrow();
    expect(_ => Project.updateDeliverable(valid, valid)).not.toThrow();
  });
});

/* eslint-env jasmine */
const mockDeliverable = {
  "name": "Rush with possible clients",
  "url": "localhost:8080/deliverables/rush-cold-call",
  "recording": {
    "startTime": null,
    "intervals": [{
      "start": "2016-12-13T13:37:01.465Z",
      "end": "2016-12-13T13:41:23.457Z"
    }]
  }
};

const mockProject = {
  "name": "Rushed project",
  "url": "localhost:8080/projects/rushed-project",
  "unselectedDeliverables": [mockDeliverable, {
    "name": "Rush with online ads",
    "url": "localhost:8080/deliverables/rush-buy-ads",
    "recording": {
      "startTime": null,
      "intervals": [{
        "start": "2016-12-13T13:36:58.941Z",
        "end": "2016-12-13T13:37:01.460Z"
      }]
    }
  }, {
    "name": "Rush with logo",
    "url": "localhost:8080/deliverables/rush-create-logo",
    "recording": null
  }],
  "selectedDeliverable": mockDeliverable
};

const mockUnselectedDeliverable = {
  "name": "Useless logo",
  "url": "localhost:8080/deliverables/useless-create-logo",
  "recording": null
};

const mockUnselectedProject = {
  "name": "Useless project",
  "url": "localhost:8080/projects/rushed-project",
  "unselectedDeliverables": [mockUnselectedDeliverable, {
    "name": "Useless online ads",
    "url": "localhost:8080/deliverables/useless-buy-ads",
    "recording": null
  }, {
    "name": "Useless possible clients",
    "url": "localhost:8080/deliverables/useless-cold-call",
    "recording": null
  }],
  "selectedDeliverable": null
};

const mockModel = {
  "minimised": false,
  "serverURL": "./data.json",
  "unselectedProjects": [mockUnselectedProject, {
    "name": "Big project",
    "url": "localhost:8080/projects/big-project",
    "unselectedDeliverables": [{
      "name": "Cold call possible clients",
      "url": "localhost:8080/deliverables/cold-call",
      "recording": {
        "startTime": "2016-12-13T13:37:52.078Z", /// Is recording
        "intervals": [{
          "start": "2016-12-13T13:36:52.078Z",
          "end": "2016-12-13T13:36:55.013Z"
        }]
      }
    }, {
      "name": "Buy online ads",
      "url": "localhost:8080/deliverables/buy-ads",
      "recording": {
        "startTime": "2016-12-13T13:39:52.078Z", // Is recording
        "intervals": [{
          "start": "2016-12-13T13:36:50.309Z",
          "end": "2016-12-13T13:36:52.075Z"
        }]
      }
    }],
    "selectedDeliverable": {
      "name": "Create logo",
      "url": "localhost:8080/deliverables/create-logo",
      "recording": {
        "startTime": null,
        "intervals": [{
          "start": "2016-12-13T13:36:55.018Z",
          "end": "2016-12-13T13:36:58.935Z"
        }]
      }
    }
  }],
  "selectedProject": {
    "name": "Rushed project",
    "url": "localhost:8080/projects/rushed-project",
    "unselectedDeliverables": [{
      "name": "Rush with online ads",
      "url": "localhost:8080/deliverables/rush-buy-ads",
      "recording": {
        "startTime": null,
        "intervals": [{
          "start": "2016-12-13T13:36:58.941Z",
          "end": "2016-12-13T13:37:01.460Z"
        }]
      }
    }, {
      "name": "Rush with logo",
      "url": "localhost:8080/deliverables/rush-create-logo",
      "recording": null
    }],
    "selectedDeliverable": {
      "name": "Rush with possible clients",
      "url": "localhost:8080/deliverables/rush-cold-call",
      "recording": {
        "startTime": "2016-12-13T13:41:24.202Z",
        "intervals": [{
          "start": "2016-12-13T13:37:01.465Z",
          "end": "2016-12-13T13:41:23.457Z"
        }]
      }
    }
  }
};

describe('Update.toggleRecording', () => {
  it('stops other recordings when toggling the selected project', () => {
    const mockAction = {
      project: mockProject,
      deliverable: mockDeliverable
    };

    const toggledModel = toggleRecording$2(mockModel, mockAction);

    const deliverablesRecording = recordingsInfo(toggledModel).filter(pipe$1(prop('recording'), Recording.isRecording)).map(prop('deliverable'));

    expect(deliverablesRecording.length).toEqual(1);
    const sameName = Deliverable.getName(mockDeliverable) === Deliverable.getName(deliverablesRecording[0]);
    expect(sameName).toEqual(true);
  });

  it('stops other recordings when toggling an unselected project and deliverable', () => {
    const mockAction = {
      project: mockUnselectedProject,
      deliverable: mockUnselectedDeliverable
    };

    const toggledModel = toggleRecording$2(mockModel, mockAction);

    const deliverablesRecording = recordingsInfo(toggledModel).filter(pipe$1(prop('recording'), Recording.isRecording)).map(prop('deliverable'));

    expect(deliverablesRecording.length).toEqual(1);
    const sameName = Deliverable.getName(mockUnselectedDeliverable) === Deliverable.getName(deliverablesRecording[0]);
    expect(sameName).toEqual(true);
  });
});

var main = function () {
  const wrapper = document.createElement('div');

  index$3.render(react.createElement(Widget, { store: store }), wrapper);
  return wrapper;
};

return main;

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QvbGliL3JlYWN0UHJvZEludmFyaWFudC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUG9vbGVkQ2xhc3MuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2NhbkRlZmluZVByb3BlcnR5LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFbGVtZW50U3ltYm9sLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFbGVtZW50LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0SXRlcmF0b3JGbi5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0tleUVzY2FwZVV0aWxzLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q2hpbGRyZW4uanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE5vb3BVcGRhdGVRdWV1ZS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHVyZUNvbXBvbmVudC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDbGFzcy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2suanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2NoZWNrUmVhY3RUeXBlU3BlYy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RWxlbWVudFZhbGlkYXRvci5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NRmFjdG9yaWVzLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFZlcnNpb24uanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9vbmx5Q2hpbGQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QvcmVhY3QuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0RPTVByb3BlcnR5LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29tcG9uZW50RmxhZ3MuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01Db21wb25lbnRUcmVlLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0FSSUFET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9FdmVudFBsdWdpblJlZ2lzdHJ5LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RXJyb3JVdGlscy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9FdmVudFBsdWdpblV0aWxzLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2FjY3VtdWxhdGVJbnRvLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2ZvckVhY2hBY2N1bXVsYXRlZC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9FdmVudFBsdWdpbkh1Yi5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9FdmVudFByb3BhZ2F0b3JzLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9Qb29sZWRDbGFzcy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9nZXRUZXh0Q29udGVudEFjY2Vzc29yLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNFdmVudC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0lucHV0RXZlbnQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvQmVmb3JlSW5wdXRFdmVudFBsdWdpbi5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9DYWxsYmFja1F1ZXVlLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RmVhdHVyZUZsYWdzLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0T3duZXIuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RSZWYuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vay5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvZmJqcy9saWIvcGVyZm9ybWFuY2UuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL2ZianMvbGliL3BlcmZvcm1hbmNlTm93LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RGVidWdUb29sLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0SW5zdHJ1bWVudGF0aW9uLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0UmVjb25jaWxlci5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9UcmFuc2FjdGlvbi5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFVwZGF0ZXMuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0RXZlbnRUYXJnZXQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvaXNFdmVudFN1cHBvcnRlZC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvQ2hhbmdlRXZlbnRQbHVnaW4uanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljVUlFdmVudC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9WaWV3cG9ydE1ldHJpY3MuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0RXZlbnRNb2RpZmllclN0YXRlLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY01vdXNlRXZlbnQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0hUTUxET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9ET01OYW1lc3BhY2VzLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24uanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvc2V0SW5uZXJIVE1MLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlci5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9zZXRUZXh0Q29udGVudC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9ET01MYXp5VHJlZS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvZmJqcy9saWIvY3JlYXRlQXJyYXlGcm9tTWl4ZWQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldE1hcmt1cFdyYXAuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9EYW5nZXIuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NSURPcGVyYXRpb25zLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9mb2N1c05vZGUuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvQXV0b0ZvY3VzVXRpbHMuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvQ1NTUHJvcGVydHkuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9kYW5nZXJvdXNTdHlsZVZhbHVlLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHkuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0RPTVByb3BlcnR5T3BlcmF0aW9ucy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldFZlbmRvclByZWZpeGVkRXZlbnROYW1lLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NSW5wdXQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01TZWxlY3QuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01PcHRpb24uanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01UZXh0YXJlYS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0SW5zdGFuY2VNYXAuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3ROb2RlVHlwZXMuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvY2hlY2tSZWFjdFR5cGVTcGVjLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RDb21wb3NpdGVDb21wb25lbnQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RFbXB0eUNvbXBvbmVudC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEhvc3RDb21wb25lbnQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0TmV4dERlYnVnSUQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9LZXlFc2NhcGVVdGlscy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEVsZW1lbnRTeW1ib2wuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0SXRlcmF0b3JGbi5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0Q2hpbGRSZWNvbmNpbGVyLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2ZsYXR0ZW5DaGlsZHJlbi5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdE11bHRpQ2hpbGQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RVcGRhdGVRdWV1ZS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24uanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvdmFsaWRhdGVET01OZXN0aW5nLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NQ29tcG9uZW50LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NRW1wdHlDb21wb25lbnQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01UcmVlVHJhdmVyc2FsLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbi5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEV2ZW50TGlzdGVuZXIuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RJbmplY3Rpb24uanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTVNlbGVjdGlvbi5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNOb2RlLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jb250YWluc05vZGUuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RJbnB1dFNlbGVjdGlvbi5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1NWR0RPTVByb3BlcnR5Q29uZmlnLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0RXZlbnRDaGFyQ29kZS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9nZXRFdmVudEtleS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNLZXlib2FyZEV2ZW50LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0RyYWdFdmVudC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNUb3VjaEV2ZW50LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1RyYW5zaXRpb25FdmVudC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNXaGVlbEV2ZW50LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1NpbXBsZUV2ZW50UGx1Z2luLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RGVmYXVsdEluamVjdGlvbi5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUNvbnRhaW5lckluZm8uanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01GZWF0dXJlRmxhZ3MuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvYWRsZXIzMi5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdE1hcmt1cENoZWNrc3VtLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0TW91bnQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RWZXJzaW9uLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2ZpbmRET01Ob2RlLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vay5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2suanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01JbnZhbGlkQVJJQUhvb2suanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET00uanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19pc1BsYWNlaG9sZGVyLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2N1cnJ5MS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19jdXJyeTIuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fc2xpY2UuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9zb3J0QnkuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9faXNBcnJheS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19pc1RyYW5zZm9ybWVyLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19maWx0ZXIuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9faXNPYmplY3QuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9feHdyYXAuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fYXJpdHkuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9iaW5kLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2lzU3RyaW5nLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaXNBcnJheUxpa2UuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fcmVkdWNlLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX3hmQmFzZS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL194ZmlsdGVyLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2hhcy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19pc0FyZ3VtZW50cy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2tleXMuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9maWx0ZXIuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9wcm9wLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX21hcC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL194bWFwLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2N1cnJ5Ti5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2N1cnJ5Ti5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL21hcC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19jdXJyeTMuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fYXJyYXlGcm9tSXRlcmF0b3IuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fZnVuY3Rpb25OYW1lLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaWRlbnRpY2FsLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvdHlwZS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19lcXVhbHMuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9lcXVhbHMuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9wcm9wRXEuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fcmVkdWNlZC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL194ZmluZC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ZpbmQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9wcm9wT3IuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9fcGlwZS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3JlZHVjZS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19jaGVja0Zvck1ldGhvZC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3NsaWNlLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvdGFpbC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3BpcGUuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LWlucHV0LWF1dG9zaXplL2xpYi9BdXRvc2l6ZUlucHV0LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1zZWxlY3QvbGliL3V0aWxzL2RlZmF1bHRBcnJvd1JlbmRlcmVyLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1zZWxlY3QvbGliL3V0aWxzL3N0cmlwRGlhY3JpdGljcy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3Qtc2VsZWN0L2xpYi91dGlscy9kZWZhdWx0RmlsdGVyT3B0aW9ucy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3Qtc2VsZWN0L2xpYi91dGlscy9kZWZhdWx0TWVudVJlbmRlcmVyLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1zZWxlY3QvbGliL0FzeW5jLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1zZWxlY3QvbGliL0FzeW5jQ3JlYXRhYmxlLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1zZWxlY3QvbGliL0NyZWF0YWJsZS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3Qtc2VsZWN0L2xpYi9PcHRpb24uanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXNlbGVjdC9saWIvVmFsdWUuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXNlbGVjdC9saWIvU2VsZWN0LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvY3VycnkuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvc3JjL2pzL3R5cGVzL01heWJlLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL3NyYy9qcy90eXBlcy9SZW1vdGVEYXRhLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9mbC1hc3NlcnQvZGlzdC9hc3NlcnQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvc3JjL2pzL3R5cGVzL1ZhbGlkYXRpb24uanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pc05pbC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9zcmMvanMvdHlwZXMvdHlwZS1jaGVja2Vycy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvc2VhbWxlc3MtaW1tdXRhYmxlL3NyYy9zZWFtbGVzcy1pbW11dGFibGUuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvc3JjL2pzL3R5cGVzL3V0aWxzLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL3NyYy9qcy90eXBlcy9UaW1lSW50ZXJ2YWwuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvc3JjL2pzL3R5cGVzL1JlY29yZGluZy90b2dnbGVSZWNvcmRpbmcuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9hZGQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvc3JjL2pzL3R5cGVzL1JlY29yZGluZy90b3RhbFRpbWUuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvc3JjL2pzL3R5cGVzL1JlY29yZGluZy9pbmRleC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9zcmMvanMvdHlwZXMvRGVsaXZlcmFibGUuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvc3JjL2pzL3R5cGVzL1Byb2plY3QuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvc3JjL2pzL3R5cGVzL2luZGV4LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL3NyYy9qcy9XaWRnZXQvdmlldy9UaW1lci5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9zcmMvanMvV2lkZ2V0L2FjdGlvbnMuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvc3JjL2pzL1dpZGdldC92aWV3L1JlY29yZGluZ1Jvdy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9zcmMvanMvV2lkZ2V0L3ZpZXcvaW5kZXguanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2xpYi91dGlscy9zdG9yZVNoYXBlLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9saWIvdXRpbHMvd2FybmluZy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbGliL2NvbXBvbmVudHMvUHJvdmlkZXIuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2xpYi91dGlscy9zaGFsbG93RXF1YWwuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZnJlZUdsb2JhbC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N5bWJvbC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRSYXdUYWcuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyQXJnLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFByb3RvdHlwZS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0TGlrZS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3N5bWJvbC1vYnNlcnZhYmxlL2VzL3BvbnlmaWxsLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9lcy9pbmRleC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVkdXgvZXMvY3JlYXRlU3RvcmUuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlZHV4L2VzL3V0aWxzL3dhcm5pbmcuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2NvbWJpbmVSZWR1Y2Vycy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVkdXgvZXMvYmluZEFjdGlvbkNyZWF0b3JzLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9jb21wb3NlLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWR1eC9lcy9hcHBseU1pZGRsZXdhcmUuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JlZHV4L2VzL2luZGV4LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9saWIvdXRpbHMvd3JhcEFjdGlvbkNyZWF0b3JzLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvaW52YXJpYW50L2ludmFyaWFudC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbGliL2NvbXBvbmVudHMvY29ubmVjdC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvbGliL2luZGV4LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX2lzRnVuY3Rpb24uanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9pbnRlcm5hbC9faW5kZXhPZi5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19jb250YWlucy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19xdW90ZS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL190b0lTT1N0cmluZy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2ludGVybmFsL19jb21wbGVtZW50LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvcmVqZWN0LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaW50ZXJuYWwvX3RvU3RyaW5nLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvdG9TdHJpbmcuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9jb25jYXQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9sdC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL2RlZmF1bHRUby5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9ub2RlX21vZHVsZXMvcmFtZGEvc3JjL3BhdGguanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3JhbWRhL3NyYy9wYXRoT3IuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvc3JjL2pzL1dpZGdldC91cGRhdGUvdXRpbHMuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvc3JjL2pzL1dpZGdldC9pbmRleC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9zcmMvanMvV2lkZ2V0L21vZGVsLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvbnRoLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL25vZGVfbW9kdWxlcy9yYW1kYS9zcmMvaGVhZC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9zcmMvanMvV2lkZ2V0L3VwZGF0ZS90b2dnbGVSZWNvcmRpbmcuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvc3JjL2pzL1dpZGdldC91cGRhdGUvc2VsZWN0UHJvamVjdC5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9zcmMvanMvV2lkZ2V0L3VwZGF0ZS9zZWxlY3REZWxpdmVyYWJsZS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9zcmMvanMvV2lkZ2V0L3VwZGF0ZS9zZXRQcm9qZWN0cy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9zcmMvanMvV2lkZ2V0L3VwZGF0ZS90b2dnbGVNaW5pbWlzZWQuanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvc3JjL2pzL1dpZGdldC91cGRhdGUvaW5kZXguanMiLCIvaG9tZS9tYXJjZWxvL1Byb2dyYW1zL0ZvdXJMYWJzL1V0aWxpdGllcy90aW1lLXRyYWNrZXIvc3JjL2pzL3N0b3JlLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL3NyYy90ZXN0cy90eXBlcy9WYWxpZGF0aW9uLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL3NyYy90ZXN0cy90eXBlcy9EZWxpdmVyYWJsZS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9zcmMvdGVzdHMvdHlwZXMvUmVjb3JkaW5nLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL3NyYy90ZXN0cy90eXBlcy9NYXliZS5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9zcmMvdGVzdHMvdHlwZXMvVGltZUludGVydmFsLmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL3NyYy90ZXN0cy90eXBlcy9Qcm9qZWN0LmpzIiwiL2hvbWUvbWFyY2Vsby9Qcm9ncmFtcy9Gb3VyTGFicy9VdGlsaXRpZXMvdGltZS10cmFja2VyL3NyYy90ZXN0cy9XaWRnZXQvdXBkYXRlLnRvZ2dsZVJlY29yZGluZy5qcyIsIi9ob21lL21hcmNlbG8vUHJvZ3JhbXMvRm91ckxhYnMvVXRpbGl0aWVzL3RpbWUtdHJhY2tlci9zcmMvanMvbWFpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBXQVJOSU5HOiBETyBOT1QgbWFudWFsbHkgcmVxdWlyZSB0aGlzIG1vZHVsZS5cbiAqIFRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgYGludmFyaWFudCguLi4pYCB1c2VkIGJ5IHRoZSBlcnJvciBjb2RlIHN5c3RlbVxuICogYW5kIHdpbGwgX29ubHlfIGJlIHJlcXVpcmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGJhYmVsIHBhc3MuXG4gKiBJdCBhbHdheXMgdGhyb3dzLlxuICovXG5cbmZ1bmN0aW9uIHJlYWN0UHJvZEludmFyaWFudChjb2RlKSB7XG4gIHZhciBhcmdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuXG4gIHZhciBtZXNzYWdlID0gJ01pbmlmaWVkIFJlYWN0IGVycm9yICMnICsgY29kZSArICc7IHZpc2l0ICcgKyAnaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnQ9JyArIGNvZGU7XG5cbiAgZm9yICh2YXIgYXJnSWR4ID0gMDsgYXJnSWR4IDwgYXJnQ291bnQ7IGFyZ0lkeCsrKSB7XG4gICAgbWVzc2FnZSArPSAnJmFyZ3NbXT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1thcmdJZHggKyAxXSk7XG4gIH1cblxuICBtZXNzYWdlICs9ICcgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50JyArICcgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJztcblxuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCByZWFjdFByb2RJbnZhcmlhbnQncyBvd24gZnJhbWVcblxuICB0aHJvdyBlcnJvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdFByb2RJbnZhcmlhbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBTdGF0aWMgcG9vbGVycy4gU2V2ZXJhbCBjdXN0b20gdmVyc2lvbnMgZm9yIGVhY2ggcG90ZW50aWFsIG51bWJlciBvZlxuICogYXJndW1lbnRzLiBBIGNvbXBsZXRlbHkgZ2VuZXJpYyBwb29sZXIgaXMgZWFzeSB0byBpbXBsZW1lbnQsIGJ1dCB3b3VsZFxuICogcmVxdWlyZSBhY2Nlc3NpbmcgdGhlIGBhcmd1bWVudHNgIG9iamVjdC4gSW4gZWFjaCBvZiB0aGVzZSwgYHRoaXNgIHJlZmVycyB0b1xuICogdGhlIENsYXNzIGl0c2VsZiwgbm90IGFuIGluc3RhbmNlLiBJZiBhbnkgb3RoZXJzIGFyZSBuZWVkZWQsIHNpbXBseSBhZGQgdGhlbVxuICogaGVyZSwgb3IgaW4gdGhlaXIgb3duIGZpbGVzLlxuICovXG52YXIgb25lQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoY29weUZpZWxkc0Zyb20pIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgY29weUZpZWxkc0Zyb20pO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGNvcHlGaWVsZHNGcm9tKTtcbiAgfVxufTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMikge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMik7XG4gIH1cbn07XG5cbnZhciB0aHJlZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMyk7XG4gIH1cbn07XG5cbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMywgYTQpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0KTtcbiAgfVxufTtcblxudmFyIGZpdmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMywgYTQsIGE1KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICB9XG59O1xuXG52YXIgc3RhbmRhcmRSZWxlYXNlciA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICAhKGluc3RhbmNlIGluc3RhbmNlb2YgS2xhc3MpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyeWluZyB0byByZWxlYXNlIGFuIGluc3RhbmNlIGludG8gYSBwb29sIG9mIGEgZGlmZmVyZW50IHR5cGUuJykgOiBfcHJvZEludmFyaWFudCgnMjUnKSA6IHZvaWQgMDtcbiAgaW5zdGFuY2UuZGVzdHJ1Y3RvcigpO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCA8IEtsYXNzLnBvb2xTaXplKSB7XG4gICAgS2xhc3MuaW5zdGFuY2VQb29sLnB1c2goaW5zdGFuY2UpO1xuICB9XG59O1xuXG52YXIgREVGQVVMVF9QT09MX1NJWkUgPSAxMDtcbnZhciBERUZBVUxUX1BPT0xFUiA9IG9uZUFyZ3VtZW50UG9vbGVyO1xuXG4vKipcbiAqIEF1Z21lbnRzIGBDb3B5Q29uc3RydWN0b3JgIHRvIGJlIGEgcG9vbGFibGUgY2xhc3MsIGF1Z21lbnRpbmcgb25seSB0aGUgY2xhc3NcbiAqIGl0c2VsZiAoc3RhdGljYWxseSkgbm90IGFkZGluZyBhbnkgcHJvdG90eXBpY2FsIGZpZWxkcy4gQW55IENvcHlDb25zdHJ1Y3RvclxuICogeW91IGdpdmUgdGhpcyBtYXkgaGF2ZSBhIGBwb29sU2l6ZWAgcHJvcGVydHksIGFuZCB3aWxsIGxvb2sgZm9yIGFcbiAqIHByb3RvdHlwaWNhbCBgZGVzdHJ1Y3RvcmAgb24gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IENvcHlDb25zdHJ1Y3RvciBDb25zdHJ1Y3RvciB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcG9vbGVyIEN1c3RvbWl6YWJsZSBwb29sZXIuXG4gKi9cbnZhciBhZGRQb29saW5nVG8gPSBmdW5jdGlvbiAoQ29weUNvbnN0cnVjdG9yLCBwb29sZXIpIHtcbiAgLy8gQ2FzdGluZyBhcyBhbnkgc28gdGhhdCBmbG93IGlnbm9yZXMgdGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvbiBhbmQgdHJ1c3RzXG4gIC8vIGl0IHRvIG1hdGNoIHRoZSB0eXBlIHdlIGRlY2xhcmVkXG4gIHZhciBOZXdLbGFzcyA9IENvcHlDb25zdHJ1Y3RvcjtcbiAgTmV3S2xhc3MuaW5zdGFuY2VQb29sID0gW107XG4gIE5ld0tsYXNzLmdldFBvb2xlZCA9IHBvb2xlciB8fCBERUZBVUxUX1BPT0xFUjtcbiAgaWYgKCFOZXdLbGFzcy5wb29sU2l6ZSkge1xuICAgIE5ld0tsYXNzLnBvb2xTaXplID0gREVGQVVMVF9QT09MX1NJWkU7XG4gIH1cbiAgTmV3S2xhc3MucmVsZWFzZSA9IHN0YW5kYXJkUmVsZWFzZXI7XG4gIHJldHVybiBOZXdLbGFzcztcbn07XG5cbnZhciBQb29sZWRDbGFzcyA9IHtcbiAgYWRkUG9vbGluZ1RvOiBhZGRQb29saW5nVG8sXG4gIG9uZUFyZ3VtZW50UG9vbGVyOiBvbmVBcmd1bWVudFBvb2xlcixcbiAgdHdvQXJndW1lbnRQb29sZXI6IHR3b0FyZ3VtZW50UG9vbGVyLFxuICB0aHJlZUFyZ3VtZW50UG9vbGVyOiB0aHJlZUFyZ3VtZW50UG9vbGVyLFxuICBmb3VyQXJndW1lbnRQb29sZXI6IGZvdXJBcmd1bWVudFBvb2xlcixcbiAgZml2ZUFyZ3VtZW50UG9vbGVyOiBmaXZlQXJndW1lbnRQb29sZXJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbGVkQ2xhc3M7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q3VycmVudE93bmVyOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoICh4KSB7fVxuICAgIH07XG5cbiAgICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgICAgfVxuXG4gICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gZmFsc2U7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB0cnkge1xuICAgIC8vICRGbG93Rml4TWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7IGdldDogZnVuY3Rpb24gKCkge30gfSk7XG4gICAgY2FuRGVmaW5lUHJvcGVydHkgPSB0cnVlO1xuICB9IGNhdGNoICh4KSB7XG4gICAgLy8gSUUgd2lsbCBmYWlsIG9uIGRlZmluZVByb3BlcnR5XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW5EZWZpbmVQcm9wZXJ0eTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudCB0eXBlLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ10gJiYgU3ltYm9sWydmb3InXSgncmVhY3QuZWxlbWVudCcpIHx8IDB4ZWFjNztcblxubW9kdWxlLmV4cG9ydHMgPSBSRUFDVF9FTEVNRU5UX1RZUEU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRTeW1ib2wnKTtcblxudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcblxudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9O1xuICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcblxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcblxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307XG5cbiAgICAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG4gICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzZWxmXG4gICAgICB9KTtcbiAgICAgIC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHNvdXJjZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgZWxlbWVudC5fc2VsZiA9IHNlbGY7XG4gICAgICBlbGVtZW50Ll9zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWVsZW1lbnRcbiAqL1xuUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIgcHJvcHMgPSB7fTtcblxuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTtcbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy4kJHR5cGVvZiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcHMuJCR0eXBlb2YgIT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIFJlYWN0RWxlbWVudHMgb2YgYSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWZhY3RvcnlcbiAqL1xuUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgZmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIEV4cG9zZSB0aGUgdHlwZSBvbiB0aGUgZmFjdG9yeSBhbmQgdGhlIHByb3RvdHlwZSBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyBlYXNpbHkgYWNjZXNzZWQgb24gZWxlbWVudHMuIEUuZy4gYDxGb28gLz4udHlwZSA9PT0gRm9vYC5cbiAgLy8gVGhpcyBzaG91bGQgbm90IGJlIG5hbWVkIGBjb25zdHJ1Y3RvcmAgc2luY2UgdGhpcyBtYXkgbm90IGJlIHRoZSBmdW5jdGlvblxuICAvLyB0aGF0IGNyZWF0ZWQgdGhlIGVsZW1lbnQsIGFuZCBpdCBtYXkgbm90IGV2ZW4gYmUgYSBjb25zdHJ1Y3Rvci5cbiAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gIGZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIHJldHVybiBmYWN0b3J5O1xufTtcblxuUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleSA9IGZ1bmN0aW9uIChvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG5cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2xvbmVlbGVtZW50XG4gKi9cblJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXG4gIC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgY29tcG9uZW50LlxuICogQGZpbmFsXG4gKi9cblJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuXG52YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gKlxuICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gKlxuICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICogICAgICAgLi4uXG4gKiAgICAgfVxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRJdGVyYXRvckZuOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBVbmVzY2FwZSBhbmQgdW53cmFwIGtleSBmb3IgaHVtYW4tcmVhZGFibGUgZGlzcGxheVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gdW5lc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSB1bmVzY2FwZWQga2V5LlxuICovXG5mdW5jdGlvbiB1bmVzY2FwZShrZXkpIHtcbiAgdmFyIHVuZXNjYXBlUmVnZXggPSAvKD0wfD0yKS9nO1xuICB2YXIgdW5lc2NhcGVyTG9va3VwID0ge1xuICAgICc9MCc6ICc9JyxcbiAgICAnPTInOiAnOidcbiAgfTtcbiAgdmFyIGtleVN1YnN0cmluZyA9IGtleVswXSA9PT0gJy4nICYmIGtleVsxXSA9PT0gJyQnID8ga2V5LnN1YnN0cmluZygyKSA6IGtleS5zdWJzdHJpbmcoMSk7XG5cbiAgcmV0dXJuICgnJyArIGtleVN1YnN0cmluZykucmVwbGFjZSh1bmVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG59XG5cbnZhciBLZXlFc2NhcGVVdGlscyA9IHtcbiAgZXNjYXBlOiBlc2NhcGUsXG4gIHVuZXNjYXBlOiB1bmVzY2FwZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlFc2NhcGVVdGlsczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRTeW1ib2wnKTtcblxudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6JztcblxuLyoqXG4gKiBUaGlzIGlzIGlubGluZWQgZnJvbSBSZWFjdEVsZW1lbnQgc2luY2UgdGhpcyBmaWxlIGlzIHNoYXJlZCBiZXR3ZWVuXG4gKiBpc29tb3JwaGljIGFuZCByZW5kZXJlcnMuIFdlIGNvdWxkIGV4dHJhY3QgdGhpcyB0byBhXG4gKlxuICovXG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmIChjb21wb25lbnQgJiYgdHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIEtleUVzY2FwZVV0aWxzLmVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwgfHwgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicgfHxcbiAgLy8gVGhlIGZvbGxvd2luZyBpcyBpbmxpbmVkIGZyb20gUmVhY3RFbGVtZW50LiBUaGlzIG1lYW5zIHdlIGNhbiBvcHRpbWl6ZVxuICAvLyBzb21lIGNoZWNrcy4gUmVhY3QgRmliZXIgYWxzbyBpbmxpbmVzIHRoaXMgbG9naWMgZm9yIHNpbWlsYXIgcHVycG9zZXMuXG4gIHR5cGUgPT09ICdvYmplY3QnICYmIGNoaWxkcmVuLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpaSA9IDA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0gPSAnJztcbiAgICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgICBpZiAobWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUpIHtcbiAgICAgICAgICAgICAgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkLiBJdCBpcyBhbiAnICsgJ2V4cGVyaW1lbnRhbCBmZWF0dXJlIHRoYXQgbWlnaHQgYmUgcmVtb3ZlZC4gQ29udmVydCBpdCB0byBhICcgKyAnc2VxdWVuY2UgLyBpdGVyYWJsZSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIEtleUVzY2FwZVV0aWxzLmVzY2FwZShlbnRyeVswXSkgKyBTVUJTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIDApO1xuICAgICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQgb3Igd3JhcCB0aGUgb2JqZWN0IHVzaW5nIGNyZWF0ZUZyYWdtZW50KG9iamVjdCkgZnJvbSB0aGUgJyArICdSZWFjdCBhZGQtb25zLic7XG4gICAgICAgIGlmIChjaGlsZHJlbi5faXNSZWFjdEVsZW1lbnQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSXQgbG9va3MgbGlrZSB5b3VcXCdyZSB1c2luZyBhbiBlbGVtZW50IGNyZWF0ZWQgYnkgYSBkaWZmZXJlbnQgJyArICd2ZXJzaW9uIG9mIFJlYWN0LiBNYWtlIHN1cmUgdG8gdXNlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGFkZGVuZHVtICs9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKSA6IF9wcm9kSW52YXJpYW50KCczMScsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhdmVyc2VBbGxDaGlsZHJlbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlcjtcbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXI7XG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogdHJhdmVyc2FsLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIEZvckVhY2hCb29rS2VlcGluZ1xuICogQHBhcmFtIHshZnVuY3Rpb259IGZvckVhY2hGdW5jdGlvbiBGdW5jdGlvbiB0byBwZXJmb3JtIHRyYXZlcnNhbCB3aXRoLlxuICogQHBhcmFtIHs/Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIGNvbnRleHQgd2l0aC5cbiAqL1xuZnVuY3Rpb24gRm9yRWFjaEJvb2tLZWVwaW5nKGZvckVhY2hGdW5jdGlvbiwgZm9yRWFjaENvbnRleHQpIHtcbiAgdGhpcy5mdW5jID0gZm9yRWFjaEZ1bmN0aW9uO1xuICB0aGlzLmNvbnRleHQgPSBmb3JFYWNoQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5Gb3JFYWNoQm9va0tlZXBpbmcucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZnVuYyA9IG51bGw7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG4gIHRoaXMuY291bnQgPSAwO1xufTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhGb3JFYWNoQm9va0tlZXBpbmcsIHR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gRm9yRWFjaEJvb2tLZWVwaW5nLmdldFBvb2xlZChmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIEZvckVhY2hCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiBtYXBwaW5nLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIE1hcEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyEqfSBtYXBSZXN1bHQgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gbWFwRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKiBAcGFyYW0gez8qfSBtYXBDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKi9cbmZ1bmN0aW9uIE1hcEJvb2tLZWVwaW5nKG1hcFJlc3VsdCwga2V5UHJlZml4LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xuICB0aGlzLnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgdGhpcy5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gIHRoaXMuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICB0aGlzLmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbk1hcEJvb2tLZWVwaW5nLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlc3VsdCA9IG51bGw7XG4gIHRoaXMua2V5UHJlZml4ID0gbnVsbDtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKE1hcEJvb2tLZWVwaW5nLCBmb3VyQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdCxcbiAgICAgIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeCxcbiAgICAgIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxuICAgICAgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cblxuICB2YXIgbWFwcGVkQ2hpbGQgPSBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xuICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKG1hcHBlZENoaWxkLCByZXN1bHQsIGNoaWxkS2V5LCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLFxuICAgICAgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAga2V5UHJlZml4ICsgKG1hcHBlZENoaWxkLmtleSAmJiAoIWNoaWxkIHx8IGNoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IGVzY2FwZVVzZXJQcm92aWRlZEtleShtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChtYXBwZWRDaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgYXJyYXksIHByZWZpeCwgZnVuYywgY29udGV4dCkge1xuICB2YXIgZXNjYXBlZFByZWZpeCA9ICcnO1xuICBpZiAocHJlZml4ICE9IG51bGwpIHtcbiAgICBlc2NhcGVkUHJlZml4ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHByZWZpeCkgKyAnLyc7XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IE1hcEJvb2tLZWVwaW5nLmdldFBvb2xlZChhcnJheSwgZXNjYXBlZFByZWZpeCwgZnVuYywgY29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIE1hcEJvb2tLZWVwaW5nLnJlbGVhc2UodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGV4dCkge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXksIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi50b2FycmF5XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBSZWFjdENoaWxkcmVuID0ge1xuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWw6IG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwsXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRyZW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrKSB7fSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0Q29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuXG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKSA6IF9wcm9kSW52YXJpYW50KCc4NScpIDogdm9pZCAwO1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pIDogdm9pZCAwO1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gUmVhY3RDb21wb25lbnQuXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBSZWFjdENvbXBvbmVudC5wcm90b3R5cGU7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVhY3RQdXJlQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKFJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSk7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFB1cmVDb21wb25lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7XG4gICAgcHJvcDogJ3Byb3AnLFxuICAgIGNvbnRleHQ6ICdjb250ZXh0JyxcbiAgICBjaGlsZENvbnRleHQ6ICdjaGlsZCBjb250ZXh0J1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudCcpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIE1JWElOU19LRVkgPSAnbWl4aW5zJztcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGFsbG93IHRoZSBjcmVhdGlvbiBvZiBhbm9ueW1vdXMgZnVuY3Rpb25zIHdoaWNoIGRvIG5vdFxuLy8gaGF2ZSAubmFtZSBzZXQgdG8gdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIGJlaW5nIGFzc2lnbmVkIHRvLlxuZnVuY3Rpb24gaWRlbnRpdHkoZm4pIHtcbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFBvbGljaWVzIHRoYXQgZGVzY3JpYmUgbWV0aG9kcyBpbiBgUmVhY3RDbGFzc0ludGVyZmFjZWAuXG4gKi9cblxuXG52YXIgaW5qZWN0ZWRNaXhpbnMgPSBbXTtcblxuLyoqXG4gKiBDb21wb3NpdGUgY29tcG9uZW50cyBhcmUgaGlnaGVyLWxldmVsIGNvbXBvbmVudHMgdGhhdCBjb21wb3NlIG90aGVyIGNvbXBvc2l0ZVxuICogb3IgaG9zdCBjb21wb25lbnRzLlxuICpcbiAqIFRvIGNyZWF0ZSBhIG5ldyB0eXBlIG9mIGBSZWFjdENsYXNzYCwgcGFzcyBhIHNwZWNpZmljYXRpb24gb2ZcbiAqIHlvdXIgbmV3IGNsYXNzIHRvIGBSZWFjdC5jcmVhdGVDbGFzc2AuIFRoZSBvbmx5IHJlcXVpcmVtZW50IG9mIHlvdXIgY2xhc3NcbiAqIHNwZWNpZmljYXRpb24gaXMgdGhhdCB5b3UgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLlxuICpcbiAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gPGRpdj5IZWxsbyBXb3JsZDwvZGl2PjtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIHN1cHBvcnRzIGEgc3BlY2lmaWMgcHJvdG9jb2wgb2YgbWV0aG9kcyB0aGF0IGhhdmVcbiAqIHNwZWNpYWwgbWVhbmluZyAoZS5nLiBgcmVuZGVyYCkuIFNlZSBgUmVhY3RDbGFzc0ludGVyZmFjZWAgZm9yXG4gKiBtb3JlIHRoZSBjb21wcmVoZW5zaXZlIHByb3RvY29sLiBBbnkgb3RoZXIgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBpbiB0aGVcbiAqIGNsYXNzIHNwZWNpZmljYXRpb24gd2lsbCBiZSBhdmFpbGFibGUgb24gdGhlIHByb3RvdHlwZS5cbiAqXG4gKiBAaW50ZXJmYWNlIFJlYWN0Q2xhc3NJbnRlcmZhY2VcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RDbGFzc0ludGVyZmFjZSA9IHtcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgTWl4aW4gb2JqZWN0cyB0byBpbmNsdWRlIHdoZW4gZGVmaW5pbmcgeW91ciBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHthcnJheX1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBtaXhpbnM6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgdGhhdCBzaG91bGQgYmUgZGVmaW5lZCBvblxuICAgKiB0aGUgY29tcG9uZW50J3MgY29uc3RydWN0b3IgaW5zdGVhZCBvZiBpdHMgcHJvdG90eXBlIChzdGF0aWMgbWV0aG9kcykuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgc3RhdGljczogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBwcm9wIHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBwcm9wVHlwZXM6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29udGV4dFR5cGVzOiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgdGhpcyBjb21wb25lbnQgc2V0cyBmb3IgaXRzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNoaWxkQ29udGV4dFR5cGVzOiAnREVGSU5FX01BTlknLFxuXG4gIC8vID09PT0gRGVmaW5pdGlvbiBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVmFsdWVzIGluIHRoZSBtYXBwaW5nIHdpbGwgYmUgc2V0IG9uXG4gICAqIGB0aGlzLnByb3BzYCBpZiB0aGF0IHByb3AgaXMgbm90IHNwZWNpZmllZCAoaS5lLiB1c2luZyBhbiBgaW5gIGNoZWNrKS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBiZWZvcmUgYGdldEluaXRpYWxTdGF0ZWAgYW5kIHRoZXJlZm9yZSBjYW5ub3QgcmVseVxuICAgKiBvbiBgdGhpcy5zdGF0ZWAgb3IgdXNlIGB0aGlzLnNldFN0YXRlYC5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogJ0RFRklORV9NQU5ZX01FUkdFRCcsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZFxuICAgKiBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBgdGhpcy5zdGF0ZWAuXG4gICAqXG4gICAqICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHJldHVybiB7XG4gICAqICAgICAgIGlzT246IGZhbHNlLFxuICAgKiAgICAgICBmb29CYXo6IG5ldyBCYXpGb28oKVxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldEluaXRpYWxTdGF0ZTogJ0RFRklORV9NQU5ZX01FUkdFRCcsXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXRDaGlsZENvbnRleHQ6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gIC8qKlxuICAgKiBVc2VzIHByb3BzIGZyb20gYHRoaXMucHJvcHNgIGFuZCBzdGF0ZSBmcm9tIGB0aGlzLnN0YXRlYCB0byByZW5kZXIgdGhlXG4gICAqIHN0cnVjdHVyZSBvZiB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBObyBndWFyYW50ZWVzIGFyZSBtYWRlIGFib3V0IHdoZW4gb3IgaG93IG9mdGVuIHRoaXMgbWV0aG9kIGlzIGludm9rZWQsIHNvXG4gICAqIGl0IG11c3Qgbm90IGhhdmUgc2lkZSBlZmZlY3RzLlxuICAgKlxuICAgKiAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAqICAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICogICAgIHJldHVybiA8ZGl2PkhlbGxvLCB7bmFtZX0hPC9kaXY+O1xuICAgKiAgIH1cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gICAqIEBub3NpZGVlZmZlY3RzXG4gICAqIEByZXF1aXJlZFxuICAgKi9cbiAgcmVuZGVyOiAnREVGSU5FX09OQ0UnLFxuXG4gIC8vID09PT0gRGVsZWdhdGUgbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGluaXRpYWxseSBjcmVhdGVkIGFuZCBhYm91dCB0byBiZSBtb3VudGVkLlxuICAgKiBUaGlzIG1heSBoYXZlIHNpZGUgZWZmZWN0cywgYnV0IGFueSBleHRlcm5hbCBzdWJzY3JpcHRpb25zIG9yIGRhdGEgY3JlYXRlZFxuICAgKiBieSB0aGlzIG1ldGhvZCBtdXN0IGJlIGNsZWFuZWQgdXAgaW4gYGNvbXBvbmVudFdpbGxVbm1vdW50YC5cbiAgICpcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsTW91bnQ6ICdERUZJTkVfTUFOWScsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgYW5kIGhhcyBhIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICogSG93ZXZlciwgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIERPTSBub2RlIGlzIGluIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICogYmVlbiBtb3VudGVkIChpbml0aWFsaXplZCBhbmQgcmVuZGVyZWQpIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogSW52b2tlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCByZWNlaXZlcyBuZXcgcHJvcHMuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHJlYWN0IHRvIGEgcHJvcCB0cmFuc2l0aW9uIGJ5IHVwZGF0aW5nIHRoZVxuICAgKiBzdGF0ZSB1c2luZyBgdGhpcy5zZXRTdGF0ZWAuIEN1cnJlbnQgcHJvcHMgYXJlIGFjY2Vzc2VkIHZpYSBgdGhpcy5wcm9wc2AuXG4gICAqXG4gICAqICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0Q29udGV4dCkge1xuICAgKiAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAqICAgICAgIGxpa2VzSW5jcmVhc2luZzogbmV4dFByb3BzLmxpa2VDb3VudCA+IHRoaXMucHJvcHMubGlrZUNvdW50XG4gICAqICAgICB9KTtcbiAgICogICB9XG4gICAqXG4gICAqIE5PVEU6IFRoZXJlIGlzIG5vIGVxdWl2YWxlbnQgYGNvbXBvbmVudFdpbGxSZWNlaXZlU3RhdGVgLiBBbiBpbmNvbWluZyBwcm9wXG4gICAqIHRyYW5zaXRpb24gbWF5IGNhdXNlIGEgc3RhdGUgY2hhbmdlLCBidXQgdGhlIG9wcG9zaXRlIGlzIG5vdCB0cnVlLiBJZiB5b3VcbiAgICogbmVlZCBpdCwgeW91IGFyZSBwcm9iYWJseSBsb29raW5nIGZvciBgY29tcG9uZW50V2lsbFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoaWxlIGRlY2lkaW5nIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIHVwZGF0ZWQgYXMgYSByZXN1bHQgb2ZcbiAgICogcmVjZWl2aW5nIG5ldyBwcm9wcywgc3RhdGUgYW5kL29yIGNvbnRleHQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGByZXR1cm4gZmFsc2VgIHdoZW4geW91J3JlIGNlcnRhaW4gdGhhdCB0aGVcbiAgICogdHJhbnNpdGlvbiB0byB0aGUgbmV3IHByb3BzL3N0YXRlL2NvbnRleHQgd2lsbCBub3QgcmVxdWlyZSBhIGNvbXBvbmVudFxuICAgKiB1cGRhdGUuXG4gICAqXG4gICAqICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgICogICAgIHJldHVybiAhZXF1YWwobmV4dFByb3BzLCB0aGlzLnByb3BzKSB8fFxuICAgKiAgICAgICAhZXF1YWwobmV4dFN0YXRlLCB0aGlzLnN0YXRlKSB8fFxuICAgKiAgICAgICAhZXF1YWwobmV4dENvbnRleHQsIHRoaXMuY29udGV4dCk7XG4gICAqICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29tcG9uZW50IHNob3VsZCB1cGRhdGUuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiAnREVGSU5FX09OQ0UnLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byB1cGRhdGUgZHVlIHRvIGEgdHJhbnNpdGlvbiBmcm9tXG4gICAqIGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YCB0byBgbmV4dFByb3BzYCwgYG5leHRTdGF0ZWBcbiAgICogYW5kIGBuZXh0Q29udGV4dGAuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHBlcmZvcm0gcHJlcGFyYXRpb24gYmVmb3JlIGFuIHVwZGF0ZSBvY2N1cnMuXG4gICAqXG4gICAqIE5PVEU6IFlvdSAqKmNhbm5vdCoqIHVzZSBgdGhpcy5zZXRTdGF0ZSgpYCBpbiB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsVXBkYXRlOiAnREVGSU5FX01BTlknLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCdzIERPTSByZXByZXNlbnRhdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgKiBiZWVuIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcmV2UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q29udGV4dFxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogJ0RFRklORV9NQU5ZJyxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgYW5kIGhhdmVcbiAgICogaXRzIERPTSByZXByZXNlbnRhdGlvbiBkZXN0cm95ZWQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGRlYWxsb2NhdGUgYW55IGV4dGVybmFsIHJlc291cmNlcy5cbiAgICpcbiAgICogTk9URTogVGhlcmUgaXMgbm8gYGNvbXBvbmVudERpZFVubW91bnRgIHNpbmNlIHlvdXIgY29tcG9uZW50IHdpbGwgaGF2ZSBiZWVuXG4gICAqIGRlc3Ryb3llZCBieSB0aGF0IHBvaW50LlxuICAgKlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiAnREVGSU5FX01BTlknLFxuXG4gIC8vID09PT0gQWR2YW5jZWQgbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCdzIGN1cnJlbnRseSBtb3VudGVkIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhpcyBpbXBsZW1lbnRzIFJlYWN0J3MgcmVuZGVyaW5nIGFuZCByZWNvbmNpbGlhdGlvbiBhbGdvcml0aG0uXG4gICAqIFNvcGhpc3RpY2F0ZWQgY2xpZW50cyBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogJ09WRVJSSURFX0JBU0UnXG5cbn07XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGNsYXNzIHNwZWNpZmljYXRpb24ga2V5cyB0byBzcGVjaWFsIHByb2Nlc3NpbmcgZnVuY3Rpb25zLlxuICpcbiAqIEFsdGhvdWdoIHRoZXNlIGFyZSBkZWNsYXJlZCBsaWtlIGluc3RhbmNlIHByb3BlcnRpZXMgaW4gdGhlIHNwZWNpZmljYXRpb25cbiAqIHdoZW4gZGVmaW5pbmcgY2xhc3NlcyB1c2luZyBgUmVhY3QuY3JlYXRlQ2xhc3NgLCB0aGV5IGFyZSBhY3R1YWxseSBzdGF0aWNcbiAqIGFuZCBhcmUgYWNjZXNzaWJsZSBvbiB0aGUgY29uc3RydWN0b3IgaW5zdGVhZCBvZiB0aGUgcHJvdG90eXBlLiBEZXNwaXRlXG4gKiBiZWluZyBzdGF0aWMsIHRoZXkgbXVzdCBiZSBkZWZpbmVkIG91dHNpZGUgb2YgdGhlIFwic3RhdGljc1wiIGtleSB1bmRlclxuICogd2hpY2ggYWxsIG90aGVyIHN0YXRpYyBtZXRob2RzIGFyZSBkZWZpbmVkLlxuICovXG52YXIgUkVTRVJWRURfU1BFQ19LRVlTID0ge1xuICBkaXNwbGF5TmFtZTogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBkaXNwbGF5TmFtZSkge1xuICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gIH0sXG4gIG1peGluczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBtaXhpbnMpIHtcbiAgICBpZiAobWl4aW5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgbWl4aW5zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNoaWxkQ29udGV4dFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMsICdjaGlsZENvbnRleHQnKTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0VHlwZXMpO1xuICB9LFxuICBjb250ZXh0VHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzLCAnY29udGV4dCcpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMsIGNvbnRleHRUeXBlcyk7XG4gIH0sXG4gIC8qKlxuICAgKiBTcGVjaWFsIGNhc2UgZ2V0RGVmYXVsdFByb3BzIHdoaWNoIHNob3VsZCBtb3ZlIGludG8gc3RhdGljcyBidXQgcmVxdWlyZXNcbiAgICogYXV0b21hdGljIG1lcmdpbmcuXG4gICAqL1xuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24oQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLCBnZXREZWZhdWx0UHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBnZXREZWZhdWx0UHJvcHM7XG4gICAgfVxuICB9LFxuICBwcm9wVHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvcFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgcHJvcFR5cGVzLCAncHJvcCcpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMsIHByb3BUeXBlcyk7XG4gIH0sXG4gIHN0YXRpY3M6IGZ1bmN0aW9uIChDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuICAgIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKTtcbiAgfSxcbiAgYXV0b2JpbmQ6IGZ1bmN0aW9uICgpIHt9IH07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgdHlwZURlZiwgbG9jYXRpb24pIHtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdHlwZURlZikge1xuICAgIGlmICh0eXBlRGVmLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgLy8gdXNlIGEgd2FybmluZyBpbnN0ZWFkIG9mIGFuIGludmFyaWFudCBzbyBjb21wb25lbnRzXG4gICAgICAvLyBkb24ndCBzaG93IHVwIGluIHByb2QgYnV0IG9ubHkgaW4gX19ERVZfX1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIHR5cGVEZWZbcHJvcE5hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ1JlYWN0LlByb3BUeXBlcy4nLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgcHJvcE5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpIHtcbiAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpID8gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXSA6IG51bGw7XG5cbiAgLy8gRGlzYWxsb3cgb3ZlcnJpZGluZyBvZiBiYXNlIGNsYXNzIG1ldGhvZHMgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKFJlYWN0Q2xhc3NNaXhpbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICEoc3BlY1BvbGljeSA9PT0gJ09WRVJSSURFX0JBU0UnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gb3ZlcnJpZGUgYCVzYCBmcm9tIHlvdXIgY2xhc3Mgc3BlY2lmaWNhdGlvbi4gRW5zdXJlIHRoYXQgeW91ciBtZXRob2QgbmFtZXMgZG8gbm90IG92ZXJsYXAgd2l0aCBSZWFjdCBtZXRob2RzLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzczJywgbmFtZSkgOiB2b2lkIDA7XG4gIH1cblxuICAvLyBEaXNhbGxvdyBkZWZpbmluZyBtZXRob2RzIG1vcmUgdGhhbiBvbmNlIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgIShzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknIHx8IHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGAlc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSB0byBhIG1peGluLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc0JywgbmFtZSkgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBNaXhpbiBoZWxwZXIgd2hpY2ggaGFuZGxlcyBwb2xpY3kgdmFsaWRhdGlvbiBhbmQgcmVzZXJ2ZWRcbiAqIHNwZWNpZmljYXRpb24ga2V5cyB3aGVuIGJ1aWxkaW5nIFJlYWN0IGNsYXNzZXMuXG4gKi9cbmZ1bmN0aW9uIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKSB7XG4gIGlmICghc3BlYykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgdHlwZW9mU3BlYyA9IHR5cGVvZiBzcGVjO1xuICAgICAgdmFyIGlzTWl4aW5WYWxpZCA9IHR5cGVvZlNwZWMgPT09ICdvYmplY3QnICYmIHNwZWMgIT09IG51bGw7XG5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGlzTWl4aW5WYWxpZCwgJyVzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvIGluY2x1ZGUgYSBtaXhpbiB0aGF0IGlzIGVpdGhlciBudWxsICcgKyAnb3Igbm90IGFuIG9iamVjdC4gQ2hlY2sgdGhlIG1peGlucyBpbmNsdWRlZCBieSB0aGUgY29tcG9uZW50LCAnICsgJ2FzIHdlbGwgYXMgYW55IG1peGlucyB0aGV5IGluY2x1ZGUgdGhlbXNlbHZlcy4gJyArICdFeHBlY3RlZCBvYmplY3QgYnV0IGdvdCAlcy4nLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsIHNwZWMgPT09IG51bGwgPyBudWxsIDogdHlwZW9mU3BlYykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgISh0eXBlb2Ygc3BlYyAhPT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91XFwncmUgYXR0ZW1wdGluZyB0byB1c2UgYSBjb21wb25lbnQgY2xhc3Mgb3IgZnVuY3Rpb24gYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSByZWd1bGFyIG9iamVjdC4nKSA6IF9wcm9kSW52YXJpYW50KCc3NScpIDogdm9pZCAwO1xuICAhIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzcGVjKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGNvbXBvbmVudCBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LicpIDogX3Byb2RJbnZhcmlhbnQoJzc2JykgOiB2b2lkIDA7XG5cbiAgdmFyIHByb3RvID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICB2YXIgYXV0b0JpbmRQYWlycyA9IHByb3RvLl9fcmVhY3RBdXRvQmluZFBhaXJzO1xuXG4gIC8vIEJ5IGhhbmRsaW5nIG1peGlucyBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMsIHdlIGVuc3VyZSB0aGUgc2FtZVxuICAvLyBjaGFpbmluZyBvcmRlciBpcyBhcHBsaWVkIHRvIG1ldGhvZHMgd2l0aCBERUZJTkVfTUFOWSBwb2xpY3ksIHdoZXRoZXJcbiAgLy8gbWl4aW5zIGFyZSBsaXN0ZWQgYmVmb3JlIG9yIGFmdGVyIHRoZXNlIG1ldGhvZHMgaW4gdGhlIHNwZWMuXG4gIGlmIChzcGVjLmhhc093blByb3BlcnR5KE1JWElOU19LRVkpKSB7XG4gICAgUkVTRVJWRURfU1BFQ19LRVlTLm1peGlucyhDb25zdHJ1Y3Rvciwgc3BlYy5taXhpbnMpO1xuICB9XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBzcGVjKSB7XG4gICAgaWYgKCFzcGVjLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gTUlYSU5TX0tFWSkge1xuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWQgbWl4aW5zIGluIGEgc3BlY2lhbCBjYXNlIGFib3ZlLlxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHByb3BlcnR5ID0gc3BlY1tuYW1lXTtcbiAgICB2YXIgaXNBbHJlYWR5RGVmaW5lZCA9IHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSk7XG5cbiAgICBpZiAoUkVTRVJWRURfU1BFQ19LRVlTLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBSRVNFUlZFRF9TUEVDX0tFWVNbbmFtZV0oQ29uc3RydWN0b3IsIHByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0dXAgbWV0aG9kcyBvbiBwcm90b3R5cGU6XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIG1lbWJlciBtZXRob2RzIHNob3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBib3VuZDpcbiAgICAgIC8vIDEuIEV4cGVjdGVkIFJlYWN0Q2xhc3MgbWV0aG9kcyAoaW4gdGhlIFwiaW50ZXJmYWNlXCIpLlxuICAgICAgLy8gMi4gT3ZlcnJpZGRlbiBtZXRob2RzICh0aGF0IHdlcmUgbWl4ZWQgaW4pLlxuICAgICAgdmFyIGlzUmVhY3RDbGFzc01ldGhvZCA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIHZhciBzaG91bGRBdXRvQmluZCA9IGlzRnVuY3Rpb24gJiYgIWlzUmVhY3RDbGFzc01ldGhvZCAmJiAhaXNBbHJlYWR5RGVmaW5lZCAmJiBzcGVjLmF1dG9iaW5kICE9PSBmYWxzZTtcblxuICAgICAgaWYgKHNob3VsZEF1dG9CaW5kKSB7XG4gICAgICAgIGF1dG9CaW5kUGFpcnMucHVzaChuYW1lLCBwcm9wZXJ0eSk7XG4gICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNBbHJlYWR5RGVmaW5lZCkge1xuICAgICAgICAgIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXTtcblxuICAgICAgICAgIC8vIFRoZXNlIGNhc2VzIHNob3VsZCBhbHJlYWR5IGJlIGNhdWdodCBieSB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlLlxuICAgICAgICAgICEoaXNSZWFjdENsYXNzTWV0aG9kICYmIChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJyB8fCBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogVW5leHBlY3RlZCBzcGVjIHBvbGljeSAlcyBmb3Iga2V5ICVzIHdoZW4gbWl4aW5nIGluIGNvbXBvbmVudCBzcGVjcy4nLCBzcGVjUG9saWN5LCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3NycsIHNwZWNQb2xpY3ksIG5hbWUpIDogdm9pZCAwO1xuXG4gICAgICAgICAgLy8gRm9yIG1ldGhvZHMgd2hpY2ggYXJlIGRlZmluZWQgbW9yZSB0aGFuIG9uY2UsIGNhbGwgdGhlIGV4aXN0aW5nXG4gICAgICAgICAgLy8gbWV0aG9kcyBiZWZvcmUgY2FsbGluZyB0aGUgbmV3IHByb3BlcnR5LCBtZXJnaW5nIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgIGlmIChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJykge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJykge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgLy8gQWRkIHZlcmJvc2UgZGlzcGxheU5hbWUgdG8gdGhlIGZ1bmN0aW9uLCB3aGljaCBoZWxwcyB3aGVuIGxvb2tpbmdcbiAgICAgICAgICAgIC8vIGF0IHByb2ZpbGluZyB0b29scy5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbicgJiYgc3BlYy5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgICBwcm90b1tuYW1lXS5kaXNwbGF5TmFtZSA9IHNwZWMuZGlzcGxheU5hbWUgKyAnXycgKyBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuICBpZiAoIXN0YXRpY3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgbmFtZSBpbiBzdGF0aWNzKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gc3RhdGljc1tuYW1lXTtcbiAgICBpZiAoIXN0YXRpY3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBpc1Jlc2VydmVkID0gbmFtZSBpbiBSRVNFUlZFRF9TUEVDX0tFWVM7XG4gICAgISFpc1Jlc2VydmVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYSByZXNlcnZlZCBwcm9wZXJ0eSwgYCVzYCwgdGhhdCBzaG91bGRuXFwndCBiZSBvbiB0aGUgXCJzdGF0aWNzXCIga2V5LiBEZWZpbmUgaXQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgaW5zdGVhZDsgaXQgd2lsbCBzdGlsbCBiZSBhY2Nlc3NpYmxlIG9uIHRoZSBjb25zdHJ1Y3Rvci4nLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3OCcsIG5hbWUpIDogdm9pZCAwO1xuXG4gICAgdmFyIGlzSW5oZXJpdGVkID0gbmFtZSBpbiBDb25zdHJ1Y3RvcjtcbiAgICAhIWlzSW5oZXJpdGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgZHVlIHRvIGEgbWl4aW4uJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzknLCBuYW1lKSA6IHZvaWQgMDtcbiAgICBDb25zdHJ1Y3RvcltuYW1lXSA9IHByb3BlcnR5O1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9iamVjdHMsIGJ1dCB0aHJvdyBpZiBib3RoIGNvbnRhaW4gdGhlIHNhbWUga2V5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvbmUgVGhlIGZpcnN0IG9iamVjdCwgd2hpY2ggaXMgbXV0YXRlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0d28gVGhlIHNlY29uZCBvYmplY3RcbiAqIEByZXR1cm4ge29iamVjdH0gb25lIGFmdGVyIGl0IGhhcyBiZWVuIG11dGF0ZWQgdG8gY29udGFpbiBldmVyeXRoaW5nIGluIHR3by5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhvbmUsIHR3bykge1xuICAhKG9uZSAmJiB0d28gJiYgdHlwZW9mIG9uZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHR3byA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogQ2Fubm90IG1lcmdlIG5vbi1vYmplY3RzLicpIDogX3Byb2RJbnZhcmlhbnQoJzgwJykgOiB2b2lkIDA7XG5cbiAgZm9yICh2YXIga2V5IGluIHR3bykge1xuICAgIGlmICh0d28uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgIShvbmVba2V5XSA9PT0gdW5kZWZpbmVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6IFRyaWVkIHRvIG1lcmdlIHR3byBvYmplY3RzIHdpdGggdGhlIHNhbWUga2V5OiBgJXNgLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgdG8gYSBtaXhpbjsgaW4gcGFydGljdWxhciwgdGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHR3byBnZXRJbml0aWFsU3RhdGUoKSBvciBnZXREZWZhdWx0UHJvcHMoKSBtZXRob2RzIHJldHVybmluZyBvYmplY3RzIHdpdGggY2xhc2hpbmcga2V5cy4nLCBrZXkpIDogX3Byb2RJbnZhcmlhbnQoJzgxJywga2V5KSA6IHZvaWQgMDtcbiAgICAgIG9uZVtrZXldID0gdHdvW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvbmU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBtZXJnZXMgdGhlaXIgcmV0dXJuIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZFJlc3VsdCgpIHtcbiAgICB2YXIgYSA9IG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHZhciBiID0gdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSBlbHNlIGlmIChiID09IG51bGwpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICB2YXIgYyA9IHt9O1xuICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYSk7XG4gICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBiKTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIGlnbm9yZXMgdGhlaXIgcmV0dXJuIHZhbGVzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNoYWluZWRGdW5jdGlvbigpIHtcbiAgICBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBCaW5kcyBhIG1ldGhvZCB0byB0aGUgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZXRob2QgdG8gYmUgYm91bmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGJvdW5kIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKSB7XG4gIHZhciBib3VuZE1ldGhvZCA9IG1ldGhvZC5iaW5kKGNvbXBvbmVudCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gbnVsbDtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcbiAgICB2YXIgX2JpbmQgPSBib3VuZE1ldGhvZC5iaW5kO1xuICAgIGJvdW5kTWV0aG9kLmJpbmQgPSBmdW5jdGlvbiAobmV3VGhpcykge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2VyIGlzIHRyeWluZyB0byBiaW5kKCkgYW4gYXV0b2JvdW5kIG1ldGhvZDsgd2UgZWZmZWN0aXZlbHkgd2lsbFxuICAgICAgLy8gaWdub3JlIHRoZSB2YWx1ZSBvZiBcInRoaXNcIiB0aGF0IHRoZSB1c2VyIGlzIHRyeWluZyB0byB1c2UsIHNvXG4gICAgICAvLyBsZXQncyB3YXJuLlxuICAgICAgaWYgKG5ld1RoaXMgIT09IGNvbXBvbmVudCAmJiBuZXdUaGlzICE9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYmluZCgpOiBSZWFjdCBjb21wb25lbnQgbWV0aG9kcyBtYXkgb25seSBiZSBib3VuZCB0byB0aGUgJyArICdjb21wb25lbnQgaW5zdGFuY2UuIFNlZSAlcycsIGNvbXBvbmVudE5hbWUpIDogdm9pZCAwO1xuICAgICAgfSBlbHNlIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdiaW5kKCk6IFlvdSBhcmUgYmluZGluZyBhIGNvbXBvbmVudCBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC4gJyArICdSZWFjdCBkb2VzIHRoaXMgZm9yIHlvdSBhdXRvbWF0aWNhbGx5IGluIGEgaGlnaC1wZXJmb3JtYW5jZSAnICsgJ3dheSwgc28geW91IGNhbiBzYWZlbHkgcmVtb3ZlIHRoaXMgY2FsbC4gU2VlICVzJywgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XG4gICAgICAgIHJldHVybiBib3VuZE1ldGhvZDtcbiAgICAgIH1cbiAgICAgIHZhciByZWJvdW5kTWV0aG9kID0gX2JpbmQuYXBwbHkoYm91bmRNZXRob2QsIGFyZ3VtZW50cyk7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gYXJncztcbiAgICAgIHJldHVybiByZWJvdW5kTWV0aG9kO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGJvdW5kTWV0aG9kO1xufVxuXG4vKipcbiAqIEJpbmRzIGFsbCBhdXRvLWJvdW5kIG1ldGhvZHMgaW4gYSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICovXG5mdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2RzKGNvbXBvbmVudCkge1xuICB2YXIgcGFpcnMgPSBjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kUGFpcnM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgYXV0b0JpbmRLZXkgPSBwYWlyc1tpXTtcbiAgICB2YXIgbWV0aG9kID0gcGFpcnNbaSArIDFdO1xuICAgIGNvbXBvbmVudFthdXRvQmluZEtleV0gPSBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpO1xuICB9XG59XG5cbi8qKlxuICogQWRkIG1vcmUgdG8gdGhlIFJlYWN0Q2xhc3MgYmFzZSBjbGFzcy4gVGhlc2UgYXJlIGFsbCBsZWdhY3kgZmVhdHVyZXMgYW5kXG4gKiB0aGVyZWZvcmUgbm90IGFscmVhZHkgcGFydCBvZiB0aGUgbW9kZXJuIFJlYWN0Q29tcG9uZW50LlxuICovXG52YXIgUmVhY3RDbGFzc01peGluID0ge1xuXG4gIC8qKlxuICAgKiBUT0RPOiBUaGlzIHdpbGwgYmUgZGVwcmVjYXRlZCBiZWNhdXNlIHN0YXRlIHNob3VsZCBhbHdheXMga2VlcCBhIGNvbnNpc3RlbnRcbiAgICogdHlwZSBzaWduYXR1cmUgYW5kIHRoZSBvbmx5IHVzZSBjYXNlIGZvciB0aGlzLCBpcyB0byBhdm9pZCB0aGF0LlxuICAgKi9cbiAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAobmV3U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUodGhpcywgbmV3U3RhdGUpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZXIuaXNNb3VudGVkKHRoaXMpO1xuICB9XG59O1xuXG52YXIgUmVhY3RDbGFzc0NvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHt9O1xuX2Fzc2lnbihSZWFjdENsYXNzQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENsYXNzTWl4aW4pO1xuXG4vKipcbiAqIE1vZHVsZSBmb3IgY3JlYXRpbmcgY29tcG9zaXRlIGNvbXBvbmVudHMuXG4gKlxuICogQGNsYXNzIFJlYWN0Q2xhc3NcbiAqL1xudmFyIFJlYWN0Q2xhc3MgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgY29tcG9uZW50IGNsYXNzIGdpdmVuIGEgY2xhc3Mgc3BlY2lmaWNhdGlvbi5cbiAgICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzcGVjIENsYXNzIHNwZWNpZmljYXRpb24gKHdoaWNoIG11c3QgZGVmaW5lIGByZW5kZXJgKS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IENvbXBvbmVudCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY3JlYXRlQ2xhc3M6IGZ1bmN0aW9uIChzcGVjKSB7XG4gICAgLy8gVG8ga2VlcCBvdXIgd2FybmluZ3MgbW9yZSB1bmRlcnN0YW5kYWJsZSwgd2UnbGwgdXNlIGEgbGl0dGxlIGhhY2sgaGVyZSB0b1xuICAgIC8vIGVuc3VyZSB0aGF0IENvbnN0cnVjdG9yLm5hbWUgIT09ICdDb25zdHJ1Y3RvcicuIFRoaXMgbWFrZXMgc3VyZSB3ZSBkb24ndFxuICAgIC8vIHVubmVjZXNzYXJpbHkgaWRlbnRpZnkgYSBjbGFzcyB3aXRob3V0IGRpc3BsYXlOYW1lIGFzICdDb25zdHJ1Y3RvcicuXG4gICAgdmFyIENvbnN0cnVjdG9yID0gaWRlbnRpdHkoZnVuY3Rpb24gKHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgICAvLyBUaGlzIGNvbnN0cnVjdG9yIGdldHMgb3ZlcnJpZGRlbiBieSBtb2Nrcy4gVGhlIGFyZ3VtZW50IGlzIHVzZWRcbiAgICAgIC8vIGJ5IG1vY2tzIHRvIGFzc2VydCBvbiB3aGF0IGdldHMgbW91bnRlZC5cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodGhpcyBpbnN0YW5jZW9mIENvbnN0cnVjdG9yLCAnU29tZXRoaW5nIGlzIGNhbGxpbmcgYSBSZWFjdCBjb21wb25lbnQgZGlyZWN0bHkuIFVzZSBhIGZhY3Rvcnkgb3IgJyArICdKU1ggaW5zdGVhZC4gU2VlOiBodHRwczovL2ZiLm1lL3JlYWN0LWxlZ2FjeWZhY3RvcnknKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgLy8gV2lyZSB1cCBhdXRvLWJpbmRpbmdcbiAgICAgIGlmICh0aGlzLl9fcmVhY3RBdXRvQmluZFBhaXJzLmxlbmd0aCkge1xuICAgICAgICBiaW5kQXV0b0JpbmRNZXRob2RzKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG4gICAgICB0aGlzLnN0YXRlID0gbnVsbDtcblxuICAgICAgLy8gUmVhY3RDbGFzc2VzIGRvZXNuJ3QgaGF2ZSBjb25zdHJ1Y3RvcnMuIEluc3RlYWQsIHRoZXkgdXNlIHRoZVxuICAgICAgLy8gZ2V0SW5pdGlhbFN0YXRlIGFuZCBjb21wb25lbnRXaWxsTW91bnQgbWV0aG9kcyBmb3IgaW5pdGlhbGl6YXRpb24uXG5cbiAgICAgIHZhciBpbml0aWFsU3RhdGUgPSB0aGlzLmdldEluaXRpYWxTdGF0ZSA/IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCkgOiBudWxsO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgIGlmIChpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLmdldEluaXRpYWxTdGF0ZS5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgICAgaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgISh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRJbml0aWFsU3RhdGUoKTogbXVzdCByZXR1cm4gYW4gb2JqZWN0IG9yIG51bGwnLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCc4MicsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIH0pO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ldyBSZWFjdENsYXNzQ29tcG9uZW50KCk7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLl9fcmVhY3RBdXRvQmluZFBhaXJzID0gW107XG5cbiAgICBpbmplY3RlZE1peGlucy5mb3JFYWNoKG1peFNwZWNJbnRvQ29tcG9uZW50LmJpbmQobnVsbCwgQ29uc3RydWN0b3IpKTtcblxuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGRlZmF1bHRQcm9wcyBwcm9wZXJ0eSBhZnRlciBhbGwgbWl4aW5zIGhhdmUgYmVlbiBtZXJnZWQuXG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgQ29uc3RydWN0b3IuZGVmYXVsdFByb3BzID0gQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB0YWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdXNlIG9mIHRoZXNlIG1ldGhvZCBuYW1lcyBpcyBvayxcbiAgICAgIC8vIHNpbmNlIGl0J3MgdXNlZCB3aXRoIGNyZWF0ZUNsYXNzLiBJZiBpdCdzIG5vdCwgdGhlbiBpdCdzIGxpa2VseSBhXG4gICAgICAvLyBtaXN0YWtlIHNvIHdlJ2xsIHdhcm4geW91IHRvIHVzZSB0aGUgc3RhdGljIHByb3BlcnR5LCBwcm9wZXJ0eVxuICAgICAgLy8gaW5pdGlhbGl6ZXIgb3IgY29uc3RydWN0b3IgcmVzcGVjdGl2ZWx5LlxuICAgICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLnJlbmRlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVDbGFzcyguLi4pOiBDbGFzcyBzcGVjaWZpY2F0aW9uIG11c3QgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLicpIDogX3Byb2RJbnZhcmlhbnQoJzgzJykgOiB2b2lkIDA7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRTaG91bGRVcGRhdGUsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIC8vIFJlZHVjZSB0aW1lIHNwZW50IGRvaW5nIGxvb2t1cHMgYnkgc2V0dGluZyB0aGVzZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gUmVhY3RDbGFzc0ludGVyZmFjZSkge1xuICAgICAgaWYgKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0TWl4aW46IGZ1bmN0aW9uIChtaXhpbikge1xuICAgICAgaW5qZWN0ZWRNaXhpbnMucHVzaChtaXhpbik7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDbGFzczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE2LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGlzTmF0aXZlKGZuKSB7XG4gIC8vIEJhc2VkIG9uIGlzTmF0aXZlKCkgZnJvbSBMb2Rhc2hcbiAgdmFyIGZ1bmNUb1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICsgZnVuY1RvU3RyaW5nXG4gIC8vIFRha2UgYW4gZXhhbXBsZSBuYXRpdmUgZnVuY3Rpb24gc291cmNlIGZvciBjb21wYXJpc29uXG4gIC5jYWxsKGhhc093blByb3BlcnR5KVxuICAvLyBTdHJpcCByZWdleCBjaGFyYWN0ZXJzIHNvIHdlIGNhbiB1c2UgaXQgZm9yIHJlZ2V4XG4gIC5yZXBsYWNlKC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZywgJ1xcXFwkJicpXG4gIC8vIFJlbW92ZSBoYXNPd25Qcm9wZXJ0eSBmcm9tIHRoZSB0ZW1wbGF0ZSB0byBtYWtlIGl0IGdlbmVyaWNcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnKTtcbiAgdHJ5IHtcbiAgICB2YXIgc291cmNlID0gZnVuY1RvU3RyaW5nLmNhbGwoZm4pO1xuICAgIHJldHVybiByZUlzTmF0aXZlLnRlc3Qoc291cmNlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbnZhciBjYW5Vc2VDb2xsZWN0aW9ucyA9XG4vLyBBcnJheS5mcm9tXG50eXBlb2YgQXJyYXkuZnJvbSA9PT0gJ2Z1bmN0aW9uJyAmJlxuLy8gTWFwXG50eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKE1hcCkgJiZcbi8vIE1hcC5wcm90b3R5cGUua2V5c1xuTWFwLnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiBNYXAucHJvdG90eXBlLmtleXMgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoTWFwLnByb3RvdHlwZS5rZXlzKSAmJlxuLy8gU2V0XG50eXBlb2YgU2V0ID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKFNldCkgJiZcbi8vIFNldC5wcm90b3R5cGUua2V5c1xuU2V0LnByb3RvdHlwZSAhPSBudWxsICYmIHR5cGVvZiBTZXQucHJvdG90eXBlLmtleXMgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoU2V0LnByb3RvdHlwZS5rZXlzKTtcblxudmFyIHNldEl0ZW07XG52YXIgZ2V0SXRlbTtcbnZhciByZW1vdmVJdGVtO1xudmFyIGdldEl0ZW1JRHM7XG52YXIgYWRkUm9vdDtcbnZhciByZW1vdmVSb290O1xudmFyIGdldFJvb3RJRHM7XG5cbmlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xuICB2YXIgaXRlbU1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIHJvb3RJRFNldCA9IG5ldyBTZXQoKTtcblxuICBzZXRJdGVtID0gZnVuY3Rpb24gKGlkLCBpdGVtKSB7XG4gICAgaXRlbU1hcC5zZXQoaWQsIGl0ZW0pO1xuICB9O1xuICBnZXRJdGVtID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIGl0ZW1NYXAuZ2V0KGlkKTtcbiAgfTtcbiAgcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIGl0ZW1NYXBbJ2RlbGV0ZSddKGlkKTtcbiAgfTtcbiAgZ2V0SXRlbUlEcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShpdGVtTWFwLmtleXMoKSk7XG4gIH07XG5cbiAgYWRkUm9vdCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHJvb3RJRFNldC5hZGQoaWQpO1xuICB9O1xuICByZW1vdmVSb290ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcm9vdElEU2V0WydkZWxldGUnXShpZCk7XG4gIH07XG4gIGdldFJvb3RJRHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ocm9vdElEU2V0LmtleXMoKSk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgaXRlbUJ5S2V5ID0ge307XG4gIHZhciByb290QnlLZXkgPSB7fTtcblxuICAvLyBVc2Ugbm9uLW51bWVyaWMga2V5cyB0byBwcmV2ZW50IFY4IHBlcmZvcm1hbmNlIGlzc3VlczpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzIzMlxuICB2YXIgZ2V0S2V5RnJvbUlEID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuICcuJyArIGlkO1xuICB9O1xuICB2YXIgZ2V0SURGcm9tS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBwYXJzZUludChrZXkuc3Vic3RyKDEpLCAxMCk7XG4gIH07XG5cbiAgc2V0SXRlbSA9IGZ1bmN0aW9uIChpZCwgaXRlbSkge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIGl0ZW1CeUtleVtrZXldID0gaXRlbTtcbiAgfTtcbiAgZ2V0SXRlbSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIHJldHVybiBpdGVtQnlLZXlba2V5XTtcbiAgfTtcbiAgcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIGRlbGV0ZSBpdGVtQnlLZXlba2V5XTtcbiAgfTtcbiAgZ2V0SXRlbUlEcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoaXRlbUJ5S2V5KS5tYXAoZ2V0SURGcm9tS2V5KTtcbiAgfTtcblxuICBhZGRSb290ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgcm9vdEJ5S2V5W2tleV0gPSB0cnVlO1xuICB9O1xuICByZW1vdmVSb290ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgZGVsZXRlIHJvb3RCeUtleVtrZXldO1xuICB9O1xuICBnZXRSb290SURzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhyb290QnlLZXkpLm1hcChnZXRJREZyb21LZXkpO1xuICB9O1xufVxuXG52YXIgdW5tb3VudGVkSURzID0gW107XG5cbmZ1bmN0aW9uIHB1cmdlRGVlcChpZCkge1xuICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICBpZiAoaXRlbSkge1xuICAgIHZhciBjaGlsZElEcyA9IGl0ZW0uY2hpbGRJRHM7XG5cbiAgICByZW1vdmVJdGVtKGlkKTtcbiAgICBjaGlsZElEcy5mb3JFYWNoKHB1cmdlRGVlcCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIChzb3VyY2UgPyAnIChhdCAnICsgc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknIDogb3duZXJOYW1lID8gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknIDogJycpO1xufVxuXG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gJyNlbXB0eSc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiAnI3RleHQnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQudHlwZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxlbWVudC50eXBlLmRpc3BsYXlOYW1lIHx8IGVsZW1lbnQudHlwZS5uYW1lIHx8ICdVbmtub3duJztcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZUlEKGlkKSB7XG4gIHZhciBuYW1lID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShpZCk7XG4gIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgdmFyIG93bmVySUQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldE93bmVySUQoaWQpO1xuICB2YXIgb3duZXJOYW1lO1xuICBpZiAob3duZXJJRCkge1xuICAgIG93bmVyTmFtZSA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUob3duZXJJRCk7XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZWxlbWVudCwgJ1JlYWN0Q29tcG9uZW50VHJlZUhvb2s6IE1pc3NpbmcgUmVhY3QgZWxlbWVudCBmb3IgZGVidWdJRCAlcyB3aGVuICcgKyAnYnVpbGRpbmcgc3RhY2snLCBpZCkgOiB2b2lkIDA7XG4gIHJldHVybiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIGVsZW1lbnQgJiYgZWxlbWVudC5fc291cmNlLCBvd25lck5hbWUpO1xufVxuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHtcbiAgb25TZXRDaGlsZHJlbjogZnVuY3Rpb24gKGlkLCBuZXh0Q2hpbGRJRHMpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgICFpdGVtID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0l0ZW0gbXVzdCBoYXZlIGJlZW4gc2V0JykgOiBfcHJvZEludmFyaWFudCgnMTQ0JykgOiB2b2lkIDA7XG4gICAgaXRlbS5jaGlsZElEcyA9IG5leHRDaGlsZElEcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV4dENoaWxkSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dENoaWxkSUQgPSBuZXh0Q2hpbGRJRHNbaV07XG4gICAgICB2YXIgbmV4dENoaWxkID0gZ2V0SXRlbShuZXh0Q2hpbGRJRCk7XG4gICAgICAhbmV4dENoaWxkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGhvb2sgZXZlbnRzIHRvIGZpcmUgZm9yIHRoZSBjaGlsZCBiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiBfcHJvZEludmFyaWFudCgnMTQwJykgOiB2b2lkIDA7XG4gICAgICAhKG5leHRDaGlsZC5jaGlsZElEcyAhPSBudWxsIHx8IHR5cGVvZiBuZXh0Q2hpbGQuZWxlbWVudCAhPT0gJ29iamVjdCcgfHwgbmV4dENoaWxkLmVsZW1lbnQgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25TZXRDaGlsZHJlbigpIHRvIGZpcmUgZm9yIGEgY29udGFpbmVyIGNoaWxkIGJlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxNDEnKSA6IHZvaWQgMDtcbiAgICAgICFuZXh0Q2hpbGQuaXNNb3VudGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIG9uTW91bnRDb21wb25lbnQoKSB0byBmaXJlIGZvciB0aGUgY2hpbGQgYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogX3Byb2RJbnZhcmlhbnQoJzcxJykgOiB2b2lkIDA7XG4gICAgICBpZiAobmV4dENoaWxkLnBhcmVudElEID09IG51bGwpIHtcbiAgICAgICAgbmV4dENoaWxkLnBhcmVudElEID0gaWQ7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkbid0IGJlIG5lY2Vzc2FyeSBidXQgbW91bnRpbmcgYSBuZXcgcm9vdCBkdXJpbmcgaW5cbiAgICAgICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGN1cnJlbnRseSBjYXVzZXMgbm90LXlldC1tb3VudGVkIGNvbXBvbmVudHMgdG9cbiAgICAgICAgLy8gYmUgcHVyZ2VkIGZyb20gb3VyIHRyZWUgZGF0YSBzbyB0aGVpciBwYXJlbnQgaWQgaXMgbWlzc2luZy5cbiAgICAgIH1cbiAgICAgICEobmV4dENoaWxkLnBhcmVudElEID09PSBpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25CZWZvcmVNb3VudENvbXBvbmVudCgpIHBhcmVudCBhbmQgb25TZXRDaGlsZHJlbigpIHRvIGJlIGNvbnNpc3RlbnQgKCVzIGhhcyBwYXJlbnRzICVzIGFuZCAlcykuJywgbmV4dENoaWxkSUQsIG5leHRDaGlsZC5wYXJlbnRJRCwgaWQpIDogX3Byb2RJbnZhcmlhbnQoJzE0MicsIG5leHRDaGlsZElELCBuZXh0Q2hpbGQucGFyZW50SUQsIGlkKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0sXG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCwgZWxlbWVudCwgcGFyZW50SUQpIHtcbiAgICB2YXIgaXRlbSA9IHtcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgICB0ZXh0OiBudWxsLFxuICAgICAgY2hpbGRJRHM6IFtdLFxuICAgICAgaXNNb3VudGVkOiBmYWxzZSxcbiAgICAgIHVwZGF0ZUNvdW50OiAwXG4gICAgfTtcbiAgICBzZXRJdGVtKGlkLCBpdGVtKTtcbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCwgZWxlbWVudCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgaWYgKCFpdGVtIHx8ICFpdGVtLmlzTW91bnRlZCkge1xuICAgICAgLy8gV2UgbWF5IGVuZCB1cCBoZXJlIGFzIGEgcmVzdWx0IG9mIHNldFN0YXRlKCkgaW4gY29tcG9uZW50V2lsbFVubW91bnQoKS5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgaWdub3JlIHRoZSBlbGVtZW50LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpdGVtLmVsZW1lbnQgPSBlbGVtZW50O1xuICB9LFxuICBvbk1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgICFpdGVtID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0l0ZW0gbXVzdCBoYXZlIGJlZW4gc2V0JykgOiBfcHJvZEludmFyaWFudCgnMTQ0JykgOiB2b2lkIDA7XG4gICAgaXRlbS5pc01vdW50ZWQgPSB0cnVlO1xuICAgIHZhciBpc1Jvb3QgPSBpdGVtLnBhcmVudElEID09PSAwO1xuICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgIGFkZFJvb3QoaWQpO1xuICAgIH1cbiAgfSxcbiAgb25VcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgaWYgKCFpdGVtIHx8ICFpdGVtLmlzTW91bnRlZCkge1xuICAgICAgLy8gV2UgbWF5IGVuZCB1cCBoZXJlIGFzIGEgcmVzdWx0IG9mIHNldFN0YXRlKCkgaW4gY29tcG9uZW50V2lsbFVubW91bnQoKS5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgaWdub3JlIHRoZSBlbGVtZW50LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpdGVtLnVwZGF0ZUNvdW50Kys7XG4gIH0sXG4gIG9uVW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiBpdCBleGlzdHMuXG4gICAgICAvLyBgaXRlbWAgbWlnaHQgbm90IGV4aXN0IGlmIGl0IGlzIGluc2lkZSBhbiBlcnJvciBib3VuZGFyeSwgYW5kIGEgc2libGluZ1xuICAgICAgLy8gZXJyb3IgYm91bmRhcnkgY2hpbGQgdGhyZXcgd2hpbGUgbW91bnRpbmcuIFRoZW4gdGhpcyBpbnN0YW5jZSBuZXZlclxuICAgICAgLy8gZ290IGEgY2hhbmNlIHRvIG1vdW50LCBidXQgaXQgc3RpbGwgZ2V0cyBhbiB1bm1vdW50aW5nIGV2ZW50IGR1cmluZ1xuICAgICAgLy8gdGhlIGVycm9yIGJvdW5kYXJ5IGNsZWFudXAuXG4gICAgICBpdGVtLmlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgdmFyIGlzUm9vdCA9IGl0ZW0ucGFyZW50SUQgPT09IDA7XG4gICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgIHJlbW92ZVJvb3QoaWQpO1xuICAgICAgfVxuICAgIH1cbiAgICB1bm1vdW50ZWRJRHMucHVzaChpZCk7XG4gIH0sXG4gIHB1cmdlVW5tb3VudGVkQ29tcG9uZW50czogZnVuY3Rpb24gKCkge1xuICAgIGlmIChSZWFjdENvbXBvbmVudFRyZWVIb29rLl9wcmV2ZW50UHVyZ2luZykge1xuICAgICAgLy8gU2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgdGVzdGluZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVubW91bnRlZElEcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkID0gdW5tb3VudGVkSURzW2ldO1xuICAgICAgcHVyZ2VEZWVwKGlkKTtcbiAgICB9XG4gICAgdW5tb3VudGVkSURzLmxlbmd0aCA9IDA7XG4gIH0sXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uaXNNb3VudGVkIDogZmFsc2U7XG4gIH0sXG4gIGdldEN1cnJlbnRTdGFja0FkZGVuZHVtOiBmdW5jdGlvbiAodG9wRWxlbWVudCkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgaWYgKHRvcEVsZW1lbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0RGlzcGxheU5hbWUodG9wRWxlbWVudCk7XG4gICAgICB2YXIgb3duZXIgPSB0b3BFbGVtZW50Ll9vd25lcjtcbiAgICAgIGluZm8gKz0gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCB0b3BFbGVtZW50Ll9zb3VyY2UsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSk7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRPd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgdmFyIGlkID0gY3VycmVudE93bmVyICYmIGN1cnJlbnRPd25lci5fZGVidWdJRDtcblxuICAgIGluZm8gKz0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChpZCk7XG4gICAgcmV0dXJuIGluZm87XG4gIH0sXG4gIGdldFN0YWNrQWRkZW5kdW1CeUlEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHdoaWxlIChpZCkge1xuICAgICAgaW5mbyArPSBkZXNjcmliZUlEKGlkKTtcbiAgICAgIGlkID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRQYXJlbnRJRChpZCk7XG4gICAgfVxuICAgIHJldHVybiBpbmZvO1xuICB9LFxuICBnZXRDaGlsZElEczogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uY2hpbGRJRHMgOiBbXTtcbiAgfSxcbiAgZ2V0RGlzcGxheU5hbWU6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0RGlzcGxheU5hbWUoZWxlbWVudCk7XG4gIH0sXG4gIGdldEVsZW1lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmVsZW1lbnQgOiBudWxsO1xuICB9LFxuICBnZXRPd25lcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50Ll9vd25lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50Ll9vd25lci5fZGVidWdJRDtcbiAgfSxcbiAgZ2V0UGFyZW50SUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLnBhcmVudElEIDogbnVsbDtcbiAgfSxcbiAgZ2V0U291cmNlOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIHZhciBlbGVtZW50ID0gaXRlbSA/IGl0ZW0uZWxlbWVudCA6IG51bGw7XG4gICAgdmFyIHNvdXJjZSA9IGVsZW1lbnQgIT0gbnVsbCA/IGVsZW1lbnQuX3NvdXJjZSA6IG51bGw7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfSxcbiAgZ2V0VGV4dDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJycgKyBlbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sXG4gIGdldFVwZGF0ZUNvdW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS51cGRhdGVDb3VudCA6IDA7XG4gIH0sXG5cblxuICBnZXRSb290SURzOiBnZXRSb290SURzLFxuICBnZXRSZWdpc3RlcmVkSURzOiBnZXRJdGVtSURzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgLy8gVGVtcG9yYXJ5IGhhY2suXG4gIC8vIElubGluZSByZXF1aXJlcyBkb24ndCB3b3JrIHdlbGwgd2l0aCBKZXN0OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNDBcbiAgLy8gUmVtb3ZlIHRoZSBpbmxpbmUgcmVxdWlyZXMgd2hlbiB3ZSBkb24ndCBuZWVkIHRoZW0gYW55bW9yZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzE3OFxuICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/b2JqZWN0fSBlbGVtZW50IFRoZSBSZWFjdCBlbGVtZW50IHRoYXQgaXMgYmVpbmcgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0gez9udW1iZXJ9IGRlYnVnSUQgVGhlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIHR5cGUtY2hlY2tlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tSZWFjdFR5cGVTcGVjKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCwgZGVidWdJRCkge1xuICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICB2YXIgZXJyb3I7XG4gICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgISh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gUmVhY3QuUHJvcFR5cGVzLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzg0JywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiB2b2lkIDA7XG4gICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgfVxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpIDogdm9pZCAwO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGNvbXBvbmVudFN0YWNrSW5mbyA9ICcnO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKCFSZWFjdENvbXBvbmVudFRyZWVIb29rKSB7XG4gICAgICAgICAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWJ1Z0lEICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21wb25lbnRTdGFja0luZm8gPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tJbmZvID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDdXJyZW50U3RhY2tBZGRlbmR1bShlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCAlcyB0eXBlOiAlcyVzJywgbG9jYXRpb24sIGVycm9yLm1lc3NhZ2UsIGNvbXBvbmVudFN0YWNrSW5mbykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tSZWFjdFR5cGVTcGVjOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGNoZWNrUmVhY3RUeXBlU3BlYyA9IHJlcXVpcmUoJy4vY2hlY2tSZWFjdFR5cGVTcGVjJyk7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSAnIENoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPCcgKyBwYXJlbnROYW1lICsgJz4uJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgdmFyIG1lbW9pemVyID0gb3duZXJIYXNLZXlVc2VXYXJuaW5nLnVuaXF1ZUtleSB8fCAob3duZXJIYXNLZXlVc2VXYXJuaW5nLnVuaXF1ZUtleSA9IHt9KTtcblxuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG4gIGlmIChtZW1vaXplcltjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBtZW1vaXplcltjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9ICcgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gJyArIGVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJztcbiAgfVxuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4lcycsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW0oZWxlbWVudCkpIDogdm9pZCAwO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyBwcm92aWRlIGltcGxpY2l0IGtleXMuXG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAgdmFyIGNvbXBvbmVudENsYXNzID0gZWxlbWVudC50eXBlO1xuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuYW1lID0gY29tcG9uZW50Q2xhc3MuZGlzcGxheU5hbWUgfHwgY29tcG9uZW50Q2xhc3MubmFtZTtcbiAgaWYgKGNvbXBvbmVudENsYXNzLnByb3BUeXBlcykge1xuICAgIGNoZWNrUmVhY3RUeXBlU3BlYyhjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCwgbnVsbCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gIH1cbn1cblxudmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHtcblxuICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBzaG91bGQgbm90IGJlIG51bGwsIHVuZGVmaW5lZCwgYm9vbGVhbiwgb3IgJyArICdudW1iZXIuIEl0IHNob3VsZCBiZSBhIHN0cmluZyAoZm9yIERPTSBlbGVtZW50cykgb3IgYSBSZWFjdENsYXNzICcgKyAnKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykuJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSkgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcblxuICBjcmVhdGVGYWN0b3J5OiBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbiAgfSxcblxuICBjbG9uZUVsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICAgIH1cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RWxlbWVudFZhbGlkYXRvcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBmYWN0b3J5IHRoYXQgY3JlYXRlcyBIVE1MIHRhZyBlbGVtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgY3JlYXRlRE9NRmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50VmFsaWRhdG9yJyk7XG4gIGNyZWF0ZURPTUZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwcGluZyBmcm9tIHN1cHBvcnRlZCBIVE1MIHRhZ3MgdG8gYFJlYWN0RE9NQ29tcG9uZW50YCBjbGFzc2VzLlxuICogVGhpcyBpcyBhbHNvIGFjY2Vzc2libGUgdmlhIGBSZWFjdC5ET01gLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlYWN0RE9NRmFjdG9yaWVzID0ge1xuICBhOiBjcmVhdGVET01GYWN0b3J5KCdhJyksXG4gIGFiYnI6IGNyZWF0ZURPTUZhY3RvcnkoJ2FiYnInKSxcbiAgYWRkcmVzczogY3JlYXRlRE9NRmFjdG9yeSgnYWRkcmVzcycpLFxuICBhcmVhOiBjcmVhdGVET01GYWN0b3J5KCdhcmVhJyksXG4gIGFydGljbGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2FydGljbGUnKSxcbiAgYXNpZGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2FzaWRlJyksXG4gIGF1ZGlvOiBjcmVhdGVET01GYWN0b3J5KCdhdWRpbycpLFxuICBiOiBjcmVhdGVET01GYWN0b3J5KCdiJyksXG4gIGJhc2U6IGNyZWF0ZURPTUZhY3RvcnkoJ2Jhc2UnKSxcbiAgYmRpOiBjcmVhdGVET01GYWN0b3J5KCdiZGknKSxcbiAgYmRvOiBjcmVhdGVET01GYWN0b3J5KCdiZG8nKSxcbiAgYmlnOiBjcmVhdGVET01GYWN0b3J5KCdiaWcnKSxcbiAgYmxvY2txdW90ZTogY3JlYXRlRE9NRmFjdG9yeSgnYmxvY2txdW90ZScpLFxuICBib2R5OiBjcmVhdGVET01GYWN0b3J5KCdib2R5JyksXG4gIGJyOiBjcmVhdGVET01GYWN0b3J5KCdicicpLFxuICBidXR0b246IGNyZWF0ZURPTUZhY3RvcnkoJ2J1dHRvbicpLFxuICBjYW52YXM6IGNyZWF0ZURPTUZhY3RvcnkoJ2NhbnZhcycpLFxuICBjYXB0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdjYXB0aW9uJyksXG4gIGNpdGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2NpdGUnKSxcbiAgY29kZTogY3JlYXRlRE9NRmFjdG9yeSgnY29kZScpLFxuICBjb2w6IGNyZWF0ZURPTUZhY3RvcnkoJ2NvbCcpLFxuICBjb2xncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnY29sZ3JvdXAnKSxcbiAgZGF0YTogY3JlYXRlRE9NRmFjdG9yeSgnZGF0YScpLFxuICBkYXRhbGlzdDogY3JlYXRlRE9NRmFjdG9yeSgnZGF0YWxpc3QnKSxcbiAgZGQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2RkJyksXG4gIGRlbDogY3JlYXRlRE9NRmFjdG9yeSgnZGVsJyksXG4gIGRldGFpbHM6IGNyZWF0ZURPTUZhY3RvcnkoJ2RldGFpbHMnKSxcbiAgZGZuOiBjcmVhdGVET01GYWN0b3J5KCdkZm4nKSxcbiAgZGlhbG9nOiBjcmVhdGVET01GYWN0b3J5KCdkaWFsb2cnKSxcbiAgZGl2OiBjcmVhdGVET01GYWN0b3J5KCdkaXYnKSxcbiAgZGw6IGNyZWF0ZURPTUZhY3RvcnkoJ2RsJyksXG4gIGR0OiBjcmVhdGVET01GYWN0b3J5KCdkdCcpLFxuICBlbTogY3JlYXRlRE9NRmFjdG9yeSgnZW0nKSxcbiAgZW1iZWQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2VtYmVkJyksXG4gIGZpZWxkc2V0OiBjcmVhdGVET01GYWN0b3J5KCdmaWVsZHNldCcpLFxuICBmaWdjYXB0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdmaWdjYXB0aW9uJyksXG4gIGZpZ3VyZTogY3JlYXRlRE9NRmFjdG9yeSgnZmlndXJlJyksXG4gIGZvb3RlcjogY3JlYXRlRE9NRmFjdG9yeSgnZm9vdGVyJyksXG4gIGZvcm06IGNyZWF0ZURPTUZhY3RvcnkoJ2Zvcm0nKSxcbiAgaDE6IGNyZWF0ZURPTUZhY3RvcnkoJ2gxJyksXG4gIGgyOiBjcmVhdGVET01GYWN0b3J5KCdoMicpLFxuICBoMzogY3JlYXRlRE9NRmFjdG9yeSgnaDMnKSxcbiAgaDQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2g0JyksXG4gIGg1OiBjcmVhdGVET01GYWN0b3J5KCdoNScpLFxuICBoNjogY3JlYXRlRE9NRmFjdG9yeSgnaDYnKSxcbiAgaGVhZDogY3JlYXRlRE9NRmFjdG9yeSgnaGVhZCcpLFxuICBoZWFkZXI6IGNyZWF0ZURPTUZhY3RvcnkoJ2hlYWRlcicpLFxuICBoZ3JvdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ2hncm91cCcpLFxuICBocjogY3JlYXRlRE9NRmFjdG9yeSgnaHInKSxcbiAgaHRtbDogY3JlYXRlRE9NRmFjdG9yeSgnaHRtbCcpLFxuICBpOiBjcmVhdGVET01GYWN0b3J5KCdpJyksXG4gIGlmcmFtZTogY3JlYXRlRE9NRmFjdG9yeSgnaWZyYW1lJyksXG4gIGltZzogY3JlYXRlRE9NRmFjdG9yeSgnaW1nJyksXG4gIGlucHV0OiBjcmVhdGVET01GYWN0b3J5KCdpbnB1dCcpLFxuICBpbnM6IGNyZWF0ZURPTUZhY3RvcnkoJ2lucycpLFxuICBrYmQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2tiZCcpLFxuICBrZXlnZW46IGNyZWF0ZURPTUZhY3RvcnkoJ2tleWdlbicpLFxuICBsYWJlbDogY3JlYXRlRE9NRmFjdG9yeSgnbGFiZWwnKSxcbiAgbGVnZW5kOiBjcmVhdGVET01GYWN0b3J5KCdsZWdlbmQnKSxcbiAgbGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpJyksXG4gIGxpbms6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpbmsnKSxcbiAgbWFpbjogY3JlYXRlRE9NRmFjdG9yeSgnbWFpbicpLFxuICBtYXA6IGNyZWF0ZURPTUZhY3RvcnkoJ21hcCcpLFxuICBtYXJrOiBjcmVhdGVET01GYWN0b3J5KCdtYXJrJyksXG4gIG1lbnU6IGNyZWF0ZURPTUZhY3RvcnkoJ21lbnUnKSxcbiAgbWVudWl0ZW06IGNyZWF0ZURPTUZhY3RvcnkoJ21lbnVpdGVtJyksXG4gIG1ldGE6IGNyZWF0ZURPTUZhY3RvcnkoJ21ldGEnKSxcbiAgbWV0ZXI6IGNyZWF0ZURPTUZhY3RvcnkoJ21ldGVyJyksXG4gIG5hdjogY3JlYXRlRE9NRmFjdG9yeSgnbmF2JyksXG4gIG5vc2NyaXB0OiBjcmVhdGVET01GYWN0b3J5KCdub3NjcmlwdCcpLFxuICBvYmplY3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ29iamVjdCcpLFxuICBvbDogY3JlYXRlRE9NRmFjdG9yeSgnb2wnKSxcbiAgb3B0Z3JvdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ29wdGdyb3VwJyksXG4gIG9wdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnb3B0aW9uJyksXG4gIG91dHB1dDogY3JlYXRlRE9NRmFjdG9yeSgnb3V0cHV0JyksXG4gIHA6IGNyZWF0ZURPTUZhY3RvcnkoJ3AnKSxcbiAgcGFyYW06IGNyZWF0ZURPTUZhY3RvcnkoJ3BhcmFtJyksXG4gIHBpY3R1cmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3BpY3R1cmUnKSxcbiAgcHJlOiBjcmVhdGVET01GYWN0b3J5KCdwcmUnKSxcbiAgcHJvZ3Jlc3M6IGNyZWF0ZURPTUZhY3RvcnkoJ3Byb2dyZXNzJyksXG4gIHE6IGNyZWF0ZURPTUZhY3RvcnkoJ3EnKSxcbiAgcnA6IGNyZWF0ZURPTUZhY3RvcnkoJ3JwJyksXG4gIHJ0OiBjcmVhdGVET01GYWN0b3J5KCdydCcpLFxuICBydWJ5OiBjcmVhdGVET01GYWN0b3J5KCdydWJ5JyksXG4gIHM6IGNyZWF0ZURPTUZhY3RvcnkoJ3MnKSxcbiAgc2FtcDogY3JlYXRlRE9NRmFjdG9yeSgnc2FtcCcpLFxuICBzY3JpcHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3NjcmlwdCcpLFxuICBzZWN0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdzZWN0aW9uJyksXG4gIHNlbGVjdDogY3JlYXRlRE9NRmFjdG9yeSgnc2VsZWN0JyksXG4gIHNtYWxsOiBjcmVhdGVET01GYWN0b3J5KCdzbWFsbCcpLFxuICBzb3VyY2U6IGNyZWF0ZURPTUZhY3RvcnkoJ3NvdXJjZScpLFxuICBzcGFuOiBjcmVhdGVET01GYWN0b3J5KCdzcGFuJyksXG4gIHN0cm9uZzogY3JlYXRlRE9NRmFjdG9yeSgnc3Ryb25nJyksXG4gIHN0eWxlOiBjcmVhdGVET01GYWN0b3J5KCdzdHlsZScpLFxuICBzdWI6IGNyZWF0ZURPTUZhY3RvcnkoJ3N1YicpLFxuICBzdW1tYXJ5OiBjcmVhdGVET01GYWN0b3J5KCdzdW1tYXJ5JyksXG4gIHN1cDogY3JlYXRlRE9NRmFjdG9yeSgnc3VwJyksXG4gIHRhYmxlOiBjcmVhdGVET01GYWN0b3J5KCd0YWJsZScpLFxuICB0Ym9keTogY3JlYXRlRE9NRmFjdG9yeSgndGJvZHknKSxcbiAgdGQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RkJyksXG4gIHRleHRhcmVhOiBjcmVhdGVET01GYWN0b3J5KCd0ZXh0YXJlYScpLFxuICB0Zm9vdDogY3JlYXRlRE9NRmFjdG9yeSgndGZvb3QnKSxcbiAgdGg6IGNyZWF0ZURPTUZhY3RvcnkoJ3RoJyksXG4gIHRoZWFkOiBjcmVhdGVET01GYWN0b3J5KCd0aGVhZCcpLFxuICB0aW1lOiBjcmVhdGVET01GYWN0b3J5KCd0aW1lJyksXG4gIHRpdGxlOiBjcmVhdGVET01GYWN0b3J5KCd0aXRsZScpLFxuICB0cjogY3JlYXRlRE9NRmFjdG9yeSgndHInKSxcbiAgdHJhY2s6IGNyZWF0ZURPTUZhY3RvcnkoJ3RyYWNrJyksXG4gIHU6IGNyZWF0ZURPTUZhY3RvcnkoJ3UnKSxcbiAgdWw6IGNyZWF0ZURPTUZhY3RvcnkoJ3VsJyksXG4gICd2YXInOiBjcmVhdGVET01GYWN0b3J5KCd2YXInKSxcbiAgdmlkZW86IGNyZWF0ZURPTUZhY3RvcnkoJ3ZpZGVvJyksXG4gIHdicjogY3JlYXRlRE9NRmFjdG9yeSgnd2JyJyksXG5cbiAgLy8gU1ZHXG4gIGNpcmNsZTogY3JlYXRlRE9NRmFjdG9yeSgnY2lyY2xlJyksXG4gIGNsaXBQYXRoOiBjcmVhdGVET01GYWN0b3J5KCdjbGlwUGF0aCcpLFxuICBkZWZzOiBjcmVhdGVET01GYWN0b3J5KCdkZWZzJyksXG4gIGVsbGlwc2U6IGNyZWF0ZURPTUZhY3RvcnkoJ2VsbGlwc2UnKSxcbiAgZzogY3JlYXRlRE9NRmFjdG9yeSgnZycpLFxuICBpbWFnZTogY3JlYXRlRE9NRmFjdG9yeSgnaW1hZ2UnKSxcbiAgbGluZTogY3JlYXRlRE9NRmFjdG9yeSgnbGluZScpLFxuICBsaW5lYXJHcmFkaWVudDogY3JlYXRlRE9NRmFjdG9yeSgnbGluZWFyR3JhZGllbnQnKSxcbiAgbWFzazogY3JlYXRlRE9NRmFjdG9yeSgnbWFzaycpLFxuICBwYXRoOiBjcmVhdGVET01GYWN0b3J5KCdwYXRoJyksXG4gIHBhdHRlcm46IGNyZWF0ZURPTUZhY3RvcnkoJ3BhdHRlcm4nKSxcbiAgcG9seWdvbjogY3JlYXRlRE9NRmFjdG9yeSgncG9seWdvbicpLFxuICBwb2x5bGluZTogY3JlYXRlRE9NRmFjdG9yeSgncG9seWxpbmUnKSxcbiAgcmFkaWFsR3JhZGllbnQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3JhZGlhbEdyYWRpZW50JyksXG4gIHJlY3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ3JlY3QnKSxcbiAgc3RvcDogY3JlYXRlRE9NRmFjdG9yeSgnc3RvcCcpLFxuICBzdmc6IGNyZWF0ZURPTUZhY3RvcnkoJ3N2ZycpLFxuICB0ZXh0OiBjcmVhdGVET01GYWN0b3J5KCd0ZXh0JyksXG4gIHRzcGFuOiBjcmVhdGVET01GYWN0b3J5KCd0c3BhbicpXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRmFjdG9yaWVzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAqXG4gKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcHJvcFR5cGVzOiB7XG4gKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICpcbiAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAqXG4gKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAqICAgICB9LFxuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gKiAgIH0pO1xuICpcbiAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAqXG4gKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICpcbiAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgIHByb3BUeXBlczoge1xuICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICogICAgICAgICAgKTtcbiAqICAgICAgICB9XG4gKiAgICAgIH1cbiAqICAgIH0sXG4gKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAqICB9KTtcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG52YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG52YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXJcbn07XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoeCA9PT0geSkge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbi8qKlxuICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciB3ZSBkb24ndCB1c2UgcmVhbFxuICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICovXG5mdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5zdGFjayA9ICcnO1xufVxuLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgaWYgKCFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0pIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgKyAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgKyAnYW5kIHdpbGwgbm90IHdvcmsgaW4gcHJvZHVjdGlvbiB3aXRoIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uICcgKyAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICsgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsIHByb3BGdWxsTmFtZSwgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XG4gICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zKG51bGwpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgfVxuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmICghUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICB9XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICByZXR1cm4gJ2FycmF5JztcbiAgfVxuICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgIHJldHVybiAnb2JqZWN0JztcbiAgfVxuICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICByZXR1cm4gJ3N5bWJvbCc7XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG4vLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4vLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbmZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG4vLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICByZXR1cm4gQU5PTllNT1VTO1xuICB9XG4gIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICcxNS40LjEnOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MycpIDogdm9pZCAwO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb25seUNoaWxkOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZHJlbicpO1xudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudCcpO1xudmFyIFJlYWN0UHVyZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RQdXJlQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RDbGFzcyA9IHJlcXVpcmUoJy4vUmVhY3RDbGFzcycpO1xudmFyIFJlYWN0RE9NRmFjdG9yaWVzID0gcmVxdWlyZSgnLi9SZWFjdERPTUZhY3RvcmllcycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzJyk7XG52YXIgUmVhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi9SZWFjdFZlcnNpb24nKTtcblxudmFyIG9ubHlDaGlsZCA9IHJlcXVpcmUoJy4vb25seUNoaWxkJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGNyZWF0ZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3Rvcnk7XG52YXIgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudDtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50VmFsaWRhdG9yJyk7XG4gIGNyZWF0ZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudDtcbiAgY3JlYXRlRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVGYWN0b3J5O1xuICBjbG9uZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY2xvbmVFbGVtZW50O1xufVxuXG52YXIgX19zcHJlYWQgPSBfYXNzaWduO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIF9fc3ByZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHdhcm5lZCwgJ1JlYWN0Ll9fc3ByZWFkIGlzIGRlcHJlY2F0ZWQgYW5kIHNob3VsZCBub3QgYmUgdXNlZC4gVXNlICcgKyAnT2JqZWN0LmFzc2lnbiBkaXJlY3RseSBvciBhbm90aGVyIGhlbHBlciBmdW5jdGlvbiB3aXRoIHNpbWlsYXIgJyArICdzZW1hbnRpY3MuIFlvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8geW91ciBjb21waWxlci4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcHJlYWQtZGVwcmVjYXRpb24gZm9yIG1vcmUgZGV0YWlscy4nKSA6IHZvaWQgMDtcbiAgICB3YXJuZWQgPSB0cnVlO1xuICAgIHJldHVybiBfYXNzaWduLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbnZhciBSZWFjdCA9IHtcblxuICAvLyBNb2Rlcm5cblxuICBDaGlsZHJlbjoge1xuICAgIG1hcDogUmVhY3RDaGlsZHJlbi5tYXAsXG4gICAgZm9yRWFjaDogUmVhY3RDaGlsZHJlbi5mb3JFYWNoLFxuICAgIGNvdW50OiBSZWFjdENoaWxkcmVuLmNvdW50LFxuICAgIHRvQXJyYXk6IFJlYWN0Q2hpbGRyZW4udG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50LFxuICBQdXJlQ29tcG9uZW50OiBSZWFjdFB1cmVDb21wb25lbnQsXG5cbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnQsXG4gIGlzVmFsaWRFbGVtZW50OiBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQsXG5cbiAgLy8gQ2xhc3NpY1xuXG4gIFByb3BUeXBlczogUmVhY3RQcm9wVHlwZXMsXG4gIGNyZWF0ZUNsYXNzOiBSZWFjdENsYXNzLmNyZWF0ZUNsYXNzLFxuICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5LFxuICBjcmVhdGVNaXhpbjogZnVuY3Rpb24gKG1peGluKSB7XG4gICAgLy8gQ3VycmVudGx5IGEgbm9vcC4gV2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIGFuZCB0cmFjZSBtaXhpbnMuXG4gICAgcmV0dXJuIG1peGluO1xuICB9LFxuXG4gIC8vIFRoaXMgbG9va3MgRE9NIHNwZWNpZmljIGJ1dCB0aGVzZSBhcmUgYWN0dWFsbHkgaXNvbW9ycGhpYyBoZWxwZXJzXG4gIC8vIHNpbmNlIHRoZXkgYXJlIGp1c3QgZ2VuZXJhdGluZyBET00gc3RyaW5ncy5cbiAgRE9NOiBSZWFjdERPTUZhY3RvcmllcyxcblxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgLy8gRGVwcmVjYXRlZCBob29rIGZvciBKU1ggc3ByZWFkLCBkb24ndCB1c2UgdGhpcyBmb3IgYW55dGhpbmcuXG4gIF9fc3ByZWFkOiBfX3NwcmVhZFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdDsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvUmVhY3QnKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxuZnVuY3Rpb24gcmVhY3RQcm9kSW52YXJpYW50KGNvZGUpIHtcbiAgdmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG5cbiAgdmFyIG1lc3NhZ2UgPSAnTWluaWZpZWQgUmVhY3QgZXJyb3IgIycgKyBjb2RlICsgJzsgdmlzaXQgJyArICdodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudD0nICsgY29kZTtcblxuICBmb3IgKHZhciBhcmdJZHggPSAwOyBhcmdJZHggPCBhcmdDb3VudDsgYXJnSWR4KyspIHtcbiAgICBtZXNzYWdlICs9ICcmYXJnc1tdPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2FyZ0lkeCArIDFdKTtcbiAgfVxuXG4gIG1lc3NhZ2UgKz0gJyBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQnICsgJyBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nO1xuXG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IHJlYWN0UHJvZEludmFyaWFudCdzIG93biBmcmFtZVxuXG4gIHRocm93IGVycm9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0UHJvZEludmFyaWFudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbmZ1bmN0aW9uIGNoZWNrTWFzayh2YWx1ZSwgYml0bWFzaykge1xuICByZXR1cm4gKHZhbHVlICYgYml0bWFzaykgPT09IGJpdG1hc2s7XG59XG5cbnZhciBET01Qcm9wZXJ0eUluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAqIHNwZWNpZmllcyBob3cgdGhlIGFzc29jaWF0ZWQgRE9NIHByb3BlcnR5IHNob3VsZCBiZSBhY2Nlc3NlZCBvciByZW5kZXJlZC5cbiAgICovXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDEsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiAweDQsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDgsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDEwIHwgMHg4LFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDIwLFxuXG4gIC8qKlxuICAgKiBJbmplY3Qgc29tZSBzcGVjaWFsaXplZCBrbm93bGVkZ2UgYWJvdXQgdGhlIERPTS4gVGhpcyB0YWtlcyBhIGNvbmZpZyBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiB0aGF0IGdpdmVuIGFuIGF0dHJpYnV0ZSBuYW1lIHdpbGwgcmV0dXJuIHRydWVcbiAgICogaWYgaXQgY2FuIGJlIGluc2VydGVkIGludG8gdGhlIERPTSB2ZXJiYXRpbS4gVXNlZnVsIGZvciBkYXRhLSogb3IgYXJpYS0qXG4gICAqIGF0dHJpYnV0ZXMgd2hlcmUgaXQncyBpbXBvc3NpYmxlIHRvIGVudW1lcmF0ZSBhbGwgb2YgdGhlIHBvc3NpYmxlXG4gICAqIGF0dHJpYnV0ZSBuYW1lcyxcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01Qcm9wZXJ0eU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NUHJvcGVydHlOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NTXV0YXRpb25NZXRob2RzID0gZG9tUHJvcGVydHlDb25maWcuRE9NTXV0YXRpb25NZXRob2RzIHx8IHt9O1xuXG4gICAgaWYgKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKSB7XG4gICAgICBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMucHVzaChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gUHJvcGVydGllcykge1xuICAgICAgISFET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyguLi4pOiBZb3VcXCdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSBcXCclc1xcJyB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGluamVjdGVkLiBZb3UgbWF5IGJlIGFjY2lkZW50YWxseSBpbmplY3RpbmcgdGhlIHNhbWUgRE9NIHByb3BlcnR5IGNvbmZpZyB0d2ljZSwgb3IgeW91IG1heSBiZSBpbmplY3RpbmcgdHdvIGNvbmZpZ3MgdGhhdCBoYXZlIGNvbmZsaWN0aW5nIHByb3BlcnR5IG5hbWVzLicsIHByb3BOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc0OCcsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgdmFyIGxvd2VyQ2FzZWQgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHByb3BDb25maWcgPSBQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogbG93ZXJDYXNlZCxcbiAgICAgICAgYXR0cmlidXRlTmFtZXNwYWNlOiBudWxsLFxuICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BOYW1lLFxuICAgICAgICBtdXRhdGlvbk1ldGhvZDogbnVsbCxcblxuICAgICAgICBtdXN0VXNlUHJvcGVydHk6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpLFxuICAgICAgICBoYXNCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUUpLFxuICAgICAgICBoYXNOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSlcbiAgICAgIH07XG4gICAgICAhKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICsgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgPD0gMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRE9NUHJvcGVydHk6IFZhbHVlIGNhbiBiZSBvbmUgb2YgYm9vbGVhbiwgb3ZlcmxvYWRlZCBib29sZWFuLCBvciBudW1lcmljIHZhbHVlLCBidXQgbm90IGEgY29tYmluYXRpb246ICVzJywgcHJvcE5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzUwJywgcHJvcE5hbWUpIDogdm9pZCAwO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkXSA9IHByb3BOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gRE9NQXR0cmlidXRlTmFtZXNbcHJvcE5hbWVdO1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbYXR0cmlidXRlTmFtZV0gPSBwcm9wTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IERPTUF0dHJpYnV0ZU5hbWVzcGFjZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NUHJvcGVydHlOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZSA9IERPTVByb3BlcnR5TmFtZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2QgPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IHByb3BlcnR5SW5mbztcbiAgICB9XG4gIH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gJzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkQnO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbi8qKlxuICogRE9NUHJvcGVydHkgZXhwb3J0cyBsb29rdXAgb2JqZWN0cyB0aGF0IGNhbiBiZSB1c2VkIGxpa2UgZnVuY3Rpb25zOlxuICpcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydpZCddXG4gKiAgIHRydWVcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydmb29iYXInXVxuICogICB1bmRlZmluZWRcbiAqXG4gKiBBbHRob3VnaCB0aGlzIG1heSBiZSBjb25mdXNpbmcsIGl0IHBlcmZvcm1zIGJldHRlciBpbiBnZW5lcmFsLlxuICpcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LWV4aXN0c1xuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktbWlzc2luZ1xuICovXG52YXIgRE9NUHJvcGVydHkgPSB7XG5cbiAgSURfQVRUUklCVVRFX05BTUU6ICdkYXRhLXJlYWN0aWQnLFxuICBST09UX0FUVFJJQlVURV9OQU1FOiAnZGF0YS1yZWFjdHJvb3QnLFxuXG4gIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVI6IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIsXG4gIEFUVFJJQlVURV9OQU1FX0NIQVI6IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDAnLFxuXG4gIC8qKlxuICAgKiBNYXAgZnJvbSBwcm9wZXJ0eSBcInN0YW5kYXJkIG5hbWVcIiB0byBhbiBvYmplY3Qgd2l0aCBpbmZvIGFib3V0IGhvdyB0byBzZXRcbiAgICogdGhlIHByb3BlcnR5IGluIHRoZSBET00uIEVhY2ggb2JqZWN0IGNvbnRhaW5zOlxuICAgKlxuICAgKiBhdHRyaWJ1dGVOYW1lOlxuICAgKiAgIFVzZWQgd2hlbiByZW5kZXJpbmcgbWFya3VwIG9yIHdpdGggYCpBdHRyaWJ1dGUoKWAuXG4gICAqIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICAgKiBwcm9wZXJ0eU5hbWU6XG4gICAqICAgVXNlZCBvbiBET00gbm9kZSBpbnN0YW5jZXMuIChUaGlzIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBtdXRhdGUgZHVlIHRvXG4gICAqICAgZXh0ZXJuYWwgZmFjdG9ycy4pXG4gICAqIG11dGF0aW9uTWV0aG9kOlxuICAgKiAgIElmIG5vbi1udWxsLCB1c2VkIGluc3RlYWQgb2YgdGhlIHByb3BlcnR5IG9yIGBzZXRBdHRyaWJ1dGUoKWAgYWZ0ZXJcbiAgICogICBpbml0aWFsIHJlbmRlci5cbiAgICogbXVzdFVzZVByb3BlcnR5OlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgYXMgYW4gb2JqZWN0IHByb3BlcnR5LlxuICAgKiBoYXNCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc051bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljIGFuZCBzaG91bGQgYmVcbiAgICogICByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZVxuICAgKiAgIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbiAgICogICBSZW1vdmVkIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW5cbiAgICogICBzdHJpY3RseSBlcXVhbCB0byB0cnVlOyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvdGhlcndpc2UuXG4gICAqL1xuICBwcm9wZXJ0aWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbiwgdXNlZFxuICAgKiB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgcHJvcGVydGllcy4gQXZhaWxhYmxlIG9ubHkgaW4gX19ERVZfXy5cbiAgICpcbiAgICogYXV0b2ZvY3VzIGlzIHByZWRlZmluZWQsIGJlY2F1c2UgYWRkaW5nIGl0IHRvIHRoZSBwcm9wZXJ0eSB3aGl0ZWxpc3RcbiAgICogY2F1c2VzIHVuaW50ZW5kZWQgc2lkZSBlZmZlY3RzLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0UG9zc2libGVTdGFuZGFyZE5hbWU6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB7IGF1dG9mb2N1czogJ2F1dG9Gb2N1cycgfSA6IG51bGwsXG5cbiAgLyoqXG4gICAqIEFsbCBvZiB0aGUgaXNDdXN0b21BdHRyaWJ1dGUoKSBmdW5jdGlvbnMgdGhhdCBoYXZlIGJlZW4gaW5qZWN0ZWQuXG4gICAqL1xuICBfaXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIHByb3BlcnR5IG5hbWUgaXMgYSBjdXN0b20gYXR0cmlidXRlLlxuICAgKiBAbWV0aG9kXG4gICAqL1xuICBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlzQ3VzdG9tQXR0cmlidXRlRm4gPSBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnNbaV07XG4gICAgICBpZiAoaXNDdXN0b21BdHRyaWJ1dGVGbihhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIGluamVjdGlvbjogRE9NUHJvcGVydHlJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NUHJvcGVydHk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NQ29tcG9uZW50RmxhZ3MgPSB7XG4gIGhhc0NhY2hlZENoaWxkTm9kZXM6IDEgPDwgMFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbXBvbmVudEZsYWdzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudEZsYWdzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xudmFyIEZsYWdzID0gUmVhY3RET01Db21wb25lbnRGbGFncztcblxudmFyIGludGVybmFsSW5zdGFuY2VLZXkgPSAnX19yZWFjdEludGVybmFsSW5zdGFuY2UkJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG4vKipcbiAqIERyaWxsIGRvd24gKHRocm91Z2ggY29tcG9zaXRlcyBhbmQgZW1wdHkgY29tcG9uZW50cykgdW50aWwgd2UgZ2V0IGEgaG9zdCBvclxuICogaG9zdCB0ZXh0IGNvbXBvbmVudC5cbiAqXG4gKiBUaGlzIGlzIHByZXR0eSBwb2x5bW9ycGhpYyBidXQgdW5hdm9pZGFibGUgd2l0aCB0aGUgY3VycmVudCBzdHJ1Y3R1cmUgd2UgaGF2ZVxuICogZm9yIGBfcmVuZGVyZWRDaGlsZHJlbmAuXG4gKi9cbmZ1bmN0aW9uIGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoY29tcG9uZW50KSB7XG4gIHZhciByZW5kZXJlZDtcbiAgd2hpbGUgKHJlbmRlcmVkID0gY29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudCA9IHJlbmRlcmVkO1xuICB9XG4gIHJldHVybiBjb21wb25lbnQ7XG59XG5cbi8qKlxuICogUG9wdWxhdGUgYF9ob3N0Tm9kZWAgb24gdGhlIHJlbmRlcmVkIGhvc3QvdGV4dCBjb21wb25lbnQgd2l0aCB0aGUgZ2l2ZW5cbiAqIERPTSBub2RlLiBUaGUgcGFzc2VkIGBpbnN0YCBjYW4gYmUgYSBjb21wb3NpdGUuXG4gKi9cbmZ1bmN0aW9uIHByZWNhY2hlTm9kZShpbnN0LCBub2RlKSB7XG4gIHZhciBob3N0SW5zdCA9IGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoaW5zdCk7XG4gIGhvc3RJbnN0Ll9ob3N0Tm9kZSA9IG5vZGU7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cblxuZnVuY3Rpb24gdW5jYWNoZU5vZGUoaW5zdCkge1xuICB2YXIgbm9kZSA9IGluc3QuX2hvc3ROb2RlO1xuICBpZiAobm9kZSkge1xuICAgIGRlbGV0ZSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICAgIGluc3QuX2hvc3ROb2RlID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFBvcHVsYXRlIGBfaG9zdE5vZGVgIG9uIGVhY2ggY2hpbGQgb2YgYGluc3RgLCBhc3N1bWluZyB0aGF0IHRoZSBjaGlsZHJlblxuICogbWF0Y2ggdXAgd2l0aCB0aGUgRE9NIChlbGVtZW50KSBjaGlsZHJlbiBvZiBgbm9kZWAuXG4gKlxuICogV2UgY2FjaGUgZW50aXJlIGxldmVscyBhdCBvbmNlIHRvIGF2b2lkIGFuIG5eMiBwcm9ibGVtIHdoZXJlIHdlIGFjY2VzcyB0aGVcbiAqIGNoaWxkcmVuIG9mIGEgbm9kZSBzZXF1ZW50aWFsbHkgYW5kIGhhdmUgdG8gd2FsayBmcm9tIHRoZSBzdGFydCB0byBvdXIgdGFyZ2V0XG4gKiBub2RlIGV2ZXJ5IHRpbWUuXG4gKlxuICogU2luY2Ugd2UgdXBkYXRlIGBfcmVuZGVyZWRDaGlsZHJlbmAgYW5kIHRoZSBhY3R1YWwgRE9NIGF0IChzbGlnaHRseSlcbiAqIGRpZmZlcmVudCB0aW1lcywgd2UgY291bGQgcmFjZSBoZXJlIGFuZCBzZWUgYSBuZXdlciBgX3JlbmRlcmVkQ2hpbGRyZW5gIHRoYW5cbiAqIHRoZSBET00gbm9kZXMgd2Ugc2VlLiBUbyBhdm9pZCB0aGlzLCBSZWFjdE11bHRpQ2hpbGQgY2FsbHNcbiAqIGBwcmVwYXJlVG9NYW5hZ2VDaGlsZHJlbmAgYmVmb3JlIHdlIGNoYW5nZSBgX3JlbmRlcmVkQ2hpbGRyZW5gLCBhdCB3aGljaFxuICogdGltZSB0aGUgY29udGFpbmVyJ3MgY2hpbGQgbm9kZXMgYXJlIGFsd2F5cyBjYWNoZWQgKHVudGlsIGl0IHVubW91bnRzKS5cbiAqL1xuZnVuY3Rpb24gcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIG5vZGUpIHtcbiAgaWYgKGluc3QuX2ZsYWdzICYgRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2Rlcykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2hpbGRyZW4gPSBpbnN0Ll9yZW5kZXJlZENoaWxkcmVuO1xuICB2YXIgY2hpbGROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICBvdXRlcjogZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xuICAgIGlmICghY2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgY2hpbGRJbnN0ID0gY2hpbGRyZW5bbmFtZV07XG4gICAgdmFyIGNoaWxkSUQgPSBnZXRSZW5kZXJlZEhvc3RPclRleHRGcm9tQ29tcG9uZW50KGNoaWxkSW5zdCkuX2RvbUlEO1xuICAgIGlmIChjaGlsZElEID09PSAwKSB7XG4gICAgICAvLyBXZSdyZSBjdXJyZW50bHkgdW5tb3VudGluZyB0aGlzIGNoaWxkIGluIFJlYWN0TXVsdGlDaGlsZDsgc2tpcCBpdC5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBXZSBhc3N1bWUgdGhlIGNoaWxkIG5vZGVzIGFyZSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgY2hpbGQgaW5zdGFuY2VzLlxuICAgIGZvciAoOyBjaGlsZE5vZGUgIT09IG51bGw7IGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZykge1xuICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBjaGlsZE5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgPT09IFN0cmluZyhjaGlsZElEKSB8fCBjaGlsZE5vZGUubm9kZVR5cGUgPT09IDggJiYgY2hpbGROb2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC10ZXh0OiAnICsgY2hpbGRJRCArICcgJyB8fCBjaGlsZE5vZGUubm9kZVR5cGUgPT09IDggJiYgY2hpbGROb2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC1lbXB0eTogJyArIGNoaWxkSUQgKyAnICcpIHtcbiAgICAgICAgcHJlY2FjaGVOb2RlKGNoaWxkSW5zdCwgY2hpbGROb2RlKTtcbiAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgRE9NIGNoaWxkcmVuIHdpdGhvdXQgZmluZGluZyBhbiBJRCBtYXRjaC5cbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgZWxlbWVudCB3aXRoIElEICVzLicsIGNoaWxkSUQpIDogX3Byb2RJbnZhcmlhbnQoJzMyJywgY2hpbGRJRCkgOiB2b2lkIDA7XG4gIH1cbiAgaW5zdC5fZmxhZ3MgfD0gRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2Rlcztcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgUmVhY3RET01Db21wb25lbnQgb3JcbiAqIFJlYWN0RE9NVGV4dENvbXBvbmVudCBpbnN0YW5jZSBhbmNlc3Rvci5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICBpZiAobm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHJldHVybiBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIGluc3RhbmNlIHdlIGhhdmUgY2FjaGVkLlxuICB2YXIgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoIW5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9wIG9mIHRoZSB0cmVlLiBUaGlzIG5vZGUgbXVzdCBub3QgYmUgcGFydCBvZiBhIFJlYWN0IHRyZWUgKG9yIGlzXG4gICAgICAvLyB1bm1vdW50ZWQsIHBvdGVudGlhbGx5KS5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjbG9zZXN0O1xuICB2YXIgaW5zdDtcbiAgZm9yICg7IG5vZGUgJiYgKGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKTsgbm9kZSA9IHBhcmVudHMucG9wKCkpIHtcbiAgICBjbG9zZXN0ID0gaW5zdDtcbiAgICBpZiAocGFyZW50cy5sZW5ndGgpIHtcbiAgICAgIHByZWNhY2hlQ2hpbGROb2RlcyhpbnN0LCBub2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogaW5zdGFuY2UsIG9yIG51bGwgaWYgdGhlIG5vZGUgd2FzIG5vdCByZW5kZXJlZCBieSB0aGlzIFJlYWN0LlxuICovXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgdmFyIGluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShub2RlKTtcbiAgaWYgKGluc3QgIT0gbnVsbCAmJiBpbnN0Ll9ob3N0Tm9kZSA9PT0gbm9kZSkge1xuICAgIHJldHVybiBpbnN0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnQsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZ1xuICogRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkge1xuICAvLyBXaXRob3V0IHRoaXMgZmlyc3QgaW52YXJpYW50LCBwYXNzaW5nIGEgbm9uLURPTS1jb21wb25lbnQgdHJpZ2dlcnMgdGhlIG5leHRcbiAgLy8gaW52YXJpYW50IGZvciBhIG1pc3NpbmcgcGFyZW50LCB3aGljaCBpcyBzdXBlciBjb25mdXNpbmcuXG4gICEoaW5zdC5faG9zdE5vZGUgIT09IHVuZGVmaW5lZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczMycpIDogdm9pZCAwO1xuXG4gIGlmIChpbnN0Ll9ob3N0Tm9kZSkge1xuICAgIHJldHVybiBpbnN0Ll9ob3N0Tm9kZTtcbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhbiBhbmNlc3RvciB3aG9zZSBET00gbm9kZSB3ZSBoYXZlIGNhY2hlZC5cbiAgdmFyIHBhcmVudHMgPSBbXTtcbiAgd2hpbGUgKCFpbnN0Ll9ob3N0Tm9kZSkge1xuICAgIHBhcmVudHMucHVzaChpbnN0KTtcbiAgICAhaW5zdC5faG9zdFBhcmVudCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdCBET00gdHJlZSByb290IHNob3VsZCBhbHdheXMgaGF2ZSBhIG5vZGUgcmVmZXJlbmNlLicpIDogX3Byb2RJbnZhcmlhbnQoJzM0JykgOiB2b2lkIDA7XG4gICAgaW5zdCA9IGluc3QuX2hvc3RQYXJlbnQ7XG4gIH1cblxuICAvLyBOb3cgcGFyZW50cyBjb250YWlucyBlYWNoIGFuY2VzdG9yIHRoYXQgZG9lcyAqbm90KiBoYXZlIGEgY2FjaGVkIG5hdGl2ZVxuICAvLyBub2RlLCBhbmQgYGluc3RgIGlzIHRoZSBkZWVwZXN0IGFuY2VzdG9yIHRoYXQgZG9lcy5cbiAgZm9yICg7IHBhcmVudHMubGVuZ3RoOyBpbnN0ID0gcGFyZW50cy5wb3AoKSkge1xuICAgIHByZWNhY2hlQ2hpbGROb2RlcyhpbnN0LCBpbnN0Ll9ob3N0Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gaW5zdC5faG9zdE5vZGU7XG59XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSB7XG4gIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcbiAgZ2V0SW5zdGFuY2VGcm9tTm9kZTogZ2V0SW5zdGFuY2VGcm9tTm9kZSxcbiAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZ2V0Tm9kZUZyb21JbnN0YW5jZSxcbiAgcHJlY2FjaGVDaGlsZE5vZGVzOiBwcmVjYWNoZUNoaWxkTm9kZXMsXG4gIHByZWNhY2hlTm9kZTogcHJlY2FjaGVOb2RlLFxuICB1bmNhY2hlTm9kZTogdW5jYWNoZU5vZGVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnRUcmVlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBUklBRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHtcbiAgICAvLyBHbG9iYWwgU3RhdGVzIGFuZCBQcm9wZXJ0aWVzXG4gICAgJ2FyaWEtY3VycmVudCc6IDAsIC8vIHN0YXRlXG4gICAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICAgJ2FyaWEtZGlzYWJsZWQnOiAwLCAvLyBzdGF0ZVxuICAgICdhcmlhLWhpZGRlbic6IDAsIC8vIHN0YXRlXG4gICAgJ2FyaWEtaW52YWxpZCc6IDAsIC8vIHN0YXRlXG4gICAgJ2FyaWEta2V5c2hvcnRjdXRzJzogMCxcbiAgICAnYXJpYS1sYWJlbCc6IDAsXG4gICAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgICAvLyBXaWRnZXQgQXR0cmlidXRlc1xuICAgICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICAgJ2FyaWEtZXhwYW5kZWQnOiAwLFxuICAgICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgICAnYXJpYS1sZXZlbCc6IDAsXG4gICAgJ2FyaWEtbW9kYWwnOiAwLFxuICAgICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgICAnYXJpYS1vcmllbnRhdGlvbic6IDAsXG4gICAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAgICdhcmlhLXByZXNzZWQnOiAwLFxuICAgICdhcmlhLXJlYWRvbmx5JzogMCxcbiAgICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAgICdhcmlhLXNvcnQnOiAwLFxuICAgICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAgICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gICAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAgICdhcmlhLWF0b21pYyc6IDAsXG4gICAgJ2FyaWEtYnVzeSc6IDAsXG4gICAgJ2FyaWEtbGl2ZSc6IDAsXG4gICAgJ2FyaWEtcmVsZXZhbnQnOiAwLFxuICAgIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAgICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAgICdhcmlhLWdyYWJiZWQnOiAwLFxuICAgIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICAgJ2FyaWEtY29sY291bnQnOiAwLFxuICAgICdhcmlhLWNvbGluZGV4JzogMCxcbiAgICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgICAnYXJpYS1jb250cm9scyc6IDAsXG4gICAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAgICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICAgJ2FyaWEtZmxvd3RvJzogMCxcbiAgICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgICAnYXJpYS1vd25zJzogMCxcbiAgICAnYXJpYS1wb3NpbnNldCc6IDAsXG4gICAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAgICdhcmlhLXJvd2luZGV4JzogMCxcbiAgICAnYXJpYS1yb3dzcGFuJzogMCxcbiAgICAnYXJpYS1zZXRzaXplJzogMFxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge30sXG4gIERPTVByb3BlcnR5TmFtZXM6IHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFSSUFET01Qcm9wZXJ0eUNvbmZpZzsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG9yZGVyaW5nIG9mIGV2ZW50IHBsdWdpbnMuXG4gKi9cbnZhciBldmVudFBsdWdpbk9yZGVyID0gbnVsbDtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG1hcHBpbmcgZnJvbSBuYW1lcyB0byBldmVudCBwbHVnaW4gbW9kdWxlcy5cbiAqL1xudmFyIG5hbWVzVG9QbHVnaW5zID0ge307XG5cbi8qKlxuICogUmVjb21wdXRlcyB0aGUgcGx1Z2luIGxpc3QgdXNpbmcgdGhlIGluamVjdGVkIHBsdWdpbnMgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpIHtcbiAgaWYgKCFldmVudFBsdWdpbk9yZGVyKSB7XG4gICAgLy8gV2FpdCB1bnRpbCBhbiBgZXZlbnRQbHVnaW5PcmRlcmAgaXMgaW5qZWN0ZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgcGx1Z2luTW9kdWxlID0gbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgdmFyIHBsdWdpbkluZGV4ID0gZXZlbnRQbHVnaW5PcmRlci5pbmRleE9mKHBsdWdpbk5hbWUpO1xuICAgICEocGx1Z2luSW5kZXggPiAtMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTYnLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBpZiAoRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFwbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudCBwbHVnaW5zIG11c3QgaW1wbGVtZW50IGFuIGBleHRyYWN0RXZlbnRzYCBtZXRob2QsIGJ1dCBgJXNgIGRvZXMgbm90LicsIHBsdWdpbk5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzk3JywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSA9IHBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgIXB1Ymxpc2hFdmVudEZvclBsdWdpbihwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTgnLCBldmVudE5hbWUsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhbiBldmVudCBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBzdXBwbGllZCBwbHVnaW4uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIERpc3BhdGNoIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoRXZlbnRGb3JQbHVnaW4oZGlzcGF0Y2hDb25maWcsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgZXZlbnQgbmFtZSwgYCVzYC4nLCBldmVudE5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzk5JywgZXZlbnROYW1lKSA6IHZvaWQgMDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXSA9IGRpc3BhdGNoQ29uZmlnO1xuXG4gIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyA9IGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO1xuICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBmb3IgKHZhciBwaGFzZU5hbWUgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZU5hbWUpKSB7XG4gICAgICAgIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lID0gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VOYW1lXTtcbiAgICAgICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocGhhc2VkUmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYSByZWdpc3RyYXRpb24gbmFtZSB0aGF0IGlzIHVzZWQgdG8gaWRlbnRpZnkgZGlzcGF0Y2hlZCBldmVudHMgYW5kXG4gKiBjYW4gYmUgdXNlZCB3aXRoIGBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcmAgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSByZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDAnLCByZWdpc3RyYXRpb25OYW1lKSA6IHZvaWQgMDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA9IHBsdWdpbk1vZHVsZTtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSByZWdpc3RyYXRpb25OYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snKSB7XG4gICAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0ge1xuXG4gIC8qKlxuICAgKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAgICovXG4gIHBsdWdpbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAgICovXG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gICAqIHVzZWQgdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIGV2ZW50IGhhbmRsZXJzLiBBdmFpbGFibGVcbiAgICogb25seSBpbiBfX0RFVl9fLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHt9IDogbnVsbCxcbiAgLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIGluIF9fREVWX19cblxuICAvKipcbiAgICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICAgKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAgICogYWx3YXlzIGRldGVybWluaXN0aWMgcmVnYXJkbGVzcyBvZiBwYWNrYWdpbmcsIG9uLXRoZS1mbHkgaW5qZWN0aW9uLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBmdW5jdGlvbiAoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgISFldmVudFBsdWdpbk9yZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiBfcHJvZEludmFyaWFudCgnMTAxJykgOiB2b2lkIDA7XG4gICAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICAgIGV2ZW50UGx1Z2luT3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpO1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluamVjdHMgcGx1Z2lucyB0byBiZSB1c2VkIGJ5IGBFdmVudFBsdWdpbkh1YmAuIFRoZSBwbHVnaW4gbmFtZXMgbXVzdCBiZVxuICAgKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICAgKlxuICAgKiBQbHVnaW5zIGNhbiBiZSBpbmplY3RlZCBhcyBwYXJ0IG9mIHBhZ2UgaW5pdGlhbGl6YXRpb24gb3Igb24tdGhlLWZseS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBmdW5jdGlvbiAoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fCBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gcGx1Z2luTW9kdWxlKSB7XG4gICAgICAgICEhbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgdXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDInLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMb29rcyB1cCB0aGUgcGx1Z2luIGZvciB0aGUgc3VwcGxpZWQgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBBIHN5bnRoZXRpYyBldmVudC5cbiAgICogQHJldHVybiB7P29iamVjdH0gVGhlIHBsdWdpbiB0aGF0IGNyZWF0ZWQgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFBsdWdpbk1vZHVsZUZvckV2ZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSBldmVudC5kaXNwYXRjaENvbmZpZztcbiAgICBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZV0gfHwgbnVsbDtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHB1bGxpbmcgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgb3V0IG9mIGRpc3BhdGNoQ29uZmlnIGhlbHBzIEZsb3cgc2VlXG4gICAgICAvLyB0aGF0IGl0IGlzIG5vdCB1bmRlZmluZWQuXG4gICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcblxuICAgICAgZm9yICh2YXIgcGhhc2UgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgICAgaWYgKCFwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1twaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZV1dO1xuICAgICAgICBpZiAocGx1Z2luTW9kdWxlKSB7XG4gICAgICAgICAgcmV0dXJuIHBsdWdpbk1vZHVsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0RXZlbnRQbHVnaW5zOiBmdW5jdGlvbiAoKSB7XG4gICAgZXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgICAgaWYgKG5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zLmxlbmd0aCA9IDA7XG5cbiAgICB2YXIgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncykge1xuICAgICAgaWYgKGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMpIHtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShyZWdpc3RyYXRpb25OYW1lKSkge1xuICAgICAgICBkZWxldGUgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuICAgICAgZm9yICh2YXIgbG93ZXJDYXNlZE5hbWUgaW4gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgICBpZiAocG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgICAgICBkZWxldGUgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhdWdodEVycm9yID0gbnVsbDtcblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGEgRmlyc3QgYXJndW1lbnRcbiAqIEBwYXJhbSB7Kn0gYiBTZWNvbmQgYXJndW1lbnRcbiAqL1xuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGZ1bmMsIGEpIHtcbiAgdHJ5IHtcbiAgICBmdW5jKGEpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgaWYgKGNhdWdodEVycm9yID09PSBudWxsKSB7XG4gICAgICBjYXVnaHRFcnJvciA9IHg7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEVycm9yVXRpbHMgPSB7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFjazogaW52b2tlR3VhcmRlZENhbGxiYWNrLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJ5IFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlIHNvIHRoYXQgYW55IGVycm9ycyB0aHJvd24gYnkgdGhlIGV2ZW50XG4gICAqIGhhbmRsZXIgYXJlIHN1cmUgdG8gYmUgcmV0aHJvd24gYnkgcmV0aHJvd0NhdWdodEVycm9yLlxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrV2l0aENhdGNoOiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssXG5cbiAgLyoqXG4gICAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICAgKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gICAqL1xuICByZXRocm93Q2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2F1Z2h0RXJyb3IpIHtcbiAgICAgIHZhciBlcnJvciA9IGNhdWdodEVycm9yO1xuICAgICAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvKipcbiAgICogVG8gaGVscCBkZXZlbG9wbWVudCB3ZSBjYW4gZ2V0IGJldHRlciBkZXZ0b29scyBpbnRlZ3JhdGlvbiBieSBzaW11bGF0aW5nIGFcbiAgICogcmVhbCBicm93c2VyIGV2ZW50LlxuICAgKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZGlzcGF0Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBmYWtlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3JlYWN0Jyk7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBhKSB7XG4gICAgICB2YXIgYm91bmRGdW5jID0gZnVuYy5iaW5kKG51bGwsIGEpO1xuICAgICAgdmFyIGV2dFR5cGUgPSAncmVhY3QtJyArIG5hbWU7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGJvdW5kRnVuYywgZmFsc2UpO1xuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgLy8gJEZsb3dGaXhNZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjMzNlxuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBib3VuZEZ1bmMsIGZhbHNlKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFcnJvclV0aWxzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBJbmplY3RlZCBkZXBlbmRlbmNpZXM6XG4gKi9cblxuLyoqXG4gKiAtIGBDb21wb25lbnRUcmVlYDogW3JlcXVpcmVkXSBNb2R1bGUgdGhhdCBjYW4gY29udmVydCBiZXR3ZWVuIFJlYWN0IGluc3RhbmNlc1xuICogICBhbmQgYWN0dWFsIG5vZGUgcmVmZXJlbmNlcy5cbiAqL1xudmFyIENvbXBvbmVudFRyZWU7XG52YXIgVHJlZVRyYXZlcnNhbDtcbnZhciBpbmplY3Rpb24gPSB7XG4gIGluamVjdENvbXBvbmVudFRyZWU6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIENvbXBvbmVudFRyZWUgPSBJbmplY3RlZDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoSW5qZWN0ZWQgJiYgSW5qZWN0ZWQuZ2V0Tm9kZUZyb21JbnN0YW5jZSAmJiBJbmplY3RlZC5nZXRJbnN0YW5jZUZyb21Ob2RlLCAnRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0Q29tcG9uZW50VHJlZSguLi4pOiBJbmplY3RlZCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGdldE5vZGVGcm9tSW5zdGFuY2Ugb3IgZ2V0SW5zdGFuY2VGcm9tTm9kZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0sXG4gIGluamVjdFRyZWVUcmF2ZXJzYWw6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIFRyZWVUcmF2ZXJzYWwgPSBJbmplY3RlZDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoSW5qZWN0ZWQgJiYgSW5qZWN0ZWQuaXNBbmNlc3RvciAmJiBJbmplY3RlZC5nZXRMb3dlc3RDb21tb25BbmNlc3RvciwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdFRyZWVUcmF2ZXJzYWwoLi4uKTogSW5qZWN0ZWQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBpc0FuY2VzdG9yIG9yIGdldExvd2VzdENvbW1vbkFuY2VzdG9yLicpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gaXNFbmRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZVVwJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BUb3VjaEVuZCcgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wVG91Y2hDYW5jZWwnO1xufVxuXG5mdW5jdGlvbiBpc01vdmVpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZU1vdmUnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcFRvdWNoTW92ZSc7XG59XG5mdW5jdGlvbiBpc1N0YXJ0aXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VEb3duJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BUb3VjaFN0YXJ0Jztcbn1cblxudmFyIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgIHZhciBpbnN0YW5jZXNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICAgIHZhciBpbnN0YW5jZXNMZW4gPSBpbnN0YW5jZXNJc0FyciA/IGRpc3BhdGNoSW5zdGFuY2VzLmxlbmd0aCA6IGRpc3BhdGNoSW5zdGFuY2VzID8gMSA6IDA7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnN0YW5jZXNJc0FyciA9PT0gbGlzdGVuZXJzSXNBcnIgJiYgaW5zdGFuY2VzTGVuID09PSBsaXN0ZW5lcnNMZW4sICdFdmVudFBsdWdpblV0aWxzOiBJbnZhbGlkIGBldmVudGAuJykgOiB2b2lkIDA7XG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggdGhlIGV2ZW50IHRvIHRoZSBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFN5bnRoZXRpY0V2ZW50IHRvIGhhbmRsZVxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBBcHBsaWNhdGlvbi1sZXZlbCBjYWxsYmFja1xuICogQHBhcmFtIHsqfSBpbnN0IEludGVybmFsIGNvbXBvbmVudCBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgbGlzdGVuZXIsIGluc3QpIHtcbiAgdmFyIHR5cGUgPSBldmVudC50eXBlIHx8ICd1bmtub3duLWV2ZW50JztcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IEV2ZW50UGx1Z2luVXRpbHMuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2godHlwZSwgbGlzdGVuZXIsIGV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrKHR5cGUsIGxpc3RlbmVyLCBldmVudCk7XG4gIH1cbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcywgYnV0IHN0b3BzXG4gKiBhdCB0aGUgZmlyc3QgZGlzcGF0Y2ggZXhlY3V0aW9uIHJldHVybmluZyB0cnVlLCBhbmQgcmV0dXJucyB0aGF0IGlkLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IGlkIG9mIHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gd2hvJ3MgbGlzdGVuZXIgcmV0dXJuc1xuICogdHJ1ZSwgb3IgbnVsbCBpZiBubyBsaXN0ZW5lciByZXR1cm5lZCB0cnVlLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbChldmVudCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIEluc3RhbmNlcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGlmIChkaXNwYXRjaExpc3RlbmVyc1tpXShldmVudCwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaEluc3RhbmNlc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMoZXZlbnQsIGRpc3BhdGNoSW5zdGFuY2VzKSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoSW5zdGFuY2VzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUoZXZlbnQpIHtcbiAgdmFyIHJldCA9IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KTtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlyZWN0RGlzcGF0Y2goZXZlbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXIgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICAhIUFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZXhlY3V0ZURpcmVjdERpc3BhdGNoKC4uLik6IEludmFsaWQgYGV2ZW50YC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMDMnKSA6IHZvaWQgMDtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IGRpc3BhdGNoTGlzdGVuZXIgPyBFdmVudFBsdWdpblV0aWxzLmdldE5vZGVGcm9tSW5zdGFuY2UoZGlzcGF0Y2hJbnN0YW5jZSkgOiBudWxsO1xuICB2YXIgcmVzID0gZGlzcGF0Y2hMaXN0ZW5lciA/IGRpc3BhdGNoTGlzdGVuZXIoZXZlbnQpIDogbnVsbDtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5mdW5jdGlvbiBoYXNEaXNwYXRjaGVzKGV2ZW50KSB7XG4gIHJldHVybiAhIWV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbn1cblxuLyoqXG4gKiBHZW5lcmFsIHV0aWxpdGllcyB0aGF0IGFyZSB1c2VmdWwgaW4gY3JlYXRpbmcgY3VzdG9tIEV2ZW50IFBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpblV0aWxzID0ge1xuICBpc0VuZGlzaDogaXNFbmRpc2gsXG4gIGlzTW92ZWlzaDogaXNNb3ZlaXNoLFxuICBpc1N0YXJ0aXNoOiBpc1N0YXJ0aXNoLFxuXG4gIGV4ZWN1dGVEaXJlY3REaXNwYXRjaDogZXhlY3V0ZURpcmVjdERpc3BhdGNoLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXI6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcixcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZTogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSxcbiAgaGFzRGlzcGF0Y2hlczogaGFzRGlzcGF0Y2hlcyxcblxuICBnZXRJbnN0YW5jZUZyb21Ob2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBDb21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSk7XG4gIH0sXG4gIGdldE5vZGVGcm9tSW5zdGFuY2U6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIENvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShub2RlKTtcbiAgfSxcbiAgaXNBbmNlc3RvcjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5pc0FuY2VzdG9yKGEsIGIpO1xuICB9LFxuICBnZXRMb3dlc3RDb21tb25BbmNlc3RvcjogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5nZXRMb3dlc3RDb21tb25BbmNlc3RvcihhLCBiKTtcbiAgfSxcbiAgZ2V0UGFyZW50SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgcmV0dXJuIFRyZWVUcmF2ZXJzYWwuZ2V0UGFyZW50SW5zdGFuY2UoaW5zdCk7XG4gIH0sXG4gIHRyYXZlcnNlVHdvUGhhc2U6IGZ1bmN0aW9uICh0YXJnZXQsIGZuLCBhcmcpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC50cmF2ZXJzZVR3b1BoYXNlKHRhcmdldCwgZm4sIGFyZyk7XG4gIH0sXG4gIHRyYXZlcnNlRW50ZXJMZWF2ZTogZnVuY3Rpb24gKGZyb20sIHRvLCBmbiwgYXJnRnJvbSwgYXJnVG8pIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbyk7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiBpbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5VdGlsczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBpdGVtcyB0aGF0IG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGludG8gdGhlIGZpcnN0IG9uZS4gVGhpc1xuICogaXMgdXNlZCB0byBjb25zZXJ2ZSBtZW1vcnkgYnkgYXZvaWRpbmcgYXJyYXkgYWxsb2NhdGlvbnMsIGFuZCB0aHVzIHNhY3JpZmljZXNcbiAqIEFQSSBjbGVhbm5lc3MuIFNpbmNlIGBjdXJyZW50YCBjYW4gYmUgbnVsbCBiZWZvcmUgYmVpbmcgcGFzc2VkIGluIGFuZCBub3RcbiAqIG51bGwgYWZ0ZXIgdGhpcyBmdW5jdGlvbiwgbWFrZSBzdXJlIHRvIGFzc2lnbiBpdCBiYWNrIHRvIGBjdXJyZW50YDpcbiAqXG4gKiBgYSA9IGFjY3VtdWxhdGVJbnRvKGEsIGIpO2BcbiAqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgc3BhcmluZ2x5IHVzZWQuIFRyeSBgYWNjdW11bGF0ZWAgZm9yIHNvbWV0aGluZyBjbGVhbmVyLlxuICpcbiAqIEByZXR1cm4geyp8YXJyYXk8Kj59IEFuIGFjY3VtdWxhdGlvbiBvZiBpdGVtcy5cbiAqL1xuXG5mdW5jdGlvbiBhY2N1bXVsYXRlSW50byhjdXJyZW50LCBuZXh0KSB7XG4gICEobmV4dCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdhY2N1bXVsYXRlSW50byguLi4pOiBBY2N1bXVsYXRlZCBpdGVtcyBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nKSA6IF9wcm9kSW52YXJpYW50KCczMCcpIDogdm9pZCAwO1xuXG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8vIEJvdGggYXJlIG5vdCBlbXB0eS4gV2FybmluZzogTmV2ZXIgY2FsbCB4LmNvbmNhdCh5KSB3aGVuIHlvdSBhcmUgbm90XG4gIC8vIGNlcnRhaW4gdGhhdCB4IGlzIGFuIEFycmF5ICh4IGNvdWxkIGJlIGEgc3RyaW5nIHdpdGggY29uY2F0IG1ldGhvZCkuXG4gIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAgIGN1cnJlbnQucHVzaC5hcHBseShjdXJyZW50LCBuZXh0KTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBjdXJyZW50LnB1c2gobmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIC8vIEEgYml0IHRvbyBkYW5nZXJvdXMgdG8gbXV0YXRlIGBuZXh0YC5cbiAgICByZXR1cm4gW2N1cnJlbnRdLmNvbmNhdChuZXh0KTtcbiAgfVxuXG4gIHJldHVybiBbY3VycmVudCwgbmV4dF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWNjdW11bGF0ZUludG87IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7YXJyYXl9IGFyciBhbiBcImFjY3VtdWxhdGlvblwiIG9mIGl0ZW1zIHdoaWNoIGlzIGVpdGhlciBhbiBBcnJheSBvclxuICogYSBzaW5nbGUgaXRlbS4gVXNlZnVsIHdoZW4gcGFpcmVkIHdpdGggdGhlIGBhY2N1bXVsYXRlYCBtb2R1bGUuIFRoaXMgaXMgYVxuICogc2ltcGxlIHV0aWxpdHkgdGhhdCBhbGxvd3MgdXMgdG8gcmVhc29uIGFib3V0IGEgY29sbGVjdGlvbiBvZiBpdGVtcywgYnV0XG4gKiBoYW5kbGluZyB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGV4YWN0bHkgb25lIGl0ZW0gKGFuZCB3ZSBkbyBub3QgbmVlZCB0b1xuICogYWxsb2NhdGUgYW4gYXJyYXkpLlxuICovXG5cbmZ1bmN0aW9uIGZvckVhY2hBY2N1bXVsYXRlZChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaEFjY3VtdWxhdGVkOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5VdGlscycpO1xudmFyIFJlYWN0RXJyb3JVdGlscyA9IHJlcXVpcmUoJy4vUmVhY3RFcnJvclV0aWxzJyk7XG5cbnZhciBhY2N1bXVsYXRlSW50byA9IHJlcXVpcmUoJy4vYWNjdW11bGF0ZUludG8nKTtcbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSByZXF1aXJlKCcuL2ZvckVhY2hBY2N1bXVsYXRlZCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEludGVybmFsIHN0b3JlIGZvciBldmVudCBsaXN0ZW5lcnNcbiAqL1xudmFyIGxpc3RlbmVyQmFuayA9IHt9O1xuXG4vKipcbiAqIEludGVybmFsIHF1ZXVlIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWNjdW11bGF0ZWQgdGhlaXIgZGlzcGF0Y2hlcyBhbmQgYXJlXG4gKiB3YWl0aW5nIHRvIGhhdmUgdGhlaXIgZGlzcGF0Y2hlcyBleGVjdXRlZC5cbiAqL1xudmFyIGV2ZW50UXVldWUgPSBudWxsO1xuXG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIHJlbGVhc2VzIGl0IGJhY2sgaW50byB0aGUgcG9vbCwgdW5sZXNzIHBlcnNpc3RlbnQuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBldmVudCBTeW50aGV0aWMgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHByaXZhdGVcbiAqL1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSA9IGZ1bmN0aW9uIChldmVudCwgc2ltdWxhdGVkKSB7XG4gIGlmIChldmVudCkge1xuICAgIEV2ZW50UGx1Z2luVXRpbHMuZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XG59O1xuXG52YXIgZ2V0RGljdGlvbmFyeUtleSA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gIC8vIFByZXZlbnRzIFY4IHBlcmZvcm1hbmNlIGlzc3VlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MjMyXG4gIHJldHVybiAnLicgKyBpbnN0Ll9yb290Tm9kZUlEO1xufTtcblxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpIHtcbiAgcmV0dXJuIHRhZyA9PT0gJ2J1dHRvbicgfHwgdGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3NlbGVjdCcgfHwgdGFnID09PSAndGV4dGFyZWEnO1xufVxuXG5mdW5jdGlvbiBzaG91bGRQcmV2ZW50TW91c2VFdmVudChuYW1lLCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdvbkNsaWNrJzpcbiAgICBjYXNlICdvbkNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGljayc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VEb3duJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bkNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZUNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VVcCc6XG4gICAgY2FzZSAnb25Nb3VzZVVwQ2FwdHVyZSc6XG4gICAgICByZXR1cm4gISEocHJvcHMuZGlzYWJsZWQgJiYgaXNJbnRlcmFjdGl2ZSh0eXBlKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgZXZlbnQgcGx1Z2lucyB0byBiZSBpbnN0YWxsZWQgYW5kIGNvbmZpZ3VyZWQuXG4gKlxuICogRXZlbnQgcGx1Z2lucyBjYW4gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIGBleHRyYWN0RXZlbnRzYCB7ZnVuY3Rpb24oc3RyaW5nLCBET01FdmVudFRhcmdldCwgc3RyaW5nLCBvYmplY3QpOiAqfVxuICogICAgIFJlcXVpcmVkLiBXaGVuIGEgdG9wLWxldmVsIGV2ZW50IGlzIGZpcmVkLCB0aGlzIG1ldGhvZCBpcyBleHBlY3RlZCB0b1xuICogICAgIGV4dHJhY3Qgc3ludGhldGljIGV2ZW50cyB0aGF0IHdpbGwgaW4gdHVybiBiZSBxdWV1ZWQgYW5kIGRpc3BhdGNoZWQuXG4gKlxuICogICBgZXZlbnRUeXBlc2Age29iamVjdH1cbiAqICAgICBPcHRpb25hbCwgcGx1Z2lucyB0aGF0IGZpcmUgZXZlbnRzIG11c3QgcHVibGlzaCBhIG1hcHBpbmcgb2YgcmVnaXN0cmF0aW9uXG4gKiAgICAgbmFtZXMgdGhhdCBhcmUgdXNlZCB0byByZWdpc3RlciBsaXN0ZW5lcnMuIFZhbHVlcyBvZiB0aGlzIG1hcHBpbmcgbXVzdFxuICogICAgIGJlIG9iamVjdHMgdGhhdCBjb250YWluIGByZWdpc3RyYXRpb25OYW1lYCBvciBgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNgLlxuICpcbiAqICAgYGV4ZWN1dGVEaXNwYXRjaGAge2Z1bmN0aW9uKG9iamVjdCwgZnVuY3Rpb24sIHN0cmluZyl9XG4gKiAgICAgT3B0aW9uYWwsIGFsbG93cyBwbHVnaW5zIHRvIG92ZXJyaWRlIGhvdyBhbiBldmVudCBnZXRzIGRpc3BhdGNoZWQuIEJ5XG4gKiAgICAgZGVmYXVsdCwgdGhlIGxpc3RlbmVyIGlzIHNpbXBseSBpbnZva2VkLlxuICpcbiAqIEVhY2ggcGx1Z2luIHRoYXQgaXMgaW5qZWN0ZWQgaW50byBgRXZlbnRzUGx1Z2luSHViYCBpcyBpbW1lZGlhdGVseSBvcGVyYWJsZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBFdmVudFBsdWdpbkh1YiA9IHtcblxuICAvKipcbiAgICogTWV0aG9kcyBmb3IgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy5cbiAgICovXG4gIGluamVjdGlvbjoge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IEV2ZW50UGx1Z2luUmVnaXN0cnkuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgICAqL1xuICAgIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcblxuICB9LFxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYGxpc3RlbmVyYCBhdCBgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2tleV1gLiBJcyBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIFRoZSBjYWxsYmFjayB0byBzdG9yZS5cbiAgICovXG4gIHB1dExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAhKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgJXMgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgdHlwZSAlcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiBfcHJvZEludmFyaWFudCgnOTQnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogdm9pZCAwO1xuXG4gICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdIHx8IChsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gPSB7fSk7XG4gICAgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVba2V5XSA9IGxpc3RlbmVyO1xuXG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUuZGlkUHV0TGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS5kaWRQdXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAgICovXG4gIGdldExpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIC8vIFRPRE86IHNob3VsZFByZXZlbnRNb3VzZUV2ZW50IGlzIERPTS1zcGVjaWZpYyBhbmQgZGVmaW5pdGVseSBzaG91bGQgbm90XG4gICAgLy8gbGl2ZSBoZXJlOyBuZWVkcyB0byBiZSBtb3ZlZCB0byBhIGJldHRlciBwbGFjZSBzb29uXG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIGlmIChzaG91bGRQcmV2ZW50TW91c2VFdmVudChyZWdpc3RyYXRpb25OYW1lLCBpbnN0Ll9jdXJyZW50RWxlbWVudC50eXBlLCBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICByZXR1cm4gYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgJiYgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVba2V5XTtcbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhIGxpc3RlbmVyIGZyb20gdGhlIHJlZ2lzdHJhdGlvbiBiYW5rLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqL1xuICBkZWxldGVMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIG5ldmVyIGJlIG51bGwgLS0gd2hlbiBpcyBpdD9cbiAgICBpZiAoYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgICAgZGVsZXRlIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2tleV07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBET00gZWxlbWVudCB3aXRoIHRoZSBzdXBwbGllZCBJRC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAgICovXG4gIGRlbGV0ZUFsbExpc3RlbmVyczogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICBmb3IgKHZhciByZWdpc3RyYXRpb25OYW1lIGluIGxpc3RlbmVyQmFuaykge1xuICAgICAgaWYgKCFsaXN0ZW5lckJhbmsuaGFzT3duUHJvcGVydHkocmVnaXN0cmF0aW9uTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2tleV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKSB7XG4gICAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1ba2V5XTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAgICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZXZlbnRzO1xuICAgIHZhciBwbHVnaW5zID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICAgIGlmIChwb3NzaWJsZVBsdWdpbikge1xuICAgICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgICBldmVudHMgPSBhY2N1bXVsYXRlSW50byhldmVudHMsIGV4dHJhY3RlZEV2ZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50cztcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBzeW50aGV0aWMgZXZlbnQgdGhhdCBzaG91bGQgYmUgZGlzcGF0Y2hlZCB3aGVuXG4gICAqIGBwcm9jZXNzRXZlbnRRdWV1ZWAgaXMgaW52b2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBldmVudHMgQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUV2ZW50czogZnVuY3Rpb24gKGV2ZW50cykge1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgIGV2ZW50UXVldWUgPSBhY2N1bXVsYXRlSW50byhldmVudFF1ZXVlLCBldmVudHMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbGwgc3ludGhldGljIGV2ZW50cyBvbiB0aGUgZXZlbnQgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc0V2ZW50UXVldWU6IGZ1bmN0aW9uIChzaW11bGF0ZWQpIHtcbiAgICAvLyBTZXQgYGV2ZW50UXVldWVgIHRvIG51bGwgYmVmb3JlIHByb2Nlc3NpbmcgaXQgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBtb3JlXG4gICAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICAgIHZhciBwcm9jZXNzaW5nRXZlbnRRdWV1ZSA9IGV2ZW50UXVldWU7XG4gICAgZXZlbnRRdWV1ZSA9IG51bGw7XG4gICAgaWYgKHNpbXVsYXRlZCkge1xuICAgICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgICB9XG4gICAgISFldmVudFF1ZXVlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3Byb2Nlc3NFdmVudFF1ZXVlKCk6IEFkZGl0aW9uYWwgZXZlbnRzIHdlcmUgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZyBhbiBldmVudCBxdWV1ZS4gU3VwcG9ydCBmb3IgdGhpcyBoYXMgbm90IHlldCBiZWVuIGltcGxlbWVudGVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzk1JykgOiB2b2lkIDA7XG4gICAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gICAgUmVhY3RFcnJvclV0aWxzLnJldGhyb3dDYXVnaHRFcnJvcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGVzZSBhcmUgbmVlZGVkIGZvciB0ZXN0cyBvbmx5LiBEbyBub3QgdXNlIVxuICAgKi9cbiAgX19wdXJnZTogZnVuY3Rpb24gKCkge1xuICAgIGxpc3RlbmVyQmFuayA9IHt9O1xuICB9LFxuXG4gIF9fZ2V0TGlzdGVuZXJCYW5rOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQmFuaztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luSHViOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XG5cbnZhciBhY2N1bXVsYXRlSW50byA9IHJlcXVpcmUoJy4vYWNjdW11bGF0ZUludG8nKTtcbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSByZXF1aXJlKCcuL2ZvckVhY2hBY2N1bXVsYXRlZCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBnZXRMaXN0ZW5lciA9IEV2ZW50UGx1Z2luSHViLmdldExpc3RlbmVyO1xuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcHJvcGFnYXRpb25QaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3Byb3BhZ2F0aW9uUGhhc2VdO1xuICByZXR1cm4gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG59XG5cbi8qKlxuICogVGFncyBhIGBTeW50aGV0aWNFdmVudGAgd2l0aCBkaXNwYXRjaGVkIGxpc3RlbmVycy4gQ3JlYXRpbmcgdGhpcyBmdW5jdGlvblxuICogaGVyZSwgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGJpbmQgb3IgY3JlYXRlIGZ1bmN0aW9ucyBmb3IgZWFjaCBldmVudC5cbiAqIE11dGF0aW5nIHRoZSBldmVudCdzIG1lbWJlcnMgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBhIHdyYXBwaW5nXG4gKiBcImRpc3BhdGNoXCIgb2JqZWN0IHRoYXQgcGFpcnMgdGhlIGV2ZW50IHdpdGggdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzKGluc3QsIHBoYXNlLCBldmVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGluc3QsICdEaXNwYXRjaGluZyBpbnN0IG11c3Qgbm90IGJlIG51bGwnKSA6IHZvaWQgMDtcbiAgfVxuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHBoYXNlKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBFdmVudFBsdWdpblV0aWxzLnRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuX3RhcmdldEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbWUgYXMgYGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVgLCBidXQgc2tpcHMgb3ZlciB0aGUgdGFyZ2V0SUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHZhciB0YXJnZXRJbnN0ID0gZXZlbnQuX3RhcmdldEluc3Q7XG4gICAgdmFyIHBhcmVudEluc3QgPSB0YXJnZXRJbnN0ID8gRXZlbnRQbHVnaW5VdGlscy5nZXRQYXJlbnRJbnN0YW5jZSh0YXJnZXRJbnN0KSA6IG51bGw7XG4gICAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZVR3b1BoYXNlKHBhcmVudEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIHdpdGhvdXQgcmVnYXJkIHRvIGRpcmVjdGlvbiwgZG9lcyBub3QgbG9vayBmb3IgcGhhc2VkXG4gKiByZWdpc3RyYXRpb24gbmFtZXMuIFNhbWUgYXMgYGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlYCBidXQgd2l0aG91dFxuICogcmVxdWlyaW5nIHRoYXQgdGhlIGBkaXNwYXRjaE1hcmtlcmAgYmUgdGhlIHNhbWUgYXMgdGhlIGRpc3BhdGNoZWQgSUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGluc3QsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxuICogYGRpc3BhdGNoTWFya2VyYC5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuX3RhcmdldEluc3QsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pIHtcbiAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGFjY3VtdWxhdGVEaXNwYXRjaGVzLCBsZWF2ZSwgZW50ZXIpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW50IGFcbiAqIHNpbmdsZSBvbmUuXG4gKlxuICogQGNvbnN0cnVjdG9yIEV2ZW50UHJvcGFnYXRvcnNcbiAqL1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSB7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcbiAgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFByb3BhZ2F0b3JzOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuLyoqXG4gKiBTaW1wbGUsIGxpZ2h0d2VpZ2h0IG1vZHVsZSBhc3Npc3Rpbmcgd2l0aCB0aGUgZGV0ZWN0aW9uIGFuZCBjb250ZXh0IG9mXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XG4gKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBpbiBhIFdvcmtlciwgZXZlbiBpZiB0aGV5IG5ldmVyIGluY2x1ZGUgdGhlIG1haW5cbiAqIGBSZWFjdFdvcmtlcmAgZGVwZW5kZW5jeS5cbiAqL1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxuXG4gIGNhblVzZVdvcmtlcnM6IHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnLFxuXG4gIGNhblVzZUV2ZW50TGlzdGVuZXJzOiBjYW5Vc2VET00gJiYgISEod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgfHwgd2luZG93LmF0dGFjaEV2ZW50KSxcblxuICBjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlbixcblxuICBpc0luV29ya2VyOiAhY2FuVXNlRE9NIC8vIEZvciBub3csIHRoaXMgaXMgdHJ1ZSAtIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFN0YXRpYyBwb29sZXJzLiBTZXZlcmFsIGN1c3RvbSB2ZXJzaW9ucyBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mXG4gKiBhcmd1bWVudHMuIEEgY29tcGxldGVseSBnZW5lcmljIHBvb2xlciBpcyBlYXN5IHRvIGltcGxlbWVudCwgYnV0IHdvdWxkXG4gKiByZXF1aXJlIGFjY2Vzc2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBJbiBlYWNoIG9mIHRoZXNlLCBgdGhpc2AgcmVmZXJzIHRvXG4gKiB0aGUgQ2xhc3MgaXRzZWxmLCBub3QgYW4gaW5zdGFuY2UuIElmIGFueSBvdGhlcnMgYXJlIG5lZWRlZCwgc2ltcGx5IGFkZCB0aGVtXG4gKiBoZXJlLCBvciBpbiB0aGVpciBvd24gZmlsZXMuXG4gKi9cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChjb3B5RmllbGRzRnJvbSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBjb3B5RmllbGRzRnJvbSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoY29weUZpZWxkc0Zyb20pO1xuICB9XG59O1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMik7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyKTtcbiAgfVxufTtcblxudmFyIHRocmVlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMykge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzKTtcbiAgfVxufTtcblxudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQpO1xuICB9XG59O1xuXG52YXIgZml2ZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gIH1cbn07XG5cbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gICEoaW5zdGFuY2UgaW5zdGFuY2VvZiBLbGFzcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gaW5zdGFuY2UgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IF9wcm9kSW52YXJpYW50KCcyNScpIDogdm9pZCAwO1xuICBpbnN0YW5jZS5kZXN0cnVjdG9yKCk7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoIDwgS2xhc3MucG9vbFNpemUpIHtcbiAgICBLbGFzcy5pbnN0YW5jZVBvb2wucHVzaChpbnN0YW5jZSk7XG4gIH1cbn07XG5cbnZhciBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xudmFyIERFRkFVTFRfUE9PTEVSID0gb25lQXJndW1lbnRQb29sZXI7XG5cbi8qKlxuICogQXVnbWVudHMgYENvcHlDb25zdHJ1Y3RvcmAgdG8gYmUgYSBwb29sYWJsZSBjbGFzcywgYXVnbWVudGluZyBvbmx5IHRoZSBjbGFzc1xuICogaXRzZWxmIChzdGF0aWNhbGx5KSBub3QgYWRkaW5nIGFueSBwcm90b3R5cGljYWwgZmllbGRzLiBBbnkgQ29weUNvbnN0cnVjdG9yXG4gKiB5b3UgZ2l2ZSB0aGlzIG1heSBoYXZlIGEgYHBvb2xTaXplYCBwcm9wZXJ0eSwgYW5kIHdpbGwgbG9vayBmb3IgYVxuICogcHJvdG90eXBpY2FsIGBkZXN0cnVjdG9yYCBvbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29weUNvbnN0cnVjdG9yIENvbnN0cnVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb29sZXIgQ3VzdG9taXphYmxlIHBvb2xlci5cbiAqL1xudmFyIGFkZFBvb2xpbmdUbyA9IGZ1bmN0aW9uIChDb3B5Q29uc3RydWN0b3IsIHBvb2xlcikge1xuICAvLyBDYXN0aW5nIGFzIGFueSBzbyB0aGF0IGZsb3cgaWdub3JlcyB0aGUgYWN0dWFsIGltcGxlbWVudGF0aW9uIGFuZCB0cnVzdHNcbiAgLy8gaXQgdG8gbWF0Y2ggdGhlIHR5cGUgd2UgZGVjbGFyZWRcbiAgdmFyIE5ld0tsYXNzID0gQ29weUNvbnN0cnVjdG9yO1xuICBOZXdLbGFzcy5pbnN0YW5jZVBvb2wgPSBbXTtcbiAgTmV3S2xhc3MuZ2V0UG9vbGVkID0gcG9vbGVyIHx8IERFRkFVTFRfUE9PTEVSO1xuICBpZiAoIU5ld0tsYXNzLnBvb2xTaXplKSB7XG4gICAgTmV3S2xhc3MucG9vbFNpemUgPSBERUZBVUxUX1BPT0xfU0laRTtcbiAgfVxuICBOZXdLbGFzcy5yZWxlYXNlID0gc3RhbmRhcmRSZWxlYXNlcjtcbiAgcmV0dXJuIE5ld0tsYXNzO1xufTtcblxudmFyIFBvb2xlZENsYXNzID0ge1xuICBhZGRQb29saW5nVG86IGFkZFBvb2xpbmdUbyxcbiAgb25lQXJndW1lbnRQb29sZXI6IG9uZUFyZ3VtZW50UG9vbGVyLFxuICB0d29Bcmd1bWVudFBvb2xlcjogdHdvQXJndW1lbnRQb29sZXIsXG4gIHRocmVlQXJndW1lbnRQb29sZXI6IHRocmVlQXJndW1lbnRQb29sZXIsXG4gIGZvdXJBcmd1bWVudFBvb2xlcjogZm91ckFyZ3VtZW50UG9vbGVyLFxuICBmaXZlQXJndW1lbnRQb29sZXI6IGZpdmVBcmd1bWVudFBvb2xlclxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb29sZWRDbGFzczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY29udGVudEtleSA9IG51bGw7XG5cbi8qKlxuICogR2V0cyB0aGUga2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudCBvbiBhIERPTSBub2RlLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IEtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpIHtcbiAgaWYgKCFjb250ZW50S2V5ICYmIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAgIC8vIFByZWZlciB0ZXh0Q29udGVudCB0byBpbm5lclRleHQgYmVjYXVzZSBtYW55IGJyb3dzZXJzIHN1cHBvcnQgYm90aCBidXRcbiAgICAvLyBTVkcgPHRleHQ+IGVsZW1lbnRzIGRvbid0IHN1cHBvcnQgaW5uZXJUZXh0IGV2ZW4gd2hlbiA8ZGl2PiBkb2VzLlxuICAgIGNvbnRlbnRLZXkgPSAndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/ICd0ZXh0Q29udGVudCcgOiAnaW5uZXJUZXh0JztcbiAgfVxuICByZXR1cm4gY29udGVudEtleTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUZXh0Q29udGVudEFjY2Vzc29yOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG5cbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yJyk7XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgY2xhc3Mgc3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IHRleHQgY29udGVudCBvZiBhIHRhcmdldCBub2RlLFxuICogYWxsb3dpbmcgY29tcGFyaXNvbiBvZiBjb250ZW50IGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBJZGVudGlmeSB0aGUgbm9kZSB3aGVyZSBzZWxlY3Rpb24gY3VycmVudGx5IGJlZ2lucywgdGhlbiBvYnNlcnZlXG4gKiBib3RoIGl0cyB0ZXh0IGNvbnRlbnQgYW5kIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBET00uIFNpbmNlIHRoZVxuICogYnJvd3NlciBtYXkgbmF0aXZlbHkgcmVwbGFjZSB0aGUgdGFyZ2V0IG5vZGUgZHVyaW5nIGNvbXBvc2l0aW9uLCB3ZSBjYW5cbiAqIHVzZSBpdHMgcG9zaXRpb24gdG8gZmluZCBpdHMgcmVwbGFjZW1lbnQuXG4gKlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gcm9vdFxuICovXG5mdW5jdGlvbiBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUocm9vdCkge1xuICB0aGlzLl9yb290ID0gcm9vdDtcbiAgdGhpcy5fc3RhcnRUZXh0ID0gdGhpcy5nZXRUZXh0KCk7XG4gIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5cbl9hc3NpZ24oRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLnByb3RvdHlwZSwge1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgdGhpcy5fc3RhcnRUZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9mYWxsYmFja1RleHQgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCB0ZXh0IG9mIGlucHV0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRUZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCd2YWx1ZScgaW4gdGhpcy5fcm9vdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3QudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yb290W2dldFRleHRDb250ZW50QWNjZXNzb3IoKV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGVybWluZSB0aGUgZGlmZmVyaW5nIHN1YnN0cmluZyBiZXR3ZWVuIHRoZSBpbml0aWFsbHkgc3RvcmVkXG4gICAqIHRleHQgY29udGVudCBhbmQgdGhlIGN1cnJlbnQgY29udGVudC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0RGF0YTogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9mYWxsYmFja1RleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mYWxsYmFja1RleHQ7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0O1xuICAgIHZhciBzdGFydFZhbHVlID0gdGhpcy5fc3RhcnRUZXh0O1xuICAgIHZhciBzdGFydExlbmd0aCA9IHN0YXJ0VmFsdWUubGVuZ3RoO1xuICAgIHZhciBlbmQ7XG4gICAgdmFyIGVuZFZhbHVlID0gdGhpcy5nZXRUZXh0KCk7XG4gICAgdmFyIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcblxuICAgIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IHN0YXJ0TGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydF0gIT09IGVuZFZhbHVlW3N0YXJ0XSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWluRW5kID0gc3RhcnRMZW5ndGggLSBzdGFydDtcbiAgICBmb3IgKGVuZCA9IDE7IGVuZCA8PSBtaW5FbmQ7IGVuZCsrKSB7XG4gICAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydExlbmd0aCAtIGVuZF0gIT09IGVuZFZhbHVlW2VuZExlbmd0aCAtIGVuZF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZhbGxiYWNrVGV4dCA9IGVuZFZhbHVlLnNsaWNlKHN0YXJ0LCBzbGljZVRhaWwpO1xuICAgIHJldHVybiB0aGlzLl9mYWxsYmFja1RleHQ7XG4gIH1cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gZmFsc2U7XG52YXIgaXNQcm94eVN1cHBvcnRlZCA9IHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzID0gWydkaXNwYXRjaENvbmZpZycsICdfdGFyZ2V0SW5zdCcsICduYXRpdmVFdmVudCcsICdpc0RlZmF1bHRQcmV2ZW50ZWQnLCAnaXNQcm9wYWdhdGlvblN0b3BwZWQnLCAnX2Rpc3BhdGNoTGlzdGVuZXJzJywgJ19kaXNwYXRjaEluc3RhbmNlcyddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIHRoZXNlIGhhdmUgYSBnZXR0ZXIvc2V0dGVyIGZvciB3YXJuaW5nc1xuICAgIGRlbGV0ZSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGRlbGV0ZSB0aGlzLnByZXZlbnREZWZhdWx0O1xuICAgIGRlbGV0ZSB0aGlzLnN0b3BQcm9wYWdhdGlvbjtcbiAgfVxuXG4gIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBkaXNwYXRjaENvbmZpZztcbiAgdGhpcy5fdGFyZ2V0SW5zdCA9IHRhcmdldEluc3Q7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcblxuICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgIGlmICghSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBkZWxldGUgdGhpc1twcm9wTmFtZV07IC8vIHRoaXMgaGFzIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtwcm9wTmFtZV07XG4gICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBub3JtYWxpemUobmF0aXZlRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcE5hbWUgPT09ICd0YXJnZXQnKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgIT0gbnVsbCA/IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOiBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZSA9PT0gZmFsc2U7XG4gIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgfVxuICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICByZXR1cm4gdGhpcztcbn1cblxuX2Fzc2lnbihTeW50aGV0aWNFdmVudC5wcm90b3R5cGUsIHtcblxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LnJldHVyblZhbHVlICE9PSAndW5rbm93bicpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgdmFsaWQtdHlwZW9mXG4gICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHZhbGlkLXR5cGVvZlxuICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcE5hbWUsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIEludGVyZmFjZVtwcm9wTmFtZV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpc1tzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllc1tpXV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYXRpdmVFdmVudCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ25hdGl2ZUV2ZW50JywgbnVsbCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwcmV2ZW50RGVmYXVsdCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3ByZXZlbnREZWZhdWx0JywgZW1wdHlGdW5jdGlvbikpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdG9wUHJvcGFnYXRpb24nLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdzdG9wUHJvcGFnYXRpb24nLCBlbXB0eUZ1bmN0aW9uKSk7XG4gICAgfVxuICB9XG5cbn0pO1xuXG5TeW50aGV0aWNFdmVudC5JbnRlcmZhY2UgPSBFdmVudEludGVyZmFjZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgaWYgKGlzUHJveHlTdXBwb3J0ZWQpIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gICAgU3ludGhldGljRXZlbnQgPSBuZXcgUHJveHkoU3ludGhldGljRXZlbnQsIHtcbiAgICAgIGNvbnN0cnVjdDogZnVuY3Rpb24gKHRhcmdldCwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseSh0YXJnZXQsIE9iamVjdC5jcmVhdGUodGFyZ2V0LnByb3RvdHlwZSksIGFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbiAoY29uc3RydWN0b3IsIHRoYXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShjb25zdHJ1Y3Rvci5hcHBseSh0aGF0LCBhcmdzKSwge1xuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wICE9PSAnaXNQZXJzaXN0ZW50JyAmJiAhdGFyZ2V0LmNvbnN0cnVjdG9yLkludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSB8fCB0YXJnZXQuaXNQZXJzaXN0ZW50KCksICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlICcgKyAnc2VlaW5nIHRoaXMsIHlvdVxcJ3JlIGFkZGluZyBhIG5ldyBwcm9wZXJ0eSBpbiB0aGUgc3ludGhldGljIGV2ZW50IG9iamVjdC4gJyArICdUaGUgcHJvcGVydHkgaXMgbmV2ZXIgcmVsZWFzZWQuIFNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qZXNsaW50LWVuYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICB9XG59XG4vKipcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzXG4gKiBAcGFyYW0gez9vYmplY3R9IEludGVyZmFjZVxuICovXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MgPSBmdW5jdGlvbiAoQ2xhc3MsIEludGVyZmFjZSkge1xuICB2YXIgU3VwZXIgPSB0aGlzO1xuXG4gIHZhciBFID0gZnVuY3Rpb24gKCkge307XG4gIEUucHJvdG90eXBlID0gU3VwZXIucHJvdG90eXBlO1xuICB2YXIgcHJvdG90eXBlID0gbmV3IEUoKTtcblxuICBfYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBTdXBlci5JbnRlcmZhY2UsIEludGVyZmFjZSk7XG4gIENsYXNzLmF1Z21lbnRDbGFzcyA9IFN1cGVyLmF1Z21lbnRDbGFzcztcblxuICBQb29sZWRDbGFzcy5hZGRQb29saW5nVG8oQ2xhc3MsIFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcik7XG59O1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oU3ludGhldGljRXZlbnQsIFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRXZlbnQ7XG5cbi8qKlxuICAqIEhlbHBlciB0byBudWxsaWZ5IHN5bnRoZXRpY0V2ZW50IGluc3RhbmNlIHByb3BlcnRpZXMgd2hlbiBkZXN0cnVjdGluZ1xuICAqXG4gICogQHBhcmFtIHtvYmplY3R9IFN5bnRoZXRpY0V2ZW50XG4gICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXG4gICogQHJldHVybiB7b2JqZWN0fSBkZWZpbmVQcm9wZXJ0eSBvYmplY3RcbiAgKi9cbmZ1bmN0aW9uIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIGdldFZhbCkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBnZXRWYWwgPT09ICdmdW5jdGlvbic7XG4gIHJldHVybiB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHNldDogc2V0LFxuICAgIGdldDogZ2V0XG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ3NldHRpbmcgdGhlIG1ldGhvZCcgOiAnc2V0dGluZyB0aGUgcHJvcGVydHknO1xuICAgIHdhcm4oYWN0aW9uLCAnVGhpcyBpcyBlZmZlY3RpdmVseSBhIG5vLW9wJyk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdhY2Nlc3NpbmcgdGhlIG1ldGhvZCcgOiAnYWNjZXNzaW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgdmFyIHJlc3VsdCA9IGlzRnVuY3Rpb24gPyAnVGhpcyBpcyBhIG5vLW9wIGZ1bmN0aW9uJyA6ICdUaGlzIGlzIHNldCB0byBudWxsJztcbiAgICB3YXJuKGFjdGlvbiwgcmVzdWx0KTtcbiAgICByZXR1cm4gZ2V0VmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FybihhY3Rpb24sIHJlc3VsdCkge1xuICAgIHZhciB3YXJuaW5nQ29uZGl0aW9uID0gZmFsc2U7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcod2FybmluZ0NvbmRpdGlvbiwgJ1RoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91XFwncmUgc2VlaW5nIHRoaXMsICcgKyAneW91XFwncmUgJXMgYCVzYCBvbiBhIHJlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuICVzLiAnICsgJ0lmIHlvdSBtdXN0IGtlZXAgdGhlIG9yaWdpbmFsIHN5bnRoZXRpYyBldmVudCBhcm91bmQsIHVzZSBldmVudC5wZXJzaXN0KCkuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBhY3Rpb24sIHByb3BOYW1lLCByZXN1bHQpIDogdm9pZCAwO1xuICB9XG59IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHNcbiAqL1xudmFyIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQ29tcG9zaXRpb25FdmVudCwgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG52YXIgSW5wdXRFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljSW5wdXRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNJbnB1dEV2ZW50LCBJbnB1dEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNJbnB1dEV2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlID0gcmVxdWlyZSgnLi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUnKTtcbnZhciBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50Jyk7XG52YXIgU3ludGhldGljSW5wdXRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljSW5wdXRFdmVudCcpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgJiYgIWlzUHJlc3RvKCk7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbi8qKlxuICogT3BlcmEgPD0gMTIgaW5jbHVkZXMgVGV4dEV2ZW50IGluIHdpbmRvdywgYnV0IGRvZXMgbm90IGZpcmVcbiAqIHRleHQgaW5wdXQgZXZlbnRzLiBSZWx5IG9uIGtleXByZXNzIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGlzUHJlc3RvKCkge1xuICB2YXIgb3BlcmEgPSB3aW5kb3cub3BlcmE7XG4gIHJldHVybiB0eXBlb2Ygb3BlcmEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcGVyYS52ZXJzaW9uID09PSAnZnVuY3Rpb24nICYmIHBhcnNlSW50KG9wZXJhLnZlcnNpb24oKSwgMTApIDw9IDEyO1xufVxuXG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG4vLyBFdmVudHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYmVmb3JlSW5wdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQmVmb3JlSW5wdXQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkJlZm9yZUlucHV0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BDb21wb3NpdGlvbkVuZCcsICd0b3BLZXlQcmVzcycsICd0b3BUZXh0SW5wdXQnLCAndG9wUGFzdGUnXVxuICB9LFxuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvbkVuZCcsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25FbmRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25FbmQnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25TdGFydCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH0sXG4gIGNvbXBvc2l0aW9uVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvblVwZGF0ZScsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH1cbn07XG5cbi8vIFRyYWNrIHdoZXRoZXIgd2UndmUgZXZlciBoYW5kbGVkIGEga2V5cHJlc3Mgb24gdGhlIHNwYWNlIGtleS5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiZcbiAgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25TdGFydCc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uVXBkYXRlJzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uVXBkYXRlO1xuICB9XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlEb3duJyAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcbiAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgY2FzZSAndG9wQmx1cic6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gZmFsbGJhY2sgb2JqZWN0LCBpZiBhbnkuXG52YXIgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcblxuLyoqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudFR5cGU7XG4gIHZhciBmYWxsYmFja0RhdGE7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpO1xuICB9IGVsc2UgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEpIHtcbiAgICAvLyBUaGUgY3VycmVudCBjb21wb3NpdGlvbiBpcyBzdG9yZWQgc3RhdGljYWxseSBhbmQgbXVzdCBub3QgYmVcbiAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG4gICAgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24gJiYgZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQpIHtcbiAgICAgIGN1cnJlbnRDb21wb3NpdGlvbiA9IEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5nZXRQb29sZWQobmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XG4gICAgICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmIChmYWxsYmFja0RhdGEpIHtcbiAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cbiAgICAvLyBUaGlzIG1hdGNoZXMgdGhlIHByb3BlcnR5IG9mIG5hdGl2ZSBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlLlxuICAgIGV2ZW50LmRhdGEgPSBmYWxsYmFja0RhdGE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1c3RvbURhdGEgPSBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBpZiAoY3VzdG9tRGF0YSAhPT0gbnVsbCkge1xuICAgICAgZXZlbnQuZGF0YSA9IGN1c3RvbURhdGE7XG4gICAgfVxuICB9XG5cbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgJ3RvcFRleHRJbnB1dCc6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICAgIC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gYmxhY2tsaXN0IGl0LlxuICAgICAgaWYgKGNoYXJzID09PSBTUEFDRUJBUl9DSEFSICYmIGhhc1NwYWNlS2V5cHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFycztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBmYWxsYmFjayBzdHJpbmcgZm9yIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgLy8gSWYgY29tcG9zaXRpb24gZXZlbnQgaXMgYXZhaWxhYmxlLCB3ZSBleHRyYWN0IGEgc3RyaW5nIG9ubHkgYXRcbiAgLy8gY29tcG9zaXRpb25ldmVudCwgb3RoZXJ3aXNlIGV4dHJhY3QgaXQgYXQgZmFsbGJhY2sgZXZlbnRzLlxuICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENvbXBvc2l0aW9uRW5kJyB8fCAhY2FuVXNlQ29tcG9zaXRpb25FdmVudCAmJiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHZhciBjaGFycyA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucmVsZWFzZShjdXJyZW50Q29tcG9zaXRpb24pO1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcFBhc3RlJzpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgIC8qKlxuICAgICAgICogQXMgb2YgdjI3LCBGaXJlZm94IG1heSBmaXJlIGtleXByZXNzIGV2ZW50cyBldmVuIHdoZW4gbm8gY2hhcmFjdGVyXG4gICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyBgMGAuIEFycm93IGtleXMsIEVzYyBrZXksIGV0Yy5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBubyBjaGFyIGlzIGF2YWlsYWJsZS5cbiAgICAgICAqICAgRXg6ICdBbHRHciArIGRgIGluIFBvbGlzaC4gVGhlcmUgaXMgbm8gbW9kaWZpZWQgY2hhcmFjdGVyIGZvclxuICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXG4gICAgICAgKiAgIGRvY3VtZW50LCBidXQgRkYgZmlyZXMgdGhlIGtleXByZXNzIGZvciBjaGFyIGNvZGUgYDEwMGAgYW55d2F5LlxuICAgICAgICogICBObyBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgYSBjb21tYW5kIGNvbWJpbmF0aW9uIGlzXG4gICAgICAgKiAgIGJlaW5nIHVzZWQuIEV4OiBgQ21kK0NgLiBObyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGFuZCBub1xuICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKi9cbiAgICAgIGlmIChuYXRpdmVFdmVudC53aGljaCAmJiAhaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBgb25CZWZvcmVJbnB1dGAgZXZlbnQgdG8gbWF0Y2hcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1LyNldmVudHMtaW5wdXRldmVudHMuXG4gKlxuICogVGhpcyBldmVudCBwbHVnaW4gaXMgYmFzZWQgb24gdGhlIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudFxuICogYXZhaWxhYmxlIGluIENocm9tZSwgU2FmYXJpLCBPcGVyYSwgYW5kIElFLiBUaGlzIGV2ZW50IGZpcmVzIGFmdGVyXG4gKiBgb25LZXlQcmVzc2AgYW5kIGBvbkNvbXBvc2l0aW9uRW5kYCwgYnV0IGJlZm9yZSBgb25JbnB1dGAuXG4gKlxuICogYGJlZm9yZUlucHV0YCBpcyBzcGVjJ2QgYnV0IG5vdCBpbXBsZW1lbnRlZCBpbiBhbnkgYnJvd3NlcnMsIGFuZFxuICogdGhlIGBpbnB1dGAgZXZlbnQgZG9lcyBub3QgcHJvdmlkZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaGFzXG4gKiBhY3R1YWxseSBiZWVuIGFkZGVkLCBjb250cmFyeSB0byB0aGUgc3BlYy4gVGh1cywgYHRleHRJbnB1dGAgaXMgdGhlIGJlc3RcbiAqIGF2YWlsYWJsZSBldmVudCB0byBpZGVudGlmeSB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBpbnNlcnRlZFxuICogaW50byB0aGUgdGFyZ2V0IG5vZGUuXG4gKlxuICogVGhpcyBwbHVnaW4gaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZW1pdHRpbmcgYGNvbXBvc2l0aW9uYCBldmVudHMsIHRodXNcbiAqIGFsbG93aW5nIHVzIHRvIHNoYXJlIGNvbXBvc2l0aW9uIGZhbGxiYWNrIGNvZGUgZm9yIGJvdGggYGJlZm9yZUlucHV0YCBhbmRcbiAqIGBjb21wb3NpdGlvbmAgZXZlbnQgdHlwZXMuXG4gKi9cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgcmV0dXJuIFtleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCksIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KV07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmVmb3JlSW5wdXRFdmVudFBsdWdpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgcHNldWRvLWV2ZW50IG1vZHVsZSB0byBoZWxwIGtlZXAgdHJhY2sgb2YgY29tcG9uZW50cyB3YWl0aW5nIHRvXG4gKiBiZSBub3RpZmllZCB3aGVuIHRoZWlyIERPTSByZXByZXNlbnRhdGlvbnMgYXJlIGF2YWlsYWJsZSBmb3IgdXNlLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50cyBgUG9vbGVkQ2xhc3NgLCBzbyB5b3Ugc2hvdWxkIG5ldmVyIG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcy5cbiAqIEluc3RlYWQsIHVzZSBgQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKWAuXG4gKlxuICogQGNsYXNzIFJlYWN0TW91bnRSZWFkeVxuICogQGltcGxlbWVudHMgUG9vbGVkQ2xhc3NcbiAqIEBpbnRlcm5hbFxuICovXG5cbnZhciBDYWxsYmFja1F1ZXVlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDYWxsYmFja1F1ZXVlKGFyZykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYWxsYmFja1F1ZXVlKTtcblxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICAgIHRoaXMuX2FyZyA9IGFyZztcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBJbnZva2VkIHdoZW4gYG5vdGlmeUFsbGAgaXMgaW52b2tlZC5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0IENvbnRleHQgdG8gY2FsbCBgY2FsbGJhY2tgIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIENhbGxiYWNrUXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiBlbnF1ZXVlKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IFtdO1xuICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB0aGlzLl9jb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzIHx8IFtdO1xuICAgIHRoaXMuX2NvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEludm9rZXMgYWxsIGVucXVldWVkIGNhbGxiYWNrcyBhbmQgY2xlYXJzIHRoZSBxdWV1ZS4gVGhpcyBpcyBpbnZva2VkIGFmdGVyXG4gICAqIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgYSBjb21wb25lbnQgaGFzIGJlZW4gY3JlYXRlZCBvciB1cGRhdGVkLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5ub3RpZnlBbGwgPSBmdW5jdGlvbiBub3RpZnlBbGwoKSB7XG4gICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgICB2YXIgY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cztcbiAgICB2YXIgYXJnID0gdGhpcy5fYXJnO1xuICAgIGlmIChjYWxsYmFja3MgJiYgY29udGV4dHMpIHtcbiAgICAgICEoY2FsbGJhY2tzLmxlbmd0aCA9PT0gY29udGV4dHMubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNtYXRjaGVkIGxpc3Qgb2YgY29udGV4dHMgaW4gY2FsbGJhY2sgcXVldWUnKSA6IF9wcm9kSW52YXJpYW50KCcyNCcpIDogdm9pZCAwO1xuICAgICAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKGNvbnRleHRzW2ldLCBhcmcpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICBjb250ZXh0cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfTtcblxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5jaGVja3BvaW50ID0gZnVuY3Rpb24gY2hlY2twb2ludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzID8gdGhpcy5fY2FsbGJhY2tzLmxlbmd0aCA6IDA7XG4gIH07XG5cbiAgQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUucm9sbGJhY2sgPSBmdW5jdGlvbiByb2xsYmFjayhsZW4pIHtcbiAgICBpZiAodGhpcy5fY2FsbGJhY2tzICYmIHRoaXMuX2NvbnRleHRzKSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3MubGVuZ3RoID0gbGVuO1xuICAgICAgdGhpcy5fY29udGV4dHMubGVuZ3RoID0gbGVuO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBpbnRlcm5hbCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcy5cbiAgICovXG5cblxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH07XG5cbiAgcmV0dXJuIENhbGxiYWNrUXVldWU7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKENhbGxiYWNrUXVldWUpOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RmVhdHVyZUZsYWdzID0ge1xuICAvLyBXaGVuIHRydWUsIGNhbGwgY29uc29sZS50aW1lKCkgYmVmb3JlIGFuZCAudGltZUVuZCgpIGFmdGVyIGVhY2ggdG9wLWxldmVsXG4gIC8vIHJlbmRlciAoYm90aCBpbml0aWFsIHJlbmRlcnMgYW5kIHVwZGF0ZXMpLiBVc2VmdWwgd2hlbiBsb29raW5nIGF0IHByb2QtbW9kZVxuICAvLyB0aW1lbGluZSBwcm9maWxlcyBpbiBDaHJvbWUsIGZvciBleGFtcGxlLlxuICBsb2dUb3BMZXZlbFJlbmRlcnM6IGZhbHNlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RmVhdHVyZUZsYWdzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgb3duZXIuXG4gKiBAZmluYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZE93bmVyKG9iamVjdCkge1xuICByZXR1cm4gISEob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QuYXR0YWNoUmVmID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmplY3QuZGV0YWNoUmVmID09PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBSZWFjdE93bmVycyBhcmUgY2FwYWJsZSBvZiBzdG9yaW5nIHJlZmVyZW5jZXMgdG8gb3duZWQgY29tcG9uZW50cy5cbiAqXG4gKiBBbGwgY29tcG9uZW50cyBhcmUgY2FwYWJsZSBvZiAvL2JlaW5nLy8gcmVmZXJlbmNlZCBieSBvd25lciBjb21wb25lbnRzLCBidXRcbiAqIG9ubHkgUmVhY3RPd25lciBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vcmVmZXJlbmNpbmcvLyBvd25lZCBjb21wb25lbnRzLlxuICogVGhlIG5hbWVkIHJlZmVyZW5jZSBpcyBrbm93biBhcyBhIFwicmVmXCIuXG4gKlxuICogUmVmcyBhcmUgYXZhaWxhYmxlIHdoZW4gbW91bnRlZCBhbmQgdXBkYXRlZCBkdXJpbmcgcmVjb25jaWxpYXRpb24uXG4gKlxuICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiAoXG4gKiAgICAgICAgIDxkaXYgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja30+XG4gKiAgICAgICAgICAgPEN1c3RvbUNvbXBvbmVudCByZWY9XCJjdXN0b21cIiAvPlxuICogICAgICAgICA8L2Rpdj5cbiAqICAgICAgICk7XG4gKiAgICAgfSxcbiAqICAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLnJlZnMuY3VzdG9tLmhhbmRsZUNsaWNrKCk7XG4gKiAgICAgfSxcbiAqICAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLnJlZnMuY3VzdG9tLmluaXRpYWxpemUoKTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFJlZnMgc2hvdWxkIHJhcmVseSBiZSB1c2VkLiBXaGVuIHJlZnMgYXJlIHVzZWQsIHRoZXkgc2hvdWxkIG9ubHkgYmUgZG9uZSB0b1xuICogY29udHJvbCBkYXRhIHRoYXQgaXMgbm90IGhhbmRsZWQgYnkgUmVhY3QncyBkYXRhIGZsb3cuXG4gKlxuICogQGNsYXNzIFJlYWN0T3duZXJcbiAqL1xudmFyIFJlYWN0T3duZXIgPSB7XG4gIC8qKlxuICAgKiBBZGRzIGEgY29tcG9uZW50IGJ5IHJlZiB0byBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgYnkgd2hpY2ggdG8gcmVmZXIgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdG8gcmVjb3JkIHRoZSByZWYuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFkZENvbXBvbmVudEFzUmVmVG86IGZ1bmN0aW9uIChjb21wb25lbnQsIHJlZiwgb3duZXIpIHtcbiAgICAhaXNWYWxpZE93bmVyKG93bmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdhZGRDb21wb25lbnRBc1JlZlRvKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFlvdSBtaWdodCBiZSBhZGRpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50XFwncyBgcmVuZGVyYCBtZXRob2QsIG9yIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQgKGRldGFpbHM6IGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIpLicpIDogX3Byb2RJbnZhcmlhbnQoJzExOScpIDogdm9pZCAwO1xuICAgIG93bmVyLmF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjb21wb25lbnQgYnkgcmVmIGZyb20gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgb2YgdGhlIHJlZiB0byByZW1vdmUuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRoZSByZWYgaXMgcmVjb3JkZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbTogZnVuY3Rpb24gKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xuICAgICFpc1ZhbGlkT3duZXIob3duZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3JlbW92ZUNvbXBvbmVudEFzUmVmRnJvbSguLi4pOiBPbmx5IGEgUmVhY3RPd25lciBjYW4gaGF2ZSByZWZzLiBZb3UgbWlnaHQgYmUgcmVtb3ZpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50XFwncyBgcmVuZGVyYCBtZXRob2QsIG9yIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQgKGRldGFpbHM6IGh0dHBzOi8vZmIubWUvcmVhY3QtcmVmcy1tdXN0LWhhdmUtb3duZXIpLicpIDogX3Byb2RJbnZhcmlhbnQoJzEyMCcpIDogdm9pZCAwO1xuICAgIHZhciBvd25lclB1YmxpY0luc3RhbmNlID0gb3duZXIuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAvLyBDaGVjayB0aGF0IGBjb21wb25lbnRgJ3Mgb3duZXIgaXMgc3RpbGwgYWxpdmUgYW5kIHRoYXQgYGNvbXBvbmVudGAgaXMgc3RpbGwgdGhlIGN1cnJlbnQgcmVmXG4gICAgLy8gYmVjYXVzZSB3ZSBkbyBub3Qgd2FudCB0byBkZXRhY2ggdGhlIHJlZiBpZiBhbm90aGVyIGNvbXBvbmVudCBzdG9sZSBpdC5cbiAgICBpZiAob3duZXJQdWJsaWNJbnN0YW5jZSAmJiBvd25lclB1YmxpY0luc3RhbmNlLnJlZnNbcmVmXSA9PT0gY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpIHtcbiAgICAgIG93bmVyLmRldGFjaFJlZihyZWYpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0T3duZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RPd25lcicpO1xuXG52YXIgUmVhY3RSZWYgPSB7fTtcblxuZnVuY3Rpb24gYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50LCBvd25lcikge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlZihjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIuYWRkQ29tcG9uZW50QXNSZWZUbyhjb21wb25lbnQsIHJlZiwgb3duZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaFJlZihyZWYsIGNvbXBvbmVudCwgb3duZXIpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYobnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIucmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKGNvbXBvbmVudCwgcmVmLCBvd25lcik7XG4gIH1cbn1cblxuUmVhY3RSZWYuYXR0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBhdHRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5SZWFjdFJlZi5zaG91bGRVcGRhdGVSZWZzID0gZnVuY3Rpb24gKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xuICAvLyBJZiBlaXRoZXIgdGhlIG93bmVyIG9yIGEgYHJlZmAgaGFzIGNoYW5nZWQsIG1ha2Ugc3VyZSB0aGUgbmV3ZXN0IG93bmVyXG4gIC8vIGhhcyBzdG9yZWQgYSByZWZlcmVuY2UgdG8gYHRoaXNgLCBhbmQgdGhlIHByZXZpb3VzIG93bmVyIChpZiBkaWZmZXJlbnQpXG4gIC8vIGhhcyBmb3Jnb3R0ZW4gdGhlIHJlZmVyZW5jZSB0byBgdGhpc2AuIFdlIHVzZSB0aGUgZWxlbWVudCBpbnN0ZWFkXG4gIC8vIG9mIHRoZSBwdWJsaWMgdGhpcy5wcm9wcyBiZWNhdXNlIHRoZSBwb3N0IHByb2Nlc3NpbmcgY2Fubm90IGRldGVybWluZVxuICAvLyBhIHJlZi4gVGhlIHJlZiBjb25jZXB0dWFsbHkgbGl2ZXMgb24gdGhlIGVsZW1lbnQuXG5cbiAgLy8gVE9ETzogU2hvdWxkIHRoaXMgZXZlbiBiZSBwb3NzaWJsZT8gVGhlIG93bmVyIGNhbm5vdCBjaGFuZ2UgYmVjYXVzZVxuICAvLyBpdCdzIGZvcmJpZGRlbiBieSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC4gVGhlIHJlZiBjYW4gY2hhbmdlXG4gIC8vIGlmIHlvdSBzd2FwIHRoZSBrZXlzIG9mIGJ1dCBub3QgdGhlIHJlZnMuIFJlY29uc2lkZXIgd2hlcmUgdGhpcyBjaGVja1xuICAvLyBpcyBtYWRlLiBJdCBwcm9iYWJseSBiZWxvbmdzIHdoZXJlIHRoZSBrZXkgY2hlY2tpbmcgYW5kXG4gIC8vIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgaXMgZG9uZS5cblxuICB2YXIgcHJldlJlZiA9IG51bGw7XG4gIHZhciBwcmV2T3duZXIgPSBudWxsO1xuICBpZiAocHJldkVsZW1lbnQgIT09IG51bGwgJiYgdHlwZW9mIHByZXZFbGVtZW50ID09PSAnb2JqZWN0Jykge1xuICAgIHByZXZSZWYgPSBwcmV2RWxlbWVudC5yZWY7XG4gICAgcHJldk93bmVyID0gcHJldkVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgdmFyIG5leHRSZWYgPSBudWxsO1xuICB2YXIgbmV4dE93bmVyID0gbnVsbDtcbiAgaWYgKG5leHRFbGVtZW50ICE9PSBudWxsICYmIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICBuZXh0UmVmID0gbmV4dEVsZW1lbnQucmVmO1xuICAgIG5leHRPd25lciA9IG5leHRFbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHJldHVybiBwcmV2UmVmICE9PSBuZXh0UmVmIHx8XG4gIC8vIElmIG93bmVyIGNoYW5nZXMgYnV0IHdlIGhhdmUgYW4gdW5jaGFuZ2VkIGZ1bmN0aW9uIHJlZiwgZG9uJ3QgdXBkYXRlIHJlZnNcbiAgdHlwZW9mIG5leHRSZWYgPT09ICdzdHJpbmcnICYmIG5leHRPd25lciAhPT0gcHJldk93bmVyO1xufTtcblxuUmVhY3RSZWYuZGV0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBkZXRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVmOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5JbnZhbGlkU2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIXByb2Nlc3NpbmdDaGlsZENvbnRleHQsICdzZXRTdGF0ZSguLi4pOiBDYW5ub3QgY2FsbCBzZXRTdGF0ZSgpIGluc2lkZSBnZXRDaGlsZENvbnRleHQoKScpIDogdm9pZCAwO1xuICB9O1xufVxuXG52YXIgUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vayA9IHtcbiAgb25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gdHJ1ZTtcbiAgfSxcbiAgb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCA9IGZhbHNlO1xuICB9LFxuICBvblNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgd2FybkludmFsaWRTZXRTdGF0ZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2s7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGlzdG9yeSA9IFtdO1xuXG52YXIgUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2sgPSB7XG4gIG9uSG9zdE9wZXJhdGlvbjogZnVuY3Rpb24gKG9wZXJhdGlvbikge1xuICAgIGhpc3RvcnkucHVzaChvcGVyYXRpb24pO1xuICB9LFxuICBjbGVhckhpc3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2suX3ByZXZlbnRDbGVhcmluZykge1xuICAgICAgLy8gU2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgdGVzdHMuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGlzdG9yeSA9IFtdO1xuICB9LFxuICBnZXRIaXN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGhpc3Rvcnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2s7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBwZXJmb3JtYW5jZTtcblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBwZXJmb3JtYW5jZSA9IHdpbmRvdy5wZXJmb3JtYW5jZSB8fCB3aW5kb3cubXNQZXJmb3JtYW5jZSB8fCB3aW5kb3cud2Via2l0UGVyZm9ybWFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2UgfHwge307IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgcGVyZm9ybWFuY2UgPSByZXF1aXJlKCcuL3BlcmZvcm1hbmNlJyk7XG5cbnZhciBwZXJmb3JtYW5jZU5vdztcblxuLyoqXG4gKiBEZXRlY3QgaWYgd2UgY2FuIHVzZSBgd2luZG93LnBlcmZvcm1hbmNlLm5vdygpYCBhbmQgZ3JhY2VmdWxseSBmYWxsYmFjayB0b1xuICogYERhdGUubm93KClgIGlmIGl0IGRvZXNuJ3QgZXhpc3QuIFdlIG5lZWQgdG8gc3VwcG9ydCBGaXJlZm94IDwgMTUgZm9yIG5vd1xuICogYmVjYXVzZSBvZiBGYWNlYm9vaydzIHRlc3RpbmcgaW5mcmFzdHJ1Y3R1cmUuXG4gKi9cbmlmIChwZXJmb3JtYW5jZS5ub3cpIHtcbiAgcGVyZm9ybWFuY2VOb3cgPSBmdW5jdGlvbiBwZXJmb3JtYW5jZU5vdygpIHtcbiAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gIH07XG59IGVsc2Uge1xuICBwZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uIHBlcmZvcm1hbmNlTm93KCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcmZvcm1hbmNlTm93OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2sgPSByZXF1aXJlKCcuL1JlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2snKTtcbnZhciBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayA9IHJlcXVpcmUoJy4vUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2snKTtcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBwZXJmb3JtYW5jZU5vdyA9IHJlcXVpcmUoJ2ZianMvbGliL3BlcmZvcm1hbmNlTm93Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGhvb2tzID0gW107XG52YXIgZGlkSG9va1Rocm93Rm9yRXZlbnQgPSB7fTtcblxuZnVuY3Rpb24gY2FsbEhvb2soZXZlbnQsIGZuLCBjb250ZXh0LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gIHRyeSB7XG4gICAgZm4uY2FsbChjb250ZXh0LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZEhvb2tUaHJvd0ZvckV2ZW50W2V2ZW50XSwgJ0V4Y2VwdGlvbiB0aHJvd24gYnkgaG9vayB3aGlsZSBoYW5kbGluZyAlczogJXMnLCBldmVudCwgZSArICdcXG4nICsgZS5zdGFjaykgOiB2b2lkIDA7XG4gICAgZGlkSG9va1Rocm93Rm9yRXZlbnRbZXZlbnRdID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXZlbnQoZXZlbnQsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBob29rID0gaG9va3NbaV07XG4gICAgdmFyIGZuID0gaG9va1tldmVudF07XG4gICAgaWYgKGZuKSB7XG4gICAgICBjYWxsSG9vayhldmVudCwgZm4sIGhvb2ssIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgaXNQcm9maWxpbmcgPSBmYWxzZTtcbnZhciBmbHVzaEhpc3RvcnkgPSBbXTtcbnZhciBsaWZlQ3ljbGVUaW1lclN0YWNrID0gW107XG52YXIgY3VycmVudEZsdXNoTmVzdGluZyA9IDA7XG52YXIgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzID0gW107XG52YXIgY3VycmVudEZsdXNoU3RhcnRUaW1lID0gMDtcbnZhciBjdXJyZW50VGltZXJEZWJ1Z0lEID0gbnVsbDtcbnZhciBjdXJyZW50VGltZXJTdGFydFRpbWUgPSAwO1xudmFyIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gPSAwO1xudmFyIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xuXG52YXIgbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2xlYXJIaXN0b3J5KCkge1xuICBSZWFjdENvbXBvbmVudFRyZWVIb29rLnB1cmdlVW5tb3VudGVkQ29tcG9uZW50cygpO1xuICBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5jbGVhckhpc3RvcnkoKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJlZVNuYXBzaG90KHJlZ2lzdGVyZWRJRHMpIHtcbiAgcmV0dXJuIHJlZ2lzdGVyZWRJRHMucmVkdWNlKGZ1bmN0aW9uICh0cmVlLCBpZCkge1xuICAgIHZhciBvd25lcklEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKGlkKTtcbiAgICB2YXIgcGFyZW50SUQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFBhcmVudElEKGlkKTtcbiAgICB0cmVlW2lkXSA9IHtcbiAgICAgIGRpc3BsYXlOYW1lOiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKGlkKSxcbiAgICAgIHRleHQ6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0VGV4dChpZCksXG4gICAgICB1cGRhdGVDb3VudDogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRVcGRhdGVDb3VudChpZCksXG4gICAgICBjaGlsZElEczogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDaGlsZElEcyhpZCksXG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUgb3duZXJzIGJ1dCB0aGlzIGlzIGNsb3NlIGVub3VnaC5cbiAgICAgIG93bmVySUQ6IG93bmVySUQgfHwgcGFyZW50SUQgJiYgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKHBhcmVudElEKSB8fCAwLFxuICAgICAgcGFyZW50SUQ6IHBhcmVudElEXG4gICAgfTtcbiAgICByZXR1cm4gdHJlZTtcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiByZXNldE1lYXN1cmVtZW50cygpIHtcbiAgdmFyIHByZXZpb3VzU3RhcnRUaW1lID0gY3VycmVudEZsdXNoU3RhcnRUaW1lO1xuICB2YXIgcHJldmlvdXNNZWFzdXJlbWVudHMgPSBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHM7XG4gIHZhciBwcmV2aW91c09wZXJhdGlvbnMgPSBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5nZXRIaXN0b3J5KCk7XG5cbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcbiAgICBjdXJyZW50Rmx1c2hTdGFydFRpbWUgPSAwO1xuICAgIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyA9IFtdO1xuICAgIGNsZWFySGlzdG9yeSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChwcmV2aW91c01lYXN1cmVtZW50cy5sZW5ndGggfHwgcHJldmlvdXNPcGVyYXRpb25zLmxlbmd0aCkge1xuICAgIHZhciByZWdpc3RlcmVkSURzID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRSZWdpc3RlcmVkSURzKCk7XG4gICAgZmx1c2hIaXN0b3J5LnB1c2goe1xuICAgICAgZHVyYXRpb246IHBlcmZvcm1hbmNlTm93KCkgLSBwcmV2aW91c1N0YXJ0VGltZSxcbiAgICAgIG1lYXN1cmVtZW50czogcHJldmlvdXNNZWFzdXJlbWVudHMgfHwgW10sXG4gICAgICBvcGVyYXRpb25zOiBwcmV2aW91c09wZXJhdGlvbnMgfHwgW10sXG4gICAgICB0cmVlU25hcHNob3Q6IGdldFRyZWVTbmFwc2hvdChyZWdpc3RlcmVkSURzKVxuICAgIH0pO1xuICB9XG5cbiAgY2xlYXJIaXN0b3J5KCk7XG4gIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyA9IFtdO1xufVxuXG5mdW5jdGlvbiBjaGVja0RlYnVnSUQoZGVidWdJRCkge1xuICB2YXIgYWxsb3dSb290ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICBpZiAoYWxsb3dSb290ICYmIGRlYnVnSUQgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFkZWJ1Z0lEKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERlYnVnVG9vbDogZGVidWdJRCBtYXkgbm90IGJlIGVtcHR5LicpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJlZ2luTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gIGlmIChjdXJyZW50Rmx1c2hOZXN0aW5nID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChjdXJyZW50VGltZXJUeXBlICYmICFsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlcmUgaXMgYW4gaW50ZXJuYWwgZXJyb3IgaW4gdGhlIFJlYWN0IHBlcmZvcm1hbmNlIG1lYXN1cmVtZW50IGNvZGUuICcgKyAnRGlkIG5vdCBleHBlY3QgJXMgdGltZXIgdG8gc3RhcnQgd2hpbGUgJXMgdGltZXIgaXMgc3RpbGwgaW4gJyArICdwcm9ncmVzcyBmb3IgJXMgaW5zdGFuY2UuJywgdGltZXJUeXBlLCBjdXJyZW50VGltZXJUeXBlIHx8ICdubycsIGRlYnVnSUQgPT09IGN1cnJlbnRUaW1lckRlYnVnSUQgPyAndGhlIHNhbWUnIDogJ2Fub3RoZXInKSA6IHZvaWQgMDtcbiAgICBsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCA9IHRydWU7XG4gIH1cbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IDA7XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBkZWJ1Z0lEO1xuICBjdXJyZW50VGltZXJUeXBlID0gdGltZXJUeXBlO1xufVxuXG5mdW5jdGlvbiBlbmRMaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGN1cnJlbnRUaW1lclR5cGUgIT09IHRpbWVyVHlwZSAmJiAhbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZXJlIGlzIGFuIGludGVybmFsIGVycm9yIGluIHRoZSBSZWFjdCBwZXJmb3JtYW5jZSBtZWFzdXJlbWVudCBjb2RlLiAnICsgJ1dlIGRpZCBub3QgZXhwZWN0ICVzIHRpbWVyIHRvIHN0b3Agd2hpbGUgJXMgdGltZXIgaXMgc3RpbGwgaW4gJyArICdwcm9ncmVzcyBmb3IgJXMgaW5zdGFuY2UuIFBsZWFzZSByZXBvcnQgdGhpcyBhcyBhIGJ1ZyBpbiBSZWFjdC4nLCB0aW1lclR5cGUsIGN1cnJlbnRUaW1lclR5cGUgfHwgJ25vJywgZGVidWdJRCA9PT0gY3VycmVudFRpbWVyRGVidWdJRCA/ICd0aGUgc2FtZScgOiAnYW5vdGhlcicpIDogdm9pZCAwO1xuICAgIGxpZmVDeWNsZVRpbWVySGFzV2FybmVkID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMucHVzaCh7XG4gICAgICB0aW1lclR5cGU6IHRpbWVyVHlwZSxcbiAgICAgIGluc3RhbmNlSUQ6IGRlYnVnSUQsXG4gICAgICBkdXJhdGlvbjogcGVyZm9ybWFuY2VOb3coKSAtIGN1cnJlbnRUaW1lclN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb25cbiAgICB9KTtcbiAgfVxuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSAwO1xuICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gMDtcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IG51bGw7XG4gIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXVzZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpIHtcbiAgdmFyIGN1cnJlbnRUaW1lciA9IHtcbiAgICBzdGFydFRpbWU6IGN1cnJlbnRUaW1lclN0YXJ0VGltZSxcbiAgICBuZXN0ZWRGbHVzaFN0YXJ0VGltZTogcGVyZm9ybWFuY2VOb3coKSxcbiAgICBkZWJ1Z0lEOiBjdXJyZW50VGltZXJEZWJ1Z0lELFxuICAgIHRpbWVyVHlwZTogY3VycmVudFRpbWVyVHlwZVxuICB9O1xuICBsaWZlQ3ljbGVUaW1lclN0YWNrLnB1c2goY3VycmVudFRpbWVyKTtcbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gMDtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IDA7XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBudWxsO1xuICBjdXJyZW50VGltZXJUeXBlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVzdW1lQ3VycmVudExpZmVDeWNsZVRpbWVyKCkge1xuICB2YXIgX2xpZmVDeWNsZVRpbWVyU3RhY2skID0gbGlmZUN5Y2xlVGltZXJTdGFjay5wb3AoKSxcbiAgICAgIHN0YXJ0VGltZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC5zdGFydFRpbWUsXG4gICAgICBuZXN0ZWRGbHVzaFN0YXJ0VGltZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC5uZXN0ZWRGbHVzaFN0YXJ0VGltZSxcbiAgICAgIGRlYnVnSUQgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQuZGVidWdJRCxcbiAgICAgIHRpbWVyVHlwZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC50aW1lclR5cGU7XG5cbiAgdmFyIG5lc3RlZEZsdXNoRHVyYXRpb24gPSBwZXJmb3JtYW5jZU5vdygpIC0gbmVzdGVkRmx1c2hTdGFydFRpbWU7XG4gIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiArPSBuZXN0ZWRGbHVzaER1cmF0aW9uO1xuICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gZGVidWdJRDtcbiAgY3VycmVudFRpbWVyVHlwZSA9IHRpbWVyVHlwZTtcbn1cblxudmFyIGxhc3RNYXJrVGltZVN0YW1wID0gMDtcbnZhciBjYW5Vc2VQZXJmb3JtYW5jZU1lYXN1cmUgPVxuLy8gJEZsb3dGaXhNZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjM0NVxudHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UubWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UubWVhc3VyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyA9PT0gJ2Z1bmN0aW9uJztcblxuZnVuY3Rpb24gc2hvdWxkTWFyayhkZWJ1Z0lEKSB7XG4gIGlmICghaXNQcm9maWxpbmcgfHwgIWNhblVzZVBlcmZvcm1hbmNlTWVhc3VyZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChkZWJ1Z0lEKTtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGlzSG9zdEVsZW1lbnQgPSB0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJztcbiAgaWYgKGlzSG9zdEVsZW1lbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG1hcmtCZWdpbihkZWJ1Z0lELCBtYXJrVHlwZSkge1xuICBpZiAoIXNob3VsZE1hcmsoZGVidWdJRCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbWFya05hbWUgPSBkZWJ1Z0lEICsgJzo6JyArIG1hcmtUeXBlO1xuICBsYXN0TWFya1RpbWVTdGFtcCA9IHBlcmZvcm1hbmNlTm93KCk7XG4gIHBlcmZvcm1hbmNlLm1hcmsobWFya05hbWUpO1xufVxuXG5mdW5jdGlvbiBtYXJrRW5kKGRlYnVnSUQsIG1hcmtUeXBlKSB7XG4gIGlmICghc2hvdWxkTWFyayhkZWJ1Z0lEKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBtYXJrTmFtZSA9IGRlYnVnSUQgKyAnOjonICsgbWFya1R5cGU7XG4gIHZhciBkaXNwbGF5TmFtZSA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUoZGVidWdJRCkgfHwgJ1Vua25vd24nO1xuXG4gIC8vIENocm9tZSBoYXMgYW4gaXNzdWUgb2YgZHJvcHBpbmcgbWFya2VycyByZWNvcmRlZCB0b28gZmFzdDpcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjQwNjUyXG4gIC8vIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHdlIHdpbGwgbm90IHJlcG9ydCB2ZXJ5IHNtYWxsIG1lYXN1cmVtZW50cy5cbiAgLy8gSSBkZXRlcm1pbmVkIHRoZSBtYWdpYyBudW1iZXIgYnkgdHdlYWtpbmcgaXQgYmFjayBhbmQgZm9ydGguXG4gIC8vIDAuMDVtcyB3YXMgZW5vdWdoIHRvIHByZXZlbnQgdGhlIGlzc3VlLCBidXQgSSBzZXQgaXQgdG8gMC4xbXMgdG8gYmUgc2FmZS5cbiAgLy8gV2hlbiB0aGUgYnVnIGlzIGZpeGVkLCB3ZSBjYW4gYG1lYXN1cmUoKWAgdW5jb25kaXRpb25hbGx5IGlmIHdlIHdhbnQgdG8uXG4gIHZhciB0aW1lU3RhbXAgPSBwZXJmb3JtYW5jZU5vdygpO1xuICBpZiAodGltZVN0YW1wIC0gbGFzdE1hcmtUaW1lU3RhbXAgPiAwLjEpIHtcbiAgICB2YXIgbWVhc3VyZW1lbnROYW1lID0gZGlzcGxheU5hbWUgKyAnIFsnICsgbWFya1R5cGUgKyAnXSc7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZShtZWFzdXJlbWVudE5hbWUsIG1hcmtOYW1lKTtcbiAgfVxuXG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MobWFya05hbWUpO1xuICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKG1lYXN1cmVtZW50TmFtZSk7XG59XG5cbnZhciBSZWFjdERlYnVnVG9vbCA9IHtcbiAgYWRkSG9vazogZnVuY3Rpb24gKGhvb2spIHtcbiAgICBob29rcy5wdXNoKGhvb2spO1xuICB9LFxuICByZW1vdmVIb29rOiBmdW5jdGlvbiAoaG9vaykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChob29rc1tpXSA9PT0gaG9vaykge1xuICAgICAgICBob29rcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGlzUHJvZmlsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzUHJvZmlsaW5nO1xuICB9LFxuICBiZWdpblByb2ZpbGluZzogZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc1Byb2ZpbGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlzUHJvZmlsaW5nID0gdHJ1ZTtcbiAgICBmbHVzaEhpc3RvcnkubGVuZ3RoID0gMDtcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIFJlYWN0RGVidWdUb29sLmFkZEhvb2soUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2spO1xuICB9LFxuICBlbmRQcm9maWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWlzUHJvZmlsaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNQcm9maWxpbmcgPSBmYWxzZTtcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIFJlYWN0RGVidWdUb29sLnJlbW92ZUhvb2soUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2spO1xuICB9LFxuICBnZXRGbHVzaEhpc3Rvcnk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmx1c2hIaXN0b3J5O1xuICB9LFxuICBvbkJlZ2luRmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICBjdXJyZW50Rmx1c2hOZXN0aW5nKys7XG4gICAgcmVzZXRNZWFzdXJlbWVudHMoKTtcbiAgICBwYXVzZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpO1xuICAgIGVtaXRFdmVudCgnb25CZWdpbkZsdXNoJyk7XG4gIH0sXG4gIG9uRW5kRmx1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIGN1cnJlbnRGbHVzaE5lc3RpbmctLTtcbiAgICByZXN1bWVDdXJyZW50TGlmZUN5Y2xlVGltZXIoKTtcbiAgICBlbWl0RXZlbnQoJ29uRW5kRmx1c2gnKTtcbiAgfSxcbiAgb25CZWdpbkxpZmVDeWNsZVRpbWVyOiBmdW5jdGlvbiAoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25CZWdpbkxpZmVDeWNsZVRpbWVyJywgZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICBtYXJrQmVnaW4oZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICBiZWdpbkxpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gIH0sXG4gIG9uRW5kTGlmZUN5Y2xlVGltZXI6IGZ1bmN0aW9uIChkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW5kTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICBtYXJrRW5kKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gICAgZW1pdEV2ZW50KCdvbkVuZExpZmVDeWNsZVRpbWVyJywgZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgfSxcbiAgb25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0Jyk7XG4gIH0sXG4gIG9uRW5kUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0Jyk7XG4gIH0sXG4gIG9uSG9zdE9wZXJhdGlvbjogZnVuY3Rpb24gKG9wZXJhdGlvbikge1xuICAgIGNoZWNrRGVidWdJRChvcGVyYXRpb24uaW5zdGFuY2VJRCk7XG4gICAgZW1pdEV2ZW50KCdvbkhvc3RPcGVyYXRpb24nLCBvcGVyYXRpb24pO1xuICB9LFxuICBvblNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgZW1pdEV2ZW50KCdvblNldFN0YXRlJyk7XG4gIH0sXG4gIG9uU2V0Q2hpbGRyZW46IGZ1bmN0aW9uIChkZWJ1Z0lELCBjaGlsZERlYnVnSURzKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGNoaWxkRGVidWdJRHMuZm9yRWFjaChjaGVja0RlYnVnSUQpO1xuICAgIGVtaXRFdmVudCgnb25TZXRDaGlsZHJlbicsIGRlYnVnSUQsIGNoaWxkRGVidWdJRHMpO1xuICB9LFxuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCwgcGFyZW50RGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBjaGVja0RlYnVnSUQocGFyZW50RGVidWdJRCwgdHJ1ZSk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZm9yZU1vdW50Q29tcG9uZW50JywgZGVidWdJRCwgZWxlbWVudCwgcGFyZW50RGVidWdJRCk7XG4gICAgbWFya0JlZ2luKGRlYnVnSUQsICdtb3VudCcpO1xuICB9LFxuICBvbk1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBtYXJrRW5kKGRlYnVnSUQsICdtb3VudCcpO1xuICAgIGVtaXRFdmVudCgnb25Nb3VudENvbXBvbmVudCcsIGRlYnVnSUQpO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudCcsIGRlYnVnSUQsIGVsZW1lbnQpO1xuICAgIG1hcmtCZWdpbihkZWJ1Z0lELCAndXBkYXRlJyk7XG4gIH0sXG4gIG9uVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBtYXJrRW5kKGRlYnVnSUQsICd1cGRhdGUnKTtcbiAgICBlbWl0RXZlbnQoJ29uVXBkYXRlQ29tcG9uZW50JywgZGVidWdJRCk7XG4gIH0sXG4gIG9uQmVmb3JlVW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZm9yZVVubW91bnRDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgICBtYXJrQmVnaW4oZGVidWdJRCwgJ3VubW91bnQnKTtcbiAgfSxcbiAgb25Vbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBtYXJrRW5kKGRlYnVnSUQsICd1bm1vdW50Jyk7XG4gICAgZW1pdEV2ZW50KCdvblVubW91bnRDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25UZXN0RXZlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uVGVzdEV2ZW50Jyk7XG4gIH1cbn07XG5cbi8vIFRPRE8gcmVtb3ZlIHRoZXNlIHdoZW4gUk4vd3d3IGdldHMgdXBkYXRlZFxuUmVhY3REZWJ1Z1Rvb2wuYWRkRGV2dG9vbCA9IFJlYWN0RGVidWdUb29sLmFkZEhvb2s7XG5SZWFjdERlYnVnVG9vbC5yZW1vdmVEZXZ0b29sID0gUmVhY3REZWJ1Z1Rvb2wucmVtb3ZlSG9vaztcblxuUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rKTtcblJlYWN0RGVidWdUb29sLmFkZEhvb2soUmVhY3RDb21wb25lbnRUcmVlSG9vayk7XG52YXIgdXJsID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmIHx8ICcnO1xuaWYgKC9bPyZdcmVhY3RfcGVyZlxcYi8udGVzdCh1cmwpKSB7XG4gIFJlYWN0RGVidWdUb29sLmJlZ2luUHJvZmlsaW5nKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWJ1Z1Rvb2w7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUcnVzdCB0aGUgZGV2ZWxvcGVyIHRvIG9ubHkgdXNlIFJlYWN0SW5zdHJ1bWVudGF0aW9uIHdpdGggYSBfX0RFVl9fIGNoZWNrXG5cbnZhciBkZWJ1Z1Rvb2wgPSBudWxsO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3REZWJ1Z1Rvb2wgPSByZXF1aXJlKCcuL1JlYWN0RGVidWdUb29sJyk7XG4gIGRlYnVnVG9vbCA9IFJlYWN0RGVidWdUb29sO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZGVidWdUb29sOiBkZWJ1Z1Rvb2wgfTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSZWYgPSByZXF1aXJlKCcuL1JlYWN0UmVmJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEhlbHBlciB0byBjYWxsIFJlYWN0UmVmLmF0dGFjaFJlZnMgd2l0aCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQsIHNwbGl0IG91dFxuICogdG8gYXZvaWQgYWxsb2NhdGlvbnMgaW4gdGhlIHRyYW5zYWN0aW9uIG1vdW50LXJlYWR5IHF1ZXVlLlxuICovXG5mdW5jdGlvbiBhdHRhY2hSZWZzKCkge1xuICBSZWFjdFJlZi5hdHRhY2hSZWZzKHRoaXMsIHRoaXMuX2N1cnJlbnRFbGVtZW50KTtcbn1cblxudmFyIFJlYWN0UmVjb25jaWxlciA9IHtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IHRoZSBjb250YWluaW5nIGhvc3QgY29tcG9uZW50IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gaW5mbyBhYm91dCB0aGUgaG9zdCBjb250YWluZXJcbiAgICogQHJldHVybiB7P3N0cmluZ30gUmVuZGVyZWQgbWFya3VwIHRvIGJlIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHBhcmVudERlYnVnSUQgLy8gMCBpbiBwcm9kdWN0aW9uIGFuZCBmb3Igcm9vdHNcbiAgKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZU1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LCBwYXJlbnREZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1hcmt1cCA9IGludGVybmFsSW5zdGFuY2UubW91bnRDb21wb25lbnQodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBwYXJlbnREZWJ1Z0lEKTtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucmVmICE9IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoYXR0YWNoUmVmcywgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Nb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHZhbHVlIHRoYXQgY2FuIGJlIHBhc3NlZCB0b1xuICAgKiBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cC5cbiAgICovXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnRlcm5hbEluc3RhbmNlLmdldEhvc3ROb2RlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBzYWZlbHkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlVW5tb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgUmVhY3RSZWYuZGV0YWNoUmVmcyhpbnRlcm5hbEluc3RhbmNlLCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCk7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS51bm1vdW50Q29tcG9uZW50KHNhZmVseSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVubW91bnRDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYSBjb21wb25lbnQgdXNpbmcgYSBuZXcgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW50ZXJuYWxJbnN0YW5jZVxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcblxuICAgIGlmIChuZXh0RWxlbWVudCA9PT0gcHJldkVsZW1lbnQgJiYgY29udGV4dCA9PT0gaW50ZXJuYWxJbnN0YW5jZS5fY29udGV4dCkge1xuICAgICAgLy8gU2luY2UgZWxlbWVudHMgYXJlIGltbXV0YWJsZSBhZnRlciB0aGUgb3duZXIgaXMgcmVuZGVyZWQsXG4gICAgICAvLyB3ZSBjYW4gZG8gYSBjaGVhcCBpZGVudGl0eSBjb21wYXJlIGhlcmUgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYVxuICAgICAgLy8gc3VwZXJmbHVvdXMgcmVjb25jaWxlLiBJdCdzIHBvc3NpYmxlIGZvciBzdGF0ZSB0byBiZSBtdXRhYmxlIGJ1dCBzdWNoXG4gICAgICAvLyBjaGFuZ2Ugc2hvdWxkIHRyaWdnZXIgYW4gdXBkYXRlIG9mIHRoZSBvd25lciB3aGljaCB3b3VsZCByZWNyZWF0ZVxuICAgICAgLy8gdGhlIGVsZW1lbnQuIFdlIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gb3duZXIgc2luY2VcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIGFuIGVsZW1lbnQgY3JlYXRlZCBvdXRzaWRlIGEgY29tcG9zaXRlIHRvIGJlXG4gICAgICAvLyBkZWVwbHkgbXV0YXRlZCBhbmQgcmV1c2VkLlxuXG4gICAgICAvLyBUT0RPOiBCYWlsaW5nIG91dCBlYXJseSBpcyBqdXN0IGEgcGVyZiBvcHRpbWl6YXRpb24gcmlnaHQ/XG4gICAgICAvLyBUT0RPOiBSZW1vdmluZyB0aGUgcmV0dXJuIHN0YXRlbWVudCBzaG91bGQgYWZmZWN0IGNvcnJlY3RuZXNzP1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgbmV4dEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWZzQ2hhbmdlZCA9IFJlYWN0UmVmLnNob3VsZFVwZGF0ZVJlZnMocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KTtcblxuICAgIGlmIChyZWZzQ2hhbmdlZCkge1xuICAgICAgUmVhY3RSZWYuZGV0YWNoUmVmcyhpbnRlcm5hbEluc3RhbmNlLCBwcmV2RWxlbWVudCk7XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50KG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG5cbiAgICBpZiAocmVmc0NoYW5nZWQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucmVmICE9IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoYXR0YWNoUmVmcywgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZsdXNoIGFueSBkaXJ0eSBjaGFuZ2VzIGluIGEgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCB0cmFuc2FjdGlvbiwgdXBkYXRlQmF0Y2hOdW1iZXIpIHtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fdXBkYXRlQmF0Y2hOdW1iZXIgIT09IHVwZGF0ZUJhdGNoTnVtYmVyKSB7XG4gICAgICAvLyBUaGUgY29tcG9uZW50J3MgZW5xdWV1ZWQgYmF0Y2ggbnVtYmVyIHNob3VsZCBhbHdheXMgYmUgdGhlIGN1cnJlbnRcbiAgICAgIC8vIGJhdGNoIG9yIHRoZSBmb2xsb3dpbmcgb25lLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaW50ZXJuYWxJbnN0YW5jZS5fdXBkYXRlQmF0Y2hOdW1iZXIgPT0gbnVsbCB8fCBpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciA9PT0gdXBkYXRlQmF0Y2hOdW1iZXIgKyAxLCAncGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBVbmV4cGVjdGVkIGJhdGNoIG51bWJlciAoY3VycmVudCAlcywgJyArICdwZW5kaW5nICVzKScsIHVwZGF0ZUJhdGNoTnVtYmVyLCBpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlcikgOiB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnRlcm5hbEluc3RhbmNlLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSh0cmFuc2FjdGlvbik7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlY29uY2lsZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBPQlNFUlZFRF9FUlJPUiA9IHt9O1xuXG4vKipcbiAqIGBUcmFuc2FjdGlvbmAgY3JlYXRlcyBhIGJsYWNrIGJveCB0aGF0IGlzIGFibGUgdG8gd3JhcCBhbnkgbWV0aG9kIHN1Y2ggdGhhdFxuICogY2VydGFpbiBpbnZhcmlhbnRzIGFyZSBtYWludGFpbmVkIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIG1ldGhvZCBpcyBpbnZva2VkXG4gKiAoRXZlbiBpZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIHdoaWxlIGludm9raW5nIHRoZSB3cmFwcGVkIG1ldGhvZCkuIFdob2V2ZXJcbiAqIGluc3RhbnRpYXRlcyBhIHRyYW5zYWN0aW9uIGNhbiBwcm92aWRlIGVuZm9yY2VycyBvZiB0aGUgaW52YXJpYW50cyBhdFxuICogY3JlYXRpb24gdGltZS4gVGhlIGBUcmFuc2FjdGlvbmAgY2xhc3MgaXRzZWxmIHdpbGwgc3VwcGx5IG9uZSBhZGRpdGlvbmFsXG4gKiBhdXRvbWF0aWMgaW52YXJpYW50IGZvciB5b3UgLSB0aGUgaW52YXJpYW50IHRoYXQgYW55IHRyYW5zYWN0aW9uIGluc3RhbmNlXG4gKiBzaG91bGQgbm90IGJlIHJ1biB3aGlsZSBpdCBpcyBhbHJlYWR5IGJlaW5nIHJ1bi4gWW91IHdvdWxkIHR5cGljYWxseSBjcmVhdGUgYVxuICogc2luZ2xlIGluc3RhbmNlIG9mIGEgYFRyYW5zYWN0aW9uYCBmb3IgcmV1c2UgbXVsdGlwbGUgdGltZXMsIHRoYXQgcG90ZW50aWFsbHlcbiAqIGlzIHVzZWQgdG8gd3JhcCBzZXZlcmFsIGRpZmZlcmVudCBtZXRob2RzLiBXcmFwcGVycyBhcmUgZXh0cmVtZWx5IHNpbXBsZSAtXG4gKiB0aGV5IG9ubHkgcmVxdWlyZSBpbXBsZW1lbnRpbmcgdHdvIG1ldGhvZHMuXG4gKlxuICogPHByZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVycyAoaW5qZWN0ZWQgYXQgY3JlYXRpb24gdGltZSlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICAgICAgICArXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB2ICAgICAgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICAgICstLS0tLS0tLS0tLS0tLS0rICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICArLS18ICAgIHdyYXBwZXIxICAgfC0tLXwtLS0tKyAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgKy0tLS0tLS0tLS0tLS0tLSsgICB2ICAgIHwgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgICAgICAgKy0tLS0tLS0tLS0tLS0rICB8ICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICArLS0tLXwgICB3cmFwcGVyMiAgfC0tLS0tLS0tKyAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgIHwgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgIHwgICAgICAgICAgICAgICAgICAgICB8ICAgICB8ICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB2ICAgICB2ICAgICAgICAgICAgICAgICAgICAgdiAgICAgdiAgIHwgd3JhcHBlclxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHwgaW52YXJpYW50c1xuICogcGVyZm9ybShhbnlNZXRob2QpIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHwgbWFpbnRhaW5lZFxuICogKy0tLS0tLS0tLS0tLS0tLS0tPnwtfC0tLXwtfC0tLXwtLT58YW55TWV0aG9kfC0tLXwtLS18LXwtLS18LXwtLS0tLS0tLT5cbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICstLS0rICstLS0rICAgKy0tLS0tLS0tLSsgICArLS0tKyArLS0tKyB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgaW5pdGlhbGl6ZSAgICAgICAgICAgICAgICAgICAgY2xvc2UgICAgfFxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqIDwvcHJlPlxuICpcbiAqIFVzZSBjYXNlczpcbiAqIC0gUHJlc2VydmluZyB0aGUgaW5wdXQgc2VsZWN0aW9uIHJhbmdlcyBiZWZvcmUvYWZ0ZXIgcmVjb25jaWxpYXRpb24uXG4gKiAgIFJlc3RvcmluZyBzZWxlY3Rpb24gZXZlbiBpbiB0aGUgZXZlbnQgb2YgYW4gdW5leHBlY3RlZCBlcnJvci5cbiAqIC0gRGVhY3RpdmF0aW5nIGV2ZW50cyB3aGlsZSByZWFycmFuZ2luZyB0aGUgRE9NLCBwcmV2ZW50aW5nIGJsdXJzL2ZvY3VzZXMsXG4gKiAgIHdoaWxlIGd1YXJhbnRlZWluZyB0aGF0IGFmdGVyd2FyZHMsIHRoZSBldmVudCBzeXN0ZW0gaXMgcmVhY3RpdmF0ZWQuXG4gKiAtIEZsdXNoaW5nIGEgcXVldWUgb2YgY29sbGVjdGVkIERPTSBtdXRhdGlvbnMgdG8gdGhlIG1haW4gVUkgdGhyZWFkIGFmdGVyIGFcbiAqICAgcmVjb25jaWxpYXRpb24gdGFrZXMgcGxhY2UgaW4gYSB3b3JrZXIgdGhyZWFkLlxuICogLSBJbnZva2luZyBhbnkgY29sbGVjdGVkIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBhZnRlciByZW5kZXJpbmcgbmV3XG4gKiAgIGNvbnRlbnQuXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBXcmFwcGluZyBwYXJ0aWN1bGFyIGZsdXNoZXMgb2YgdGhlIGBSZWFjdFdvcmtlcmAgcXVldWVcbiAqICAgdG8gcHJlc2VydmUgdGhlIGBzY3JvbGxUb3BgIChhbiBhdXRvbWF0aWMgc2Nyb2xsIGF3YXJlIERPTSkuXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBMYXlvdXQgY2FsY3VsYXRpb25zIGJlZm9yZSBhbmQgYWZ0ZXIgRE9NIHVwZGF0ZXMuXG4gKlxuICogVHJhbnNhY3Rpb25hbCBwbHVnaW4gQVBJOlxuICogLSBBIG1vZHVsZSB0aGF0IGhhcyBhbiBgaW5pdGlhbGl6ZWAgbWV0aG9kIHRoYXQgcmV0dXJucyBhbnkgcHJlY29tcHV0YXRpb24uXG4gKiAtIGFuZCBhIGBjbG9zZWAgbWV0aG9kIHRoYXQgYWNjZXB0cyB0aGUgcHJlY29tcHV0YXRpb24uIGBjbG9zZWAgaXMgaW52b2tlZFxuICogICB3aGVuIHRoZSB3cmFwcGVkIHByb2Nlc3MgaXMgY29tcGxldGVkLCBvciBoYXMgZmFpbGVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VHJhbnNhY3Rpb25hbFdyYXBwZXI+fSB0cmFuc2FjdGlvbldyYXBwZXIgV3JhcHBlciBtb2R1bGVzXG4gKiB0aGF0IGltcGxlbWVudCBgaW5pdGlhbGl6ZWAgYW5kIGBjbG9zZWAuXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gU2luZ2xlIHRyYW5zYWN0aW9uIGZvciByZXVzZSBpbiB0aHJlYWQuXG4gKlxuICogQGNsYXNzIFRyYW5zYWN0aW9uXG4gKi9cbnZhciBUcmFuc2FjdGlvbkltcGwgPSB7XG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoaXMgaW5zdGFuY2Ugc28gdGhhdCBpdCBpcyBwcmVwYXJlZCBmb3IgY29sbGVjdGluZyBtZXRyaWNzLiBEb2VzXG4gICAqIHNvIHN1Y2ggdGhhdCB0aGlzIHNldHVwIG1ldGhvZCBtYXkgYmUgdXNlZCBvbiBhbiBpbnN0YW5jZSB0aGF0IGlzIGFscmVhZHlcbiAgICogaW5pdGlhbGl6ZWQsIGluIGEgd2F5IHRoYXQgZG9lcyBub3QgY29uc3VtZSBhZGRpdGlvbmFsIG1lbW9yeSB1cG9uIHJldXNlLlxuICAgKiBUaGF0IGNhbiBiZSB1c2VmdWwgaWYgeW91IGRlY2lkZSB0byBtYWtlIHlvdXIgc3ViY2xhc3Mgb2YgdGhpcyBtaXhpbiBhXG4gICAqIFwiUG9vbGVkQ2xhc3NcIi5cbiAgICovXG4gIHJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy5nZXRUcmFuc2FjdGlvbldyYXBwZXJzKCk7XG4gICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhKSB7XG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YS5sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgfSxcblxuICBfaXNJblRyYW5zYWN0aW9uOiBmYWxzZSxcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0FycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj59IEFycmF5IG9mIHRyYW5zYWN0aW9uIHdyYXBwZXJzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogbnVsbCxcblxuICBpc0luVHJhbnNhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9pc0luVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBmdW5jdGlvbiB3aXRoaW4gYSBzYWZldHkgd2luZG93LiBVc2UgdGhpcyBmb3IgdGhlIHRvcCBsZXZlbFxuICAgKiBtZXRob2RzIHRoYXQgcmVzdWx0IGluIGxhcmdlIGFtb3VudHMgb2YgY29tcHV0YXRpb24vbXV0YXRpb25zIHRoYXQgd291bGRcbiAgICogbmVlZCB0byBiZSBzYWZldHkgY2hlY2tlZC4gVGhlIG9wdGlvbmFsIGFyZ3VtZW50cyBoZWxwcyBwcmV2ZW50IHRoZSBuZWVkXG4gICAqIHRvIGJpbmQgaW4gbWFueSBjYXNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1lbWJlciBvZiBzY29wZSB0byBjYWxsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgU2NvcGUgdG8gaW52b2tlIGZyb20uXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGEgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBiIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYyBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGQgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBlIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZiBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqXG4gICAqIEByZXR1cm4geyp9IFJldHVybiB2YWx1ZSBmcm9tIGBtZXRob2RgLlxuICAgKi9cbiAgcGVyZm9ybTogZnVuY3Rpb24gKG1ldGhvZCwgc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAhIXRoaXMuaXNJblRyYW5zYWN0aW9uKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJhbnNhY3Rpb24ucGVyZm9ybSguLi4pOiBDYW5ub3QgaW5pdGlhbGl6ZSBhIHRyYW5zYWN0aW9uIHdoZW4gdGhlcmUgaXMgYWxyZWFkeSBhbiBvdXRzdGFuZGluZyB0cmFuc2FjdGlvbi4nKSA6IF9wcm9kSW52YXJpYW50KCcyNycpIDogdm9pZCAwO1xuICAgIHZhciBlcnJvclRocm93bjtcbiAgICB2YXIgcmV0O1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSB0cnVlO1xuICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aFxuICAgICAgLy8gZXJyb3JUaHJvd24gc2V0IHRvIHRydWUgYmVmb3JlIHNldHRpbmcgaXQgdG8gZmFsc2UgYWZ0ZXIgY2FsbGluZ1xuICAgICAgLy8gY2xvc2UgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gdHJ1ZSBpbiB0aGUgZmluYWxseSBibG9jaywgaXQgbWVhbnNcbiAgICAgIC8vIG9uZSBvZiB0aGVzZSBjYWxscyB0aHJldy5cbiAgICAgIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUFsbCgwKTtcbiAgICAgIHJldCA9IG1ldGhvZC5jYWxsKHNjb3BlLCBhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgIC8vIElmIGBtZXRob2RgIHRocm93cywgcHJlZmVyIHRvIHNob3cgdGhhdCBzdGFjayB0cmFjZSBvdmVyIGFueSB0aHJvd25cbiAgICAgICAgICAvLyBieSBpbnZva2luZyBgY2xvc2VBbGxgLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQWxsKDApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTaW5jZSBgbWV0aG9kYCBkaWRuJ3QgdGhyb3csIHdlIGRvbid0IHdhbnQgdG8gc2lsZW5jZSB0aGUgZXhjZXB0aW9uXG4gICAgICAgICAgLy8gaGVyZS5cbiAgICAgICAgICB0aGlzLmNsb3NlQWxsKDApO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBpbml0aWFsaXplQWxsOiBmdW5jdGlvbiAoc3RhcnRJbmRleCkge1xuICAgIHZhciB0cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgdHJhbnNhY3Rpb25XcmFwcGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0cmFuc2FjdGlvbldyYXBwZXJzW2ldO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aCB0aGVcbiAgICAgICAgLy8gT0JTRVJWRURfRVJST1Igc3RhdGUgYmVmb3JlIG92ZXJ3cml0aW5nIGl0IHdpdGggdGhlIHJlYWwgcmV0dXJuIHZhbHVlXG4gICAgICAgIC8vIG9mIGluaXRpYWxpemUgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gT0JTRVJWRURfRVJST1IgaW4gdGhlIGZpbmFsbHlcbiAgICAgICAgLy8gYmxvY2ssIGl0IG1lYW5zIHdyYXBwZXIuaW5pdGlhbGl6ZSB0aHJldy5cbiAgICAgICAgdGhpcy53cmFwcGVySW5pdERhdGFbaV0gPSBPQlNFUlZFRF9FUlJPUjtcbiAgICAgICAgdGhpcy53cmFwcGVySW5pdERhdGFbaV0gPSB3cmFwcGVyLmluaXRpYWxpemUgPyB3cmFwcGVyLmluaXRpYWxpemUuY2FsbCh0aGlzKSA6IG51bGw7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodGhpcy53cmFwcGVySW5pdERhdGFbaV0gPT09IE9CU0VSVkVEX0VSUk9SKSB7XG4gICAgICAgICAgLy8gVGhlIGluaXRpYWxpemVyIGZvciB3cmFwcGVyIGkgdGhyZXcgYW4gZXJyb3I7IGluaXRpYWxpemUgdGhlXG4gICAgICAgICAgLy8gcmVtYWluaW5nIHdyYXBwZXJzIGJ1dCBzaWxlbmNlIGFueSBleGNlcHRpb25zIGZyb20gdGhlbSB0byBlbnN1cmVcbiAgICAgICAgICAvLyB0aGF0IHRoZSBmaXJzdCBlcnJvciBpcyB0aGUgb25lIHRvIGJ1YmJsZSB1cC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplQWxsKGkgKyAxKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZXMgZWFjaCBvZiBgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzLmNsb3NlW2ldYCBmdW5jdGlvbnMsIHBhc3NpbmcgaW50b1xuICAgKiB0aGVtIHRoZSByZXNwZWN0aXZlIHJldHVybiB2YWx1ZXMgb2YgYHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycy5pbml0W2ldYFxuICAgKiAoYGNsb3NlYHJzIHRoYXQgY29ycmVzcG9uZCB0byBpbml0aWFsaXplcnMgdGhhdCBmYWlsZWQgd2lsbCBub3QgYmVcbiAgICogaW52b2tlZCkuXG4gICAqL1xuICBjbG9zZUFsbDogZnVuY3Rpb24gKHN0YXJ0SW5kZXgpIHtcbiAgICAhdGhpcy5pc0luVHJhbnNhY3Rpb24oKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcmFuc2FjdGlvbi5jbG9zZUFsbCgpOiBDYW5ub3QgY2xvc2UgdHJhbnNhY3Rpb24gd2hlbiBub25lIGFyZSBvcGVuLicpIDogX3Byb2RJbnZhcmlhbnQoJzI4JykgOiB2b2lkIDA7XG4gICAgdmFyIHRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnM7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0cmFuc2FjdGlvbldyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRyYW5zYWN0aW9uV3JhcHBlcnNbaV07XG4gICAgICB2YXIgaW5pdERhdGEgPSB0aGlzLndyYXBwZXJJbml0RGF0YVtpXTtcbiAgICAgIHZhciBlcnJvclRocm93bjtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcbiAgICAgICAgLy8gZXJyb3JUaHJvd24gc2V0IHRvIHRydWUgYmVmb3JlIHNldHRpbmcgaXQgdG8gZmFsc2UgYWZ0ZXIgY2FsbGluZ1xuICAgICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xuICAgICAgICAvLyB3cmFwcGVyLmNsb3NlIHRocmV3LlxuICAgICAgICBlcnJvclRocm93biA9IHRydWU7XG4gICAgICAgIGlmIChpbml0RGF0YSAhPT0gT0JTRVJWRURfRVJST1IgJiYgd3JhcHBlci5jbG9zZSkge1xuICAgICAgICAgIHdyYXBwZXIuY2xvc2UuY2FsbCh0aGlzLCBpbml0RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgIC8vIFRoZSBjbG9zZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgY2xvc2UgdGhlIHJlbWFpbmluZ1xuICAgICAgICAgIC8vIHdyYXBwZXJzIGJ1dCBzaWxlbmNlIGFueSBleGNlcHRpb25zIGZyb20gdGhlbSB0byBlbnN1cmUgdGhhdCB0aGVcbiAgICAgICAgICAvLyBmaXJzdCBlcnJvciBpcyB0aGUgb25lIHRvIGJ1YmJsZSB1cC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFsbChpICsgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLndyYXBwZXJJbml0RGF0YS5sZW5ndGggPSAwO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zYWN0aW9uSW1wbDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZSgnLi9DYWxsYmFja1F1ZXVlJyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RGZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgZGlydHlDb21wb25lbnRzID0gW107XG52YXIgdXBkYXRlQmF0Y2hOdW1iZXIgPSAwO1xudmFyIGFzYXBDYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbnZhciBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcblxudmFyIGJhdGNoaW5nU3RyYXRlZ3kgPSBudWxsO1xuXG5mdW5jdGlvbiBlbnN1cmVJbmplY3RlZCgpIHtcbiAgIShSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiAmJiBiYXRjaGluZ1N0cmF0ZWd5KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgaW5qZWN0IGEgcmVjb25jaWxlIHRyYW5zYWN0aW9uIGNsYXNzIGFuZCBiYXRjaGluZyBzdHJhdGVneScpIDogX3Byb2RJbnZhcmlhbnQoJzEyMycpIDogdm9pZCAwO1xufVxuXG52YXIgTkVTVEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IGRpcnR5Q29tcG9uZW50cy5sZW5ndGg7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoICE9PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBBZGRpdGlvbmFsIHVwZGF0ZXMgd2VyZSBlbnF1ZXVlZCBieSBjb21wb25lbnREaWRVcGRhdGUgaGFuZGxlcnMgb3JcbiAgICAgIC8vIHNpbWlsYXI7IGJlZm9yZSBvdXIgb3duIFVQREFURV9RVUVVRUlORyB3cmFwcGVyIGNsb3Nlcywgd2Ugd2FudCB0byBydW5cbiAgICAgIC8vIHRoZXNlIG5ldyB1cGRhdGVzIHNvIHRoYXQgaWYgQSdzIGNvbXBvbmVudERpZFVwZGF0ZSBjYWxscyBzZXRTdGF0ZSBvblxuICAgICAgLy8gQiwgQiB3aWxsIHVwZGF0ZSBiZWZvcmUgdGhlIGNhbGxiYWNrIEEncyB1cGRhdGVyIHByb3ZpZGVkIHdoZW4gY2FsbGluZ1xuICAgICAgLy8gc2V0U3RhdGUuXG4gICAgICBkaXJ0eUNvbXBvbmVudHMuc3BsaWNlKDAsIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoKTtcbiAgICAgIGZsdXNoQmF0Y2hlZFVwZGF0ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlydHlDb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG59O1xuXG52YXIgVVBEQVRFX1FVRVVFSU5HID0ge1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLnJlc2V0KCk7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLm5vdGlmeUFsbCgpO1xuICB9XG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbTkVTVEVEX1VQREFURVMsIFVQREFURV9RVUVVRUlOR107XG5cbmZ1bmN0aW9uIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xuICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKFxuICAvKiB1c2VDcmVhdGVFbGVtZW50ICovdHJ1ZSk7XG59XG5cbl9hc3NpZ24oUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLCB7XG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gbnVsbDtcbiAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UodGhpcy5jYWxsYmFja1F1ZXVlKTtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUgPSBudWxsO1xuICAgIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnJlbGVhc2UodGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbik7XG4gICAgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiA9IG51bGw7XG4gIH0sXG5cbiAgcGVyZm9ybTogZnVuY3Rpb24gKG1ldGhvZCwgc2NvcGUsIGEpIHtcbiAgICAvLyBFc3NlbnRpYWxseSBjYWxscyBgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtKG1ldGhvZCwgc2NvcGUsIGEpYFxuICAgIC8vIHdpdGggdGhpcyB0cmFuc2FjdGlvbidzIHdyYXBwZXJzIGFyb3VuZCBpdC5cbiAgICByZXR1cm4gVHJhbnNhY3Rpb24ucGVyZm9ybS5jYWxsKHRoaXMsIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24ucGVyZm9ybSwgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiwgbWV0aG9kLCBzY29wZSwgYSk7XG4gIH1cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbik7XG5cbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKSB7XG4gIGVuc3VyZUluamVjdGVkKCk7XG4gIHJldHVybiBiYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKTtcbn1cblxuLyoqXG4gKiBBcnJheSBjb21wYXJhdG9yIGZvciBSZWFjdENvbXBvbmVudHMgYnkgbW91bnQgb3JkZXJpbmcuXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gYzEgZmlyc3QgY29tcG9uZW50IHlvdSdyZSBjb21wYXJpbmdcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGMyIHNlY29uZCBjb21wb25lbnQgeW91J3JlIGNvbXBhcmluZ1xuICogQHJldHVybiB7bnVtYmVyfSBSZXR1cm4gdmFsdWUgdXNhYmxlIGJ5IEFycmF5LnByb3RvdHlwZS5zb3J0KCkuXG4gKi9cbmZ1bmN0aW9uIG1vdW50T3JkZXJDb21wYXJhdG9yKGMxLCBjMikge1xuICByZXR1cm4gYzEuX21vdW50T3JkZXIgLSBjMi5fbW91bnRPcmRlcjtcbn1cblxuZnVuY3Rpb24gcnVuQmF0Y2hlZFVwZGF0ZXModHJhbnNhY3Rpb24pIHtcbiAgdmFyIGxlbiA9IHRyYW5zYWN0aW9uLmRpcnR5Q29tcG9uZW50c0xlbmd0aDtcbiAgIShsZW4gPT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGZsdXNoIHRyYW5zYWN0aW9uXFwncyBzdG9yZWQgZGlydHktY29tcG9uZW50cyBsZW5ndGggKCVzKSB0byBtYXRjaCBkaXJ0eS1jb21wb25lbnRzIGFycmF5IGxlbmd0aCAoJXMpLicsIGxlbiwgZGlydHlDb21wb25lbnRzLmxlbmd0aCkgOiBfcHJvZEludmFyaWFudCgnMTI0JywgbGVuLCBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA6IHZvaWQgMDtcblxuICAvLyBTaW5jZSByZWNvbmNpbGluZyBhIGNvbXBvbmVudCBoaWdoZXIgaW4gdGhlIG93bmVyIGhpZXJhcmNoeSB1c3VhbGx5IChub3RcbiAgLy8gYWx3YXlzIC0tIHNlZSBzaG91bGRDb21wb25lbnRVcGRhdGUoKSkgd2lsbCByZWNvbmNpbGUgY2hpbGRyZW4sIHJlY29uY2lsZVxuICAvLyB0aGVtIGJlZm9yZSB0aGVpciBjaGlsZHJlbiBieSBzb3J0aW5nIHRoZSBhcnJheS5cbiAgZGlydHlDb21wb25lbnRzLnNvcnQobW91bnRPcmRlckNvbXBhcmF0b3IpO1xuXG4gIC8vIEFueSB1cGRhdGVzIGVucXVldWVkIHdoaWxlIHJlY29uY2lsaW5nIG11c3QgYmUgcGVyZm9ybWVkIGFmdGVyIHRoaXMgZW50aXJlXG4gIC8vIGJhdGNoLiBPdGhlcndpc2UsIGlmIGRpcnR5Q29tcG9uZW50cyBpcyBbQSwgQl0gd2hlcmUgQSBoYXMgY2hpbGRyZW4gQiBhbmRcbiAgLy8gQywgQiBjb3VsZCB1cGRhdGUgdHdpY2UgaW4gYSBzaW5nbGUgYmF0Y2ggaWYgQydzIHJlbmRlciBlbnF1ZXVlcyBhbiB1cGRhdGVcbiAgLy8gdG8gQiAoc2luY2UgQiB3b3VsZCBoYXZlIGFscmVhZHkgdXBkYXRlZCwgd2Ugc2hvdWxkIHNraXAgaXQsIGFuZCB0aGUgb25seVxuICAvLyB3YXkgd2UgY2FuIGtub3cgdG8gZG8gc28gaXMgYnkgY2hlY2tpbmcgdGhlIGJhdGNoIGNvdW50ZXIpLlxuICB1cGRhdGVCYXRjaE51bWJlcisrO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAvLyBJZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgYmVmb3JlIHBlbmRpbmcgY2hhbmdlcyBhcHBseSwgaXQgd2lsbCBzdGlsbFxuICAgIC8vIGJlIGhlcmUsIGJ1dCB3ZSBhc3N1bWUgdGhhdCBpdCBoYXMgY2xlYXJlZCBpdHMgX3BlbmRpbmdDYWxsYmFja3MgYW5kXG4gICAgLy8gdGhhdCBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkgaXMgYSBub29wLlxuICAgIHZhciBjb21wb25lbnQgPSBkaXJ0eUNvbXBvbmVudHNbaV07XG5cbiAgICAvLyBJZiBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkgaGFwcGVucyB0byBlbnF1ZXVlIGFueSBuZXcgdXBkYXRlcywgd2VcbiAgICAvLyBzaG91bGRuJ3QgZXhlY3V0ZSB0aGUgY2FsbGJhY2tzIHVudGlsIHRoZSBuZXh0IHJlbmRlciBoYXBwZW5zLCBzb1xuICAgIC8vIHN0YXNoIHRoZSBjYWxsYmFja3MgZmlyc3RcbiAgICB2YXIgY2FsbGJhY2tzID0gY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzO1xuICAgIGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG5cbiAgICB2YXIgbWFya2VyTmFtZTtcbiAgICBpZiAoUmVhY3RGZWF0dXJlRmxhZ3MubG9nVG9wTGV2ZWxSZW5kZXJzKSB7XG4gICAgICB2YXIgbmFtZWRDb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAvLyBEdWNrIHR5cGUgVG9wTGV2ZWxXcmFwcGVyLiBUaGlzIGlzIHByb2JhYmx5IGFsd2F5cyB0cnVlLlxuICAgICAgaWYgKGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQudHlwZS5pc1JlYWN0VG9wTGV2ZWxXcmFwcGVyKSB7XG4gICAgICAgIG5hbWVkQ29tcG9uZW50ID0gY29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudDtcbiAgICAgIH1cbiAgICAgIG1hcmtlck5hbWUgPSAnUmVhY3QgdXBkYXRlOiAnICsgbmFtZWRDb21wb25lbnQuZ2V0TmFtZSgpO1xuICAgICAgY29uc29sZS50aW1lKG1hcmtlck5hbWUpO1xuICAgIH1cblxuICAgIFJlYWN0UmVjb25jaWxlci5wZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkoY29tcG9uZW50LCB0cmFuc2FjdGlvbi5yZWNvbmNpbGVUcmFuc2FjdGlvbiwgdXBkYXRlQmF0Y2hOdW1iZXIpO1xuXG4gICAgaWYgKG1hcmtlck5hbWUpIHtcbiAgICAgIGNvbnNvbGUudGltZUVuZChtYXJrZXJOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNhbGxiYWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICB0cmFuc2FjdGlvbi5jYWxsYmFja1F1ZXVlLmVucXVldWUoY2FsbGJhY2tzW2pdLCBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBmbHVzaEJhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKCkge1xuICAvLyBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgd2lsbCBjbGVhciB0aGUgZGlydHlDb21wb25lbnRzXG4gIC8vIGFycmF5IGFuZCBwZXJmb3JtIGFueSB1cGRhdGVzIGVucXVldWVkIGJ5IG1vdW50LXJlYWR5IGhhbmRsZXJzIChpLmUuLFxuICAvLyBjb21wb25lbnREaWRVcGRhdGUpIGJ1dCB3ZSBuZWVkIHRvIGNoZWNrIGhlcmUgdG9vIGluIG9yZGVyIHRvIGNhdGNoXG4gIC8vIHVwZGF0ZXMgZW5xdWV1ZWQgYnkgc2V0U3RhdGUgY2FsbGJhY2tzIGFuZCBhc2FwIGNhbGxzLlxuICB3aGlsZSAoZGlydHlDb21wb25lbnRzLmxlbmd0aCB8fCBhc2FwRW5xdWV1ZWQpIHtcbiAgICBpZiAoZGlydHlDb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5nZXRQb29sZWQoKTtcbiAgICAgIHRyYW5zYWN0aW9uLnBlcmZvcm0ocnVuQmF0Y2hlZFVwZGF0ZXMsIG51bGwsIHRyYW5zYWN0aW9uKTtcbiAgICAgIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFzYXBFbnF1ZXVlZCkge1xuICAgICAgYXNhcEVucXVldWVkID0gZmFsc2U7XG4gICAgICB2YXIgcXVldWUgPSBhc2FwQ2FsbGJhY2tRdWV1ZTtcbiAgICAgIGFzYXBDYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbiAgICAgIHF1ZXVlLm5vdGlmeUFsbCgpO1xuICAgICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHF1ZXVlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTWFyayBhIGNvbXBvbmVudCBhcyBuZWVkaW5nIGEgcmVyZW5kZXIsIGFkZGluZyBhbiBvcHRpb25hbCBjYWxsYmFjayB0byBhXG4gKiBsaXN0IG9mIGZ1bmN0aW9ucyB3aGljaCB3aWxsIGJlIGV4ZWN1dGVkIG9uY2UgdGhlIHJlcmVuZGVyIG9jY3Vycy5cbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShjb21wb25lbnQpIHtcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcblxuICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS4gKFRoaXMgaXMgY2FsbGVkIGJ5IGVhY2ggdG9wLWxldmVsIHVwZGF0ZVxuICAvLyBmdW5jdGlvbiwgbGlrZSBzZXRTdGF0ZSwgZm9yY2VVcGRhdGUsIGV0Yy47IGNyZWF0aW9uIGFuZFxuICAvLyBkZXN0cnVjdGlvbiBvZiB0b3AtbGV2ZWwgY29tcG9uZW50cyBpcyBndWFyZGVkIGluIFJlYWN0TW91bnQuKVxuXG4gIGlmICghYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcykge1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoZW5xdWV1ZVVwZGF0ZSwgY29tcG9uZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBkaXJ0eUNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICBpZiAoY29tcG9uZW50Ll91cGRhdGVCYXRjaE51bWJlciA9PSBudWxsKSB7XG4gICAgY29tcG9uZW50Ll91cGRhdGVCYXRjaE51bWJlciA9IHVwZGF0ZUJhdGNoTnVtYmVyICsgMTtcbiAgfVxufVxuXG4vKipcbiAqIEVucXVldWUgYSBjYWxsYmFjayB0byBiZSBydW4gYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBiYXRjaGluZyBjeWNsZS4gVGhyb3dzXG4gKiBpZiBubyB1cGRhdGVzIGFyZSBjdXJyZW50bHkgYmVpbmcgcGVyZm9ybWVkLlxuICovXG5mdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICFiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlcy5hc2FwOiBDYW5cXCd0IGVucXVldWUgYW4gYXNhcCBjYWxsYmFjayBpbiBhIGNvbnRleHQgd2hlcmV1cGRhdGVzIGFyZSBub3QgYmVpbmcgYmF0Y2hlZC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMjUnKSA6IHZvaWQgMDtcbiAgYXNhcENhbGxiYWNrUXVldWUuZW5xdWV1ZShjYWxsYmFjaywgY29udGV4dCk7XG4gIGFzYXBFbnF1ZXVlZCA9IHRydWU7XG59XG5cbnZhciBSZWFjdFVwZGF0ZXNJbmplY3Rpb24gPSB7XG4gIGluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoUmVjb25jaWxlVHJhbnNhY3Rpb24pIHtcbiAgICAhUmVjb25jaWxlVHJhbnNhY3Rpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MnKSA6IF9wcm9kSW52YXJpYW50KCcxMjYnKSA6IHZvaWQgMDtcbiAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiA9IFJlY29uY2lsZVRyYW5zYWN0aW9uO1xuICB9LFxuXG4gIGluamVjdEJhdGNoaW5nU3RyYXRlZ3k6IGZ1bmN0aW9uIChfYmF0Y2hpbmdTdHJhdGVneSkge1xuICAgICFfYmF0Y2hpbmdTdHJhdGVneSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIGJhdGNoaW5nIHN0cmF0ZWd5JykgOiBfcHJvZEludmFyaWFudCgnMTI3JykgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgX2JhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMgPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgYmF0Y2hlZFVwZGF0ZXMoKSBmdW5jdGlvbicpIDogX3Byb2RJbnZhcmlhbnQoJzEyOCcpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID09PSAnYm9vbGVhbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGFuIGlzQmF0Y2hpbmdVcGRhdGVzIGJvb2xlYW4gYXR0cmlidXRlJykgOiBfcHJvZEludmFyaWFudCgnMTI5JykgOiB2b2lkIDA7XG4gICAgYmF0Y2hpbmdTdHJhdGVneSA9IF9iYXRjaGluZ1N0cmF0ZWd5O1xuICB9XG59O1xuXG52YXIgUmVhY3RVcGRhdGVzID0ge1xuICAvKipcbiAgICogUmVhY3QgcmVmZXJlbmNlcyBgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbmAgdXNpbmcgdGhpcyBwcm9wZXJ0eSBpbiBvcmRlclxuICAgKiB0byBhbGxvdyBkZXBlbmRlbmN5IGluamVjdGlvbi5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uOiBudWxsLFxuXG4gIGJhdGNoZWRVcGRhdGVzOiBiYXRjaGVkVXBkYXRlcyxcbiAgZW5xdWV1ZVVwZGF0ZTogZW5xdWV1ZVVwZGF0ZSxcbiAgZmx1c2hCYXRjaGVkVXBkYXRlczogZmx1c2hCYXRjaGVkVXBkYXRlcyxcbiAgaW5qZWN0aW9uOiBSZWFjdFVwZGF0ZXNJbmplY3Rpb24sXG4gIGFzYXA6IGFzYXBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RVcGRhdGVzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0cyB0aGUgdGFyZ2V0IG5vZGUgZnJvbSBhIG5hdGl2ZSBicm93c2VyIGV2ZW50IGJ5IGFjY291bnRpbmcgZm9yXG4gKiBpbmNvbnNpc3RlbmNpZXMgaW4gYnJvd3NlciBET00gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gVGFyZ2V0IG5vZGUuXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcblxuICAvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXG4gIGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gIH1cblxuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSAzID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRUYXJnZXQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHVzZUhhc0ZlYXR1cmU7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHVzZUhhc0ZlYXR1cmUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gIC8vIGFsd2F5cyByZXR1cm5zIHRydWUgaW4gbmV3ZXIgYnJvd3NlcnMgYXMgcGVyIHRoZSBzdGFuZGFyZC5cbiAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcbiAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFdmVudFN1cHBvcnRlZDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cblxudmFyIHN1cHBvcnRlZElucHV0VHlwZXMgPSB7XG4gICdjb2xvcic6IHRydWUsXG4gICdkYXRlJzogdHJ1ZSxcbiAgJ2RhdGV0aW1lJzogdHJ1ZSxcbiAgJ2RhdGV0aW1lLWxvY2FsJzogdHJ1ZSxcbiAgJ2VtYWlsJzogdHJ1ZSxcbiAgJ21vbnRoJzogdHJ1ZSxcbiAgJ251bWJlcic6IHRydWUsXG4gICdwYXNzd29yZCc6IHRydWUsXG4gICdyYW5nZSc6IHRydWUsXG4gICdzZWFyY2gnOiB0cnVlLFxuICAndGVsJzogdHJ1ZSxcbiAgJ3RleHQnOiB0cnVlLFxuICAndGltZSc6IHRydWUsXG4gICd1cmwnOiB0cnVlLFxuICAnd2Vlayc6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0SW5wdXRFbGVtZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcbnZhciBpc1RleHRJbnB1dEVsZW1lbnQgPSByZXF1aXJlKCcuL2lzVGV4dElucHV0RWxlbWVudCcpO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgY2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNoYW5nZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ2hhbmdlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENoYW5nZScsICd0b3BDbGljaycsICd0b3BGb2N1cycsICd0b3BJbnB1dCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbi8qKlxuICogRm9yIElFIHNoaW1zXG4gKi9cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudFZhbHVlID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxudmFyIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBTZWUgYGhhbmRsZUNoYW5nZWAgY29tbWVudCBiZWxvd1xuICBkb2VzQ2hhbmdlRXZlbnRCdWJibGUgPSBpc0V2ZW50U3VwcG9ydGVkKCdjaGFuZ2UnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA4KTtcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIGFjdGl2ZUVsZW1lbnRJbnN0LCBuYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpKTtcbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcblxuICAvLyBJZiBjaGFuZ2UgYW5kIHByb3BlcnR5Y2hhbmdlIGJ1YmJsZWQsIHdlJ2QganVzdCBiaW5kIHRvIGl0IGxpa2UgYWxsIHRoZVxuICAvLyBvdGhlciBldmVudHMgYW5kIGhhdmUgaXQgZ28gdGhyb3VnaCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuIFNpbmNlIGl0XG4gIC8vIGRvZXNuJ3QsIHdlIG1hbnVhbGx5IGxpc3RlbiBmb3IgdGhlIGV2ZW50cyBhbmQgc28gd2UgaGF2ZSB0byBlbnF1ZXVlIGFuZFxuICAvLyBwcm9jZXNzIHRoZSBhYnN0cmFjdCBldmVudCBtYW51YWxseS5cbiAgLy9cbiAgLy8gQmF0Y2hpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgYWxsIGV2ZW50IGhhbmRsZXJzIHJ1blxuICAvLyBiZWZvcmUgdGhlIG5leHQgcmVyZW5kZXIgKGluY2x1ZGluZyBldmVudCBoYW5kbGVycyBhdHRhY2hlZCB0byBhbmNlc3RvclxuICAvLyBlbGVtZW50cyBpbnN0ZWFkIG9mIGRpcmVjdGx5IG9uIHRoZSBpbnB1dCkuIFdpdGhvdXQgdGhpcywgY29udHJvbGxlZFxuICAvLyBjb21wb25lbnRzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gY29uanVuY3Rpb24gd2l0aCBldmVudCBidWJibGluZyBiZWNhdXNlXG4gIC8vIHRoZSBjb21wb25lbnQgaXMgcmVyZW5kZXJlZCBhbmQgdGhlIHZhbHVlIHJldmVydGVkIGJlZm9yZSBhbGwgdGhlIGV2ZW50XG4gIC8vIGhhbmRsZXJzIGNhbiBydW4uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcwOC5cbiAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKHJ1bkV2ZW50SW5CYXRjaCwgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZXZlbnQpIHtcbiAgRXZlbnRQbHVnaW5IdWIuZW5xdWV1ZUV2ZW50cyhldmVudCk7XG4gIEV2ZW50UGx1Z2luSHViLnByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XG59XG5cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25jaGFuZ2UnLCBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KTtcbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ2hhbmdlJykge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JDaGFuZ2VFdmVudElFOCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wRm9jdXMnKSB7XG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgaW5wdXRgIGV2ZW50XG4gKi9cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU5IGNsYWltcyB0byBzdXBwb3J0IHRoZSBpbnB1dCBldmVudCBidXQgZmFpbHMgdG8gdHJpZ2dlciBpdCB3aGVuXG4gIC8vIGRlbGV0aW5nIHRleHQsIHNvIHdlIGlnbm9yZSBpdHMgaW5wdXQgZXZlbnRzLlxuICAvLyBJRTEwKyBmaXJlIGlucHV0IGV2ZW50cyB0byBvZnRlbiwgc3VjaCB3aGVuIGEgcGxhY2Vob2xkZXJcbiAgLy8gY2hhbmdlcyBvciB3aGVuIGFuIGlucHV0IHdpdGggYSBwbGFjZWhvbGRlciBpcyBmb2N1c2VkLlxuICBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBpc0V2ZW50U3VwcG9ydGVkKCdpbnB1dCcpICYmICghZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDExKTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9MTEpIFJlcGxhY2VtZW50IGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgdmFsdWVgIHByb3BlcnR5IHRoYXQgZ2V0c1xuICogc2V0IG9uIHRoZSBhY3RpdmUgZWxlbWVudC5cbiAqL1xudmFyIG5ld1ZhbHVlUHJvcCA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AuZ2V0LmNhbGwodGhpcyk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgIC8vIENhc3QgdG8gYSBzdHJpbmcgc28gd2UgY2FuIGRvIGVxdWFsaXR5IGNoZWNrcy5cbiAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSAnJyArIHZhbDtcbiAgICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wLnNldC5jYWxsKHRoaXMsIHZhbCk7XG4gIH1cbn07XG5cbi8qKlxuICogKEZvciBJRSA8PTExKSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gdGFyZ2V0LnZhbHVlO1xuICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQuY29uc3RydWN0b3IucHJvdG90eXBlLCAndmFsdWUnKTtcblxuICAvLyBOb3QgZ3VhcmRlZCBpbiBhIGNhbkRlZmluZVByb3BlcnR5IGNoZWNrOiBJRTggc3VwcG9ydHMgZGVmaW5lUHJvcGVydHkgb25seVxuICAvLyBvbiBET00gZWxlbWVudHNcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFjdGl2ZUVsZW1lbnQsICd2YWx1ZScsIG5ld1ZhbHVlUHJvcCk7XG4gIGlmIChhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgfSBlbHNlIHtcbiAgICBhY3RpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UsIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIChGb3IgSUUgPD0xMSkgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZGVsZXRlIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBkZWZpbml0aW9uXG4gIGRlbGV0ZSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuXG4gIGlmIChhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KSB7XG4gICAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgfSBlbHNlIHtcbiAgICBhY3RpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Byb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UsIGZhbHNlKTtcbiAgfVxuXG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD0xMSkgSGFuZGxlcyBhIHByb3BlcnR5Y2hhbmdlIGV2ZW50LCBzZW5kaW5nIGEgYGNoYW5nZWAgZXZlbnQgaWZcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgYWN0aXZlIGVsZW1lbnQgaGFzIGNoYW5nZWQuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVByb3BlcnR5Q2hhbmdlKG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5wcm9wZXJ0eU5hbWUgIT09ICd2YWx1ZScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHZhbHVlID0gbmF0aXZlRXZlbnQuc3JjRWxlbWVudC52YWx1ZTtcbiAgaWYgKHZhbHVlID09PSBhY3RpdmVFbGVtZW50VmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gdmFsdWU7XG5cbiAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG59XG5cbi8qKlxuICogSWYgYSBgY2hhbmdlYCBldmVudCBzaG91bGQgYmUgZmlyZWQsIHJldHVybnMgdGhlIHRhcmdldCdzIElELlxuICovXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcElucHV0Jykge1xuICAgIC8vIEluIG1vZGVybiBicm93c2VycyAoaS5lLiwgbm90IElFOCBvciBJRTkpLCB0aGUgaW5wdXQgZXZlbnQgaXMgZXhhY3RseVxuICAgIC8vIHdoYXQgd2Ugd2FudCBzbyBmYWxsIHRocm91Z2ggaGVyZSBhbmQgdHJpZ2dlciBhbiBhYnN0cmFjdCBldmVudFxuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wRm9jdXMnKSB7XG4gICAgLy8gSW4gSUU4LCB3ZSBjYW4gY2FwdHVyZSBhbG1vc3QgYWxsIC52YWx1ZSBjaGFuZ2VzIGJ5IGFkZGluZyBhXG4gICAgLy8gcHJvcGVydHljaGFuZ2UgaGFuZGxlciBhbmQgbG9va2luZyBmb3IgZXZlbnRzIHdpdGggcHJvcGVydHlOYW1lXG4gICAgLy8gZXF1YWwgdG8gJ3ZhbHVlJ1xuICAgIC8vIEluIElFOS0xMSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BCbHVyJykge1xuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gIH1cbn1cblxuLy8gRm9yIElFOCBhbmQgSUU5LlxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcFNlbGVjdGlvbkNoYW5nZScgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5VXAnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleURvd24nKSB7XG4gICAgLy8gT24gdGhlIHNlbGVjdGlvbmNoYW5nZSBldmVudCwgdGhlIHRhcmdldCBpcyBqdXN0IGRvY3VtZW50IHdoaWNoIGlzbid0XG4gICAgLy8gaGVscGZ1bCBmb3IgdXMgc28ganVzdCBjaGVjayBhY3RpdmVFbGVtZW50IGluc3RlYWQuXG4gICAgLy9cbiAgICAvLyA5OSUgb2YgdGhlIHRpbWUsIGtleWRvd24gYW5kIGtleXVwIGFyZW4ndCBuZWNlc3NhcnkuIElFOCBmYWlscyB0byBmaXJlXG4gICAgLy8gcHJvcGVydHljaGFuZ2Ugb24gdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFmdGVyIHNldHRpbmcgYHZhbHVlYCBmcm9tIGFcbiAgICAvLyBzY3JpcHQgYW5kIGZpcmVzIG9ubHkga2V5ZG93biwga2V5cHJlc3MsIGtleXVwLiBDYXRjaGluZyBrZXl1cCB1c3VhbGx5XG4gICAgLy8gZ2V0cyBpdCBhbmQgY2F0Y2hpbmcga2V5ZG93biBsZXRzIHVzIGZpcmUgYW4gZXZlbnQgZm9yIHRoZSBmaXJzdFxuICAgIC8vIGtleXN0cm9rZSBpZiB1c2VyIGRvZXMgYSBrZXkgcmVwZWF0IChpdCdsbCBiZSBhIGxpdHRsZSBkZWxheWVkOiByaWdodFxuICAgIC8vIGJlZm9yZSB0aGUgc2Vjb25kIGtleXN0cm9rZSkuIE90aGVyIGlucHV0IG1ldGhvZHMgKGUuZy4sIHBhc3RlKSBzZWVtIHRvXG4gICAgLy8gZmlyZSBzZWxlY3Rpb25jaGFuZ2Ugbm9ybWFsbHkuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC52YWx1ZSAhPT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XG4gICAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRJbnN0O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmIChlbGVtLnR5cGUgPT09ICdjaGVja2JveCcgfHwgZWxlbS50eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDbGljaycpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHZhciBnZXRUYXJnZXRJbnN0RnVuYywgaGFuZGxlRXZlbnRGdW5jO1xuICAgIGlmIChzaG91bGRVc2VDaGFuZ2VFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50SUU7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIGluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIGV2ZW50LnR5cGUgPSAnY2hhbmdlJztcbiAgICAgICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZUV2ZW50UGx1Z2luOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cblxudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gWydSZXNwb25kZXJFdmVudFBsdWdpbicsICdTaW1wbGVFdmVudFBsdWdpbicsICdUYXBFdmVudFBsdWdpbicsICdFbnRlckxlYXZlRXZlbnRQbHVnaW4nLCAnQ2hhbmdlRXZlbnRQbHVnaW4nLCAnU2VsZWN0RXZlbnRQbHVnaW4nLCAnQmVmb3JlSW5wdXRFdmVudFBsdWdpbiddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmF1bHRFdmVudFBsdWdpbk9yZGVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9nZXRFdmVudFRhcmdldCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudmlldykge1xuICAgICAgcmV0dXJuIGV2ZW50LnZpZXc7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICBpZiAodGFyZ2V0LndpbmRvdyA9PT0gdGFyZ2V0KSB7XG4gICAgICAvLyB0YXJnZXQgaXMgYSB3aW5kb3cgb2JqZWN0XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHZhciBkb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgaWYgKGRvYykge1xuICAgICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgfSxcbiAgZGV0YWlsOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuZGV0YWlsIHx8IDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1VJRXZlbnQsIFVJRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1VJRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFZpZXdwb3J0TWV0cmljcyA9IHtcblxuICBjdXJyZW50U2Nyb2xsTGVmdDogMCxcblxuICBjdXJyZW50U2Nyb2xsVG9wOiAwLFxuXG4gIHJlZnJlc2hTY3JvbGxWYWx1ZXM6IGZ1bmN0aW9uIChzY3JvbGxQb3NpdGlvbikge1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdCA9IHNjcm9sbFBvc2l0aW9uLng7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3AgPSBzY3JvbGxQb3NpdGlvbi55O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlld3BvcnRNZXRyaWNzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxudmFyIG1vZGlmaWVyS2V5VG9Qcm9wID0ge1xuICAnQWx0JzogJ2FsdEtleScsXG4gICdDb250cm9sJzogJ2N0cmxLZXknLFxuICAnTWV0YSc6ICdtZXRhS2V5JyxcbiAgJ1NoaWZ0JzogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudE1vZGlmaWVyU3RhdGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKCcuL1ZpZXdwb3J0TWV0cmljcycpO1xuXG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IHtcbiAgc2NyZWVuWDogbnVsbCxcbiAgc2NyZWVuWTogbnVsbCxcbiAgY2xpZW50WDogbnVsbCxcbiAgY2xpZW50WTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICBidXR0b246IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIFdlYmtpdCwgRmlyZWZveCwgSUU5K1xuICAgIC8vIHdoaWNoOiAgMSAyIDNcbiAgICAvLyBidXR0b246IDAgMSAyIChzdGFuZGFyZClcbiAgICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuICAgIGlmICgnd2hpY2gnIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH1cbiAgICAvLyBJRTw5XG4gICAgLy8gd2hpY2g6ICB1bmRlZmluZWRcbiAgICAvLyBidXR0b246IDAgMCAwXG4gICAgLy8gYnV0dG9uOiAxIDQgMiAob25tb3VzZXVwKVxuICAgIHJldHVybiBidXR0b24gPT09IDIgPyAyIDogYnV0dG9uID09PSA0ID8gMSA6IDA7XG4gIH0sXG4gIGJ1dHRvbnM6IG51bGwsXG4gIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IChldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQuc3JjRWxlbWVudCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50KTtcbiAgfSxcbiAgLy8gXCJQcm9wcmlldGFyeVwiIEludGVyZmFjZS5cbiAgcGFnZVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAncGFnZVgnIGluIGV2ZW50ID8gZXZlbnQucGFnZVggOiBldmVudC5jbGllbnRYICsgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxMZWZ0O1xuICB9LFxuICBwYWdlWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdwYWdlWScgaW4gZXZlbnQgPyBldmVudC5wYWdlWSA6IGV2ZW50LmNsaWVudFkgKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbFRvcDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljTW91c2VFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljTW91c2VFdmVudCwgTW91c2VFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljTW91c2VFdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlRW50ZXInLFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BNb3VzZU91dCcsICd0b3BNb3VzZU92ZXInXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VMZWF2ZScsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH1cbn07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlT3ZlcicgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3V0JyAmJiB0b3BMZXZlbFR5cGUgIT09ICd0b3BNb3VzZU92ZXInKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAobmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgICAgLy8gYG5hdGl2ZUV2ZW50VGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdXQnKSB7XG4gICAgICBmcm9tID0gdGFyZ2V0SW5zdDtcbiAgICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQ7XG4gICAgICB0byA9IHJlbGF0ZWQgPyBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocmVsYXRlZCkgOiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZpbmcgdG8gYSBub2RlIGZyb20gb3V0c2lkZSB0aGUgd2luZG93LlxuICAgICAgZnJvbSA9IG51bGw7XG4gICAgICB0byA9IHRhcmdldEluc3Q7XG4gICAgfVxuXG4gICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAvLyBOb3RoaW5nIHBlcnRhaW5zIHRvIG91ciBtYW5hZ2VkIGNvbXBvbmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZnJvbU5vZGUgPSBmcm9tID09IG51bGwgPyB3aW4gOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShmcm9tKTtcbiAgICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRvKTtcblxuICAgIHZhciBsZWF2ZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMubW91c2VMZWF2ZSwgZnJvbSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0b05vZGU7XG5cbiAgICB2YXIgZW50ZXIgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLm1vdXNlRW50ZXIsIHRvLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGVudGVyLnR5cGUgPSAnbW91c2VlbnRlcic7XG4gICAgZW50ZXIudGFyZ2V0ID0gdG9Ob2RlO1xuICAgIGVudGVyLnJlbGF0ZWRUYXJnZXQgPSBmcm9tTm9kZTtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pO1xuXG4gICAgcmV0dXJuIFtsZWF2ZSwgZW50ZXJdO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcblxudmFyIE1VU1RfVVNFX1BST1BFUlRZID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZO1xudmFyIEhBU19CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFO1xudmFyIEhBU19OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTtcblxudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgaXNDdXN0b21BdHRyaWJ1dGU6IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKG5ldyBSZWdFeHAoJ14oZGF0YXxhcmlhKS1bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJykpLFxuICBQcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFjY2VwdDogMCxcbiAgICBhY2NlcHRDaGFyc2V0OiAwLFxuICAgIGFjY2Vzc0tleTogMCxcbiAgICBhY3Rpb246IDAsXG4gICAgYWxsb3dGdWxsU2NyZWVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhbGxvd1RyYW5zcGFyZW5jeTogMCxcbiAgICBhbHQ6IDAsXG4gICAgLy8gc3BlY2lmaWVzIHRhcmdldCBjb250ZXh0IGZvciBsaW5rcyB3aXRoIGBwcmVsb2FkYCB0eXBlXG4gICAgYXM6IDAsXG4gICAgYXN5bmM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9Db21wbGV0ZTogMCxcbiAgICAvLyBhdXRvRm9jdXMgaXMgcG9seWZpbGxlZC9ub3JtYWxpemVkIGJ5IEF1dG9Gb2N1c1V0aWxzXG4gICAgLy8gYXV0b0ZvY3VzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvUGxheTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2FwdHVyZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2VsbFBhZGRpbmc6IDAsXG4gICAgY2VsbFNwYWNpbmc6IDAsXG4gICAgY2hhclNldDogMCxcbiAgICBjaGFsbGVuZ2U6IDAsXG4gICAgY2hlY2tlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjaXRlOiAwLFxuICAgIGNsYXNzSUQ6IDAsXG4gICAgY2xhc3NOYW1lOiAwLFxuICAgIGNvbHM6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIGNvbFNwYW46IDAsXG4gICAgY29udGVudDogMCxcbiAgICBjb250ZW50RWRpdGFibGU6IDAsXG4gICAgY29udGV4dE1lbnU6IDAsXG4gICAgY29udHJvbHM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNvb3JkczogMCxcbiAgICBjcm9zc09yaWdpbjogMCxcbiAgICBkYXRhOiAwLCAvLyBGb3IgYDxvYmplY3QgLz5gIGFjdHMgYXMgYHNyY2AuXG4gICAgZGF0ZVRpbWU6IDAsXG4gICAgJ2RlZmF1bHQnOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkZWZlcjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGlyOiAwLFxuICAgIGRpc2FibGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IDAsXG4gICAgZW5jVHlwZTogMCxcbiAgICBmb3JtOiAwLFxuICAgIGZvcm1BY3Rpb246IDAsXG4gICAgZm9ybUVuY1R5cGU6IDAsXG4gICAgZm9ybU1ldGhvZDogMCxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZm9ybVRhcmdldDogMCxcbiAgICBmcmFtZUJvcmRlcjogMCxcbiAgICBoZWFkZXJzOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBoaWRkZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGhpZ2g6IDAsXG4gICAgaHJlZjogMCxcbiAgICBocmVmTGFuZzogMCxcbiAgICBodG1sRm9yOiAwLFxuICAgIGh0dHBFcXVpdjogMCxcbiAgICBpY29uOiAwLFxuICAgIGlkOiAwLFxuICAgIGlucHV0TW9kZTogMCxcbiAgICBpbnRlZ3JpdHk6IDAsXG4gICAgaXM6IDAsXG4gICAga2V5UGFyYW1zOiAwLFxuICAgIGtleVR5cGU6IDAsXG4gICAga2luZDogMCxcbiAgICBsYWJlbDogMCxcbiAgICBsYW5nOiAwLFxuICAgIGxpc3Q6IDAsXG4gICAgbG9vcDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbG93OiAwLFxuICAgIG1hbmlmZXN0OiAwLFxuICAgIG1hcmdpbkhlaWdodDogMCxcbiAgICBtYXJnaW5XaWR0aDogMCxcbiAgICBtYXg6IDAsXG4gICAgbWF4TGVuZ3RoOiAwLFxuICAgIG1lZGlhOiAwLFxuICAgIG1lZGlhR3JvdXA6IDAsXG4gICAgbWV0aG9kOiAwLFxuICAgIG1pbjogMCxcbiAgICBtaW5MZW5ndGg6IDAsXG4gICAgLy8gQ2F1dGlvbjsgYG9wdGlvbi5zZWxlY3RlZGAgaXMgbm90IHVwZGF0ZWQgaWYgYHNlbGVjdC5tdWx0aXBsZWAgaXNcbiAgICAvLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLlxuICAgIG11bHRpcGxlOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG11dGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG5hbWU6IDAsXG4gICAgbm9uY2U6IDAsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3B0aW11bTogMCxcbiAgICBwYXR0ZXJuOiAwLFxuICAgIHBsYWNlaG9sZGVyOiAwLFxuICAgIHBsYXlzSW5saW5lOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBwb3N0ZXI6IDAsXG4gICAgcHJlbG9hZDogMCxcbiAgICBwcm9maWxlOiAwLFxuICAgIHJhZGlvR3JvdXA6IDAsXG4gICAgcmVhZE9ubHk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlZmVycmVyUG9saWN5OiAwLFxuICAgIHJlbDogMCxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmV2ZXJzZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJvbGU6IDAsXG4gICAgcm93czogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgcm93U3BhbjogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgc2FuZGJveDogMCxcbiAgICBzY29wZTogMCxcbiAgICBzY29wZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNjcm9sbGluZzogMCxcbiAgICBzZWFtbGVzczogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VsZWN0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2hhcGU6IDAsXG4gICAgc2l6ZTogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc2l6ZXM6IDAsXG4gICAgc3BhbjogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3BlbGxDaGVjazogMCxcbiAgICBzcmM6IDAsXG4gICAgc3JjRG9jOiAwLFxuICAgIHNyY0xhbmc6IDAsXG4gICAgc3JjU2V0OiAwLFxuICAgIHN0YXJ0OiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICBzdGVwOiAwLFxuICAgIHN0eWxlOiAwLFxuICAgIHN1bW1hcnk6IDAsXG4gICAgdGFiSW5kZXg6IDAsXG4gICAgdGFyZ2V0OiAwLFxuICAgIHRpdGxlOiAwLFxuICAgIC8vIFNldHRpbmcgLnR5cGUgdGhyb3dzIG9uIG5vbi08aW5wdXQ+IHRhZ3NcbiAgICB0eXBlOiAwLFxuICAgIHVzZU1hcDogMCxcbiAgICB2YWx1ZTogMCxcbiAgICB3aWR0aDogMCxcbiAgICB3bW9kZTogMCxcbiAgICB3cmFwOiAwLFxuXG4gICAgLyoqXG4gICAgICogUkRGYSBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgYWJvdXQ6IDAsXG4gICAgZGF0YXR5cGU6IDAsXG4gICAgaW5saXN0OiAwLFxuICAgIHByZWZpeDogMCxcbiAgICAvLyBwcm9wZXJ0eSBpcyBhbHNvIHN1cHBvcnRlZCBmb3IgT3BlbkdyYXBoIGluIG1ldGEgdGFncy5cbiAgICBwcm9wZXJ0eTogMCxcbiAgICByZXNvdXJjZTogMCxcbiAgICAndHlwZW9mJzogMCxcbiAgICB2b2NhYjogMCxcblxuICAgIC8qKlxuICAgICAqIE5vbi1zdGFuZGFyZCBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgLy8gYXV0b0NhcGl0YWxpemUgYW5kIGF1dG9Db3JyZWN0IGFyZSBzdXBwb3J0ZWQgaW4gTW9iaWxlIFNhZmFyaSBmb3JcbiAgICAvLyBrZXlib2FyZCBoaW50cy5cbiAgICBhdXRvQ2FwaXRhbGl6ZTogMCxcbiAgICBhdXRvQ29ycmVjdDogMCxcbiAgICAvLyBhdXRvU2F2ZSBhbGxvd3MgV2ViS2l0L0JsaW5rIHRvIHBlcnNpc3QgdmFsdWVzIG9mIGlucHV0IGZpZWxkcyBvbiBwYWdlIHJlbG9hZHNcbiAgICBhdXRvU2F2ZTogMCxcbiAgICAvLyBjb2xvciBpcyBmb3IgU2FmYXJpIG1hc2staWNvbiBsaW5rXG4gICAgY29sb3I6IDAsXG4gICAgLy8gaXRlbVByb3AsIGl0ZW1TY29wZSwgaXRlbVR5cGUgYXJlIGZvclxuICAgIC8vIE1pY3JvZGF0YSBzdXBwb3J0LiBTZWUgaHR0cDovL3NjaGVtYS5vcmcvZG9jcy9ncy5odG1sXG4gICAgaXRlbVByb3A6IDAsXG4gICAgaXRlbVNjb3BlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBpdGVtVHlwZTogMCxcbiAgICAvLyBpdGVtSUQgYW5kIGl0ZW1SZWYgYXJlIGZvciBNaWNyb2RhdGEgc3VwcG9ydCBhcyB3ZWxsIGJ1dFxuICAgIC8vIG9ubHkgc3BlY2lmaWVkIGluIHRoZSBXSEFUV0cgc3BlYyBkb2N1bWVudC4gU2VlXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvbWljcm9kYXRhLmh0bWwjbWljcm9kYXRhLWRvbS1hcGlcbiAgICBpdGVtSUQ6IDAsXG4gICAgaXRlbVJlZjogMCxcbiAgICAvLyByZXN1bHRzIHNob3cgbG9va2luZyBnbGFzcyBpY29uIGFuZCByZWNlbnQgc2VhcmNoZXMgb24gaW5wdXRcbiAgICAvLyBzZWFyY2ggZmllbGRzIGluIFdlYktpdC9CbGlua1xuICAgIHJlc3VsdHM6IDAsXG4gICAgLy8gSUUtb25seSBhdHRyaWJ1dGUgdGhhdCBzcGVjaWZpZXMgc2VjdXJpdHkgcmVzdHJpY3Rpb25zIG9uIGFuIGlmcmFtZVxuICAgIC8vIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBzYW5kYm94IGF0dHJpYnV0ZSBvbiBJRTwxMFxuICAgIHNlY3VyaXR5OiAwLFxuICAgIC8vIElFLW9ubHkgYXR0cmlidXRlIHRoYXQgY29udHJvbHMgZm9jdXMgYmVoYXZpb3JcbiAgICB1bnNlbGVjdGFibGU6IDBcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICBodG1sRm9yOiAnZm9yJyxcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xuICB9LFxuICBET01Qcm9wZXJ0eU5hbWVzOiB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIVE1MRE9NUHJvcGVydHlDb25maWc7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTU5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyxcbiAgbWF0aG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCcsXG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01OYW1lc3BhY2VzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB3aGljaCBoYXMgJ3Vuc2FmZScgcHJpdmlsZWdlcyAocmVxdWlyZWQgYnkgd2luZG93czggYXBwcylcbiAqL1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIGlmICh0eXBlb2YgTVNBcHAgIT09ICd1bmRlZmluZWQnICYmIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuYztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgRE9NTmFtZXNwYWNlcyA9IHJlcXVpcmUoJy4vRE9NTmFtZXNwYWNlcycpO1xuXG52YXIgV0hJVEVTUEFDRV9URVNUID0gL15bIFxcclxcblxcdFxcZl0vO1xudmFyIE5PTlZJU0lCTEVfVEVTVCA9IC88KCEtLXxsaW5rfG5vc2NyaXB0fG1ldGF8c2NyaXB0fHN0eWxlKVsgXFxyXFxuXFx0XFxmXFwvPl0vO1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbicpO1xuXG4vLyBTVkcgdGVtcCBjb250YWluZXIgZm9yIElFIGxhY2tpbmcgaW5uZXJIVE1MXG52YXIgcmV1c2FibGVTVkdDb250YWluZXI7XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldElubmVySFRNTCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgLy8gSUUgZG9lcyBub3QgaGF2ZSBpbm5lckhUTUwgZm9yIFNWRyBub2Rlcywgc28gaW5zdGVhZCB3ZSBpbmplY3QgdGhlXG4gIC8vIG5ldyBtYXJrdXAgaW4gYSB0ZW1wIG5vZGUgYW5kIHRoZW4gbW92ZSB0aGUgY2hpbGQgbm9kZXMgYWNyb3NzIGludG9cbiAgLy8gdGhlIHRhcmdldCBub2RlXG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5zdmcgJiYgISgnaW5uZXJIVE1MJyBpbiBub2RlKSkge1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gcmV1c2FibGVTVkdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwgKyAnPC9zdmc+JztcbiAgICB2YXIgc3ZnTm9kZSA9IHJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKHN2Z05vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChzdmdOb2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gIH1cbn0pO1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFODogV2hlbiB1cGRhdGluZyBhIGp1c3QgY3JlYXRlZCBub2RlIHdpdGggaW5uZXJIVE1MIG9ubHkgbGVhZGluZ1xuICAvLyB3aGl0ZXNwYWNlIGlzIHJlbW92ZWQuIFdoZW4gdXBkYXRpbmcgYW4gZXhpc3Rpbmcgbm9kZSB3aXRoIGlubmVySFRNTFxuICAvLyB3aGl0ZXNwYWNlIGluIHJvb3QgVGV4dE5vZGVzIGlzIGFsc28gY29sbGFwc2VkLlxuICAvLyBAc2VlIHF1aXJrc21vZGUub3JnL2J1Z3JlcG9ydHMvYXJjaGl2ZXMvMjAwNC8xMS9pbm5lcmh0bWxfYW5kX3QuaHRtbFxuXG4gIC8vIEZlYXR1cmUgZGV0ZWN0aW9uOyBvbmx5IElFOCBpcyBrbm93biB0byBiZWhhdmUgaW1wcm9wZXJseSBsaWtlIHRoaXMuXG4gIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSAnICc7XG4gIGlmICh0ZXN0RWxlbWVudC5pbm5lckhUTUwgPT09ICcnKSB7XG4gICAgc2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgICAgIC8vIE1hZ2ljIHRoZW9yeTogSUU4IHN1cHBvc2VkbHkgZGlmZmVyZW50aWF0ZXMgYmV0d2VlbiBhZGRlZCBhbmQgdXBkYXRlZFxuICAgICAgLy8gbm9kZXMgd2hlbiBwcm9jZXNzaW5nIGlubmVySFRNTCwgaW5uZXJIVE1MIG9uIHVwZGF0ZWQgbm9kZXMgc3VmZmVyc1xuICAgICAgLy8gZnJvbSB3b3JzZSB3aGl0ZXNwYWNlIGJlaGF2aW9yLiBSZS1hZGRpbmcgYSBub2RlIGxpa2UgdGhpcyB0cmlnZ2Vyc1xuICAgICAgLy8gdGhlIGluaXRpYWwgYW5kIG1vcmUgZmF2b3JhYmxlIHdoaXRlc3BhY2UgYmVoYXZpb3IuXG4gICAgICAvLyBUT0RPOiBXaGF0IHRvIGRvIG9uIGEgZGV0YWNoZWQgbm9kZT9cbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChub2RlLCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgYWxzbyBpbXBsZW1lbnQgYSB3b3JrYXJvdW5kIGZvciBub24tdmlzaWJsZSB0YWdzIGRpc2FwcGVhcmluZyBpbnRvXG4gICAgICAvLyB0aGluIGFpciBvbiBJRTgsIHRoaXMgb25seSBoYXBwZW5zIGlmIHRoZXJlIGlzIG5vIHZpc2libGUgdGV4dFxuICAgICAgLy8gaW4tZnJvbnQgb2YgdGhlIG5vbi12aXNpYmxlIHRhZ3MuIFBpZ2d5YmFjayBvbiB0aGUgd2hpdGVzcGFjZSBmaXhcbiAgICAgIC8vIGFuZCBzaW1wbHkgY2hlY2sgaWYgYW55IG5vbi12aXNpYmxlIHRhZ3MgYXBwZWFyIGluIHRoZSBzb3VyY2UuXG4gICAgICBpZiAoV0hJVEVTUEFDRV9URVNULnRlc3QoaHRtbCkgfHwgaHRtbFswXSA9PT0gJzwnICYmIE5PTlZJU0lCTEVfVEVTVC50ZXN0KGh0bWwpKSB7XG4gICAgICAgIC8vIFJlY292ZXIgbGVhZGluZyB3aGl0ZXNwYWNlIGJ5IHRlbXBvcmFyaWx5IHByZXBlbmRpbmcgYW55IGNoYXJhY3Rlci5cbiAgICAgICAgLy8gXFx1RkVGRiBoYXMgdGhlIHBvdGVudGlhbCBhZHZhbnRhZ2Ugb2YgYmVpbmcgemVyby13aWR0aC9pbnZpc2libGUuXG4gICAgICAgIC8vIFVnbGlmeUpTIGRyb3BzIFUrRkVGRiBjaGFycyB3aGVuIHBhcnNpbmcsIHNvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlXG4gICAgICAgIC8vIGluIGhvcGVzIHRoYXQgdGhpcyBpcyBwcmVzZXJ2ZWQgZXZlbiBpZiBcIlxcdUZFRkZcIiBpcyB0cmFuc2Zvcm1lZCB0b1xuICAgICAgICAvLyB0aGUgYWN0dWFsIFVuaWNvZGUgY2hhcmFjdGVyIChieSBCYWJlbCwgZm9yIGV4YW1wbGUpLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9ibG9iL3YyLjQuMjAvbGliL3BhcnNlLmpzI0wyMTZcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkVGRikgKyBodG1sO1xuXG4gICAgICAgIC8vIGRlbGV0ZURhdGEgbGVhdmVzIGFuIGVtcHR5IGBUZXh0Tm9kZWAgd2hpY2ggb2Zmc2V0cyB0aGUgaW5kZXggb2YgYWxsXG4gICAgICAgIC8vIGNoaWxkcmVuLiBEZWZpbml0ZWx5IHdhbnQgdG8gYXZvaWQgdGhpcy5cbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGV4dE5vZGUuZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKHRleHROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0Tm9kZS5kZWxldGVEYXRhKDAsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0ZXN0RWxlbWVudCA9IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0SW5uZXJIVE1MOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEJhc2VkIG9uIHRoZSBlc2NhcGUtaHRtbCBsaWJyYXJ5LCB3aGljaCBpcyB1c2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSBiZWxvdzpcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxMyBUSiBIb2xvd2F5Y2h1a1xuICogQ29weXJpZ2h0IChjKSAyMDE1IEFuZHJlYXMgTHViYmVcbiAqIENvcHlyaWdodCAoYykgMjAxNSBUaWFuY2hlbmcgXCJUaW1vdGh5XCIgR3VcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogJ1NvZnR3YXJlJyksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cbiAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXG4gKiBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULFxuICogVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcbiAqIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vO1xuXG4vKipcbiAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZyBvZiBodG1sLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gZXNjYXBlIGZvciBpbnNlcnRpbmcgaW50byBIVE1MXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xuICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGVzY2FwZTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RJbmRleCA9IDA7XG5cbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgLy8gXCJcbiAgICAgICAgZXNjYXBlID0gJyZxdW90Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgLy8gJlxuICAgICAgICBlc2NhcGUgPSAnJmFtcDsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIC8vICdcbiAgICAgICAgZXNjYXBlID0gJyYjeDI3Oyc7IC8vIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWw7IHVzZWQgdG8gYmUgJyYjMzknXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgLy8gPFxuICAgICAgICBlc2NhcGUgPSAnJmx0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MjpcbiAgICAgICAgLy8gPlxuICAgICAgICBlc2NhcGUgPSAnJmd0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGU7XG4gIH1cblxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn1cbi8vIGVuZCBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxuXG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gdGhpcyBzaG9ydGNpcmN1aXQgaGVscHMgcGVyZiBmb3IgdHlwZXMgdGhhdCB3ZSBrbm93IHdpbGwgbmV2ZXIgaGF2ZVxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuICByZXR1cm4gZXNjYXBlSHRtbCh0ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LiBpbm5lclRleHQgaXMgYSBwb29yIHN1YnN0aXR1dGUgZm9yIHRleHRDb250ZW50IGFuZCwgYW1vbmcgbWFueVxuICogaXNzdWVzLCBpbnNlcnRzIDxicj4gaW5zdGVhZCBvZiB0aGUgbGl0ZXJhbCBuZXdsaW5lIGNoYXJzLiBpbm5lckhUTUwgYmVoYXZlc1xuICogYXMgaXQgc2hvdWxkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn07XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgaWYgKCEoJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgbm9kZS5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRJbm5lckhUTUwobm9kZSwgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VGV4dENvbnRlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTU5hbWVzcGFjZXMgPSByZXF1aXJlKCcuL0RPTU5hbWVzcGFjZXMnKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbicpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xuXG52YXIgRUxFTUVOVF9OT0RFX1RZUEUgPSAxO1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSA9IDExO1xuXG4vKipcbiAqIEluIElFICg4LTExKSBhbmQgRWRnZSwgYXBwZW5kaW5nIG5vZGVzIHdpdGggbm8gY2hpbGRyZW4gaXMgZHJhbWF0aWNhbGx5XG4gKiBmYXN0ZXIgdGhhbiBhcHBlbmRpbmcgYSBmdWxsIHN1YnRyZWUsIHNvIHdlIGVzc2VudGlhbGx5IHF1ZXVlIHVwIHRoZVxuICogLmFwcGVuZENoaWxkIGNhbGxzIGhlcmUgYW5kIGFwcGx5IHRoZW0gc28gZWFjaCBub2RlIGlzIGFkZGVkIHRvIGl0cyBwYXJlbnRcbiAqIGJlZm9yZSBhbnkgY2hpbGRyZW4gYXJlIGFkZGVkLlxuICpcbiAqIEluIG90aGVyIGJyb3dzZXJzLCBkb2luZyBzbyBpcyBzbG93ZXIgb3IgbmV1dHJhbCBjb21wYXJlZCB0byB0aGUgb3RoZXIgb3JkZXJcbiAqIChpbiBGaXJlZm94LCB0d2ljZSBhcyBzbG93KSBzbyB3ZSBvbmx5IGRvIHRoaXMgaW52ZXJzaW9uIGluIElFLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc3BpY3lqL2lubmVyaHRtbC12cy1jcmVhdGVlbGVtZW50LXZzLWNsb25lbm9kZS5cbiAqL1xudmFyIGVuYWJsZUxhenkgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPT09ICdudW1iZXInIHx8IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50ID09PSAnc3RyaW5nJyAmJiAvXFxiRWRnZVxcL1xcZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuZnVuY3Rpb24gaW5zZXJ0VHJlZUNoaWxkcmVuKHRyZWUpIHtcbiAgaWYgKCFlbmFibGVMYXp5KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBub2RlID0gdHJlZS5ub2RlO1xuICB2YXIgY2hpbGRyZW4gPSB0cmVlLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgaW5zZXJ0VHJlZUJlZm9yZShub2RlLCBjaGlsZHJlbltpXSwgbnVsbCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRyZWUuaHRtbCAhPSBudWxsKSB7XG4gICAgc2V0SW5uZXJIVE1MKG5vZGUsIHRyZWUuaHRtbCk7XG4gIH0gZWxzZSBpZiAodHJlZS50ZXh0ICE9IG51bGwpIHtcbiAgICBzZXRUZXh0Q29udGVudChub2RlLCB0cmVlLnRleHQpO1xuICB9XG59XG5cbnZhciBpbnNlcnRUcmVlQmVmb3JlID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAocGFyZW50Tm9kZSwgdHJlZSwgcmVmZXJlbmNlTm9kZSkge1xuICAvLyBEb2N1bWVudEZyYWdtZW50cyBhcmVuJ3QgYWN0dWFsbHkgcGFydCBvZiB0aGUgRE9NIGFmdGVyIGluc2VydGlvbiBzb1xuICAvLyBhcHBlbmRpbmcgY2hpbGRyZW4gd29uJ3QgdXBkYXRlIHRoZSBET00uIFdlIG5lZWQgdG8gZW5zdXJlIHRoZSBmcmFnbWVudFxuICAvLyBpcyBwcm9wZXJseSBwb3B1bGF0ZWQgZmlyc3QsIGJyZWFraW5nIG91dCBvZiBvdXIgbGF6eSBhcHByb2FjaCBmb3IganVzdFxuICAvLyB0aGlzIGxldmVsLiBBbHNvLCBzb21lIDxvYmplY3Q+IHBsdWdpbnMgKGxpa2UgRmxhc2ggUGxheWVyKSB3aWxsIHJlYWRcbiAgLy8gPHBhcmFtPiBub2RlcyBpbW1lZGlhdGVseSB1cG9uIGluc2VydGlvbiBpbnRvIHRoZSBET00sIHNvIDxvYmplY3Q+XG4gIC8vIG11c3QgYWxzbyBiZSBwb3B1bGF0ZWQgcHJpb3IgdG8gaW5zZXJ0aW9uIGludG8gdGhlIERPTS5cbiAgaWYgKHRyZWUubm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFIHx8IHRyZWUubm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgJiYgdHJlZS5ub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvYmplY3QnICYmICh0cmVlLm5vZGUubmFtZXNwYWNlVVJJID09IG51bGwgfHwgdHJlZS5ub2RlLm5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5odG1sKSkge1xuICAgIGluc2VydFRyZWVDaGlsZHJlbih0cmVlKTtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0cmVlLm5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRyZWUubm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gICAgaW5zZXJ0VHJlZUNoaWxkcmVuKHRyZWUpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gcmVwbGFjZUNoaWxkV2l0aFRyZWUob2xkTm9kZSwgbmV3VHJlZSkge1xuICBvbGROb2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld1RyZWUubm9kZSwgb2xkTm9kZSk7XG4gIGluc2VydFRyZWVDaGlsZHJlbihuZXdUcmVlKTtcbn1cblxuZnVuY3Rpb24gcXVldWVDaGlsZChwYXJlbnRUcmVlLCBjaGlsZFRyZWUpIHtcbiAgaWYgKGVuYWJsZUxhenkpIHtcbiAgICBwYXJlbnRUcmVlLmNoaWxkcmVuLnB1c2goY2hpbGRUcmVlKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnRUcmVlLm5vZGUuYXBwZW5kQ2hpbGQoY2hpbGRUcmVlLm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHF1ZXVlSFRNTCh0cmVlLCBodG1sKSB7XG4gIGlmIChlbmFibGVMYXp5KSB7XG4gICAgdHJlZS5odG1sID0gaHRtbDtcbiAgfSBlbHNlIHtcbiAgICBzZXRJbm5lckhUTUwodHJlZS5ub2RlLCBodG1sKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBxdWV1ZVRleHQodHJlZSwgdGV4dCkge1xuICBpZiAoZW5hYmxlTGF6eSkge1xuICAgIHRyZWUudGV4dCA9IHRleHQ7XG4gIH0gZWxzZSB7XG4gICAgc2V0VGV4dENvbnRlbnQodHJlZS5ub2RlLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHRoaXMubm9kZS5ub2RlTmFtZTtcbn1cblxuZnVuY3Rpb24gRE9NTGF6eVRyZWUobm9kZSkge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IG5vZGUsXG4gICAgY2hpbGRyZW46IFtdLFxuICAgIGh0bWw6IG51bGwsXG4gICAgdGV4dDogbnVsbCxcbiAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgfTtcbn1cblxuRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZSA9IGluc2VydFRyZWVCZWZvcmU7XG5ET01MYXp5VHJlZS5yZXBsYWNlQ2hpbGRXaXRoVHJlZSA9IHJlcGxhY2VDaGlsZFdpdGhUcmVlO1xuRE9NTGF6eVRyZWUucXVldWVDaGlsZCA9IHF1ZXVlQ2hpbGQ7XG5ET01MYXp5VHJlZS5xdWV1ZUhUTUwgPSBxdWV1ZUhUTUw7XG5ET01MYXp5VHJlZS5xdWV1ZVRleHQgPSBxdWV1ZVRleHQ7XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NTGF6eVRyZWU7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBDb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byBhcnJheXMuXG4gKlxuICogVGhpcyBBUEkgYXNzdW1lcyB0aGUgY2FsbGVyIGtub3dzIHRoZSBjb250ZW50cyBvZiB0aGUgZGF0YSB0eXBlLiBGb3IgbGVzc1xuICogd2VsbCBkZWZpbmVkIGlucHV0cyB1c2UgY3JlYXRlQXJyYXlGcm9tTWl4ZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb258ZmlsZWxpc3R9IG9ialxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gIHZhciBsZW5ndGggPSBvYmoubGVuZ3RoO1xuXG4gIC8vIFNvbWUgYnJvd3NlcnMgYnVpbHRpbiBvYmplY3RzIGNhbiByZXBvcnQgdHlwZW9mICdmdW5jdGlvbicgKGUuZy4gTm9kZUxpc3RcbiAgLy8gaW4gb2xkIHZlcnNpb25zIG9mIFNhZmFyaSkuXG4gICEoIUFycmF5LmlzQXJyYXkob2JqKSAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IEFycmF5LWxpa2Ugb2JqZWN0IGV4cGVjdGVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICEodHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBuZWVkcyBhIGxlbmd0aCBwcm9wZXJ0eScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAhKGxlbmd0aCA9PT0gMCB8fCBsZW5ndGggLSAxIGluIG9iaikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IHNob3VsZCBoYXZlIGtleXMgZm9yIGluZGljZXMnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgISh0eXBlb2Ygb2JqLmNhbGxlZSAhPT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IGNhblxcJ3QgYmUgYGFyZ3VtZW50c2AuIFVzZSByZXN0IHBhcmFtcyAnICsgJyhmdW5jdGlvbiguLi5hcmdzKSB7fSkgb3IgQXJyYXkuZnJvbSgpIGluc3RlYWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gIC8vIE9sZCBJRSBkb2Vzbid0IGdpdmUgY29sbGVjdGlvbnMgYWNjZXNzIHRvIGhhc093blByb3BlcnR5LiBBc3N1bWUgaW5wdXRzXG4gIC8vIHdpdGhvdXQgbWV0aG9kIHdpbGwgdGhyb3cgZHVyaW5nIHRoZSBzbGljZSBjYWxsIGFuZCBza2lwIHN0cmFpZ2h0IHRvIHRoZVxuICAvLyBmYWxsYmFjay5cbiAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJRSA8IDkgZG9lcyBub3Qgc3VwcG9ydCBBcnJheSNzbGljZSBvbiBjb2xsZWN0aW9ucyBvYmplY3RzXG4gICAgfVxuICB9XG5cbiAgLy8gRmFsbCBiYWNrIHRvIGNvcHlpbmcga2V5IGJ5IGtleS4gVGhpcyBhc3N1bWVzIGFsbCBrZXlzIGhhdmUgYSB2YWx1ZSxcbiAgLy8gc28gd2lsbCBub3QgcHJlc2VydmUgc3BhcnNlbHkgcG9wdWxhdGVkIGlucHV0cy5cbiAgdmFyIHJldCA9IEFycmF5KGxlbmd0aCk7XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW5ndGg7IGlpKyspIHtcbiAgICByZXRbaWldID0gb2JqW2lpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFBlcmZvcm0gYSBoZXVyaXN0aWMgdGVzdCB0byBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIFwiYXJyYXktbGlrZVwiLlxuICpcbiAqICAgQSBtb25rIGFza2VkIEpvc2h1LCBhIFplbiBtYXN0ZXIsIFwiSGFzIGEgZG9nIEJ1ZGRoYSBuYXR1cmU/XCJcbiAqICAgSm9zaHUgcmVwbGllZDogXCJNdS5cIlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyBpZiBpdHMgYXJndW1lbnQgaGFzIFwiYXJyYXkgbmF0dXJlXCI6IGl0IHJldHVybnNcbiAqIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFjdHVhbCBhcnJheSwgYW4gYGFyZ3VtZW50cycgb2JqZWN0LCBvciBhblxuICogSFRNTENvbGxlY3Rpb24gKGUuZy4gbm9kZS5jaGlsZE5vZGVzIG9yIG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoKSkuXG4gKlxuICogSXQgd2lsbCByZXR1cm4gZmFsc2UgZm9yIG90aGVyIGFycmF5LWxpa2Ugb2JqZWN0cyBsaWtlIEZpbGVsaXN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNBcnJheU5hdHVyZShvYmopIHtcbiAgcmV0dXJuIChcbiAgICAvLyBub3QgbnVsbC9mYWxzZVxuICAgICEhb2JqICYmIChcbiAgICAvLyBhcnJheXMgYXJlIG9iamVjdHMsIE5vZGVMaXN0cyBhcmUgZnVuY3Rpb25zIGluIFNhZmFyaVxuICAgIHR5cGVvZiBvYmogPT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nKSAmJlxuICAgIC8vIHF1YWNrcyBsaWtlIGFuIGFycmF5XG4gICAgJ2xlbmd0aCcgaW4gb2JqICYmXG4gICAgLy8gbm90IHdpbmRvd1xuICAgICEoJ3NldEludGVydmFsJyBpbiBvYmopICYmXG4gICAgLy8gbm8gRE9NIG5vZGUgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYW4gYXJyYXktbGlrZVxuICAgIC8vIGEgJ3NlbGVjdCcgZWxlbWVudCBoYXMgJ2xlbmd0aCcgYW5kICdpdGVtJyBwcm9wZXJ0aWVzIG9uIElFOFxuICAgIHR5cGVvZiBvYmoubm9kZVR5cGUgIT0gJ251bWJlcicgJiYgKFxuICAgIC8vIGEgcmVhbCBhcnJheVxuICAgIEFycmF5LmlzQXJyYXkob2JqKSB8fFxuICAgIC8vIGFyZ3VtZW50c1xuICAgICdjYWxsZWUnIGluIG9iaiB8fFxuICAgIC8vIEhUTUxDb2xsZWN0aW9uL05vZGVMaXN0XG4gICAgJ2l0ZW0nIGluIG9iailcbiAgKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXkgYnkgd3JhcHBpbmcgaXQgaW4gYW4gYXJyYXkgaWYgaXQgaXMgbm90LlxuICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIGFyZ3VtZW50IGlmIGl0IGlzIGFscmVhZHkgYW4gYXJyYXkuXG4gKlxuICogVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGlkaW9tYXRpY2FsbHk6XG4gKlxuICogICB2YXIgY3JlYXRlQXJyYXlGcm9tTWl4ZWQgPSByZXF1aXJlKCdjcmVhdGVBcnJheUZyb21NaXhlZCcpO1xuICpcbiAqICAgZnVuY3Rpb24gdGFrZXNPbmVPck1vcmVUaGluZ3ModGhpbmdzKSB7XG4gKiAgICAgdGhpbmdzID0gY3JlYXRlQXJyYXlGcm9tTWl4ZWQodGhpbmdzKTtcbiAqICAgICAuLi5cbiAqICAgfVxuICpcbiAqIFRoaXMgYWxsb3dzIHlvdSB0byB0cmVhdCBgdGhpbmdzJyBhcyBhbiBhcnJheSwgYnV0IGFjY2VwdCBzY2FsYXJzIGluIHRoZSBBUEkuXG4gKlxuICogSWYgeW91IG5lZWQgdG8gY29udmVydCBhbiBhcnJheS1saWtlIG9iamVjdCwgbGlrZSBgYXJndW1lbnRzYCwgaW50byBhbiBhcnJheVxuICogdXNlIHRvQXJyYXkgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5RnJvbU1peGVkKG9iaikge1xuICBpZiAoIWhhc0FycmF5TmF0dXJlKG9iaikpIHtcbiAgICByZXR1cm4gW29ial07XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0b0FycmF5KG9iaik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBcnJheUZyb21NaXhlZDsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBmYi13d3cvdW5zYWZlLWh0bWwgKi9cblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBEdW1teSBjb250YWluZXIgdXNlZCB0byBkZXRlY3Qgd2hpY2ggd3JhcHMgYXJlIG5lY2Vzc2FyeS5cbiAqL1xudmFyIGR1bW15Tm9kZSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcblxuLyoqXG4gKiBTb21lIGJyb3dzZXJzIGNhbm5vdCB1c2UgYGlubmVySFRNTGAgdG8gcmVuZGVyIGNlcnRhaW4gZWxlbWVudHMgc3RhbmRhbG9uZSxcbiAqIHNvIHdlIHdyYXAgdGhlbSwgcmVuZGVyIHRoZSB3cmFwcGVkIG5vZGVzLCB0aGVuIGV4dHJhY3QgdGhlIGRlc2lyZWQgbm9kZS5cbiAqXG4gKiBJbiBJRTgsIGNlcnRhaW4gZWxlbWVudHMgY2Fubm90IHJlbmRlciBhbG9uZSwgc28gd3JhcCBhbGwgZWxlbWVudHMgKCcqJykuXG4gKi9cblxudmFyIHNob3VsZFdyYXAgPSB7fTtcblxudmFyIHNlbGVjdFdyYXAgPSBbMSwgJzxzZWxlY3QgbXVsdGlwbGU9XCJ0cnVlXCI+JywgJzwvc2VsZWN0PiddO1xudmFyIHRhYmxlV3JhcCA9IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddO1xudmFyIHRyV3JhcCA9IFszLCAnPHRhYmxlPjx0Ym9keT48dHI+JywgJzwvdHI+PC90Ym9keT48L3RhYmxlPiddO1xuXG52YXIgc3ZnV3JhcCA9IFsxLCAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+JywgJzwvc3ZnPiddO1xuXG52YXIgbWFya3VwV3JhcCA9IHtcbiAgJyonOiBbMSwgJz88ZGl2PicsICc8L2Rpdj4nXSxcblxuICAnYXJlYSc6IFsxLCAnPG1hcD4nLCAnPC9tYXA+J10sXG4gICdjb2wnOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXSxcbiAgJ2xlZ2VuZCc6IFsxLCAnPGZpZWxkc2V0PicsICc8L2ZpZWxkc2V0PiddLFxuICAncGFyYW0nOiBbMSwgJzxvYmplY3Q+JywgJzwvb2JqZWN0PiddLFxuICAndHInOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcblxuICAnb3B0Z3JvdXAnOiBzZWxlY3RXcmFwLFxuICAnb3B0aW9uJzogc2VsZWN0V3JhcCxcblxuICAnY2FwdGlvbic6IHRhYmxlV3JhcCxcbiAgJ2NvbGdyb3VwJzogdGFibGVXcmFwLFxuICAndGJvZHknOiB0YWJsZVdyYXAsXG4gICd0Zm9vdCc6IHRhYmxlV3JhcCxcbiAgJ3RoZWFkJzogdGFibGVXcmFwLFxuXG4gICd0ZCc6IHRyV3JhcCxcbiAgJ3RoJzogdHJXcmFwXG59O1xuXG4vLyBJbml0aWFsaXplIHRoZSBTVkcgZWxlbWVudHMgc2luY2Ugd2Uga25vdyB0aGV5J2xsIGFsd2F5cyBuZWVkIHRvIGJlIHdyYXBwZWRcbi8vIGNvbnNpc3RlbnRseS4gSWYgdGhleSBhcmUgY3JlYXRlZCBpbnNpZGUgYSA8ZGl2PiB0aGV5IHdpbGwgYmUgaW5pdGlhbGl6ZWQgaW5cbi8vIHRoZSB3cm9uZyBuYW1lc3BhY2UgKGFuZCB3aWxsIG5vdCBkaXNwbGF5KS5cbnZhciBzdmdFbGVtZW50cyA9IFsnY2lyY2xlJywgJ2NsaXBQYXRoJywgJ2RlZnMnLCAnZWxsaXBzZScsICdnJywgJ2ltYWdlJywgJ2xpbmUnLCAnbGluZWFyR3JhZGllbnQnLCAnbWFzaycsICdwYXRoJywgJ3BhdHRlcm4nLCAncG9seWdvbicsICdwb2x5bGluZScsICdyYWRpYWxHcmFkaWVudCcsICdyZWN0JywgJ3N0b3AnLCAndGV4dCcsICd0c3BhbiddO1xuc3ZnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobm9kZU5hbWUpIHtcbiAgbWFya3VwV3JhcFtub2RlTmFtZV0gPSBzdmdXcmFwO1xuICBzaG91bGRXcmFwW25vZGVOYW1lXSA9IHRydWU7XG59KTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uIGZvciB0aGUgc3VwcGxpZWQgYG5vZGVOYW1lYC5cbiAqXG4gKiBOT1RFOiBUaGlzIGxhemlseSBkZXRlY3RzIHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5vZGVOYW1lIExvd2VyY2FzZSBgbm9kZU5hbWVgLlxuICogQHJldHVybiB7P2FycmF5fSBNYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uLCBpZiBhcHBsaWNhYmxlLlxuICovXG5mdW5jdGlvbiBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKSB7XG4gICEhIWR1bW15Tm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNYXJrdXAgd3JhcHBpbmcgbm9kZSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGlmICghbWFya3VwV3JhcC5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICBub2RlTmFtZSA9ICcqJztcbiAgfVxuICBpZiAoIXNob3VsZFdyYXAuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgaWYgKG5vZGVOYW1lID09PSAnKicpIHtcbiAgICAgIGR1bW15Tm9kZS5pbm5lckhUTUwgPSAnPGxpbmsgLz4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdW1teU5vZGUuaW5uZXJIVE1MID0gJzwnICsgbm9kZU5hbWUgKyAnPjwvJyArIG5vZGVOYW1lICsgJz4nO1xuICAgIH1cbiAgICBzaG91bGRXcmFwW25vZGVOYW1lXSA9ICFkdW1teU5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gc2hvdWxkV3JhcFtub2RlTmFtZV0gPyBtYXJrdXBXcmFwW25vZGVOYW1lXSA6IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFya3VwV3JhcDsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qZXNsaW50LWRpc2FibGUgZmItd3d3L3Vuc2FmZS1odG1sKi9cblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY3JlYXRlQXJyYXlGcm9tTWl4ZWQgPSByZXF1aXJlKCcuL2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XG52YXIgZ2V0TWFya3VwV3JhcCA9IHJlcXVpcmUoJy4vZ2V0TWFya3VwV3JhcCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gcmVuZGVyIGFsbCBtYXJrdXAuXG4gKi9cbnZhciBkdW1teU5vZGUgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogUGF0dGVybiB1c2VkIGJ5IGBnZXROb2RlTmFtZWAuXG4gKi9cbnZhciBub2RlTmFtZVBhdHRlcm4gPSAvXlxccyo8KFxcdyspLztcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgYG5vZGVOYW1lYCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIHN0cmluZyBvZiBtYXJrdXAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICogQHJldHVybiB7P3N0cmluZ30gTm9kZSBuYW1lIG9mIHRoZSBzdXBwbGllZCBtYXJrdXAuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG1hcmt1cCkge1xuICB2YXIgbm9kZU5hbWVNYXRjaCA9IG1hcmt1cC5tYXRjaChub2RlTmFtZVBhdHRlcm4pO1xuICByZXR1cm4gbm9kZU5hbWVNYXRjaCAmJiBub2RlTmFtZU1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBub2RlcyByZW5kZXJlZCBmcm9tIHRoZSBzdXBwbGllZCBtYXJrdXAuIFRoZVxuICogb3B0aW9uYWxseSBzdXBwbGllZCBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgb25jZSBmb3IgZWFjaFxuICogPHNjcmlwdD4gZWxlbWVudCB0aGF0IGlzIHJlbmRlcmVkLiBJZiBubyBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiBpcyBzdXBwbGllZCxcbiAqIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgYW55IDxzY3JpcHQ+IGVsZW1lbnRzIGFyZSByZW5kZXJlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIEEgc3RyaW5nIG9mIHZhbGlkIEhUTUwgbWFya3VwLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGhhbmRsZVNjcmlwdCBJbnZva2VkIG9uY2UgZm9yIGVhY2ggcmVuZGVyZWQgPHNjcmlwdD4uXG4gKiBAcmV0dXJuIHthcnJheTxET01FbGVtZW50fERPTVRleHROb2RlPn0gQW4gYXJyYXkgb2YgcmVuZGVyZWQgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGhhbmRsZVNjcmlwdCkge1xuICB2YXIgbm9kZSA9IGR1bW15Tm9kZTtcbiAgISEhZHVtbXlOb2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCBkdW1teSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBub2RlTmFtZSA9IGdldE5vZGVOYW1lKG1hcmt1cCk7XG5cbiAgdmFyIHdyYXAgPSBub2RlTmFtZSAmJiBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKTtcbiAgaWYgKHdyYXApIHtcbiAgICBub2RlLmlubmVySFRNTCA9IHdyYXBbMV0gKyBtYXJrdXAgKyB3cmFwWzJdO1xuXG4gICAgdmFyIHdyYXBEZXB0aCA9IHdyYXBbMF07XG4gICAgd2hpbGUgKHdyYXBEZXB0aC0tKSB7XG4gICAgICBub2RlID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gbWFya3VwO1xuICB9XG5cbiAgdmFyIHNjcmlwdHMgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgaWYgKHNjcmlwdHMubGVuZ3RoKSB7XG4gICAgIWhhbmRsZVNjcmlwdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVOb2Rlc0Zyb21NYXJrdXAoLi4uKTogVW5leHBlY3RlZCA8c2NyaXB0PiBlbGVtZW50IHJlbmRlcmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjcmVhdGVBcnJheUZyb21NaXhlZChzY3JpcHRzKS5mb3JFYWNoKGhhbmRsZVNjcmlwdCk7XG4gIH1cblxuICB2YXIgbm9kZXMgPSBBcnJheS5mcm9tKG5vZGUuY2hpbGROb2Rlcyk7XG4gIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5sYXN0Q2hpbGQpO1xuICB9XG4gIHJldHVybiBub2Rlcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXA7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cCA9IHJlcXVpcmUoJ2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCcpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBEYW5nZXIgPSB7XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGEgbm9kZSB3aXRoIGEgc3RyaW5nIG9mIG1hcmt1cCBhdCBpdHMgY3VycmVudCBwb3NpdGlvbiB3aXRoaW4gaXRzXG4gICAqIHBhcmVudC4gVGhlIG1hcmt1cCBtdXN0IHJlbmRlciBpbnRvIGEgc2luZ2xlIHJvb3Qgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBvbGRDaGlsZCBDaGlsZCBub2RlIHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRvIHJlbmRlciBpbiBwbGFjZSBvZiB0aGUgY2hpbGQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogZnVuY3Rpb24gKG9sZENoaWxkLCBtYXJrdXApIHtcbiAgICAhRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZW5kZXIgbWFya3VwIGluIGEgd29ya2VyIHRocmVhZC4gTWFrZSBzdXJlIGB3aW5kb3dgIGFuZCBgZG9jdW1lbnRgIGFyZSBhdmFpbGFibGUgZ2xvYmFsbHkgYmVmb3JlIHJlcXVpcmluZyBSZWFjdCB3aGVuIHVuaXQgdGVzdGluZyBvciB1c2UgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKSBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IF9wcm9kSW52YXJpYW50KCc1NicpIDogdm9pZCAwO1xuICAgICFtYXJrdXAgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogTWlzc2luZyBtYXJrdXAuJykgOiBfcHJvZEludmFyaWFudCgnNTcnKSA6IHZvaWQgMDtcbiAgICAhKG9sZENoaWxkLm5vZGVOYW1lICE9PSAnSFRNTCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZXBsYWNlIG1hcmt1cCBvZiB0aGUgPGh0bWw+IG5vZGUuIFRoaXMgaXMgYmVjYXVzZSBicm93c2VyIHF1aXJrcyBtYWtlIHRoaXMgdW5yZWxpYWJsZSBhbmQvb3Igc2xvdy4gSWYgeW91IHdhbnQgdG8gcmVuZGVyIHRvIHRoZSByb290IHlvdSBtdXN0IHVzZSBzZXJ2ZXIgcmVuZGVyaW5nLiBTZWUgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKS4nKSA6IF9wcm9kSW52YXJpYW50KCc1OCcpIDogdm9pZCAwO1xuXG4gICAgaWYgKHR5cGVvZiBtYXJrdXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwLCBlbXB0eUZ1bmN0aW9uKVswXTtcbiAgICAgIG9sZENoaWxkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld0NoaWxkLCBvbGRDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIERPTUxhenlUcmVlLnJlcGxhY2VDaGlsZFdpdGhUcmVlKG9sZENoaWxkLCBtYXJrdXApO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhbmdlcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgRGFuZ2VyID0gcmVxdWlyZSgnLi9EYW5nZXInKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbicpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG52YXIgc2V0VGV4dENvbnRlbnQgPSByZXF1aXJlKCcuL3NldFRleHRDb250ZW50Jyk7XG5cbmZ1bmN0aW9uIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCBub2RlKSB7XG4gIC8vIFNwZWNpYWwgY2FzZSBmb3IgdGV4dCBjb21wb25lbnRzLCB3aGljaCByZXR1cm4gW29wZW4sIGNsb3NlXSBjb21tZW50c1xuICAvLyBmcm9tIGdldEhvc3ROb2RlLlxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIG5vZGUgPSBub2RlWzFdO1xuICB9XG4gIHJldHVybiBub2RlID8gbm9kZS5uZXh0U2libGluZyA6IHBhcmVudE5vZGUuZmlyc3RDaGlsZDtcbn1cblxuLyoqXG4gKiBJbnNlcnRzIGBjaGlsZE5vZGVgIGFzIGEgY2hpbGQgb2YgYHBhcmVudE5vZGVgIGF0IHRoZSBgaW5kZXhgLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcGFyZW50Tm9kZSBQYXJlbnQgbm9kZSBpbiB3aGljaCB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNoaWxkTm9kZSBDaGlsZCBub2RlIHRvIGluc2VydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxuICogQGludGVybmFsXG4gKi9cbnZhciBpbnNlcnRDaGlsZEF0ID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAocGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIC8vIFdlIHJlbHkgZXhjbHVzaXZlbHkgb24gYGluc2VydEJlZm9yZShub2RlLCBudWxsKWAgaW5zdGVhZCBvZiBhbHNvIHVzaW5nXG4gIC8vIGBhcHBlbmRDaGlsZChub2RlKWAuIChVc2luZyBgdW5kZWZpbmVkYCBpcyBub3QgYWxsb3dlZCBieSBhbGwgYnJvd3NlcnMgc29cbiAgLy8gd2UgYXJlIGNhcmVmdWwgdG8gdXNlIGBudWxsYC4pXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59KTtcblxuZnVuY3Rpb24gaW5zZXJ0TGF6eVRyZWVDaGlsZEF0KHBhcmVudE5vZGUsIGNoaWxkVHJlZSwgcmVmZXJlbmNlTm9kZSkge1xuICBET01MYXp5VHJlZS5pbnNlcnRUcmVlQmVmb3JlKHBhcmVudE5vZGUsIGNoaWxkVHJlZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIG1vdmVDaGlsZChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGROb2RlKSkge1xuICAgIG1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIGNoaWxkTm9kZVswXSwgY2hpbGROb2RlWzFdLCByZWZlcmVuY2VOb2RlKTtcbiAgfSBlbHNlIHtcbiAgICBpbnNlcnRDaGlsZEF0KHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgY2hpbGROb2RlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkTm9kZSkpIHtcbiAgICB2YXIgY2xvc2luZ0NvbW1lbnQgPSBjaGlsZE5vZGVbMV07XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlWzBdO1xuICAgIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCBjbG9zaW5nQ29tbWVudCk7XG4gICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9zaW5nQ29tbWVudCk7XG4gIH1cbiAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZE5vZGUpO1xufVxuXG5mdW5jdGlvbiBtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBvcGVuaW5nQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQsIHJlZmVyZW5jZU5vZGUpIHtcbiAgdmFyIG5vZGUgPSBvcGVuaW5nQ29tbWVudDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgbm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gICAgaWYgKG5vZGUgPT09IGNsb3NpbmdDb21tZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbm9kZSA9IG5leHROb2RlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgc3RhcnROb2RlLCBjbG9zaW5nQ29tbWVudCkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBub2RlID0gc3RhcnROb2RlLm5leHRTaWJsaW5nO1xuICAgIGlmIChub2RlID09PSBjbG9zaW5nQ29tbWVudCkge1xuICAgICAgLy8gVGhlIGNsb3NpbmcgY29tbWVudCBpcyByZW1vdmVkIGJ5IFJlYWN0TXVsdGlDaGlsZC5cbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlRGVsaW1pdGVkVGV4dChvcGVuaW5nQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQsIHN0cmluZ1RleHQpIHtcbiAgdmFyIHBhcmVudE5vZGUgPSBvcGVuaW5nQ29tbWVudC5wYXJlbnROb2RlO1xuICB2YXIgbm9kZUFmdGVyQ29tbWVudCA9IG9wZW5pbmdDb21tZW50Lm5leHRTaWJsaW5nO1xuICBpZiAobm9kZUFmdGVyQ29tbWVudCA9PT0gY2xvc2luZ0NvbW1lbnQpIHtcbiAgICAvLyBUaGVyZSBhcmUgbm8gdGV4dCBub2RlcyBiZXR3ZWVuIHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nIGNvbW1lbnRzOyBpbnNlcnRcbiAgICAvLyBhIG5ldyBvbmUgaWYgc3RyaW5nVGV4dCBpc24ndCBlbXB0eS5cbiAgICBpZiAoc3RyaW5nVGV4dCkge1xuICAgICAgaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHJpbmdUZXh0KSwgbm9kZUFmdGVyQ29tbWVudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzdHJpbmdUZXh0KSB7XG4gICAgICAvLyBTZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgZmlyc3Qgbm9kZSBhZnRlciB0aGUgb3BlbmluZyBjb21tZW50LCBhbmRcbiAgICAgIC8vIHJlbW92ZSBhbGwgZm9sbG93aW5nIG5vZGVzIHVwIHVudGlsIHRoZSBjbG9zaW5nIGNvbW1lbnQuXG4gICAgICBzZXRUZXh0Q29udGVudChub2RlQWZ0ZXJDb21tZW50LCBzdHJpbmdUZXh0KTtcbiAgICAgIHJlbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgbm9kZUFmdGVyQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIG9wZW5pbmdDb21tZW50LCBjbG9zaW5nQ29tbWVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgIGluc3RhbmNlSUQ6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG9wZW5pbmdDb21tZW50KS5fZGVidWdJRCxcbiAgICAgIHR5cGU6ICdyZXBsYWNlIHRleHQnLFxuICAgICAgcGF5bG9hZDogc3RyaW5nVGV4dFxuICAgIH0pO1xuICB9XG59XG5cbnZhciBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCA9IERhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwID0gZnVuY3Rpb24gKG9sZENoaWxkLCBtYXJrdXAsIHByZXZJbnN0YW5jZSkge1xuICAgIERhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cChvbGRDaGlsZCwgbWFya3VwKTtcbiAgICBpZiAocHJldkluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgaW5zdGFuY2VJRDogcHJldkluc3RhbmNlLl9kZWJ1Z0lELFxuICAgICAgICB0eXBlOiAncmVwbGFjZSB3aXRoJyxcbiAgICAgICAgcGF5bG9hZDogbWFya3VwLnRvU3RyaW5nKClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV4dEluc3RhbmNlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobWFya3VwLm5vZGUpO1xuICAgICAgaWYgKG5leHRJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgICBpbnN0YW5jZUlEOiBuZXh0SW5zdGFuY2UuX2RlYnVnSUQsXG4gICAgICAgICAgdHlwZTogJ21vdW50JyxcbiAgICAgICAgICBwYXlsb2FkOiBtYXJrdXAudG9TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgdXBkYXRpbmcgd2l0aCBET00gY2hpbGRyZW4uXG4gKi9cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSB7XG5cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwLFxuXG4gIHJlcGxhY2VEZWxpbWl0ZWRUZXh0OiByZXBsYWNlRGVsaW1pdGVkVGV4dCxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy4gVGhlXG4gICAqIHVwZGF0ZSBjb25maWd1cmF0aW9ucyBhcmUgZWFjaCBleHBlY3RlZCB0byBoYXZlIGEgYHBhcmVudE5vZGVgIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc1VwZGF0ZXM6IGZ1bmN0aW9uIChwYXJlbnROb2RlLCB1cGRhdGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXJlbnROb2RlRGVidWdJRCA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKHBhcmVudE5vZGUpLl9kZWJ1Z0lEO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdXBkYXRlcy5sZW5ndGg7IGsrKykge1xuICAgICAgdmFyIHVwZGF0ZSA9IHVwZGF0ZXNba107XG4gICAgICBzd2l0Y2ggKHVwZGF0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ0lOU0VSVF9NQVJLVVAnOlxuICAgICAgICAgIGluc2VydExhenlUcmVlQ2hpbGRBdChwYXJlbnROb2RlLCB1cGRhdGUuY29udGVudCwgZ2V0Tm9kZUFmdGVyKHBhcmVudE5vZGUsIHVwZGF0ZS5hZnRlck5vZGUpKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgICAgIGluc3RhbmNlSUQ6IHBhcmVudE5vZGVEZWJ1Z0lELFxuICAgICAgICAgICAgICB0eXBlOiAnaW5zZXJ0IGNoaWxkJyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogeyB0b0luZGV4OiB1cGRhdGUudG9JbmRleCwgY29udGVudDogdXBkYXRlLmNvbnRlbnQudG9TdHJpbmcoKSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ01PVkVfRVhJU1RJTkcnOlxuICAgICAgICAgIG1vdmVDaGlsZChwYXJlbnROb2RlLCB1cGRhdGUuZnJvbU5vZGUsIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCB1cGRhdGUuYWZ0ZXJOb2RlKSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBwYXJlbnROb2RlRGVidWdJRCxcbiAgICAgICAgICAgICAgdHlwZTogJ21vdmUgY2hpbGQnLFxuICAgICAgICAgICAgICBwYXlsb2FkOiB7IGZyb21JbmRleDogdXBkYXRlLmZyb21JbmRleCwgdG9JbmRleDogdXBkYXRlLnRvSW5kZXggfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdTRVRfTUFSS1VQJzpcbiAgICAgICAgICBzZXRJbm5lckhUTUwocGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgICAgICAgaW5zdGFuY2VJRDogcGFyZW50Tm9kZURlYnVnSUQsXG4gICAgICAgICAgICAgIHR5cGU6ICdyZXBsYWNlIGNoaWxkcmVuJyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogdXBkYXRlLmNvbnRlbnQudG9TdHJpbmcoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdURVhUX0NPTlRFTlQnOlxuICAgICAgICAgIHNldFRleHRDb250ZW50KHBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50KTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgICAgIGluc3RhbmNlSUQ6IHBhcmVudE5vZGVEZWJ1Z0lELFxuICAgICAgICAgICAgICB0eXBlOiAncmVwbGFjZSB0ZXh0JyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogdXBkYXRlLmNvbnRlbnQudG9TdHJpbmcoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdSRU1PVkVfTk9ERSc6XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgdXBkYXRlLmZyb21Ob2RlKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgICAgIGluc3RhbmNlSUQ6IHBhcmVudE5vZGVEZWJ1Z0lELFxuICAgICAgICAgICAgICB0eXBlOiAncmVtb3ZlIGNoaWxkJyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogeyBmcm9tSW5kZXg6IHVwZGF0ZS5mcm9tSW5kZXggfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTUNoaWxkcmVuT3BlcmF0aW9uczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgdXNlZCB0byBwcm9jZXNzIHVwZGF0ZXMgdG8gRE9NIG5vZGVzLlxuICovXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBjb21wb25lbnQncyBjaGlsZHJlbiBieSBwcm9jZXNzaW5nIGEgc2VyaWVzIG9mIHVwZGF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gdXBkYXRlcyBMaXN0IG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IGZ1bmN0aW9uIChwYXJlbnRJbnN0LCB1cGRhdGVzKSB7XG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShwYXJlbnRJbnN0KTtcbiAgICBET01DaGlsZHJlbk9wZXJhdGlvbnMucHJvY2Vzc1VwZGF0ZXMobm9kZSwgdXBkYXRlcyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JRE9wZXJhdGlvbnM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0RE9NSURPcGVyYXRpb25zJyk7XG5cbi8qKlxuICogQWJzdHJhY3RzIGF3YXkgYWxsIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIHJlY29uY2lsZXIgdGhhdCByZXF1aXJlcyBrbm93bGVkZ2Ugb2ZcbiAqIHRoZSBicm93c2VyIGNvbnRleHQuIFRPRE86IFRoZXNlIGNhbGxlcnMgc2hvdWxkIGJlIHJlZmFjdG9yZWQgdG8gYXZvaWQgdGhlXG4gKiBuZWVkIGZvciB0aGlzIGluamVjdGlvbi5cbiAqL1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0ge1xuXG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IFJlYWN0RE9NSURPcGVyYXRpb25zLmRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyxcblxuICByZXBsYWNlTm9kZVdpdGhNYXJrdXA6IERPTUNoaWxkcmVuT3BlcmF0aW9ucy5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBpbnB1dC90ZXh0YXJlYSB0byBmb2N1c1xuICovXG5cbmZ1bmN0aW9uIGZvY3VzTm9kZShub2RlKSB7XG4gIC8vIElFOCBjYW4gdGhyb3cgXCJDYW4ndCBtb3ZlIGZvY3VzIHRvIHRoZSBjb250cm9sIGJlY2F1c2UgaXQgaXMgaW52aXNpYmxlLFxuICAvLyBub3QgZW5hYmxlZCwgb3Igb2YgYSB0eXBlIHRoYXQgZG9lcyBub3QgYWNjZXB0IHRoZSBmb2N1cy5cIiBmb3IgYWxsIGtpbmRzIG9mXG4gIC8vIHJlYXNvbnMgdGhhdCBhcmUgdG9vIGV4cGVuc2l2ZSBhbmQgZnJhZ2lsZSB0byB0ZXN0LlxuICB0cnkge1xuICAgIG5vZGUuZm9jdXMoKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c05vZGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG5cbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcblxudmFyIEF1dG9Gb2N1c1V0aWxzID0ge1xuICBmb2N1c0RPTUNvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIGZvY3VzTm9kZShSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0b0ZvY3VzVXRpbHM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZFJvdzogdHJ1ZSxcbiAgZ3JpZENvbHVtbjogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTtcblxuLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBNb3N0IHN0eWxlIHByb3BlcnRpZXMgY2FuIGJlIHVuc2V0IGJ5IGRvaW5nIC5zdHlsZVtwcm9wXSA9ICcnIGJ1dCBJRThcbiAqIGRvZXNuJ3QgbGlrZSBkb2luZyB0aGF0IHdpdGggc2hvcnRoYW5kIHByb3BlcnRpZXMgc28gZm9yIHRoZSBwcm9wZXJ0aWVzIHRoYXRcbiAqIElFOCBicmVha3Mgb24sIHdoaWNoIGFyZSBsaXN0ZWQgaGVyZSwgd2UgaW5zdGVhZCB1bnNldCBlYWNoIG9mIHRoZVxuICogaW5kaXZpZHVhbCBwcm9wZXJ0aWVzLiBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzODUuXG4gKiBUaGUgNC12YWx1ZSAnY2xvY2snIHByb3BlcnRpZXMgbGlrZSBtYXJnaW4sIHBhZGRpbmcsIGJvcmRlci13aWR0aCBzZWVtIHRvXG4gKiBiZWhhdmUgd2l0aG91dCBhbnkgcHJvYmxlbXMuIEN1cmlvdXNseSwgbGlzdC1zdHlsZSB3b3JrcyB0b28gd2l0aG91dCBhbnlcbiAqIHNwZWNpYWwgcHJvZGRpbmcuXG4gKi9cbnZhciBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnMgPSB7XG4gIGJhY2tncm91bmQ6IHtcbiAgICBiYWNrZ3JvdW5kQXR0YWNobWVudDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHRydWUsXG4gICAgYmFja2dyb3VuZEltYWdlOiB0cnVlLFxuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUmVwZWF0OiB0cnVlXG4gIH0sXG4gIGJhY2tncm91bmRQb3NpdGlvbjoge1xuICAgIGJhY2tncm91bmRQb3NpdGlvblg6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogdHJ1ZVxuICB9LFxuICBib3JkZXI6IHtcbiAgICBib3JkZXJXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJCb3R0b206IHtcbiAgICBib3JkZXJCb3R0b21XaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21TdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJCb3R0b21Db2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJMZWZ0OiB7XG4gICAgYm9yZGVyTGVmdFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckxlZnRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJMZWZ0Q29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyUmlnaHQ6IHtcbiAgICBib3JkZXJSaWdodFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclJpZ2h0U3R5bGU6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJUb3A6IHtcbiAgICBib3JkZXJUb3BXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJUb3BTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJUb3BDb2xvcjogdHJ1ZVxuICB9LFxuICBmb250OiB7XG4gICAgZm9udFN0eWxlOiB0cnVlLFxuICAgIGZvbnRWYXJpYW50OiB0cnVlLFxuICAgIGZvbnRXZWlnaHQ6IHRydWUsXG4gICAgZm9udFNpemU6IHRydWUsXG4gICAgbGluZUhlaWdodDogdHJ1ZSxcbiAgICBmb250RmFtaWx5OiB0cnVlXG4gIH0sXG4gIG91dGxpbmU6IHtcbiAgICBvdXRsaW5lV2lkdGg6IHRydWUsXG4gICAgb3V0bGluZVN0eWxlOiB0cnVlLFxuICAgIG91dGxpbmVDb2xvcjogdHJ1ZVxuICB9XG59O1xuXG52YXIgQ1NTUHJvcGVydHkgPSB7XG4gIGlzVW5pdGxlc3NOdW1iZXI6IGlzVW5pdGxlc3NOdW1iZXIsXG4gIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uczogc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgX2h5cGhlblBhdHRlcm4gPSAvLSguKS9nO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF9oeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZTsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW1lbGl6ZSA9IHJlcXVpcmUoJy4vY2FtZWxpemUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9eLW1zLS87XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbW96LXRyYW5zaXRpb24nKVxuICogICA8IFwiTW96VHJhbnNpdGlvblwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tcy10cmFuc2l0aW9uJylcbiAqICAgPCBcIm1zVHJhbnNpdGlvblwiXG4gKlxuICogQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICogKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBjYW1lbGl6ZShzdHJpbmcucmVwbGFjZShtc1BhdHRlcm4sICdtcy0nKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemVTdHlsZU5hbWU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENTU1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eScpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0gQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcjtcbnZhciBzdHlsZVdhcm5pbmdzID0ge307XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgY29tcG9uZW50KSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG5cbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgaXNOb25OdW1lcmljID0gaXNOYU4odmFsdWUpO1xuICBpZiAoaXNOb25OdW1lcmljIHx8IHZhbHVlID09PSAwIHx8IGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNVbml0bGVzc051bWJlcltuYW1lXSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlOyAvLyBjYXN0IHRvIHN0cmluZ1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gQWxsb3cgJzAnIHRvIHBhc3MgdGhyb3VnaCB3aXRob3V0IHdhcm5pbmcuIDAgaXMgYWxyZWFkeSBzcGVjaWFsIGFuZFxuICAgICAgLy8gZG9lc24ndCByZXF1aXJlIHVuaXRzLCBzbyB3ZSBkb24ndCBuZWVkIHRvIHdhcm4gYWJvdXQgaXQuXG4gICAgICBpZiAoY29tcG9uZW50ICYmIHZhbHVlICE9PSAnMCcpIHtcbiAgICAgICAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgIHZhciBvd25lck5hbWUgPSBvd25lciA/IG93bmVyLmdldE5hbWUoKSA6IG51bGw7XG4gICAgICAgIGlmIChvd25lck5hbWUgJiYgIXN0eWxlV2FybmluZ3Nbb3duZXJOYW1lXSkge1xuICAgICAgICAgIHN0eWxlV2FybmluZ3Nbb3duZXJOYW1lXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgIHZhciB3YXJuaW5ncyA9IHN0eWxlV2FybmluZ3Nbb3duZXJOYW1lXTtcbiAgICAgICAgICB3YXJuZWQgPSB3YXJuaW5nc1tuYW1lXTtcbiAgICAgICAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgICAgICAgd2FybmluZ3NbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYSBgJXNgIHRhZyAob3duZXI6IGAlc2ApIHdhcyBwYXNzZWQgYSBudW1lcmljIHN0cmluZyB2YWx1ZSAnICsgJ2ZvciBDU1MgcHJvcGVydHkgYCVzYCAodmFsdWU6IGAlc2ApIHdoaWNoIHdpbGwgYmUgdHJlYXRlZCAnICsgJ2FzIGEgdW5pdGxlc3MgbnVtYmVyIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgUmVhY3QuJywgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC50eXBlLCBvd25lck5hbWUgfHwgJ3Vua25vd24nLCBuYW1lLCB2YWx1ZSkgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlICsgJ3B4Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkYW5nZXJvdXNTdHlsZVZhbHVlOyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHlwaGVuYXRlID0gcmVxdWlyZSgnLi9oeXBoZW5hdGUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBoeXBoZW5hdGUoc3RyaW5nKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGVTdHlsZU5hbWU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTWVtb2l6ZXMgdGhlIHJldHVybiB2YWx1ZSBvZiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmUgc3RyaW5nIGFyZ3VtZW50LlxuICovXG5cbmZ1bmN0aW9uIG1lbW9pemVTdHJpbmdPbmx5KGNhbGxiYWNrKSB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIGlmICghY2FjaGUuaGFzT3duUHJvcGVydHkoc3RyaW5nKSkge1xuICAgICAgY2FjaGVbc3RyaW5nXSA9IGNhbGxiYWNrLmNhbGwodGhpcywgc3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW3N0cmluZ107XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZVN0cmluZ09ubHk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENTU1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eScpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIGNhbWVsaXplU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUnKTtcbnZhciBkYW5nZXJvdXNTdHlsZVZhbHVlID0gcmVxdWlyZSgnLi9kYW5nZXJvdXNTdHlsZVZhbHVlJyk7XG52YXIgaHlwaGVuYXRlU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lJyk7XG52YXIgbWVtb2l6ZVN0cmluZ09ubHkgPSByZXF1aXJlKCdmYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seScpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBwcm9jZXNzU3R5bGVOYW1lID0gbWVtb2l6ZVN0cmluZ09ubHkoZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xuICByZXR1cm4gaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSk7XG59KTtcblxudmFyIGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnID0gZmFsc2U7XG52YXIgc3R5bGVGbG9hdEFjY2Vzc29yID0gJ2Nzc0Zsb2F0JztcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdmFyIHRlbXBTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICB0cnkge1xuICAgIC8vIElFOCB0aHJvd3MgXCJJbnZhbGlkIGFyZ3VtZW50LlwiIGlmIHJlc2V0dGluZyBzaG9ydGhhbmQgc3R5bGUgcHJvcGVydGllcy5cbiAgICB0ZW1wU3R5bGUuZm9udCA9ICcnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgPSB0cnVlO1xuICB9XG4gIC8vIElFOCBvbmx5IHN1cHBvcnRzIGFjY2Vzc2luZyBjc3NGbG9hdCAoc3RhbmRhcmQpIGFzIHN0eWxlRmxvYXRcbiAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jc3NGbG9hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3R5bGVGbG9hdEFjY2Vzc29yID0gJ3N0eWxlRmxvYXQnO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcblxuICAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuXG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG4gIHZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xuICB2YXIgd2FybmVkRm9yTmFOVmFsdWUgPSBmYWxzZTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSksIGNoZWNrUmVuZGVyTWVzc2FnZShvd25lcikpIDogdm9pZCAwO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvd25lcikge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1N0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuXFwndCBjb250YWluIGEgc2VtaWNvbG9uLiVzICcgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkRm9yTmFOVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgY2hlY2tSZW5kZXJNZXNzYWdlID0gZnVuY3Rpb24gKG93bmVyKSB7XG4gICAgaWYgKG93bmVyKSB7XG4gICAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICovXG4gIHZhciB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgY29tcG9uZW50KSB7XG4gICAgdmFyIG93bmVyO1xuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgfVxuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lLCBvd25lcik7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUsIG93bmVyKTtcbiAgICB9IGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlLCBvd25lcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlLCBvd25lcik7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xudmFyIENTU1Byb3BlcnR5T3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogU2VyaWFsaXplcyBhIG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyBmb3IgdXNlIGFzIGlubGluZSBzdHlsZXM6XG4gICAqXG4gICAqICAgPiBjcmVhdGVNYXJrdXBGb3JTdHlsZXMoe3dpZHRoOiAnMjAwcHgnLCBoZWlnaHQ6IDB9KVxuICAgKiAgIFwid2lkdGg6MjAwcHg7aGVpZ2h0OjA7XCJcbiAgICpcbiAgICogVW5kZWZpbmVkIHZhbHVlcyBhcmUgaWdub3JlZCBzbyB0aGF0IGRlY2xhcmF0aXZlIHByb2dyYW1taW5nIGlzIGVhc2llci5cbiAgICogVGhlIHJlc3VsdCBzaG91bGQgYmUgSFRNTC1lc2NhcGVkIGJlZm9yZSBpbnNlcnRpb24gaW50byB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gICAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yU3R5bGVzOiBmdW5jdGlvbiAoc3R5bGVzLCBjb21wb25lbnQpIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBjb21wb25lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXJpYWxpemVkICs9IHByb2Nlc3NTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgY29tcG9uZW50KSArICc7JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICAgKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqL1xuICBzZXRWYWx1ZUZvclN0eWxlczogZnVuY3Rpb24gKG5vZGUsIHN0eWxlcywgY29tcG9uZW50KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBjb21wb25lbnQuX2RlYnVnSUQsXG4gICAgICAgIHR5cGU6ICd1cGRhdGUgc3R5bGVzJyxcbiAgICAgICAgcGF5bG9hZDogc3R5bGVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBjb21wb25lbnQpO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGNvbXBvbmVudCk7XG4gICAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnIHx8IHN0eWxlTmFtZSA9PT0gJ2Nzc0Zsb2F0Jykge1xuICAgICAgICBzdHlsZU5hbWUgPSBzdHlsZUZsb2F0QWNjZXNzb3I7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSkge1xuICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBhbnNpb24gPSBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyAmJiBDU1NQcm9wZXJ0eS5zaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNbc3R5bGVOYW1lXTtcbiAgICAgICAgaWYgKGV4cGFuc2lvbikge1xuICAgICAgICAgIC8vIFNob3J0aGFuZCBwcm9wZXJ0eSB0aGF0IElFOCB3b24ndCBsaWtlIHVuc2V0dGluZywgc28gdW5zZXQgZWFjaFxuICAgICAgICAgIC8vIGNvbXBvbmVudCB0byBwbGFjYXRlIGl0XG4gICAgICAgICAgZm9yICh2YXIgaW5kaXZpZHVhbFN0eWxlTmFtZSBpbiBleHBhbnNpb24pIHtcbiAgICAgICAgICAgIHN0eWxlW2luZGl2aWR1YWxTdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5T3BlcmF0aW9uczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcblxuLyoqXG4gKiBFc2NhcGVzIGF0dHJpYnV0ZSB2YWx1ZSB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpIHtcbiAgcmV0dXJuICdcIicgKyBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodmFsdWUpICsgJ1wiJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXVsnICsgRE9NUHJvcGVydHkuQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5cbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgJiYgIXZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgJiYgaXNOYU4odmFsdWUpIHx8IHByb3BlcnR5SW5mby5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSAmJiB2YWx1ZSA8IDEgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IGZhbHNlO1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBET00gcHJvcGVydGllcy5cbiAqL1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBJRCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuZXNjYXBlZCBJRC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9ySUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKGlkKTtcbiAgfSxcblxuICBzZXRBdHRyaWJ1dGVGb3JJRDogZnVuY3Rpb24gKG5vZGUsIGlkKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUUsIGlkKTtcbiAgfSxcblxuICBjcmVhdGVNYXJrdXBGb3JSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIERPTVByb3BlcnR5LlJPT1RfQVRUUklCVVRFX05BTUUgKyAnPVwiXCInO1xuICB9LFxuXG4gIHNldEF0dHJpYnV0ZUZvclJvb3Q6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoRE9NUHJvcGVydHkuUk9PVF9BVFRSSUJVVEVfTkFNRSwgJycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBudWxsIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvclByb3BlcnR5OiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgKyAnPVwiXCInO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBjdXN0b20gcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBlbXB0eSBzdHJpbmcgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgc2V0VmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2Q7XG4gICAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSkge1xuICAgICAgICB0aGlzLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgICAvLyBDb250cmFyeSB0byBgc2V0QXR0cmlidXRlYCwgb2JqZWN0IHByb3BlcnRpZXMgYXJlIHByb3Blcmx5XG4gICAgICAgIC8vIGB0b1N0cmluZ2BlZCBieSBJRTgvOS5cbiAgICAgICAgbm9kZVtwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2U7XG4gICAgICAgIC8vIGBzZXRBdHRyaWJ1dGVgIHdpdGggb2JqZWN0cyBiZWNvbWVzIG9ubHkgYFtvYmplY3RdYCBpbiBJRTgvOSxcbiAgICAgICAgLy8gKCcnICsgdmFsdWUpIG1ha2VzIGl0IG91dHB1dCB0aGUgY29ycmVjdCB0b1N0cmluZygpLXZhbHVlLlxuICAgICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGF5bG9hZCA9IHt9O1xuICAgICAgcGF5bG9hZFtuYW1lXSA9IHZhbHVlO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgIGluc3RhbmNlSUQ6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELFxuICAgICAgICB0eXBlOiAndXBkYXRlIGF0dHJpYnV0ZScsXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICBzZXRWYWx1ZUZvckF0dHJpYnV0ZTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXlsb2FkID0ge307XG4gICAgICBwYXlsb2FkW25hbWVdID0gdmFsdWU7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgaW5zdGFuY2VJRDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsXG4gICAgICAgIHR5cGU6ICd1cGRhdGUgYXR0cmlidXRlJyxcbiAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIGF0dHJpYnV0ZXMgZnJvbSBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGU6IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKS5fZGVidWdJRCxcbiAgICAgICAgdHlwZTogJ3JlbW92ZSBhdHRyaWJ1dGUnLFxuICAgICAgICBwYXlsb2FkOiBuYW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqL1xuICBkZWxldGVWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHVuZGVmaW5lZCk7XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZTtcbiAgICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUpIHtcbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgIGluc3RhbmNlSUQ6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELFxuICAgICAgICB0eXBlOiAncmVtb3ZlIGF0dHJpYnV0ZScsXG4gICAgICAgIHBheWxvYWQ6IG5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5T3BlcmF0aW9uczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cykge1xuICBFdmVudFBsdWdpbkh1Yi5lbnF1ZXVlRXZlbnRzKGV2ZW50cyk7XG4gIEV2ZW50UGx1Z2luSHViLnByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIFN0cmVhbXMgYSBmaXJlZCB0b3AtbGV2ZWwgZXZlbnQgdG8gYEV2ZW50UGx1Z2luSHViYCB3aGVyZSBwbHVnaW5zIGhhdmUgdGhlXG4gICAqIG9wcG9ydHVuaXR5IHRvIGNyZWF0ZSBgUmVhY3RFdmVudGBzIHRvIGJlIGRpc3BhdGNoZWQuXG4gICAqL1xuICBoYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGV2ZW50cyA9IEV2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudEVtaXR0ZXJNaXhpbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgbWFwcGluZyBvZiBzdGFuZGFyZCB2ZW5kb3IgcHJlZml4ZXMgdXNpbmcgdGhlIGRlZmluZWQgc3R5bGUgcHJvcGVydHkgYW5kIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlUHJvcFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gbWFrZVByZWZpeE1hcChzdHlsZVByb3AsIGV2ZW50TmFtZSkge1xuICB2YXIgcHJlZml4ZXMgPSB7fTtcblxuICBwcmVmaXhlc1tzdHlsZVByb3AudG9Mb3dlckNhc2UoKV0gPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcHJlZml4ZXNbJ1dlYmtpdCcgKyBzdHlsZVByb3BdID0gJ3dlYmtpdCcgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydNb3onICsgc3R5bGVQcm9wXSA9ICdtb3onICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snbXMnICsgc3R5bGVQcm9wXSA9ICdNUycgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydPJyArIHN0eWxlUHJvcF0gPSAnbycgKyBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcblxuICByZXR1cm4gcHJlZml4ZXM7XG59XG5cbi8qKlxuICogQSBsaXN0IG9mIGV2ZW50IG5hbWVzIHRvIGEgY29uZmlndXJhYmxlIGxpc3Qgb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgdmVuZG9yUHJlZml4ZXMgPSB7XG4gIGFuaW1hdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkVuZCcpLFxuICBhbmltYXRpb25pdGVyYXRpb246IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25JdGVyYXRpb24nKSxcbiAgYW5pbWF0aW9uc3RhcnQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25TdGFydCcpLFxuICB0cmFuc2l0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdUcmFuc2l0aW9uJywgJ1RyYW5zaXRpb25FbmQnKVxufTtcblxuLyoqXG4gKiBFdmVudCBuYW1lcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGRldGVjdGVkIGFuZCBwcmVmaXhlZCAoaWYgYXBwbGljYWJsZSkuXG4gKi9cbnZhciBwcmVmaXhlZEV2ZW50TmFtZXMgPSB7fTtcblxuLyoqXG4gKiBFbGVtZW50IHRvIGNoZWNrIGZvciBwcmVmaXhlcyBvbi5cbiAqL1xudmFyIHN0eWxlID0ge307XG5cbi8qKlxuICogQm9vdHN0cmFwIGlmIGEgRE9NIGV4aXN0cy5cbiAqL1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuXG4gIC8vIE9uIHNvbWUgcGxhdGZvcm1zLCBpbiBwYXJ0aWN1bGFyIHNvbWUgcmVsZWFzZXMgb2YgQW5kcm9pZCA0LngsXG4gIC8vIHRoZSB1bi1wcmVmaXhlZCBcImFuaW1hdGlvblwiIGFuZCBcInRyYW5zaXRpb25cIiBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIG9uIHRoZVxuICAvLyBzdHlsZSBvYmplY3QgYnV0IHRoZSBldmVudHMgdGhhdCBmaXJlIHdpbGwgc3RpbGwgYmUgcHJlZml4ZWQsIHNvIHdlIG5lZWRcbiAgLy8gdG8gY2hlY2sgaWYgdGhlIHVuLXByZWZpeGVkIGV2ZW50cyBhcmUgdXNhYmxlLCBhbmQgaWYgbm90IHJlbW92ZSB0aGVtIGZyb20gdGhlIG1hcC5cbiAgaWYgKCEoJ0FuaW1hdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbmVuZC5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbjtcbiAgfVxuXG4gIC8vIFNhbWUgYXMgYWJvdmVcbiAgaWYgKCEoJ1RyYW5zaXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb247XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgdmVuZG9yIHByZWZpeGVkIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoZXZlbnROYW1lKSB7XG4gIGlmIChwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSkge1xuICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXTtcbiAgfSBlbHNlIGlmICghdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXSkge1xuICAgIHJldHVybiBldmVudE5hbWU7XG4gIH1cblxuICB2YXIgcHJlZml4TWFwID0gdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXTtcblxuICBmb3IgKHZhciBzdHlsZVByb3AgaW4gcHJlZml4TWFwKSB7XG4gICAgaWYgKHByZWZpeE1hcC5oYXNPd25Qcm9wZXJ0eShzdHlsZVByb3ApICYmIHN0eWxlUHJvcCBpbiBzdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdID0gcHJlZml4TWFwW3N0eWxlUHJvcF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSByZXF1aXJlKCcuL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4nKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKCcuL1ZpZXdwb3J0TWV0cmljcycpO1xuXG52YXIgZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUgPSByZXF1aXJlKCcuL2dldFZlbmRvclByZWZpeGVkRXZlbnROYW1lJyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RFdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0IHBsdWdnYWJsZVxuICogICAgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGhhc0V2ZW50UGFnZVhZO1xudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gZmFsc2U7XG52YXIgcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyID0gMDtcblxuLy8gRm9yIGV2ZW50cyBsaWtlICdzdWJtaXQnIHdoaWNoIGRvbid0IGNvbnNpc3RlbnRseSBidWJibGUgKHdoaWNoIHdlIHRyYXAgYXQgYVxuLy8gbG93ZXIgbm9kZSB0aGFuIGBkb2N1bWVudGApLCBiaW5kaW5nIGF0IGBkb2N1bWVudGAgd291bGQgY2F1c2UgZHVwbGljYXRlXG4vLyBldmVudHMgc28gd2UgZG9uJ3QgaW5jbHVkZSB0aGVtIGhlcmVcbnZhciB0b3BFdmVudE1hcHBpbmcgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BBbmltYXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25lbmQnKSB8fCAnYW5pbWF0aW9uZW5kJyxcbiAgdG9wQW5pbWF0aW9uSXRlcmF0aW9uOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJykgfHwgJ2FuaW1hdGlvbml0ZXJhdGlvbicsXG4gIHRvcEFuaW1hdGlvblN0YXJ0OiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uc3RhcnQnKSB8fCAnYW5pbWF0aW9uc3RhcnQnLFxuICB0b3BCbHVyOiAnYmx1cicsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcENoYW5nZTogJ2NoYW5nZScsXG4gIHRvcENsaWNrOiAnY2xpY2snLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BNb3VzZURvd246ICdtb3VzZWRvd24nLFxuICB0b3BNb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3BNb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgdG9wTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgdG9wTW91c2VVcDogJ21vdXNldXAnLFxuICB0b3BQYXN0ZTogJ3Bhc3RlJyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTY3JvbGw6ICdzY3JvbGwnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFNlbGVjdGlvbkNoYW5nZTogJ3NlbGVjdGlvbmNoYW5nZScsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUZXh0SW5wdXQ6ICd0ZXh0SW5wdXQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFRvdWNoQ2FuY2VsOiAndG91Y2hjYW5jZWwnLFxuICB0b3BUb3VjaEVuZDogJ3RvdWNoZW5kJyxcbiAgdG9wVG91Y2hNb3ZlOiAndG91Y2htb3ZlJyxcbiAgdG9wVG91Y2hTdGFydDogJ3RvdWNoc3RhcnQnLFxuICB0b3BUcmFuc2l0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgndHJhbnNpdGlvbmVuZCcpIHx8ICd0cmFuc2l0aW9uZW5kJyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnLFxuICB0b3BXaGVlbDogJ3doZWVsJ1xufTtcblxuLyoqXG4gKiBUbyBlbnN1cmUgbm8gY29uZmxpY3RzIHdpdGggb3RoZXIgcG90ZW50aWFsIFJlYWN0IGluc3RhbmNlcyBvbiB0aGUgcGFnZVxuICovXG52YXIgdG9wTGlzdGVuZXJzSURLZXkgPSAnX3JlYWN0TGlzdGVuZXJzSUQnICsgU3RyaW5nKE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBpcyB1c2VkIHRvIGF0dGFjaCB0b3AtbGV2ZWwgZXZlbnQgbGlzdGVuZXJzLiBGb3JcbiAqIGV4YW1wbGU6XG4gKlxuICogICBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcignbXlJRCcsICdvbkNsaWNrJywgbXlGdW5jdGlvbik7XG4gKlxuICogVGhpcyB3b3VsZCBhbGxvY2F0ZSBhIFwicmVnaXN0cmF0aW9uXCIgb2YgYCgnb25DbGljaycsIG15RnVuY3Rpb24pYCBvbiAnbXlJRCcuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSBfYXNzaWduKHt9LCBSZWFjdEV2ZW50RW1pdHRlck1peGluLCB7XG5cbiAgLyoqXG4gICAqIEluamVjdGFibGUgZXZlbnQgYmFja2VuZFxuICAgKi9cbiAgUmVhY3RFdmVudExpc3RlbmVyOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAgICAgKi9cbiAgICBpbmplY3RSZWFjdEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChSZWFjdEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5zZXRIYW5kbGVUb3BMZXZlbChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaGFuZGxlVG9wTGV2ZWwpO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciBvciBub3QgYW55IGNyZWF0ZWQgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBpZiBjYWxsYmFja3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgIGlmIChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnNldEVuYWJsZWQoZW5hYmxlZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGNhbGxiYWNrcyBhcmUgZW5hYmxlZC5cbiAgICovXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIShSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyICYmIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuaXNFbmFibGVkKCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gICAqXG4gICAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAgICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAgICogZWxlbWVudC4gVGhlIHN5bXB0b21zIHdlcmUgdGhhdCBpZiB5b3VyIG1vdXNlIGlzIG5vdCBtb3Zpbmcgb3ZlciBzb21ldGhpbmdcbiAgICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAgICogcmVnaXN0ZXIgdGhlIGBtb3VzZW1vdmVgIG9uIHRoZSBkb2N1bWVudCBvYmplY3QsIHRoZW4gaXQgd2lsbCBvZiBjb3Vyc2VcbiAgICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gICAqIG1vdmVtZW50IHR5cGVzIG9mIGV2ZW50cyBhbmQgcG9zc2libHkgYWxsIGV2ZW50cy5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAgKlxuICAgKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gICAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gICAqL1xuICBsaXN0ZW5UbzogZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICAgIHZhciBtb3VudEF0ID0gY29udGVudERvY3VtZW50SGFuZGxlO1xuICAgIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BXaGVlbCcpIHtcbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnd2hlZWwnKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BXaGVlbCcsICd3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnbW91c2V3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ21vdXNld2hlZWwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyZWZveCBuZWVkcyB0byBjYXB0dXJlIGEgZGlmZmVyZW50IG1vdXNlIHNjcm9sbCBldmVudC5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Rlc3RzL3Njcm9sbC5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BTY3JvbGwnKSB7XG5cbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQoJ3RvcFNjcm9sbCcsICdzY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BTY3JvbGwnLCAnc2Nyb2xsJywgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5XSU5ET1dfSEFORExFKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcEZvY3VzJyB8fCBkZXBlbmRlbmN5ID09PSAndG9wQmx1cicpIHtcblxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1cycsIHRydWUpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1cycsIG1vdW50QXQpO1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCgndG9wQmx1cicsICdibHVyJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1c2luJykpIHtcbiAgICAgICAgICAgIC8vIElFIGhhcyBgZm9jdXNpbmAgYW5kIGBmb2N1c291dGAgZXZlbnRzIHdoaWNoIGJ1YmJsZS5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMDgvMDQvZGVsZWdhdGluZ190aGUuaHRtbFxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1c2luJywgbW91bnRBdCk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEJsdXInLCAnZm9jdXNvdXQnLCBtb3VudEF0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0byBtYWtlIHN1cmUgYmx1ciBhbmQgZm9jdXMgZXZlbnQgbGlzdGVuZXJzIGFyZSBvbmx5IGF0dGFjaGVkIG9uY2VcbiAgICAgICAgICBpc0xpc3RlbmluZy50b3BCbHVyID0gdHJ1ZTtcbiAgICAgICAgICBpc0xpc3RlbmluZy50b3BGb2N1cyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodG9wRXZlbnRNYXBwaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIHRvcEV2ZW50TWFwcGluZ1tkZXBlbmRlbmN5XSwgbW91bnRBdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgcmV0dXJuIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfSxcblxuICB0cmFwQ2FwdHVyZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKTtcbiAgfSxcblxuICAvKipcbiAgICogUHJvdGVjdCBhZ2FpbnN0IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCkgcmV0dXJuaW5nIG51bGxcbiAgICogU29tZSBwb3B1cCBibG9ja2VyIGV4dGVuc2lvbnMgYXBwZWFyIHRvIGRvIHRoaXM6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjg4N1xuICAgKi9cbiAgc3VwcG9ydHNFdmVudFBhZ2VYWTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnQnKTtcbiAgICByZXR1cm4gZXYgIT0gbnVsbCAmJiAncGFnZVgnIGluIGV2O1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIHdpbmRvdyBzY3JvbGwgYW5kIHJlc2l6ZSBldmVudHMuIFdlIGNhY2hlIHNjcm9sbCB2YWx1ZXMgc28gdGhhdFxuICAgKiBhcHBsaWNhdGlvbiBjb2RlIGNhbiBhY2Nlc3MgdGhlbSB3aXRob3V0IHRyaWdnZXJpbmcgcmVmbG93cy5cbiAgICpcbiAgICogVmlld3BvcnRNZXRyaWNzIGlzIG9ubHkgdXNlZCBieSBTeW50aGV0aWNNb3VzZS9Ub3VjaEV2ZW50IGFuZCBvbmx5IHdoZW5cbiAgICogcGFnZVgvcGFnZVkgaXNuJ3Qgc3VwcG9ydGVkIChsZWdhY3kgYnJvd3NlcnMpLlxuICAgKlxuICAgKiBOT1RFOiBTY3JvbGwgZXZlbnRzIGRvIG5vdCBidWJibGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Njcm9sbC5odG1sXG4gICAqL1xuICBlbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3Jpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaGFzRXZlbnRQYWdlWFkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaGFzRXZlbnRQYWdlWFkgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc3VwcG9ydHNFdmVudFBhZ2VYWSgpO1xuICAgIH1cbiAgICBpZiAoIWhhc0V2ZW50UGFnZVhZICYmICFpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSkge1xuICAgICAgdmFyIHJlZnJlc2ggPSBWaWV3cG9ydE1ldHJpY3MucmVmcmVzaFNjcm9sbFZhbHVlcztcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIubW9uaXRvclNjcm9sbFZhbHVlKHJlZnJlc2gpO1xuICAgICAgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdCcpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gICdidXR0b24nOiB0cnVlLFxuICAnY2hlY2tib3gnOiB0cnVlLFxuICAnaW1hZ2UnOiB0cnVlLFxuICAnaGlkZGVuJzogdHJ1ZSxcbiAgJ3JhZGlvJzogdHJ1ZSxcbiAgJ3Jlc2V0JzogdHJ1ZSxcbiAgJ3N1Ym1pdCc6IHRydWVcbn07XG5cbmZ1bmN0aW9uIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpIHtcbiAgIShpbnB1dFByb3BzLmNoZWNrZWRMaW5rID09IG51bGwgfHwgaW5wdXRQcm9wcy52YWx1ZUxpbmsgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSB2YWx1ZUxpbmsuIElmIHlvdSB3YW50IHRvIHVzZSBjaGVja2VkTGluaywgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rIGFuZCB2aWNlIHZlcnNhLicpIDogX3Byb2RJbnZhcmlhbnQoJzg3JykgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcyk7XG4gICEoaW5wdXRQcm9wcy52YWx1ZSA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSB2YWx1ZUxpbmsgYW5kIGEgdmFsdWUgb3Igb25DaGFuZ2UgZXZlbnQuIElmIHlvdSB3YW50IHRvIHVzZSB2YWx1ZSBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rLicpIDogX3Byb2RJbnZhcmlhbnQoJzg4JykgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKSB7XG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpO1xuICAhKGlucHV0UHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSBjaGVja2VkIHByb3BlcnR5IG9yIG9uQ2hhbmdlIGV2ZW50LiBJZiB5b3Ugd2FudCB0byB1c2UgY2hlY2tlZCBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgY2hlY2tlZExpbmsnKSA6IF9wcm9kSW52YXJpYW50KCc4OScpIDogdm9pZCAwO1xufVxuXG52YXIgcHJvcFR5cGVzID0ge1xuICB2YWx1ZTogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICB9LFxuICBjaGVja2VkOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgfSxcbiAgb25DaGFuZ2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jXG59O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQcm92aWRlIGEgbGlua2VkIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBjb250cm9sbGVkIGZvcm1zLiBZb3Ugc2hvdWxkIG5vdCB1c2VcbiAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gKi9cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0ge1xuICBjaGVja1Byb3BUeXBlczogZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BzLCBvd25lcikge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgICAgaWYgKHByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yID0gcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIHRhZ05hbWUsICdwcm9wJywgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgZm9ybSBwcm9wVHlwZTogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHsqfSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCBlaXRoZXIgZnJvbSB2YWx1ZSBwcm9wIG9yIGxpbmsuXG4gICAqL1xuICBnZXRWYWx1ZTogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy52YWx1ZUxpbmspIHtcbiAgICAgIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZUxpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCBjaGVja2VkIHN0YXR1cyBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gY2hlY2tlZCBwcm9wXG4gICAqICAgICAgICAgICAgIG9yIGxpbmsuXG4gICAqL1xuICBnZXRDaGVja2VkOiBmdW5jdGlvbiAoaW5wdXRQcm9wcykge1xuICAgIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IGNoYW5nZSBldmVudCB0byBoYW5kbGVcbiAgICovXG4gIGV4ZWN1dGVPbkNoYW5nZTogZnVuY3Rpb24gKGlucHV0UHJvcHMsIGV2ZW50KSB7XG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0UHJvcHMuY2hlY2tlZExpbmspIHtcbiAgICAgIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWRMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRQcm9wcy5vbkNoYW5nZSkge1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMub25DaGFuZ2UuY2FsbCh1bmRlZmluZWQsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2VkVmFsdWVVdGlsczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FyblZhbHVlTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NSW5wdXQudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG52YXIgUmVhY3RET01JbnB1dCA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICB2YXIgY2hlY2tlZCA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0Q2hlY2tlZChwcm9wcyk7XG5cbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7XG4gICAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC50eXBlIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcyAoc2V0dGluZyAudmFsdWVcbiAgICAgIC8vIGJlZm9yZSAudHlwZSBtZWFucyAudmFsdWUgaXMgbG9zdCBpbiBJRTExIGFuZCBiZWxvdylcbiAgICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnN0ZXAgYmVmb3JlIC52YWx1ZSAoc2V0dGluZyAudmFsdWUgYmVmb3JlIC5zdGVwXG4gICAgICAvLyBtZWFucyAudmFsdWUgaXMgcm91bmRlZCBvbiBtb3VudCwgYmFzZWQgdXBvbiBzdGVwIHByZWNpc2lvbilcbiAgICAgIHN0ZXA6IHVuZGVmaW5lZCxcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLm1pbiAmIC5tYXggYmVmb3JlIC52YWx1ZSAodG8gZW5zdXJlIHByb3BlciBvcmRlclxuICAgICAgLy8gaW4gY29ybmVyIGNhc2VzIHN1Y2ggYXMgbWluIG9yIG1heCBkZXJpdmluZyBmcm9tIHZhbHVlLCBlLmcuIElzc3VlICM3MTcwKVxuICAgICAgbWluOiB1bmRlZmluZWQsXG4gICAgICBtYXg6IHVuZGVmaW5lZFxuICAgIH0sIHByb3BzLCB7XG4gICAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB2YWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcbiAgICAgIGNoZWNrZWQ6IGNoZWNrZWQgIT0gbnVsbCA/IGNoZWNrZWQgOiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQsXG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaG9zdFByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG5cbiAgICAgIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcblxuICAgICAgaWYgKHByb3BzLnZhbHVlTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVMaW5rKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgaW5wdXRgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmNoZWNrZWRMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkTGluaykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2BjaGVja2VkTGlua2AgcHJvcCBvbiBgaW5wdXRgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5DaGVja2VkTGluayA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIGluaXRpYWxDaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgICBpbml0aWFsVmFsdWU6IHByb3BzLnZhbHVlICE9IG51bGwgPyBwcm9wcy52YWx1ZSA6IGRlZmF1bHRWYWx1ZSxcbiAgICAgIGxpc3RlbmVyczogbnVsbCxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdClcbiAgICB9O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY29udHJvbGxlZCA9IGlzQ29udHJvbGxlZChwcm9wcyk7XG4gICAgICB2YXIgb3duZXIgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG5cbiAgICAgIGlmICghaW5zdC5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnN0Ll93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiAhY29udHJvbGxlZCAmJiAhZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGlzIGNoYW5naW5nIGEgY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIHVuY29udHJvbGxlZC4gJyArICdJbnB1dCBlbGVtZW50cyBzaG91bGQgbm90IHN3aXRjaCBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSkgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFNob3VsZG4ndCB0aGlzIGJlIGdldENoZWNrZWQocHJvcHMpP1xuICAgIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcbiAgICBpZiAoY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSwgJ2NoZWNrZWQnLCBjaGVja2VkIHx8IGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICB2YXIgbmV3VmFsdWUgPSAnJyArIHZhbHVlO1xuXG4gICAgICAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuICAgICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BzLnZhbHVlID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5jaGVja2VkID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcG9zdE1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuXG4gICAgLy8gRGV0YWNoIHZhbHVlIGZyb20gZGVmYXVsdFZhbHVlLiBXZSB3b24ndCBkbyBhbnl0aGluZyBpZiB3ZSdyZSB3b3JraW5nIG9uXG4gICAgLy8gc3VibWl0IG9yIHJlc2V0IGlucHV0cyBhcyB0aG9zZSB2YWx1ZXMgJiBkZWZhdWx0VmFsdWVzIGFyZSBsaW5rZWQuIFRoZXlcbiAgICAvLyBhcmUgbm90IHJlc2V0YWJsZSBub2RlcyBzbyB0aGlzIG9wZXJhdGlvbiBkb2Vzbid0IG1hdHRlciBhbmQgYWN0dWFsbHlcbiAgICAvLyByZW1vdmVzIGJyb3dzZXItZGVmYXVsdCB2YWx1ZXMgKGVnIFwiU3VibWl0IFF1ZXJ5XCIpIHdoZW4gbm8gdmFsdWUgaXNcbiAgICAvLyBwcm92aWRlZC5cblxuICAgIHN3aXRjaCAocHJvcHMudHlwZSkge1xuICAgICAgY2FzZSAnc3VibWl0JzpcbiAgICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjb2xvcic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ2RhdGV0aW1lJzpcbiAgICAgIGNhc2UgJ2RhdGV0aW1lLWxvY2FsJzpcbiAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIC8vIFRoaXMgZml4ZXMgdGhlIG5vLXNob3cgaXNzdWUgb24gaU9TIFNhZmFyaSBhbmQgQW5kcm9pZCBDaHJvbWU6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzIzM1xuICAgICAgICBub2RlLnZhbHVlID0gJyc7XG4gICAgICAgIG5vZGUudmFsdWUgPSBub2RlLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBub2RlLnZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsbHksIHdlJ2QganVzdCBkbyBgbm9kZS5jaGVja2VkID0gbm9kZS5jaGVja2VkYCB1cG9uIGluaXRpYWwgbW91bnQsIGxlc3MgdGhpcyBidWdcbiAgICAvLyB0aGlzIGlzIG5lZWRlZCB0byB3b3JrIGFyb3VuZCBhIGNocm9tZSBidWcgd2hlcmUgc2V0dGluZyBkZWZhdWx0Q2hlY2tlZFxuICAgIC8vIHdpbGwgc29tZXRpbWVzIGluZmx1ZW5jZSB0aGUgdmFsdWUgb2YgY2hlY2tlZCAoZXZlbiBhZnRlciBkZXRhY2htZW50KS5cbiAgICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYwODQxNlxuICAgIC8vIFdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgdW5zZXQgbmFtZSB0byBhdm9pZCBkaXNydXB0aW5nIHJhZGlvIGJ1dHRvbiBncm91cHMuXG4gICAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgICBub2RlLm5hbWUgPSAnJztcbiAgICB9XG4gICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG5cbiAgLy8gSGVyZSB3ZSB1c2UgYXNhcCB0byB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2hcbiAgLy8gaXMgaW1wb3J0YW50IHdoZW4gdXNpbmcgY29udHJvbGxlZCBjb21wb25lbnRzIHdpdGhpbiBsYXllcnM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG5cbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICB2YXIgcm9vdE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcbiAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgIHF1ZXJ5Um9vdCA9IHF1ZXJ5Um9vdC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAvLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgIC8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0sIGxldCdzIGp1c3QgdXNlIHRoZSBnbG9iYWxcbiAgICAvLyBgcXVlcnlTZWxlY3RvckFsbGAgdG8gZW5zdXJlIHdlIGRvbid0IG1pc3MgYW55dGhpbmcuXG4gICAgdmFyIGdyb3VwID0gcXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9JyArIEpTT04uc3RyaW5naWZ5KCcnICsgbmFtZSkgKyAnXVt0eXBlPVwicmFkaW9cIl0nKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlck5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxuICAgICAgLy8gYW5kIHRoZSBzYW1lIG5hbWUgYXJlIHJlbmRlcmVkIGludG8gdGhlIHNhbWUgZm9ybSAoc2FtZSBhcyAjMTkzOSkuXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1peGluZyBSZWFjdCByYWRpbyBidXR0b25zIHdpdGggbm9uLVJlYWN0IG9uZXMuXG4gICAgICB2YXIgb3RoZXJJbnN0YW5jZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG90aGVyTm9kZSk7XG4gICAgICAhb3RoZXJJbnN0YW5jZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nKSA6IF9wcm9kSW52YXJpYW50KCc5MCcpIDogdm9pZCAwO1xuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG4gICAgICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgb3RoZXJJbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSW5wdXQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZUxpbmsgPSBmYWxzZTtcbnZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSBmYWxzZTtcblxuZnVuY3Rpb24gdXBkYXRlT3B0aW9uc0lmUGVuZGluZ1VwZGF0ZUFuZE1vdW50ZWQoKSB7XG4gIGlmICh0aGlzLl9yb290Tm9kZUlEICYmIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlKSB7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSBmYWxzZTtcblxuICAgIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHVwZGF0ZU9wdGlvbnModGhpcywgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbnZhciB2YWx1ZVByb3BOYW1lcyA9IFsndmFsdWUnLCAnZGVmYXVsdFZhbHVlJ107XG5cbi8qKlxuICogVmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhpbnN0LCBwcm9wcykge1xuICB2YXIgb3duZXIgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ3NlbGVjdCcsIHByb3BzLCBvd25lcik7XG5cbiAgaWYgKHByb3BzLnZhbHVlTGluayAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVMaW5rKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgdmFsdWVMaW5rYCBwcm9wIG9uIGBzZWxlY3RgIGlzIGRlcHJlY2F0ZWQ7IHNldCBgdmFsdWVgIGFuZCBgb25DaGFuZ2VgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgZGlkV2FyblZhbHVlTGluayA9IHRydWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlUHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7XG4gICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFpc0FycmF5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpKSA6IHZvaWQgMDtcbiAgICB9IGVsc2UgaWYgKCFwcm9wcy5tdWx0aXBsZSAmJiBpc0FycmF5KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gaW5zdFxuICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBsZVxuICogQHBhcmFtIHsqfSBwcm9wVmFsdWUgQSBzdHJpbmdhYmxlICh3aXRoIGBtdWx0aXBsZWAsIGEgbGlzdCBvZiBzdHJpbmdhYmxlcykuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKGluc3QsIG11bHRpcGxlLCBwcm9wVmFsdWUpIHtcbiAgdmFyIHNlbGVjdGVkVmFsdWUsIGk7XG4gIHZhciBvcHRpb25zID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICBzZWxlY3RlZFZhbHVlID0ge307XG4gICAgZm9yIChpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgc2VsZWN0ZWRWYWx1ZVsnJyArIHByb3BWYWx1ZVtpXV0gPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eShvcHRpb25zW2ldLnZhbHVlKTtcbiAgICAgIGlmIChvcHRpb25zW2ldLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb25zW2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4gICAgLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbiAgICBzZWxlY3RlZFZhbHVlID0gJycgKyBwcm9wVmFsdWU7XG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvcHRpb25zW2ldLnZhbHVlID09PSBzZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxlbmd0aCkge1xuICAgICAgb3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovXG52YXIgUmVhY3RET01TZWxlY3QgPSB7XG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgcmV0dXJuIF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrU2VsZWN0UHJvcFR5cGVzKGluc3QsIHByb3BzKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBwZW5kaW5nVXBkYXRlOiBmYWxzZSxcbiAgICAgIGluaXRpYWxWYWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgbGlzdGVuZXJzOiBudWxsLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KSxcbiAgICAgIHdhc011bHRpcGxlOiBCb29sZWFuKHByb3BzLm11bHRpcGxlKVxuICAgIH07XG5cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJykgOiB2b2lkIDA7XG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBnZXRTZWxlY3RWYWx1ZUNvbnRleHQ6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgLy8gUmVhY3RET01PcHRpb24gbG9va3MgYXQgdGhpcyBpbml0aWFsIHZhbHVlIHNvIHRoZSBpbml0aWFsIGdlbmVyYXRlZFxuICAgIC8vIG1hcmt1cCBoYXMgY29ycmVjdCBgc2VsZWN0ZWRgIGF0dHJpYnV0ZXNcbiAgICByZXR1cm4gaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZTtcbiAgfSxcblxuICBwb3N0VXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIC8vIEFmdGVyIHRoZSBpbml0aWFsIG1vdW50LCB3ZSBjb250cm9sIHNlbGVjdGVkLW5lc3MgbWFudWFsbHkgc28gZG9uJ3QgcGFzc1xuICAgIC8vIHRoaXMgdmFsdWUgZG93blxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICB2YXIgd2FzTXVsdGlwbGUgPSBpbnN0Ll93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gQm9vbGVhbihwcm9wcy5tdWx0aXBsZSk7XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHdhc011bHRpcGxlICE9PSBCb29sZWFuKHByb3BzLm11bHRpcGxlKSkge1xuICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIHJlYXBwbHkgYGRlZmF1bHRWYWx1ZWAgaWYgYG11bHRpcGxlYCBpcyB0b2dnbGVkLlxuICAgICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHByb3BzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXZlcnQgdGhlIHNlbGVjdCBiYWNrIHRvIGl0cyBkZWZhdWx0IHVuc2VsZWN0ZWQgc3RhdGUuXG4gICAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHByb3BzLm11bHRpcGxlID8gW10gOiAnJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuXG4gIGlmICh0aGlzLl9yb290Tm9kZUlEKSB7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSB0cnVlO1xuICB9XG4gIFJlYWN0VXBkYXRlcy5hc2FwKHVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkLCB0aGlzKTtcbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VsZWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3QnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NU2VsZWN0ID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdCcpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIC8vIEZsYXR0ZW4gY2hpbGRyZW4gYW5kIHdhcm4gaWYgdGhleSBhcmVuJ3Qgc3RyaW5ncyBvciBudW1iZXJzO1xuICAvLyBpbnZhbGlkIHR5cGVzIGFyZSBpZ25vcmVkLlxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICBjb250ZW50ICs9IGNoaWxkO1xuICAgIH0gZWxzZSBpZiAoIWRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4pIHtcbiAgICAgIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdPbmx5IHN0cmluZ3MgYW5kIG51bWJlcnMgYXJlIHN1cHBvcnRlZCBhcyA8b3B0aW9uPiBjaGlsZHJlbi4nKSA6IHZvaWQgMDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb250ZW50O1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPG9wdGlvbj4gaG9zdCBjb21wb25lbnQgdGhhdCB3YXJucyB3aGVuIGBzZWxlY3RlZGAgaXMgc2V0LlxuICovXG52YXIgUmVhY3RET01PcHRpb24gPSB7XG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBob3N0UGFyZW50KSB7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLnNlbGVjdGVkID09IG51bGwsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICAvLyBMb29rIHVwIHdoZXRoZXIgdGhpcyBvcHRpb24gaXMgJ3NlbGVjdGVkJ1xuICAgIHZhciBzZWxlY3RWYWx1ZSA9IG51bGw7XG4gICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgdmFyIHNlbGVjdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG5cbiAgICAgIGlmIChzZWxlY3RQYXJlbnQuX3RhZyA9PT0gJ29wdGdyb3VwJykge1xuICAgICAgICBzZWxlY3RQYXJlbnQgPSBzZWxlY3RQYXJlbnQuX2hvc3RQYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RQYXJlbnQgIT0gbnVsbCAmJiBzZWxlY3RQYXJlbnQuX3RhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgc2VsZWN0VmFsdWUgPSBSZWFjdERPTVNlbGVjdC5nZXRTZWxlY3RWYWx1ZUNvbnRleHQoc2VsZWN0UGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdmFsdWUgaXMgbnVsbCAoZS5nLiwgbm8gc3BlY2lmaWVkIHZhbHVlIG9yIGFmdGVyIGluaXRpYWwgbW91bnQpXG4gICAgLy8gb3IgbWlzc2luZyAoZS5nLiwgZm9yIDxkYXRhbGlzdD4pLCB3ZSBkb24ndCBjaGFuZ2UgcHJvcHMuc2VsZWN0ZWRcbiAgICB2YXIgc2VsZWN0ZWQgPSBudWxsO1xuICAgIGlmIChzZWxlY3RWYWx1ZSAhPSBudWxsKSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YWx1ZSA9IHByb3BzLnZhbHVlICsgJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgICBzZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0VmFsdWUpKSB7XG4gICAgICAgIC8vIG11bHRpcGxlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0VmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoJycgKyBzZWxlY3RWYWx1ZVtpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0ZWQgPSAnJyArIHNlbGVjdFZhbHVlID09PSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7IHNlbGVjdGVkOiBzZWxlY3RlZCB9O1xuICB9LFxuXG4gIHBvc3RNb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgLy8gdmFsdWU9XCJcIiBzaG91bGQgbWFrZSBhIHZhbHVlIGF0dHJpYnV0ZSAoIzYyMTkpXG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBwcm9wcy52YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oeyBzZWxlY3RlZDogdW5kZWZpbmVkLCBjaGlsZHJlbjogdW5kZWZpbmVkIH0sIHByb3BzKTtcblxuICAgIC8vIFJlYWQgc3RhdGUgb25seSBmcm9tIGluaXRpYWwgbW91bnQgYmVjYXVzZSA8c2VsZWN0PiB1cGRhdGVzIHZhbHVlXG4gICAgLy8gbWFudWFsbHk7IHdlIG5lZWQgdGhlIGluaXRpYWwgc3RhdGUgb25seSBmb3Igc2VydmVyIHJlbmRlcmluZ1xuICAgIGlmIChpbnN0Ll93cmFwcGVyU3RhdGUuc2VsZWN0ZWQgIT0gbnVsbCkge1xuICAgICAgaG9zdFByb3BzLnNlbGVjdGVkID0gaW5zdC5fd3JhcHBlclN0YXRlLnNlbGVjdGVkO1xuICAgIH1cblxuICAgIHZhciBjb250ZW50ID0gZmxhdHRlbkNoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcblxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICBob3N0UHJvcHMuY2hpbGRyZW4gPSBjb250ZW50O1xuICAgIH1cblxuICAgIHJldHVybiBob3N0UHJvcHM7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTU9wdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZUxpbmsgPSBmYWxzZTtcbnZhciBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NVGV4dGFyZWEudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xudmFyIFJlYWN0RE9NVGV4dGFyZWEgPSB7XG4gIGdldEhvc3RQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgIShwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IF9wcm9kSW52YXJpYW50KCc5MScpIDogdm9pZCAwO1xuXG4gICAgLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbiAgICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgICAvLyB0byBvbmx5IHNldCB0aGUgdmFsdWUgaWYvd2hlbiB0aGUgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBub2RlIHZhbHVlICh3aGljaCB3b3VsZFxuICAgIC8vIGNvbXBsZXRlbHkgc29sdmUgdGhpcyBJRTkgYnVnKSwgYnV0IFNlYmFzdGlhbitCZW4gc2VlbWVkIHRvIGxpa2UgdGhpcyBzb2x1dGlvbi5cbiAgICAvLyBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZCB0byBiZSBhIHN0cmluZy5cbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGNoaWxkcmVuOiAnJyArIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaG9zdFByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ3RleHRhcmVhJywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG4gICAgICBpZiAocHJvcHMudmFsdWVMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZUxpbmspIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgdmFsdWVMaW5rYCBwcm9wIG9uIGB0ZXh0YXJlYWAgaXMgZGVwcmVjYXRlZDsgc2V0IGB2YWx1ZWAgYW5kIGBvbkNoYW5nZWAgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbHVlTGluayA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbERlZmF1bHRWYWwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJykgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICB2YXIgaW5pdGlhbFZhbHVlID0gdmFsdWU7XG5cbiAgICAvLyBPbmx5IGJvdGhlciBmZXRjaGluZyBkZWZhdWx0IHZhbHVlIGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSBpdFxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgICEoZGVmYXVsdFZhbHVlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IF9wcm9kSW52YXJpYW50KCc5MicpIDogdm9pZCAwO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuJykgOiBfcHJvZEludmFyaWFudCgnOTMnKSA6IHZvaWQgMDtcbiAgICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICAgIH1cbiAgICAgIGluaXRpYWxWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBpbml0aWFsVmFsdWU6ICcnICsgaW5pdGlhbFZhbHVlLFxuICAgICAgbGlzdGVuZXJzOiBudWxsLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KVxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICB2YXIgbmV3VmFsdWUgPSAnJyArIHZhbHVlO1xuXG4gICAgICAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuICAgICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgfSxcblxuICBwb3N0TW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgICB2YXIgbm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuXG4gICAgLy8gV2FybmluZzogbm9kZS52YWx1ZSBtYXkgYmUgdGhlIGVtcHR5IHN0cmluZyBhdCB0aGlzIHBvaW50IChJRTExKSBpZiBwbGFjZWhvbGRlciBpcyBzZXQuXG4gICAgbm9kZS52YWx1ZSA9IG5vZGUudGV4dENvbnRlbnQ7IC8vIERldGFjaCB2YWx1ZSBmcm9tIGRlZmF1bHRWYWx1ZVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRhcmVhOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgaW5qZWN0ZWQgPSBmYWxzZTtcblxudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSB7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgaW5qZWN0YWJsZSBob29rIGZvciBzd2FwcGluZyBvdXQgbW91bnQgaW1hZ2VzIGluIHRoZSBtaWRkbGUgb2ZcbiAgICogdGhlIHRyZWUuXG4gICAqL1xuICByZXBsYWNlTm9kZVdpdGhNYXJrdXA6IG51bGwsXG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgaW5qZWN0YWJsZSBob29rIGZvciBwcm9jZXNzaW5nIGEgcXVldWUgb2YgY2hpbGQgdXBkYXRlcy4gV2lsbFxuICAgKiBsYXRlciBtb3ZlIGludG8gTXVsdGlDaGlsZENvbXBvbmVudHMuXG4gICAqL1xuICBwcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdEVudmlyb25tZW50OiBmdW5jdGlvbiAoZW52aXJvbm1lbnQpIHtcbiAgICAgICEhaW5qZWN0ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQ6IGluamVjdEVudmlyb25tZW50KCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuJykgOiBfcHJvZEludmFyaWFudCgnMTA0JykgOiB2b2lkIDA7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cCA9IGVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyA9IGVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXM7XG4gICAgICBpbmplY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICovXG5cbi8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIEVTNjogdmFyIFJlYWN0SW5zdGFuY2VNYXAgPSBuZXcgTWFwKCk7XG5cbnZhciBSZWFjdEluc3RhbmNlTWFwID0ge1xuXG4gIC8qKlxuICAgKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICAgKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICAgKiBzdXBwb3J0ZWQgd2UgY2FuIHJlbmFtZSBpdC5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGtleSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZTtcbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB2YWx1ZTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VNYXA7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3QnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgUmVhY3ROb2RlVHlwZXMgPSB7XG4gIEhPU1Q6IDAsXG4gIENPTVBPU0lURTogMSxcbiAgRU1QVFk6IDIsXG5cbiAgZ2V0VHlwZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIFJlYWN0Tm9kZVR5cGVzLkVNUFRZO1xuICAgIH0gZWxzZSBpZiAoUmVhY3QuaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIGlmICh0eXBlb2Ygbm9kZS50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBSZWFjdE5vZGVUeXBlcy5DT01QT1NJVEU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUmVhY3ROb2RlVHlwZXMuSE9TVDtcbiAgICAgIH1cbiAgICB9XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1VuZXhwZWN0ZWQgbm9kZTogJXMnLCBub2RlKSA6IF9wcm9kSW52YXJpYW50KCcyNicsIG5vZGUpIDogdm9pZCAwO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Tm9kZVR5cGVzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge1xuICAgIHByb3A6ICdwcm9wJyxcbiAgICBjb250ZXh0OiAnY29udGV4dCcsXG4gICAgY2hpbGRDb250ZXh0OiAnY2hpbGQgY29udGV4dCdcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vaztcblxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gIC8vIFRlbXBvcmFyeSBoYWNrLlxuICAvLyBJbmxpbmUgcmVxdWlyZXMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggSmVzdDpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjQwXG4gIC8vIFJlbW92ZSB0aGUgaW5saW5lIHJlcXVpcmVzIHdoZW4gd2UgZG9uJ3QgbmVlZCB0aGVtIGFueW1vcmU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxNzhcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/b2JqZWN0fSBlbGVtZW50IFRoZSBSZWFjdCBlbGVtZW50IHRoYXQgaXMgYmVpbmcgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0gez9udW1iZXJ9IGRlYnVnSUQgVGhlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIHR5cGUtY2hlY2tlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tSZWFjdFR5cGVTcGVjKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCwgZGVidWdJRCkge1xuICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICB2YXIgZXJyb3I7XG4gICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgISh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gUmVhY3QuUHJvcFR5cGVzLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzg0JywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiB2b2lkIDA7XG4gICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgfVxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpIDogdm9pZCAwO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGNvbXBvbmVudFN0YWNrSW5mbyA9ICcnO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKCFSZWFjdENvbXBvbmVudFRyZWVIb29rKSB7XG4gICAgICAgICAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlYnVnSUQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrSW5mbyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21wb25lbnRTdGFja0luZm8gPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgY29tcG9uZW50U3RhY2tJbmZvKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1JlYWN0VHlwZVNwZWM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKiBcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoeCA9PT0geSkge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgLy8gQWRkZWQgdGhlIG5vbnplcm8geSBjaGVjayB0byBtYWtlIEZsb3cgaGFwcHksIGJ1dCBpdCBpcyByZWR1bmRhbnRcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWxsb3dFcXVhbDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdpdmVuIGEgYHByZXZFbGVtZW50YCBhbmQgYG5leHRFbGVtZW50YCwgZGV0ZXJtaW5lcyBpZiB0aGUgZXhpc3RpbmdcbiAqIGluc3RhbmNlIHNob3VsZCBiZSB1cGRhdGVkIGFzIG9wcG9zZWQgdG8gYmVpbmcgZGVzdHJveWVkIG9yIHJlcGxhY2VkIGJ5IGEgbmV3XG4gKiBpbnN0YW5jZS4gQm90aCBhcmd1bWVudHMgYXJlIGVsZW1lbnRzLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGlzIGxvZ2ljIGNhblxuICogb3BlcmF0ZSBvbiBzdGF0ZWxlc3MgdHJlZXMgd2l0aG91dCBhbnkgYmFja2luZyBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IHByZXZFbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG5leHRFbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBleGlzdGluZyBpbnN0YW5jZSBzaG91bGQgYmUgdXBkYXRlZC5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpIHtcbiAgdmFyIHByZXZFbXB0eSA9IHByZXZFbGVtZW50ID09PSBudWxsIHx8IHByZXZFbGVtZW50ID09PSBmYWxzZTtcbiAgdmFyIG5leHRFbXB0eSA9IG5leHRFbGVtZW50ID09PSBudWxsIHx8IG5leHRFbGVtZW50ID09PSBmYWxzZTtcbiAgaWYgKHByZXZFbXB0eSB8fCBuZXh0RW1wdHkpIHtcbiAgICByZXR1cm4gcHJldkVtcHR5ID09PSBuZXh0RW1wdHk7XG4gIH1cblxuICB2YXIgcHJldlR5cGUgPSB0eXBlb2YgcHJldkVsZW1lbnQ7XG4gIHZhciBuZXh0VHlwZSA9IHR5cGVvZiBuZXh0RWxlbWVudDtcbiAgaWYgKHByZXZUeXBlID09PSAnc3RyaW5nJyB8fCBwcmV2VHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbmV4dFR5cGUgPT09ICdzdHJpbmcnIHx8IG5leHRUeXBlID09PSAnbnVtYmVyJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV4dFR5cGUgPT09ICdvYmplY3QnICYmIHByZXZFbGVtZW50LnR5cGUgPT09IG5leHRFbGVtZW50LnR5cGUgJiYgcHJldkVsZW1lbnQua2V5ID09PSBuZXh0RWxlbWVudC5rZXk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdCcpO1xudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RXJyb3JVdGlscyA9IHJlcXVpcmUoJy4vUmVhY3RFcnJvclV0aWxzJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0Tm9kZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE5vZGVUeXBlcycpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBjaGVja1JlYWN0VHlwZVNwZWMgPSByZXF1aXJlKCcuL2NoZWNrUmVhY3RUeXBlU3BlYycpO1xufVxuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBDb21wb3NpdGVUeXBlcyA9IHtcbiAgSW1wdXJlQ2xhc3M6IDAsXG4gIFB1cmVDbGFzczogMSxcbiAgU3RhdGVsZXNzRnVuY3Rpb25hbDogMlxufTtcblxuZnVuY3Rpb24gU3RhdGVsZXNzQ29tcG9uZW50KENvbXBvbmVudCkge31cblN0YXRlbGVzc0NvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgQ29tcG9uZW50ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQodGhpcykuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gIHZhciBlbGVtZW50ID0gQ29tcG9uZW50KHRoaXMucHJvcHMsIHRoaXMuY29udGV4dCwgdGhpcy51cGRhdGVyKTtcbiAgd2FybklmSW52YWxpZEVsZW1lbnQoQ29tcG9uZW50LCBlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5mdW5jdGlvbiB3YXJuSWZJbnZhbGlkRWxlbWVudChDb21wb25lbnQsIGVsZW1lbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlIHx8IFJlYWN0LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpLCAnJXMoLi4uKTogQSB2YWxpZCBSZWFjdCBlbGVtZW50IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiBZb3UgbWF5IGhhdmUgJyArICdyZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzLCAnJXMoLi4uKTogY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbmFsIGNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgcmV0dXJuICEhKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gaXNQdXJlQ29tcG9uZW50KENvbXBvbmVudCkge1xuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KTtcbn1cblxuLy8gU2VwYXJhdGVkIGludG8gYSBmdW5jdGlvbiB0byBjb250YWluIGRlb3B0aW1pemF0aW9ucyBjYXVzZWQgYnkgdHJ5L2ZpbmFsbHkuXG5mdW5jdGlvbiBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmbiwgZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gIGlmIChkZWJ1Z0lEID09PSAwKSB7XG4gICAgLy8gVG9wLWxldmVsIHdyYXBwZXJzIChzZWUgUmVhY3RNb3VudCkgYW5kIGVtcHR5IGNvbXBvbmVudHMgKHNlZVxuICAgIC8vIFJlYWN0RE9NRW1wdHlDb21wb25lbnQpIGFyZSBpbnZpc2libGUgdG8gaG9va3MgYW5kIGRldnRvb2xzLlxuICAgIC8vIEJvdGggYXJlIGltcGxlbWVudGF0aW9uIGRldGFpbHMgdGhhdCBzaG91bGQgZ28gYXdheSBpbiB0aGUgZnV0dXJlLlxuICAgIHJldHVybiBmbigpO1xuICB9XG5cbiAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICB0cnkge1xuICAgIHJldHVybiBmbigpO1xuICB9IGZpbmFsbHkge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0gVGhlIExpZmUtQ3ljbGUgb2YgYSBDb21wb3NpdGUgQ29tcG9uZW50IC0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIC0gY29uc3RydWN0b3I6IEluaXRpYWxpemF0aW9uIG9mIHN0YXRlLiBUaGUgaW5zdGFuY2UgaXMgbm93IHJldGFpbmVkLlxuICogICAtIGNvbXBvbmVudFdpbGxNb3VudFxuICogICAtIHJlbmRlclxuICogICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9yc11cbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgcmVuZGVyXVxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50RGlkTW91bnRdXG4gKiAgICAgLSBjb21wb25lbnREaWRNb3VudFxuICpcbiAqICAgICAgIFVwZGF0ZSBQaGFzZXM6XG4gKiAgICAgICAtIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKG9ubHkgY2FsbGVkIGlmIHBhcmVudCB1cGRhdGVkKVxuICogICAgICAgLSBzaG91bGRDb21wb25lbnRVcGRhdGVcbiAqICAgICAgICAgLSBjb21wb25lbnRXaWxsVXBkYXRlXG4gKiAgICAgICAgICAgLSByZW5kZXJcbiAqICAgICAgICAgICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9ycyBvciByZWNlaXZlIHByb3BzIHBoYXNlc11cbiAqICAgICAgICAgLSBjb21wb25lbnREaWRVcGRhdGVcbiAqXG4gKiAgICAgLSBjb21wb25lbnRXaWxsVW5tb3VudFxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbFVubW91bnRdXG4gKiAgIC0gW2NoaWxkcmVuIGRlc3Ryb3llZF1cbiAqIC0gKGRlc3Ryb3llZCk6IFRoZSBpbnN0YW5jZSBpcyBub3cgYmxhbmssIHJlbGVhc2VkIGJ5IFJlYWN0IGFuZCByZWFkeSBmb3IgR0MuXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIEFuIGluY3JlbWVudGluZyBJRCBhc3NpZ25lZCB0byBlYWNoIGNvbXBvbmVudCB3aGVuIGl0IGlzIG1vdW50ZWQuIFRoaXMgaXNcbiAqIHVzZWQgdG8gZW5mb3JjZSB0aGUgb3JkZXIgaW4gd2hpY2ggYFJlYWN0VXBkYXRlc2AgdXBkYXRlcyBkaXJ0eSBjb21wb25lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBuZXh0TW91bnRJRCA9IDE7XG5cbi8qKlxuICogQGxlbmRzIHtSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5wcm90b3R5cGV9XG4gKi9cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHtcblxuICAvKipcbiAgICogQmFzZSBjb25zdHJ1Y3RvciBmb3IgYWxsIGNvbXBvc2l0ZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XG4gICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IG51bGw7XG4gICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gbnVsbDtcblxuICAgIC8vIFNlZSBSZWFjdFVwZGF0ZVF1ZXVlXG4gICAgdGhpcy5fdXBkYXRlQmF0Y2hOdW1iZXIgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5fcmVuZGVyZWROb2RlVHlwZSA9IG51bGw7XG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX21vdW50T3JkZXIgPSAwO1xuICAgIHRoaXMuX3RvcExldmVsV3JhcHBlciA9IG51bGw7XG5cbiAgICAvLyBTZWUgUmVhY3RVcGRhdGVzIGFuZCBSZWFjdFVwZGF0ZVF1ZXVlLlxuICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuXG4gICAgLy8gQ29tcG9uZW50V2lsbFVubW91bnQgc2hhbGwgb25seSBiZSBjYWxsZWQgb25jZVxuICAgIHRoaXMuX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50ID0gZmFsc2U7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhpcy5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjb21wb25lbnQsIHJlbmRlcnMgbWFya3VwLCBhbmQgcmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gaG9zdFBhcmVudFxuICAgKiBAcGFyYW0gez9vYmplY3R9IGhvc3RDb250YWluZXJJbmZvXG4gICAqIEBwYXJhbSB7P29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBSZW5kZXJlZCBtYXJrdXAgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLl9tb3VudE9yZGVyID0gbmV4dE1vdW50SUQrKztcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IGhvc3RDb250YWluZXJJbmZvO1xuXG4gICAgdmFyIHB1YmxpY1Byb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIHB1YmxpY0NvbnRleHQgPSB0aGlzLl9wcm9jZXNzQ29udGV4dChjb250ZXh0KTtcblxuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuXG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gdHJhbnNhY3Rpb24uZ2V0VXBkYXRlUXVldWUoKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIHB1YmxpYyBjbGFzc1xuICAgIHZhciBkb0NvbnN0cnVjdCA9IHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpO1xuICAgIHZhciBpbnN0ID0gdGhpcy5fY29uc3RydWN0Q29tcG9uZW50KGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgIHZhciByZW5kZXJlZEVsZW1lbnQ7XG5cbiAgICAvLyBTdXBwb3J0IGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAgIGlmICghZG9Db25zdHJ1Y3QgJiYgKGluc3QgPT0gbnVsbCB8fCBpbnN0LnJlbmRlciA9PSBudWxsKSkge1xuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gaW5zdDtcbiAgICAgIHdhcm5JZkludmFsaWRFbGVtZW50KENvbXBvbmVudCwgcmVuZGVyZWRFbGVtZW50KTtcbiAgICAgICEoaW5zdCA9PT0gbnVsbCB8fCBpbnN0ID09PSBmYWxzZSB8fCBSZWFjdC5pc1ZhbGlkRWxlbWVudChpbnN0KSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMoLi4uKTogQSB2YWxpZCBSZWFjdCBlbGVtZW50IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiBZb3UgbWF5IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLCBhbiBhcnJheSBvciBzb21lIG90aGVyIGludmFsaWQgb2JqZWN0LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA1JywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIGluc3QgPSBuZXcgU3RhdGVsZXNzQ29tcG9uZW50KENvbXBvbmVudCk7XG4gICAgICB0aGlzLl9jb21wb3NpdGVUeXBlID0gQ29tcG9zaXRlVHlwZXMuU3RhdGVsZXNzRnVuY3Rpb25hbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzUHVyZUNvbXBvbmVudChDb21wb25lbnQpKSB7XG4gICAgICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBDb21wb3NpdGVUeXBlcy5QdXJlQ2xhc3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jb21wb3NpdGVUeXBlID0gQ29tcG9zaXRlVHlwZXMuSW1wdXJlQ2xhc3M7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBsYXRlciBpbiBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50LCBidXQgYWRkIGFuIGVhcmx5XG4gICAgICAvLyB3YXJuaW5nIG5vdyB0byBoZWxwIGRlYnVnZ2luZ1xuICAgICAgaWYgKGluc3QucmVuZGVyID09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcHNNdXRhdGVkID0gaW5zdC5wcm9wcyAhPT0gcHVibGljUHJvcHM7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaW5zdC5wcm9wcyA9PT0gdW5kZWZpbmVkIHx8ICFwcm9wc011dGF0ZWQsICclcyguLi4pOiBXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgJ3VwIHRoZSBzYW1lIHByb3BzIHRoYXQgeW91ciBjb21wb25lbnRcXCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgLy8gVGhlc2Ugc2hvdWxkIGJlIHNldCB1cCBpbiB0aGUgY29uc3RydWN0b3IsIGJ1dCBhcyBhIGNvbnZlbmllbmNlIGZvclxuICAgIC8vIHNpbXBsZXIgY2xhc3MgYWJzdHJhY3Rpb25zLCB3ZSBzZXQgdGhlbSB1cCBhZnRlciB0aGUgZmFjdC5cbiAgICBpbnN0LnByb3BzID0gcHVibGljUHJvcHM7XG4gICAgaW5zdC5jb250ZXh0ID0gcHVibGljQ29udGV4dDtcbiAgICBpbnN0LnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICBpbnN0LnVwZGF0ZXIgPSB1cGRhdGVRdWV1ZTtcblxuICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdDtcblxuICAgIC8vIFN0b3JlIGEgcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlIGJhY2sgdG8gdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gICAgUmVhY3RJbnN0YW5jZU1hcC5zZXQoaW5zdCwgdGhpcyk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gU2luY2UgcGxhaW4gSlMgY2xhc3NlcyBhcmUgZGVmaW5lZCB3aXRob3V0IGFueSBzcGVjaWFsIGluaXRpYWxpemF0aW9uXG4gICAgICAvLyBsb2dpYywgd2UgY2FuIG5vdCBjYXRjaCBjb21tb24gZXJyb3JzIGVhcmx5LiBUaGVyZWZvcmUsIHdlIGhhdmUgdG9cbiAgICAgIC8vIGNhdGNoIHRoZW0gaGVyZSwgYXQgaW5pdGlhbGl6YXRpb24gdGltZSwgaW5zdGVhZC5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmdldEluaXRpYWxTdGF0ZSB8fCBpbnN0LmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmdldERlZmF1bHRQcm9wcyB8fCBpbnN0LmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QucHJvcFR5cGVzLCAncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5jb250ZXh0VHlwZXMsICdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhICcgKyAnc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gaW5zdC5zdGF0ZTtcbiAgICBpZiAoaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluc3Quc3RhdGUgPSBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgIH1cbiAgICAhKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwNicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICAgIHZhciBtYXJrdXA7XG4gICAgaWYgKGluc3QudW5zdGFibGVfaGFuZGxlRXJyb3IpIHtcbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudFdpdGhFcnJvckhhbmRsaW5nKHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50KHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnREaWRNb3VudCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3QuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICB9LCBfdGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudERpZE1vdW50Jyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnN0LmNvbXBvbmVudERpZE1vdW50LCBpbnN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIF9jb25zdHJ1Y3RDb21wb25lbnQ6IGZ1bmN0aW9uIChkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lcihkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0Q29tcG9uZW50V2l0aG91dE93bmVyKGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgIH1cbiAgfSxcblxuICBfY29uc3RydWN0Q29tcG9uZW50V2l0aG91dE93bmVyOiBmdW5jdGlvbiAoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSkge1xuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuXG4gICAgaWYgKGRvQ29uc3RydWN0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICByZXR1cm4gbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgICAgIH0sIHRoaXMuX2RlYnVnSUQsICdjdG9yJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgY2FuIHN0aWxsIGJlIGFuIGluc3RhbmNlIGluIGNhc2Ugb2YgZmFjdG9yeSBjb21wb25lbnRzXG4gICAgLy8gYnV0IHdlJ2xsIGNvdW50IHRoaXMgYXMgdGltZSBzcGVudCByZW5kZXJpbmcgYXMgdGhlIG1vcmUgY29tbW9uIGNhc2UuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHJldHVybiBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICAgIH0sIHRoaXMuX2RlYnVnSUQsICdyZW5kZXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgIH1cbiAgfSxcblxuICBwZXJmb3JtSW5pdGlhbE1vdW50V2l0aEVycm9ySGFuZGxpbmc6IGZ1bmN0aW9uIChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBtYXJrdXA7XG4gICAgdmFyIGNoZWNrcG9pbnQgPSB0cmFuc2FjdGlvbi5jaGVja3BvaW50KCk7XG4gICAgdHJ5IHtcbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gUm9sbCBiYWNrIHRvIGNoZWNrcG9pbnQsIGhhbmRsZSBlcnJvciAod2hpY2ggbWF5IGFkZCBpdGVtcyB0byB0aGUgdHJhbnNhY3Rpb24pLCBhbmQgdGFrZSBhIG5ldyBjaGVja3BvaW50XG4gICAgICB0cmFuc2FjdGlvbi5yb2xsYmFjayhjaGVja3BvaW50KTtcbiAgICAgIHRoaXMuX2luc3RhbmNlLnVuc3RhYmxlX2hhbmRsZUVycm9yKGUpO1xuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlKSB7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlLnN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZSh0aGlzLl9pbnN0YW5jZS5wcm9wcywgdGhpcy5faW5zdGFuY2UuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBjaGVja3BvaW50ID0gdHJhbnNhY3Rpb24uY2hlY2twb2ludCgpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudC51bm1vdW50Q29tcG9uZW50KHRydWUpO1xuICAgICAgdHJhbnNhY3Rpb24ucm9sbGJhY2soY2hlY2twb2ludCk7XG5cbiAgICAgIC8vIFRyeSBhZ2FpbiAtIHdlJ3ZlIGluZm9ybWVkIHRoZSBjb21wb25lbnQgYWJvdXQgdGhlIGVycm9yLCBzbyB0aGV5IGNhbiByZW5kZXIgYW4gZXJyb3IgbWVzc2FnZSB0aGlzIHRpbWUuXG4gICAgICAvLyBJZiB0aGlzIHRocm93cyBhZ2FpbiwgdGhlIGVycm9yIHdpbGwgYnViYmxlIHVwIChhbmQgY2FuIGJlIGNhdWdodCBieSBhIGhpZ2hlciBlcnJvciBib3VuZGFyeSkuXG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnQocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIHBlcmZvcm1Jbml0aWFsTW91bnQ6IGZ1bmN0aW9uIChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICB2YXIgZGVidWdJRCA9IDA7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGRlYnVnSUQgPSB0aGlzLl9kZWJ1Z0lEO1xuICAgIH1cblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxNb3VudCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBpbnN0LmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgICB9LCBkZWJ1Z0lELCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuICAgICAgLy8gV2hlbiBtb3VudGluZywgY2FsbHMgdG8gYHNldFN0YXRlYCBieSBgY29tcG9uZW50V2lsbE1vdW50YCB3aWxsIHNldFxuICAgICAgLy8gYHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlYCB3aXRob3V0IHRyaWdnZXJpbmcgYSByZS1yZW5kZXIuXG4gICAgICBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUpIHtcbiAgICAgICAgaW5zdC5zdGF0ZSA9IHRoaXMuX3Byb2Nlc3NQZW5kaW5nU3RhdGUoaW5zdC5wcm9wcywgaW5zdC5jb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBub3QgYSBzdGF0ZWxlc3MgY29tcG9uZW50LCB3ZSBub3cgcmVuZGVyXG4gICAgaWYgKHJlbmRlcmVkRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQoKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZVR5cGUgPSBSZWFjdE5vZGVUeXBlcy5nZXRUeXBlKHJlbmRlcmVkRWxlbWVudCk7XG4gICAgdGhpcy5fcmVuZGVyZWROb2RlVHlwZSA9IG5vZGVUeXBlO1xuICAgIHZhciBjaGlsZCA9IHRoaXMuX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQocmVuZGVyZWRFbGVtZW50LCBub2RlVHlwZSAhPT0gUmVhY3ROb2RlVHlwZXMuRU1QVFkgLyogc2hvdWxkSGF2ZURlYnVnSUQgKi9cbiAgICApO1xuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gY2hpbGQ7XG5cbiAgICB2YXIgbWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNoaWxkLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCksIGRlYnVnSUQpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChkZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIHZhciBjaGlsZERlYnVnSURzID0gY2hpbGQuX2RlYnVnSUQgIT09IDAgPyBbY2hpbGQuX2RlYnVnSURdIDogW107XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKGRlYnVnSUQsIGNoaWxkRGVidWdJRHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHNhZmVseSkge1xuICAgIGlmICghdGhpcy5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbFVubW91bnQgJiYgIWluc3QuX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50KSB7XG4gICAgICBpbnN0Ll9jYWxsZWRDb21wb25lbnRXaWxsVW5tb3VudCA9IHRydWU7XG5cbiAgICAgIGlmIChzYWZlbHkpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmdldE5hbWUoKSArICcuY29tcG9uZW50V2lsbFVubW91bnQoKSc7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sobmFtZSwgaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudC5iaW5kKGluc3QpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3QuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICAgICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50LCBzYWZlbHkpO1xuICAgICAgdGhpcy5fcmVuZGVyZWROb2RlVHlwZSA9IG51bGw7XG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgcGVuZGluZyBmaWVsZHNcbiAgICAvLyBFdmVuIGlmIHRoaXMgY29tcG9uZW50IGlzIHNjaGVkdWxlZCBmb3IgYW5vdGhlciB1cGRhdGUgaW4gUmVhY3RVcGRhdGVzLFxuICAgIC8vIGl0IHdvdWxkIHN0aWxsIGJlIGlnbm9yZWQgYmVjYXVzZSB0aGVzZSBmaWVsZHMgYXJlIHJlc2V0LlxuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgLy8gVGhlc2UgZmllbGRzIGRvIG5vdCByZWFsbHkgbmVlZCB0byBiZSByZXNldCBzaW5jZSB0aGlzIG9iamVjdCBpcyBub1xuICAgIC8vIGxvbmdlciBhY2Nlc3NpYmxlLlxuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSAwO1xuICAgIHRoaXMuX3RvcExldmVsV3JhcHBlciA9IG51bGw7XG5cbiAgICAvLyBEZWxldGUgdGhlIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZSB0byB0aGlzIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gICAgLy8gd2hpY2ggYWxsb3cgdGhlIGludGVybmFscyB0byBiZSBwcm9wZXJseSBjbGVhbmVkIHVwIGV2ZW4gaWYgdGhlIHVzZXJcbiAgICAvLyBsZWFrcyBhIHJlZmVyZW5jZSB0byB0aGUgcHVibGljIGluc3RhbmNlLlxuICAgIFJlYWN0SW5zdGFuY2VNYXAucmVtb3ZlKGluc3QpO1xuXG4gICAgLy8gU29tZSBleGlzdGluZyBjb21wb25lbnRzIHJlbHkgb24gaW5zdC5wcm9wcyBldmVuIGFmdGVyIHRoZXkndmUgYmVlblxuICAgIC8vIGRlc3Ryb3llZCAoaW4gZXZlbnQgaGFuZGxlcnMpLlxuICAgIC8vIFRPRE86IGluc3QucHJvcHMgPSBudWxsO1xuICAgIC8vIFRPRE86IGluc3Quc3RhdGUgPSBudWxsO1xuICAgIC8vIFRPRE86IGluc3QuY29udGV4dCA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhlIGNvbnRleHQgb2JqZWN0IHRvIG9ubHkgY29udGFpbiBrZXlzIHNwZWNpZmllZCBpblxuICAgKiBgY29udGV4dFR5cGVzYFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21hc2tDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBjb250ZXh0VHlwZXMgPSBDb21wb25lbnQuY29udGV4dFR5cGVzO1xuICAgIGlmICghY29udGV4dFR5cGVzKSB7XG4gICAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gICAgfVxuICAgIHZhciBtYXNrZWRDb250ZXh0ID0ge307XG4gICAgZm9yICh2YXIgY29udGV4dE5hbWUgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgICBtYXNrZWRDb250ZXh0W2NvbnRleHROYW1lXSA9IGNvbnRleHRbY29udGV4dE5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXG4gICAqIGBjb250ZXh0VHlwZXNgLCBhbmQgYXNzZXJ0cyB0aGF0IHRoZXkgYXJlIHZhbGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBtYXNrZWRDb250ZXh0ID0gdGhpcy5fbWFza0NvbnRleHQoY29udGV4dCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgICAgaWYgKENvbXBvbmVudC5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tDb250ZXh0VHlwZXMoQ29tcG9uZW50LmNvbnRleHRUeXBlcywgbWFza2VkQ29udGV4dCwgJ2NvbnRleHQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjdXJyZW50Q29udGV4dFxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKGN1cnJlbnRDb250ZXh0KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgY2hpbGRDb250ZXh0O1xuXG4gICAgaWYgKGluc3QuZ2V0Q2hpbGRDb250ZXh0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjaGlsZENvbnRleHQgPSBpbnN0LmdldENoaWxkQ29udGV4dCgpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRDb250ZXh0ID0gaW5zdC5nZXRDaGlsZENvbnRleHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2hpbGRDb250ZXh0KSB7XG4gICAgICAhKHR5cGVvZiBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvIHVzZSBnZXRDaGlsZENvbnRleHQoKS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDcnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrQ29udGV4dFR5cGVzKENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCAnY2hpbGRDb250ZXh0Jyk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkQ29udGV4dCkge1xuICAgICAgICAhKG5hbWUgaW4gQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKToga2V5IFwiJXNcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDgnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnLCBuYW1lKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfYXNzaWduKHt9LCBjdXJyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBBc3NlcnQgdGhhdCB0aGUgY29udGV4dCB0eXBlcyBhcmUgdmFsaWRcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgY29udGV4dCBmaWVsZCB0byBhIFJlYWN0UHJvcFR5cGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaGVja0NvbnRleHRUeXBlczogZnVuY3Rpb24gKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja1JlYWN0VHlwZVNwZWModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCB0aGlzLmdldE5hbWUoKSwgbnVsbCwgdGhpcy5fZGVidWdJRCk7XG4gICAgfVxuICB9LFxuXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIG5leHRDb250ZXh0KSB7XG4gICAgdmFyIHByZXZFbGVtZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQ7XG4gICAgdmFyIHByZXZDb250ZXh0ID0gdGhpcy5fY29udGV4dDtcblxuICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcblxuICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIHByZXZDb250ZXh0LCBuZXh0Q29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIGFueSBvZiBgX3BlbmRpbmdFbGVtZW50YCwgYF9wZW5kaW5nU3RhdGVRdWV1ZWAsIG9yIGBfcGVuZGluZ0ZvcmNlVXBkYXRlYFxuICAgKiBpcyBzZXQsIHVwZGF0ZSB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodGhpcy5fcGVuZGluZ0VsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQodGhpcywgdGhpcy5fcGVuZGluZ0VsZW1lbnQsIHRyYW5zYWN0aW9uLCB0aGlzLl9jb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlICE9PSBudWxsIHx8IHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSkge1xuICAgICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHRoaXMuX2N1cnJlbnRFbGVtZW50LCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdGhpcy5fY29udGV4dCwgdGhpcy5fY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUJhdGNoTnVtYmVyID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gYW4gdXBkYXRlIHRvIGEgbW91bnRlZCBjb21wb25lbnQuIFRoZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGFuZFxuICAgKiBzaG91bGRDb21wb25lbnRVcGRhdGUgbWV0aG9kcyBhcmUgY2FsbGVkLCB0aGVuIChhc3N1bWluZyB0aGUgdXBkYXRlIGlzbid0XG4gICAqIHNraXBwZWQpIHRoZSByZW1haW5pbmcgdXBkYXRlIGxpZmVjeWNsZSBtZXRob2RzIGFyZSBjYWxsZWQgYW5kIHRoZSBET01cbiAgICogcmVwcmVzZW50YXRpb24gaXMgdXBkYXRlZC5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhpcyBpbXBsZW1lbnRzIFJlYWN0J3MgcmVuZGVyaW5nIGFuZCByZWNvbmNpbGlhdGlvbiBhbGdvcml0aG0uXG4gICAqIFNvcGhpc3RpY2F0ZWQgY2xpZW50cyBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBwcmV2UGFyZW50RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dFBhcmVudEVsZW1lbnRcbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByZXZQYXJlbnRFbGVtZW50LCBuZXh0UGFyZW50RWxlbWVudCwgcHJldlVubWFza2VkQ29udGV4dCwgbmV4dFVubWFza2VkQ29udGV4dCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgIShpbnN0ICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0F0dGVtcHRlZCB0byB1cGRhdGUgY29tcG9uZW50IGAlc2AgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHVubW91bnRlZCAob3IgZmFpbGVkIHRvIG1vdW50KS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMzYnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgIHZhciB3aWxsUmVjZWl2ZSA9IGZhbHNlO1xuICAgIHZhciBuZXh0Q29udGV4dDtcblxuICAgIC8vIERldGVybWluZSBpZiB0aGUgY29udGV4dCBoYXMgY2hhbmdlZCBvciBub3RcbiAgICBpZiAodGhpcy5fY29udGV4dCA9PT0gbmV4dFVubWFza2VkQ29udGV4dCkge1xuICAgICAgbmV4dENvbnRleHQgPSBpbnN0LmNvbnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRDb250ZXh0ID0gdGhpcy5fcHJvY2Vzc0NvbnRleHQobmV4dFVubWFza2VkQ29udGV4dCk7XG4gICAgICB3aWxsUmVjZWl2ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHByZXZQcm9wcyA9IHByZXZQYXJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciBuZXh0UHJvcHMgPSBuZXh0UGFyZW50RWxlbWVudC5wcm9wcztcblxuICAgIC8vIE5vdCBhIHNpbXBsZSBzdGF0ZSB1cGRhdGUgYnV0IGEgcHJvcHMgdXBkYXRlXG4gICAgaWYgKHByZXZQYXJlbnRFbGVtZW50ICE9PSBuZXh0UGFyZW50RWxlbWVudCkge1xuICAgICAgd2lsbFJlY2VpdmUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEFuIHVwZGF0ZSBoZXJlIHdpbGwgc2NoZWR1bGUgYW4gdXBkYXRlIGJ1dCBpbW1lZGlhdGVseSBzZXRcbiAgICAvLyBfcGVuZGluZ1N0YXRlUXVldWUgd2hpY2ggd2lsbCBlbnN1cmUgdGhhdCBhbnkgc3RhdGUgdXBkYXRlcyBnZXRzXG4gICAgLy8gaW1tZWRpYXRlbHkgcmVjb25jaWxlZCBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIHRoZSBuZXh0IGJhdGNoLlxuICAgIGlmICh3aWxsUmVjZWl2ZSAmJiBpbnN0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcywgbmV4dENvbnRleHQpO1xuICAgICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcywgbmV4dENvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXh0U3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKG5leHRQcm9wcywgbmV4dENvbnRleHQpO1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSB0cnVlO1xuXG4gICAgaWYgKCF0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUpIHtcbiAgICAgIGlmIChpbnN0LnNob3VsZENvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHNob3VsZFVwZGF0ZSA9IG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0LnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgICAgIH0sIHRoaXMuX2RlYnVnSUQsICdzaG91bGRDb21wb25lbnRVcGRhdGUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaG91bGRVcGRhdGUgPSBpbnN0LnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fY29tcG9zaXRlVHlwZSA9PT0gQ29tcG9zaXRlVHlwZXMuUHVyZUNsYXNzKSB7XG4gICAgICAgICAgc2hvdWxkVXBkYXRlID0gIXNoYWxsb3dFcXVhbChwcmV2UHJvcHMsIG5leHRQcm9wcykgfHwgIXNoYWxsb3dFcXVhbChpbnN0LnN0YXRlLCBuZXh0U3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHNob3VsZFVwZGF0ZSAhPT0gdW5kZWZpbmVkLCAnJXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk6IFJldHVybmVkIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGEgJyArICdib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlQmF0Y2hOdW1iZXIgPSBudWxsO1xuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgLy8gV2lsbCBzZXQgYHRoaXMucHJvcHNgLCBgdGhpcy5zdGF0ZWAgYW5kIGB0aGlzLmNvbnRleHRgLlxuICAgICAgdGhpcy5fcGVyZm9ybUNvbXBvbmVudFVwZGF0ZShuZXh0UGFyZW50RWxlbWVudCwgbmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0LCB0cmFuc2FjdGlvbiwgbmV4dFVubWFza2VkQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGl0J3MgZGV0ZXJtaW5lZCB0aGF0IGEgY29tcG9uZW50IHNob3VsZCBub3QgdXBkYXRlLCB3ZSBzdGlsbCB3YW50XG4gICAgICAvLyB0byBzZXQgcHJvcHMgYW5kIHN0YXRlIGJ1dCB3ZSBzaG9ydGN1dCB0aGUgcmVzdCBvZiB0aGUgdXBkYXRlLlxuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0UGFyZW50RWxlbWVudDtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSBuZXh0VW5tYXNrZWRDb250ZXh0O1xuICAgICAgaW5zdC5wcm9wcyA9IG5leHRQcm9wcztcbiAgICAgIGluc3Quc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICBpbnN0LmNvbnRleHQgPSBuZXh0Q29udGV4dDtcbiAgICB9XG4gIH0sXG5cbiAgX3Byb2Nlc3NQZW5kaW5nU3RhdGU6IGZ1bmN0aW9uIChwcm9wcywgY29udGV4dCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fcGVuZGluZ1N0YXRlUXVldWU7XG4gICAgdmFyIHJlcGxhY2UgPSB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG5cbiAgICBpZiAoIXF1ZXVlKSB7XG4gICAgICByZXR1cm4gaW5zdC5zdGF0ZTtcbiAgICB9XG5cbiAgICBpZiAocmVwbGFjZSAmJiBxdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBxdWV1ZVswXTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFN0YXRlID0gX2Fzc2lnbih7fSwgcmVwbGFjZSA/IHF1ZXVlWzBdIDogaW5zdC5zdGF0ZSk7XG4gICAgZm9yICh2YXIgaSA9IHJlcGxhY2UgPyAxIDogMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFydGlhbCA9IHF1ZXVlW2ldO1xuICAgICAgX2Fzc2lnbihuZXh0U3RhdGUsIHR5cGVvZiBwYXJ0aWFsID09PSAnZnVuY3Rpb24nID8gcGFydGlhbC5jYWxsKGluc3QsIG5leHRTdGF0ZSwgcHJvcHMsIGNvbnRleHQpIDogcGFydGlhbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgfSxcblxuICAvKipcbiAgICogTWVyZ2VzIG5ldyBwcm9wcyBhbmQgc3RhdGUsIG5vdGlmaWVzIGRlbGVnYXRlIG1ldGhvZHMgb2YgdXBkYXRlIGFuZFxuICAgKiBwZXJmb3JtcyB1cGRhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBOZXh0IGVsZW1lbnRcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wcyBOZXh0IHB1YmxpYyBvYmplY3QgdG8gc2V0IGFzIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlIE5leHQgb2JqZWN0IHRvIHNldCBhcyBzdGF0ZS5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dCBOZXh0IHB1YmxpYyBvYmplY3QgdG8gc2V0IGFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHs/b2JqZWN0fSB1bm1hc2tlZENvbnRleHRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wZXJmb3JtQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCwgdHJhbnNhY3Rpb24sIHVubWFza2VkQ29udGV4dCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIHZhciBoYXNDb21wb25lbnREaWRVcGRhdGUgPSBCb29sZWFuKGluc3QuY29tcG9uZW50RGlkVXBkYXRlKTtcbiAgICB2YXIgcHJldlByb3BzO1xuICAgIHZhciBwcmV2U3RhdGU7XG4gICAgdmFyIHByZXZDb250ZXh0O1xuICAgIGlmIChoYXNDb21wb25lbnREaWRVcGRhdGUpIHtcbiAgICAgIHByZXZQcm9wcyA9IGluc3QucHJvcHM7XG4gICAgICBwcmV2U3RhdGUgPSBpbnN0LnN0YXRlO1xuICAgICAgcHJldkNvbnRleHQgPSBpbnN0LmNvbnRleHQ7XG4gICAgfVxuXG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbFVwZGF0ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBpbnN0LmNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3QuY29tcG9uZW50V2lsbFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgdGhpcy5fY29udGV4dCA9IHVubWFza2VkQ29udGV4dDtcbiAgICBpbnN0LnByb3BzID0gbmV4dFByb3BzO1xuICAgIGluc3Quc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgaW5zdC5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG5cbiAgICB0aGlzLl91cGRhdGVSZW5kZXJlZENvbXBvbmVudCh0cmFuc2FjdGlvbiwgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIGlmIChoYXNDb21wb25lbnREaWRVcGRhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGluc3QuY29tcG9uZW50RGlkVXBkYXRlLmJpbmQoaW5zdCwgcHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KSwgX3RoaXMyLl9kZWJ1Z0lELCAnY29tcG9uZW50RGlkVXBkYXRlJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnN0LmNvbXBvbmVudERpZFVwZGF0ZS5iaW5kKGluc3QsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksIGluc3QpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsbCB0aGUgY29tcG9uZW50J3MgYHJlbmRlcmAgbWV0aG9kIGFuZCB1cGRhdGUgdGhlIERPTSBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF91cGRhdGVSZW5kZXJlZENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZDb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgIHZhciBwcmV2UmVuZGVyZWRFbGVtZW50ID0gcHJldkNvbXBvbmVudEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgbmV4dFJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpO1xuXG4gICAgdmFyIGRlYnVnSUQgPSAwO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBkZWJ1Z0lEID0gdGhpcy5fZGVidWdJRDtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldlJlbmRlcmVkRWxlbWVudCwgbmV4dFJlbmRlcmVkRWxlbWVudCkpIHtcbiAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHByZXZDb21wb25lbnRJbnN0YW5jZSwgbmV4dFJlbmRlcmVkRWxlbWVudCwgdHJhbnNhY3Rpb24sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb2xkSG9zdE5vZGUgPSBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUocHJldkNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDb21wb25lbnRJbnN0YW5jZSwgZmFsc2UpO1xuXG4gICAgICB2YXIgbm9kZVR5cGUgPSBSZWFjdE5vZGVUeXBlcy5nZXRUeXBlKG5leHRSZW5kZXJlZEVsZW1lbnQpO1xuICAgICAgdGhpcy5fcmVuZGVyZWROb2RlVHlwZSA9IG5vZGVUeXBlO1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5faW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0UmVuZGVyZWRFbGVtZW50LCBub2RlVHlwZSAhPT0gUmVhY3ROb2RlVHlwZXMuRU1QVFkgLyogc2hvdWxkSGF2ZURlYnVnSUQgKi9cbiAgICAgICk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IGNoaWxkO1xuXG4gICAgICB2YXIgbmV4dE1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgdHJhbnNhY3Rpb24sIHRoaXMuX2hvc3RQYXJlbnQsIHRoaXMuX2hvc3RDb250YWluZXJJbmZvLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpLCBkZWJ1Z0lEKTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRlYnVnSUQgIT09IDApIHtcbiAgICAgICAgICB2YXIgY2hpbGREZWJ1Z0lEcyA9IGNoaWxkLl9kZWJ1Z0lEICE9PSAwID8gW2NoaWxkLl9kZWJ1Z0lEXSA6IFtdO1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKGRlYnVnSUQsIGNoaWxkRGVidWdJRHMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlcGxhY2VOb2RlV2l0aE1hcmt1cChvbGRIb3N0Tm9kZSwgbmV4dE1hcmt1cCwgcHJldkNvbXBvbmVudEluc3RhbmNlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRkZW4gaW4gc2hhbGxvdyByZW5kZXJpbmcuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9yZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGZ1bmN0aW9uIChvbGRIb3N0Tm9kZSwgbmV4dE1hcmt1cCwgcHJldkluc3RhbmNlKSB7XG4gICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXAob2xkSG9zdE5vZGUsIG5leHRNYXJrdXAsIHByZXZJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciByZW5kZXJlZEVsZW1lbnQ7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW5zdC5yZW5kZXIoKTtcbiAgICAgIH0sIHRoaXMuX2RlYnVnSUQsICdyZW5kZXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gaW5zdC5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICBpZiAocmVuZGVyZWRFbGVtZW50ID09PSB1bmRlZmluZWQgJiYgaW5zdC5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG4gICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgIHJlbmRlcmVkRWxlbWVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbmRlcmVkRWxlbWVudDtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVuZGVyZWRFbGVtZW50O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nIHx8IHRoaXMuX2NvbXBvc2l0ZVR5cGUgIT09IENvbXBvc2l0ZVR5cGVzLlN0YXRlbGVzc0Z1bmN0aW9uYWwpIHtcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0KCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0KCk7XG4gICAgfVxuICAgICEoXG4gICAgLy8gVE9ETzogQW4gYGlzVmFsaWROb2RlYCBmdW5jdGlvbiB3b3VsZCBwcm9iYWJseSBiZSBtb3JlIGFwcHJvcHJpYXRlXG4gICAgcmVuZGVyZWRFbGVtZW50ID09PSBudWxsIHx8IHJlbmRlcmVkRWxlbWVudCA9PT0gZmFsc2UgfHwgUmVhY3QuaXNWYWxpZEVsZW1lbnQocmVuZGVyZWRFbGVtZW50KSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMucmVuZGVyKCk6IEEgdmFsaWQgUmVhY3QgZWxlbWVudCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IG1heSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDknLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcblxuICAgIHJldHVybiByZW5kZXJlZEVsZW1lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExhemlseSBhbGxvY2F0ZXMgdGhlIHJlZnMgb2JqZWN0IGFuZCBzdG9yZXMgYGNvbXBvbmVudGAgYXMgYHJlZmAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgUmVmZXJlbmNlIG5hbWUuXG4gICAqIEBwYXJhbSB7Y29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIHN0b3JlIGFzIGByZWZgLlxuICAgKiBAZmluYWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGF0dGFjaFJlZjogZnVuY3Rpb24gKHJlZiwgY29tcG9uZW50KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgIShpbnN0ICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHJlZnMuJykgOiBfcHJvZEludmFyaWFudCgnMTEwJykgOiB2b2lkIDA7XG4gICAgdmFyIHB1YmxpY0NvbXBvbmVudEluc3RhbmNlID0gY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50ICYmIGNvbXBvbmVudC5nZXROYW1lID8gY29tcG9uZW50LmdldE5hbWUoKSA6ICdhIGNvbXBvbmVudCc7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwdWJsaWNDb21wb25lbnRJbnN0YW5jZSAhPSBudWxsIHx8IGNvbXBvbmVudC5fY29tcG9zaXRlVHlwZSAhPT0gQ29tcG9zaXRlVHlwZXMuU3RhdGVsZXNzRnVuY3Rpb25hbCwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzICcgKyAnKFNlZSByZWYgXCIlc1wiIGluICVzIGNyZWF0ZWQgYnkgJXMpLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuJywgcmVmLCBjb21wb25lbnROYW1lLCB0aGlzLmdldE5hbWUoKSkgOiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciByZWZzID0gaW5zdC5yZWZzID09PSBlbXB0eU9iamVjdCA/IGluc3QucmVmcyA9IHt9IDogaW5zdC5yZWZzO1xuICAgIHJlZnNbcmVmXSA9IHB1YmxpY0NvbXBvbmVudEluc3RhbmNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRhY2hlcyBhIHJlZmVyZW5jZSBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgdG8gZGVyZWZlcmVuY2UuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGV0YWNoUmVmOiBmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIHJlZnMgPSB0aGlzLmdldFB1YmxpY0luc3RhbmNlKCkucmVmcztcbiAgICBkZWxldGUgcmVmc1tyZWZdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYSB0ZXh0IGRlc2NyaXB0aW9uIG9mIHRoZSBjb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCB0byBpZGVudGlmeSBpdFxuICAgKiBpbiBlcnJvciBtZXNzYWdlcy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgbmFtZSBvciBudWxsLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldE5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gdGhpcy5faW5zdGFuY2UgJiYgdGhpcy5faW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IgJiYgY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yLm5hbWUgfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRoZSBwdWJsaWNseSBhY2Nlc3NpYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29tcG9uZW50IC0gaS5lLiB3aGF0XG4gICAqIGlzIGV4cG9zZWQgYnkgcmVmcyBhbmQgcmV0dXJuZWQgYnkgcmVuZGVyLiBDYW4gYmUgbnVsbCBmb3Igc3RhdGVsZXNzXG4gICAqIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSB0aGUgcHVibGljIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgaWYgKHRoaXMuX2NvbXBvc2l0ZVR5cGUgPT09IENvbXBvc2l0ZVR5cGVzLlN0YXRlbGVzc0Z1bmN0aW9uYWwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdDtcbiAgfSxcblxuICAvLyBTdHViXG4gIF9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50OiBudWxsXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb3NpdGVDb21wb25lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5Q29tcG9uZW50RmFjdG9yeTtcblxudmFyIFJlYWN0RW1wdHlDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIGluamVjdEVtcHR5Q29tcG9uZW50RmFjdG9yeTogZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICBlbXB0eUNvbXBvbmVudEZhY3RvcnkgPSBmYWN0b3J5O1xuICB9XG59O1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiAoaW5zdGFudGlhdGUpIHtcbiAgICByZXR1cm4gZW1wdHlDb21wb25lbnRGYWN0b3J5KGluc3RhbnRpYXRlKTtcbiAgfVxufTtcblxuUmVhY3RFbXB0eUNvbXBvbmVudC5pbmplY3Rpb24gPSBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RW1wdHlDb21wb25lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBudWxsO1xuLy8gVGhpcyByZWdpc3RyeSBrZWVwcyB0cmFjayBvZiB3cmFwcGVyIGNsYXNzZXMgYXJvdW5kIGhvc3QgdGFncy5cbnZhciB0YWdUb0NvbXBvbmVudENsYXNzID0ge307XG52YXIgdGV4dENvbXBvbmVudENsYXNzID0gbnVsbDtcblxudmFyIFJlYWN0SG9zdENvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgLy8gVGhpcyBhY2NlcHRzIGEgY2xhc3MgdGhhdCByZWNlaXZlcyB0aGUgdGFnIHN0cmluZy4gVGhpcyBpcyBhIGNhdGNoIGFsbFxuICAvLyB0aGF0IGNhbiByZW5kZXIgYW55IGtpbmQgb2YgdGFnLlxuICBpbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3M6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgIGdlbmVyaWNDb21wb25lbnRDbGFzcyA9IGNvbXBvbmVudENsYXNzO1xuICB9LFxuICAvLyBUaGlzIGFjY2VwdHMgYSB0ZXh0IGNvbXBvbmVudCBjbGFzcyB0aGF0IHRha2VzIHRoZSB0ZXh0IHN0cmluZyB0byBiZVxuICAvLyByZW5kZXJlZCBhcyBwcm9wcy5cbiAgaW5qZWN0VGV4dENvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICB0ZXh0Q29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcbiAgfSxcbiAgLy8gVGhpcyBhY2NlcHRzIGEga2V5ZWQgb2JqZWN0IHdpdGggY2xhc3NlcyBhcyB2YWx1ZXMuIEVhY2gga2V5IHJlcHJlc2VudHMgYVxuICAvLyB0YWcuIFRoYXQgcGFydGljdWxhciB0YWcgd2lsbCB1c2UgdGhpcyBjbGFzcyBpbnN0ZWFkIG9mIHRoZSBnZW5lcmljIG9uZS5cbiAgaW5qZWN0Q29tcG9uZW50Q2xhc3NlczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzZXMpIHtcbiAgICBfYXNzaWduKHRhZ1RvQ29tcG9uZW50Q2xhc3MsIGNvbXBvbmVudENsYXNzZXMpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBhIGhvc3QgaW50ZXJuYWwgY29tcG9uZW50IGNsYXNzIGZvciBhIHNwZWNpZmljIHRhZy5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBjcmVhdGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGludGVybmFsIGNsYXNzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnRlcm5hbENvbXBvbmVudChlbGVtZW50KSB7XG4gICFnZW5lcmljQ29tcG9uZW50Q2xhc3MgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVGhlcmUgaXMgbm8gcmVnaXN0ZXJlZCBjb21wb25lbnQgZm9yIHRoZSB0YWcgJXMnLCBlbGVtZW50LnR5cGUpIDogX3Byb2RJbnZhcmlhbnQoJzExMScsIGVsZW1lbnQudHlwZSkgOiB2b2lkIDA7XG4gIHJldHVybiBuZXcgZ2VuZXJpY0NvbXBvbmVudENsYXNzKGVsZW1lbnQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RUZXh0fSB0ZXh0XG4gKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VGb3JUZXh0KHRleHQpIHtcbiAgcmV0dXJuIG5ldyB0ZXh0Q29tcG9uZW50Q2xhc3ModGV4dCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1RleHRDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBjb21wb25lbnQgaW5zdGFuY2VvZiB0ZXh0Q29tcG9uZW50Q2xhc3M7XG59XG5cbnZhciBSZWFjdEhvc3RDb21wb25lbnQgPSB7XG4gIGNyZWF0ZUludGVybmFsQ29tcG9uZW50OiBjcmVhdGVJbnRlcm5hbENvbXBvbmVudCxcbiAgY3JlYXRlSW5zdGFuY2VGb3JUZXh0OiBjcmVhdGVJbnN0YW5jZUZvclRleHQsXG4gIGlzVGV4dENvbXBvbmVudDogaXNUZXh0Q29tcG9uZW50LFxuICBpbmplY3Rpb246IFJlYWN0SG9zdENvbXBvbmVudEluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEhvc3RDb21wb25lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbmV4dERlYnVnSUQgPSAxO1xuXG5mdW5jdGlvbiBnZXROZXh0RGVidWdJRCgpIHtcbiAgcmV0dXJuIG5leHREZWJ1Z0lEKys7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmV4dERlYnVnSUQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudCcpO1xudmFyIFJlYWN0SG9zdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RIb3N0Q29tcG9uZW50Jyk7XG5cbnZhciBnZXROZXh0RGVidWdJRCA9IHJlcXVpcmUoJy4vZ2V0TmV4dERlYnVnSUQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vLyBUbyBhdm9pZCBhIGN5Y2xpYyBkZXBlbmRlbmN5LCB3ZSBjcmVhdGUgdGhlIGZpbmFsIGNsYXNzIGluIHRoaXMgbW9kdWxlXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdGhpcy5jb25zdHJ1Y3QoZWxlbWVudCk7XG59O1xuX2Fzc2lnbihSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIucHJvdG90eXBlLCBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCwge1xuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudFxufSk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB0eXBlIHJlZmVyZW5jZSBpcyBhIGtub3duIGludGVybmFsIHR5cGUuIEkuZS4gbm90IGEgdXNlclxuICogcHJvdmlkZWQgY29tcG9zaXRlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHlwZVxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoaXMgaXMgYSB2YWxpZCBpbnRlcm5hbCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc0ludGVybmFsQ29tcG9uZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUucmVjZWl2ZUNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0Tm9kZSwgY3JlYXRlIGFuIGluc3RhbmNlIHRoYXQgd2lsbCBhY3R1YWxseSBiZSBtb3VudGVkLlxuICpcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZEhhdmVEZWJ1Z0lEXG4gKiBAcmV0dXJuIHtvYmplY3R9IEEgbmV3IGluc3RhbmNlIG9mIHRoZSBlbGVtZW50J3MgY29uc3RydWN0b3IuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobm9kZSwgc2hvdWxkSGF2ZURlYnVnSUQpIHtcbiAgdmFyIGluc3RhbmNlO1xuXG4gIGlmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IGZhbHNlKSB7XG4gICAgaW5zdGFuY2UgPSBSZWFjdEVtcHR5Q29tcG9uZW50LmNyZWF0ZShpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgZWxlbWVudCA9IG5vZGU7XG4gICAgIShlbGVtZW50ICYmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIGVsZW1lbnQudHlwZSA9PSBudWxsID8gZWxlbWVudC50eXBlIDogdHlwZW9mIGVsZW1lbnQudHlwZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGVsZW1lbnQuX293bmVyKSkgOiBfcHJvZEludmFyaWFudCgnMTMwJywgZWxlbWVudC50eXBlID09IG51bGwgPyBlbGVtZW50LnR5cGUgOiB0eXBlb2YgZWxlbWVudC50eXBlLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oZWxlbWVudC5fb3duZXIpKSA6IHZvaWQgMDtcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBzdHJpbmcgdmFsdWVzXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpbnN0YW5jZSA9IFJlYWN0SG9zdENvbXBvbmVudC5jcmVhdGVJbnRlcm5hbENvbXBvbmVudChlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKGlzSW50ZXJuYWxDb21wb25lbnRUeXBlKGVsZW1lbnQudHlwZSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGVtcG9yYXJpbHkgYXZhaWxhYmxlIGZvciBjdXN0b20gY29tcG9uZW50cyB0aGF0IGFyZSBub3Qgc3RyaW5nXG4gICAgICAvLyByZXByZXNlbnRhdGlvbnMuIEkuZS4gQVJULiBPbmNlIHRob3NlIGFyZSB1cGRhdGVkIHRvIHVzZSB0aGUgc3RyaW5nXG4gICAgICAvLyByZXByZXNlbnRhdGlvbiwgd2UgY2FuIGRyb3AgdGhpcyBjb2RlIHBhdGguXG4gICAgICBpbnN0YW5jZSA9IG5ldyBlbGVtZW50LnR5cGUoZWxlbWVudCk7XG5cbiAgICAgIC8vIFdlIHJlbmFtZWQgdGhpcy4gQWxsb3cgdGhlIG9sZCBuYW1lIGZvciBjb21wYXQuIDooXG4gICAgICBpZiAoIWluc3RhbmNlLmdldEhvc3ROb2RlKSB7XG4gICAgICAgIGluc3RhbmNlLmdldEhvc3ROb2RlID0gaW5zdGFuY2UuZ2V0TmF0aXZlTm9kZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UgPSBuZXcgUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyKGVsZW1lbnQpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5vZGUgPT09ICdudW1iZXInKSB7XG4gICAgaW5zdGFuY2UgPSBSZWFjdEhvc3RDb21wb25lbnQuY3JlYXRlSW5zdGFuY2VGb3JUZXh0KG5vZGUpO1xuICB9IGVsc2Uge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbmNvdW50ZXJlZCBpbnZhbGlkIFJlYWN0IG5vZGUgb2YgdHlwZSAlcycsIHR5cGVvZiBub2RlKSA6IF9wcm9kSW52YXJpYW50KCcxMzEnLCB0eXBlb2Ygbm9kZSkgOiB2b2lkIDA7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0YW5jZS5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UucmVjZWl2ZUNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0SG9zdE5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLnVubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicsICdPbmx5IFJlYWN0IENvbXBvbmVudHMgY2FuIGJlIG1vdW50ZWQuJykgOiB2b2lkIDA7XG4gIH1cblxuICAvLyBUaGVzZSB0d28gZmllbGRzIGFyZSB1c2VkIGJ5IHRoZSBET00gYW5kIEFSVCBkaWZmaW5nIGFsZ29yaXRobXNcbiAgLy8gcmVzcGVjdGl2ZWx5LiBJbnN0ZWFkIG9mIHVzaW5nIGV4cGFuZG9zIG9uIGNvbXBvbmVudHMsIHdlIHNob3VsZCBiZVxuICAvLyBzdG9yaW5nIHRoZSBzdGF0ZSBuZWVkZWQgYnkgdGhlIGRpZmZpbmcgYWxnb3JpdGhtcyBlbHNld2hlcmUuXG4gIGluc3RhbmNlLl9tb3VudEluZGV4ID0gMDtcbiAgaW5zdGFuY2UuX21vdW50SW1hZ2UgPSBudWxsO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuX2RlYnVnSUQgPSBzaG91bGRIYXZlRGVidWdJRCA/IGdldE5leHREZWJ1Z0lEKCkgOiAwO1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgaW5zdGFuY2VzIHNob3VsZCBmdWxseSBjb25zdHJ1Y3RlZCBhdCB0aGlzIHBvaW50LCBzbyB0aGV5IHNob3VsZFxuICAvLyBub3QgZ2V0IGFueSBuZXcgZmllbGRzIGFkZGVkIHRvIHRoZW0gYXQgdGhpcyBwb2ludC5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBVbmVzY2FwZSBhbmQgdW53cmFwIGtleSBmb3IgaHVtYW4tcmVhZGFibGUgZGlzcGxheVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gdW5lc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSB1bmVzY2FwZWQga2V5LlxuICovXG5mdW5jdGlvbiB1bmVzY2FwZShrZXkpIHtcbiAgdmFyIHVuZXNjYXBlUmVnZXggPSAvKD0wfD0yKS9nO1xuICB2YXIgdW5lc2NhcGVyTG9va3VwID0ge1xuICAgICc9MCc6ICc9JyxcbiAgICAnPTInOiAnOidcbiAgfTtcbiAgdmFyIGtleVN1YnN0cmluZyA9IGtleVswXSA9PT0gJy4nICYmIGtleVsxXSA9PT0gJyQnID8ga2V5LnN1YnN0cmluZygyKSA6IGtleS5zdWJzdHJpbmcoMSk7XG5cbiAgcmV0dXJuICgnJyArIGtleVN1YnN0cmluZykucmVwbGFjZSh1bmVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG59XG5cbnZhciBLZXlFc2NhcGVVdGlscyA9IHtcbiAgZXNjYXBlOiBlc2NhcGUsXG4gIHVuZXNjYXBlOiB1bmVzY2FwZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBLZXlFc2NhcGVVdGlsczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudCB0eXBlLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ10gJiYgU3ltYm9sWydmb3InXSgncmVhY3QuZWxlbWVudCcpIHx8IDB4ZWFjNztcblxubW9kdWxlLmV4cG9ydHMgPSBSRUFDVF9FTEVNRU5UX1RZUEU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgU3ltYm9sICovXG5cbnZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4vKipcbiAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAqXG4gKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAqXG4gKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gKiAgICAgICAuLi5cbiAqICAgICB9XG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEl0ZXJhdG9yRm47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRTeW1ib2wnKTtcblxudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6JztcblxuLyoqXG4gKiBUaGlzIGlzIGlubGluZWQgZnJvbSBSZWFjdEVsZW1lbnQgc2luY2UgdGhpcyBmaWxlIGlzIHNoYXJlZCBiZXR3ZWVuXG4gKiBpc29tb3JwaGljIGFuZCByZW5kZXJlcnMuIFdlIGNvdWxkIGV4dHJhY3QgdGhpcyB0byBhXG4gKlxuICovXG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmIChjb21wb25lbnQgJiYgdHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIEtleUVzY2FwZVV0aWxzLmVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwgfHwgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicgfHxcbiAgLy8gVGhlIGZvbGxvd2luZyBpcyBpbmxpbmVkIGZyb20gUmVhY3RFbGVtZW50LiBUaGlzIG1lYW5zIHdlIGNhbiBvcHRpbWl6ZVxuICAvLyBzb21lIGNoZWNrcy4gUmVhY3QgRmliZXIgYWxzbyBpbmxpbmVzIHRoaXMgbG9naWMgZm9yIHNpbWlsYXIgcHVycG9zZXMuXG4gIHR5cGUgPT09ICdvYmplY3QnICYmIGNoaWxkcmVuLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpaSA9IDA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0gPSAnJztcbiAgICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgICBpZiAobWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUpIHtcbiAgICAgICAgICAgICAgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkLiBJdCBpcyBhbiAnICsgJ2V4cGVyaW1lbnRhbCBmZWF0dXJlIHRoYXQgbWlnaHQgYmUgcmVtb3ZlZC4gQ29udmVydCBpdCB0byBhICcgKyAnc2VxdWVuY2UgLyBpdGVyYWJsZSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIEtleUVzY2FwZVV0aWxzLmVzY2FwZShlbnRyeVswXSkgKyBTVUJTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIDApO1xuICAgICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQgb3Igd3JhcCB0aGUgb2JqZWN0IHVzaW5nIGNyZWF0ZUZyYWdtZW50KG9iamVjdCkgZnJvbSB0aGUgJyArICdSZWFjdCBhZGQtb25zLic7XG4gICAgICAgIGlmIChjaGlsZHJlbi5faXNSZWFjdEVsZW1lbnQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSXQgbG9va3MgbGlrZSB5b3VcXCdyZSB1c2luZyBhbiBlbGVtZW50IGNyZWF0ZWQgYnkgYSBkaWZmZXJlbnQgJyArICd2ZXJzaW9uIG9mIFJlYWN0LiBNYWtlIHN1cmUgdG8gdXNlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGFkZGVuZHVtICs9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKSA6IF9wcm9kSW52YXJpYW50KCczMScsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhdmVyc2VBbGxDaGlsZHJlbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xufVxuXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUNoaWxkKGNoaWxkSW5zdGFuY2VzLCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpIHtcbiAgLy8gV2UgZm91bmQgYSBjb21wb25lbnQgaW5zdGFuY2UuXG4gIHZhciBrZXlVbmlxdWUgPSBjaGlsZEluc3RhbmNlc1tuYW1lXSA9PT0gdW5kZWZpbmVkO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICghUmVhY3RDb21wb25lbnRUcmVlSG9vaykge1xuICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG4gICAgfVxuICAgIGlmICgha2V5VW5pcXVlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLiVzJywgS2V5RXNjYXBlVXRpbHMudW5lc2NhcGUobmFtZSksIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoc2VsZkRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaWYgKGNoaWxkICE9IG51bGwgJiYga2V5VW5pcXVlKSB7XG4gICAgY2hpbGRJbnN0YW5jZXNbbmFtZV0gPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGNoaWxkLCB0cnVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlYWN0Q2hpbGRSZWNvbmNpbGVyIHByb3ZpZGVzIGhlbHBlcnMgZm9yIGluaXRpYWxpemluZyBvciB1cGRhdGluZyBhIHNldCBvZlxuICogY2hpbGRyZW4uIEl0cyBvdXRwdXQgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgaXQgb250byBSZWFjdE11bHRpQ2hpbGQgd2hpY2hcbiAqIGRvZXMgZGlmZmVkIHJlb3JkZXJpbmcgYW5kIGluc2VydGlvbi5cbiAqL1xudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0ge1xuICAvKipcbiAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcbiAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGROb2RlcyBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICogQHJldHVybiB7P29iamVjdH0gQSBzZXQgb2YgY2hpbGQgaW5zdGFuY2VzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCwgc2VsZkRlYnVnSUQgLy8gMCBpbiBwcm9kdWN0aW9uIGFuZCBmb3Igcm9vdHNcbiAgKSB7XG4gICAgaWYgKG5lc3RlZENoaWxkTm9kZXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBjaGlsZEluc3RhbmNlcyA9IHt9O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4obmVzdGVkQ2hpbGROb2RlcywgZnVuY3Rpb24gKGNoaWxkSW5zdHMsIGNoaWxkLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW50aWF0ZUNoaWxkKGNoaWxkSW5zdHMsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCk7XG4gICAgICB9LCBjaGlsZEluc3RhbmNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4obmVzdGVkQ2hpbGROb2RlcywgaW5zdGFudGlhdGVDaGlsZCwgY2hpbGRJbnN0YW5jZXMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRJbnN0YW5jZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIGFuZCByZXR1cm5zIGEgbmV3IHNldCBvZiBjaGlsZHJlbi5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q2hpbGRyZW4gUHJldmlvdXNseSBpbml0aWFsaXplZCBzZXQgb2YgY2hpbGRyZW4uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENoaWxkcmVuIEZsYXQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9IEEgbmV3IHNldCBvZiBjaGlsZCBpbnN0YW5jZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCAvLyAwIGluIHByb2R1Y3Rpb24gYW5kIGZvciByb290c1xuICApIHtcbiAgICAvLyBXZSBjdXJyZW50bHkgZG9uJ3QgaGF2ZSBhIHdheSB0byB0cmFjayBtb3ZlcyBoZXJlIGJ1dCBpZiB3ZSB1c2UgaXRlcmF0b3JzXG4gICAgLy8gaW5zdGVhZCBvZiBmb3IuLmluIHdlIGNhbiB6aXAgdGhlIGl0ZXJhdG9ycyBhbmQgY2hlY2sgaWYgYW4gaXRlbSBoYXNcbiAgICAvLyBtb3ZlZC5cbiAgICAvLyBUT0RPOiBJZiBub3RoaW5nIGhhcyBjaGFuZ2VkLCByZXR1cm4gdGhlIHByZXZDaGlsZHJlbiBvYmplY3Qgc28gdGhhdCB3ZVxuICAgIC8vIGNhbiBxdWlja2x5IGJhaWxvdXQgaWYgbm90aGluZyBoYXMgY2hhbmdlZC5cbiAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuYW1lO1xuICAgIHZhciBwcmV2Q2hpbGQ7XG4gICAgZm9yIChuYW1lIGluIG5leHRDaGlsZHJlbikge1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgdmFyIHByZXZFbGVtZW50ID0gcHJldkNoaWxkICYmIHByZXZDaGlsZC5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB2YXIgbmV4dEVsZW1lbnQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICBpZiAocHJldkNoaWxkICE9IG51bGwgJiYgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSkge1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudChwcmV2Q2hpbGQsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IHByZXZDaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICByZW1vdmVkTm9kZXNbbmFtZV0gPSBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUocHJldkNoaWxkKTtcbiAgICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q2hpbGQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cbiAgICAgICAgdmFyIG5leHRDaGlsZEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IG5leHRDaGlsZEluc3RhbmNlO1xuICAgICAgICAvLyBDcmVhdGluZyBtb3VudCBpbWFnZSBub3cgZW5zdXJlcyByZWZzIGFyZSByZXNvbHZlZCBpbiByaWdodCBvcmRlclxuICAgICAgICAvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxMDEgZm9yIGV4cGxhbmF0aW9uKS5cbiAgICAgICAgdmFyIG5leHRDaGlsZE1vdW50SW1hZ2UgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQobmV4dENoaWxkSW5zdGFuY2UsIHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgICBtb3VudEltYWdlcy5wdXNoKG5leHRDaGlsZE1vdW50SW1hZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBVbm1vdW50IGNoaWxkcmVuIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxuICAgIGZvciAobmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIShuZXh0Q2hpbGRyZW4gJiYgbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSkge1xuICAgICAgICBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIHJlbW92ZWROb2Rlc1tuYW1lXSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShwcmV2Q2hpbGQpO1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q2hpbGQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubW91bnRzIGFsbCByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byBjbGVhbiB1cCBjaGlsZHJlblxuICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSByZW5kZXJlZENoaWxkcmVuIFByZXZpb3VzbHkgaW5pdGlhbGl6ZWQgc2V0IG9mIGNoaWxkcmVuLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKHJlbmRlcmVkQ2hpbGRyZW4sIHNhZmVseSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gcmVuZGVyZWRDaGlsZHJlbikge1xuICAgICAgaWYgKHJlbmRlcmVkQ2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkQ2hpbGQgPSByZW5kZXJlZENoaWxkcmVuW25hbWVdO1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChyZW5kZXJlZENoaWxkLCBzYWZlbHkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRSZWNvbmNpbGVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEtleUVzY2FwZVV0aWxzID0gcmVxdWlyZSgnLi9LZXlFc2NhcGVVdGlscycpO1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vaztcblxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gIC8vIFRlbXBvcmFyeSBoYWNrLlxuICAvLyBJbmxpbmUgcmVxdWlyZXMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggSmVzdDpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjQwXG4gIC8vIFJlbW92ZSB0aGUgaW5saW5lIHJlcXVpcmVzIHdoZW4gd2UgZG9uJ3QgbmVlZCB0aGVtIGFueW1vcmU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcxNzhcbiAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgcGFzc2VkIHRocm91Z2ggdHJhdmVyc2FsLlxuICogQHBhcmFtIHs/UmVhY3RDb21wb25lbnR9IGNoaWxkIFJlYWN0IGNoaWxkIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZSBTdHJpbmcgbmFtZSBvZiBrZXkgcGF0aCB0byBjaGlsZC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gc2VsZkRlYnVnSUQgT3B0aW9uYWwgZGVidWdJRCBvZiB0aGUgY3VycmVudCBpbnRlcm5hbCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpIHtcbiAgLy8gV2UgZm91bmQgYSBjb21wb25lbnQgaW5zdGFuY2UuXG4gIGlmICh0cmF2ZXJzZUNvbnRleHQgJiYgdHlwZW9mIHRyYXZlcnNlQ29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJhdmVyc2VDb250ZXh0O1xuICAgIHZhciBrZXlVbmlxdWUgPSByZXN1bHRbbmFtZV0gPT09IHVuZGVmaW5lZDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFSZWFjdENvbXBvbmVudFRyZWVIb29rKSB7XG4gICAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuICAgICAgfVxuICAgICAgaWYgKCFrZXlVbmlxdWUpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdmbGF0dGVuQ2hpbGRyZW4oLi4uKTogRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCAnICsgJ2Alc2AuIENoaWxkIGtleXMgbXVzdCBiZSB1bmlxdWU7IHdoZW4gdHdvIGNoaWxkcmVuIHNoYXJlIGEga2V5LCBvbmx5ICcgKyAndGhlIGZpcnN0IGNoaWxkIHdpbGwgYmUgdXNlZC4lcycsIEtleUVzY2FwZVV0aWxzLnVuZXNjYXBlKG5hbWUpLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKHNlbGZEZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlVbmlxdWUgJiYgY2hpbGQgIT0gbnVsbCkge1xuICAgICAgcmVzdWx0W25hbWVdID0gY2hpbGQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRmxhdHRlbnMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLiBBbnkgbnVsbFxuICogY2hpbGRyZW4gd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdGluZyBvYmplY3QuXG4gKiBAcmV0dXJuIHshb2JqZWN0fSBmbGF0dGVuZWQgY2hpbGRyZW4ga2V5ZWQgYnkgbmFtZS5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuLCBzZWxmRGVidWdJRCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICAgICAgcmV0dXJuIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKTtcbiAgICB9LCByZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0LCByZXN1bHQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbkNoaWxkcmVuOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkUmVjb25jaWxlcicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBmbGF0dGVuQ2hpbGRyZW4gPSByZXF1aXJlKCcuL2ZsYXR0ZW5DaGlsZHJlbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBtYXJrdXAgdG8gYmUgcmVuZGVyZWQgYW5kIGluc2VydGVkIGF0IGEgc3VwcGxpZWQgaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdGhhdCByZW5kZXJzIGludG8gYW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZUluc2VydE1hcmt1cChtYXJrdXAsIGFmdGVyTm9kZSwgdG9JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0lOU0VSVF9NQVJLVVAnLFxuICAgIGNvbnRlbnQ6IG1hcmt1cCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgZnJvbU5vZGU6IG51bGwsXG4gICAgdG9JbmRleDogdG9JbmRleCxcbiAgICBhZnRlck5vZGU6IGFmdGVyTm9kZVxuICB9O1xufVxuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBtb3ZpbmcgYW4gZXhpc3RpbmcgZWxlbWVudCB0byBhbm90aGVyIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggU291cmNlIGluZGV4IG9mIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXggb2YgdGhlIGVsZW1lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlTW92ZShjaGlsZCwgYWZ0ZXJOb2RlLCB0b0luZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnTU9WRV9FWElTVElORycsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IGNoaWxkLl9tb3VudEluZGV4LFxuICAgIGZyb21Ob2RlOiBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUoY2hpbGQpLFxuICAgIHRvSW5kZXg6IHRvSW5kZXgsXG4gICAgYWZ0ZXJOb2RlOiBhZnRlck5vZGVcbiAgfTtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3IgcmVtb3ZpbmcgYW4gZWxlbWVudCBhdCBhbiBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IEluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VSZW1vdmUoY2hpbGQsIG5vZGUpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdSRU1PVkVfTk9ERScsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IGNoaWxkLl9tb3VudEluZGV4LFxuICAgIGZyb21Ob2RlOiBub2RlLFxuICAgIHRvSW5kZXg6IG51bGwsXG4gICAgYWZ0ZXJOb2RlOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIHNldHRpbmcgdGhlIG1hcmt1cCBvZiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdGhhdCByZW5kZXJzIGludG8gYW4gZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VTZXRNYXJrdXAobWFya3VwKSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnU0VUX01BUktVUCcsXG4gICAgY29udGVudDogbWFya3VwLFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0b0luZGV4OiBudWxsLFxuICAgIGFmdGVyTm9kZTogbnVsbFxuICB9O1xufVxuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciBzZXR0aW5nIHRoZSB0ZXh0IGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRDb250ZW50IFRleHQgY29udGVudCB0byBzZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlVGV4dENvbnRlbnQodGV4dENvbnRlbnQpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdURVhUX0NPTlRFTlQnLFxuICAgIGNvbnRlbnQ6IHRleHRDb250ZW50LFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0b0luZGV4OiBudWxsLFxuICAgIGFmdGVyTm9kZTogbnVsbFxuICB9O1xufVxuXG4vKipcbiAqIFB1c2ggYW4gdXBkYXRlLCBpZiBhbnksIG9udG8gdGhlIHF1ZXVlLiBDcmVhdGVzIGEgbmV3IHF1ZXVlIGlmIG5vbmUgaXNcbiAqIHBhc3NlZCBhbmQgYWx3YXlzIHJldHVybnMgdGhlIHF1ZXVlLiBNdXRhdGl2ZS5cbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZShxdWV1ZSwgdXBkYXRlKSB7XG4gIGlmICh1cGRhdGUpIHtcbiAgICBxdWV1ZSA9IHF1ZXVlIHx8IFtdO1xuICAgIHF1ZXVlLnB1c2godXBkYXRlKTtcbiAgfVxuICByZXR1cm4gcXVldWU7XG59XG5cbi8qKlxuICogUHJvY2Vzc2VzIGFueSBlbnF1ZXVlZCB1cGRhdGVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NRdWV1ZShpbnN0LCB1cGRhdGVRdWV1ZSkge1xuICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXMoaW5zdCwgdXBkYXRlUXVldWUpO1xufVxuXG52YXIgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24gPSBlbXB0eUZ1bmN0aW9uO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGdldERlYnVnSUQgPSBmdW5jdGlvbiAoaW5zdCkge1xuICAgIGlmICghaW5zdC5fZGVidWdJRCkge1xuICAgICAgLy8gQ2hlY2sgZm9yIEFSVC1saWtlIGluc3RhbmNlcy4gVE9ETzogVGhpcyBpcyBzaWxseS9ncm9zcy5cbiAgICAgIHZhciBpbnRlcm5hbDtcbiAgICAgIGlmIChpbnRlcm5hbCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KGluc3QpKSB7XG4gICAgICAgIGluc3QgPSBpbnRlcm5hbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc3QuX2RlYnVnSUQ7XG4gIH07XG4gIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uID0gZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgdmFyIGRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xuICAgIC8vIFRPRE86IFJlYWN0IE5hdGl2ZSBlbXB0eSBjb21wb25lbnRzIGFyZSBhbHNvIG11bHRpY2hpbGQuXG4gICAgLy8gVGhpcyBtZWFucyB0aGV5IHN0aWxsIGdldCBpbnRvIHRoaXMgbWV0aG9kIGJ1dCBkb24ndCBoYXZlIF9kZWJ1Z0lELlxuICAgIGlmIChkZWJ1Z0lEICE9PSAwKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbihkZWJ1Z0lELCBjaGlsZHJlbiA/IE9iamVjdC5rZXlzKGNoaWxkcmVuKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5ba2V5XS5fZGVidWdJRDtcbiAgICAgIH0pIDogW10pO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBSZWFjdE11bHRpQ2hpbGQgYXJlIGNhcGFibGUgb2YgcmVjb25jaWxpbmcgbXVsdGlwbGUgY2hpbGRyZW4uXG4gKlxuICogQGNsYXNzIFJlYWN0TXVsdGlDaGlsZFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdE11bHRpQ2hpbGQgPSB7XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGZvciBjb21wb25lbnRzIHRoYXQgbXVzdCByZWNvbmNpbGUgbXVsdGlwbGVcbiAgICogY2hpbGRyZW4uIFRoaXMgaXMgdXNlZCBieSBgUmVhY3RET01Db21wb25lbnRgIHRvIG1vdW50LCB1cGRhdGUsIGFuZFxuICAgKiB1bm1vdW50IGNoaWxkIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEBsZW5kcyB7UmVhY3RNdWx0aUNoaWxkLnByb3RvdHlwZX1cbiAgICovXG4gIE1peGluOiB7XG5cbiAgICBfcmVjb25jaWxlckluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBzZWxmRGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgbmV4dENoaWxkcmVuO1xuICAgICAgdmFyIHNlbGZEZWJ1Z0lEID0gMDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNlbGZEZWJ1Z0lEID0gZ2V0RGVidWdJRCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICBuZXh0Q2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgdGhpcywgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgICByZXR1cm4gbmV4dENoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgdGhpcywgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgIHJldHVybiBuZXh0Q2hpbGRyZW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIFwibW91bnQgaW1hZ2VcIiBmb3IgZWFjaCBvZiB0aGUgc3VwcGxpZWQgY2hpbGRyZW4uIEluIHRoZSBjYXNlXG4gICAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5lc3RlZENoaWxkcmVuIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSBvZiBtb3VudGVkIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBtb3VudENoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9yZWNvbmNpbGVySW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgICB2YXIgbW91bnRJbWFnZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW25hbWVdO1xuICAgICAgICAgIHZhciBzZWxmRGVidWdJRCA9IDA7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHNlbGZEZWJ1Z0lEID0gZ2V0RGVidWdJRCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG1vdW50SW1hZ2UgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHRyYW5zYWN0aW9uLCB0aGlzLCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgICBtb3VudEltYWdlcy5wdXNoKG1vdW50SW1hZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgY2hpbGRyZW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbW91bnRJbWFnZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFueSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgdGV4dCBjb250ZW50IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXh0Q29udGVudCBTdHJpbmcgb2YgY29udGVudC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVUZXh0Q29udGVudDogZnVuY3Rpb24gKG5leHRDb250ZW50KSB7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBmYWxzZSk7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZVRleHRDb250ZW50IGNhbGxlZCBvbiBub24tZW1wdHkgY29tcG9uZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzExOCcpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTZXQgbmV3IHRleHQgY29udGVudC5cbiAgICAgIHZhciB1cGRhdGVzID0gW21ha2VUZXh0Q29udGVudChuZXh0Q29udGVudCldO1xuICAgICAgcHJvY2Vzc1F1ZXVlKHRoaXMsIHVwZGF0ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbnkgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG1hcmt1cCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dE1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZU1hcmt1cDogZnVuY3Rpb24gKG5leHRNYXJrdXApIHtcbiAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgLy8gUmVtb3ZlIGFueSByZW5kZXJlZCBjaGlsZHJlbi5cbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIGZhbHNlKTtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlVGV4dENvbnRlbnQgY2FsbGVkIG9uIG5vbi1lbXB0eSBjb21wb25lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMTE4JykgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB1cGRhdGVzID0gW21ha2VTZXRNYXJrdXAobmV4dE1hcmt1cCldO1xuICAgICAgcHJvY2Vzc1F1ZXVlKHRoaXMsIHVwZGF0ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIG5ldyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMgTmVzdGVkIGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIC8vIEhvb2sgdXNlZCBieSBSZWFjdCBBUlRcbiAgICAgIHRoaXMuX3VwZGF0ZUNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMgTmVzdGVkIGNoaWxkIGVsZW1lbnQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGZpbmFsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF91cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICB2YXIgcmVtb3ZlZE5vZGVzID0ge307XG4gICAgICB2YXIgbW91bnRJbWFnZXMgPSBbXTtcbiAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB0aGlzLl9yZWNvbmNpbGVyVXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gJiYgIXByZXZDaGlsZHJlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdXBkYXRlcyA9IG51bGw7XG4gICAgICB2YXIgbmFtZTtcbiAgICAgIC8vIGBuZXh0SW5kZXhgIHdpbGwgaW5jcmVtZW50IGZvciBlYWNoIGNoaWxkIGluIGBuZXh0Q2hpbGRyZW5gLCBidXRcbiAgICAgIC8vIGBsYXN0SW5kZXhgIHdpbGwgYmUgdGhlIGxhc3QgaW5kZXggdmlzaXRlZCBpbiBgcHJldkNoaWxkcmVuYC5cbiAgICAgIHZhciBuZXh0SW5kZXggPSAwO1xuICAgICAgdmFyIGxhc3RJbmRleCA9IDA7XG4gICAgICAvLyBgbmV4dE1vdW50SW5kZXhgIHdpbGwgaW5jcmVtZW50IGZvciBlYWNoIG5ld2x5IG1vdW50ZWQgY2hpbGQuXG4gICAgICB2YXIgbmV4dE1vdW50SW5kZXggPSAwO1xuICAgICAgdmFyIGxhc3RQbGFjZWROb2RlID0gbnVsbDtcbiAgICAgIGZvciAobmFtZSBpbiBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuICYmIHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgdmFyIG5leHRDaGlsZCA9IG5leHRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgaWYgKHByZXZDaGlsZCA9PT0gbmV4dENoaWxkKSB7XG4gICAgICAgICAgdXBkYXRlcyA9IGVucXVldWUodXBkYXRlcywgdGhpcy5tb3ZlQ2hpbGQocHJldkNoaWxkLCBsYXN0UGxhY2VkTm9kZSwgbmV4dEluZGV4LCBsYXN0SW5kZXgpKTtcbiAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgcHJldkNoaWxkLl9tb3VudEluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBgbGFzdEluZGV4YCBiZWZvcmUgYF9tb3VudEluZGV4YCBnZXRzIHVuc2V0IGJ5IHVubW91bnRpbmcuXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgICAvLyBUaGUgYHJlbW92ZWROb2Rlc2AgbG9vcCBiZWxvdyB3aWxsIGFjdHVhbGx5IHJlbW92ZSB0aGUgY2hpbGQuXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRoZSBjaGlsZCBtdXN0IGJlIGluc3RhbnRpYXRlZCBiZWZvcmUgaXQncyBtb3VudGVkLlxuICAgICAgICAgIHVwZGF0ZXMgPSBlbnF1ZXVlKHVwZGF0ZXMsIHRoaXMuX21vdW50Q2hpbGRBdEluZGV4KG5leHRDaGlsZCwgbW91bnRJbWFnZXNbbmV4dE1vdW50SW5kZXhdLCBsYXN0UGxhY2VkTm9kZSwgbmV4dEluZGV4LCB0cmFuc2FjdGlvbiwgY29udGV4dCkpO1xuICAgICAgICAgIG5leHRNb3VudEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICAgIGxhc3RQbGFjZWROb2RlID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKG5leHRDaGlsZCk7XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgY2hpbGRyZW4gdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAgICBmb3IgKG5hbWUgaW4gcmVtb3ZlZE5vZGVzKSB7XG4gICAgICAgIGlmIChyZW1vdmVkTm9kZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICB1cGRhdGVzID0gZW5xdWV1ZSh1cGRhdGVzLCB0aGlzLl91bm1vdW50Q2hpbGQocHJldkNoaWxkcmVuW25hbWVdLCByZW1vdmVkTm9kZXNbbmFtZV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHVwZGF0ZXMpIHtcbiAgICAgICAgcHJvY2Vzc1F1ZXVlKHRoaXMsIHVwZGF0ZXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG5leHRDaGlsZHJlbjtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24uY2FsbCh0aGlzLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhbGwgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gY2xlYW4gdXAgY2hpbGRyZW5cbiAgICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC4gSXQgZG9lcyBub3QgYWN0dWFsbHkgcGVyZm9ybSBhbnlcbiAgICAgKiBiYWNrZW5kIG9wZXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1bm1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChzYWZlbHkpIHtcbiAgICAgIHZhciByZW5kZXJlZENoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihyZW5kZXJlZENoaWxkcmVuLCBzYWZlbHkpO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgY2hpbGQgY29tcG9uZW50IHRvIHRoZSBzdXBwbGllZCBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBtb3ZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0SW5kZXggTGFzdCBpbmRleCB2aXNpdGVkIG9mIHRoZSBzaWJsaW5ncyBvZiBgY2hpbGRgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgYWZ0ZXJOb2RlLCB0b0luZGV4LCBsYXN0SW5kZXgpIHtcbiAgICAgIC8vIElmIHRoZSBpbmRleCBvZiBgY2hpbGRgIGlzIGxlc3MgdGhhbiBgbGFzdEluZGV4YCwgdGhlbiBpdCBuZWVkcyB0b1xuICAgICAgLy8gYmUgbW92ZWQuIE90aGVyd2lzZSwgd2UgZG8gbm90IG5lZWQgdG8gbW92ZSBpdCBiZWNhdXNlIGEgY2hpbGQgd2lsbCBiZVxuICAgICAgLy8gaW5zZXJ0ZWQgb3IgbW92ZWQgYmVmb3JlIGBjaGlsZGAuXG4gICAgICBpZiAoY2hpbGQuX21vdW50SW5kZXggPCBsYXN0SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VNb3ZlKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIGNyZWF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW91bnRJbWFnZSBNYXJrdXAgdG8gaW5zZXJ0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBhZnRlck5vZGUsIG1vdW50SW1hZ2UpIHtcbiAgICAgIHJldHVybiBtYWtlSW5zZXJ0TWFya3VwKG1vdW50SW1hZ2UsIGFmdGVyTm9kZSwgY2hpbGQuX21vdW50SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ2hpbGQgdG8gcmVtb3ZlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVDaGlsZDogZnVuY3Rpb24gKGNoaWxkLCBub2RlKSB7XG4gICAgICByZXR1cm4gbWFrZVJlbW92ZShjaGlsZCwgbm9kZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdW50cyBhIGNoaWxkIHdpdGggdGhlIHN1cHBsaWVkIG5hbWUuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW91bnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21vdW50Q2hpbGRBdEluZGV4OiBmdW5jdGlvbiAoY2hpbGQsIG1vdW50SW1hZ2UsIGFmdGVyTm9kZSwgaW5kZXgsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4O1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ2hpbGQoY2hpbGQsIGFmdGVyTm9kZSwgbW91bnRJbWFnZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGEgcmVuZGVyZWQgY2hpbGQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gdW5tb3VudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91bm1vdW50Q2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgbm9kZSkge1xuICAgICAgdmFyIHVwZGF0ZSA9IHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGQsIG5vZGUpO1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZTtcbiAgICB9XG5cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TXVsdGlDaGlsZDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSkge1xuICBSZWFjdFVwZGF0ZXMuZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VW5leHBlY3RlZEFyZ3VtZW50KGFyZykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBhcmc7XG4gIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHZhciBkaXNwbGF5TmFtZSA9IGFyZy5jb25zdHJ1Y3RvciAmJiBhcmcuY29uc3RydWN0b3IubmFtZSB8fCB0eXBlO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFyZyk7XG4gIGlmIChrZXlzLmxlbmd0aCA+IDAgJiYga2V5cy5sZW5ndGggPCAyMCkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZSArICcgKGtleXM6ICcgKyBrZXlzLmpvaW4oJywgJykgKyAnKSc7XG4gIH1cbiAgcmV0dXJuIGRpc3BsYXlOYW1lO1xufVxuXG5mdW5jdGlvbiBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSk7XG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgICAgLy8gT25seSB3YXJuIHdoZW4gd2UgaGF2ZSBhIGNhbGxlck5hbWUuIE90aGVyd2lzZSB3ZSBzaG91bGQgYmUgc2lsZW50LlxuICAgICAgLy8gV2UncmUgcHJvYmFibHkgY2FsbGluZyBmcm9tIGVucXVldWVDYWxsYmFjay4gV2UgZG9uJ3Qgd2FudCB0byB3YXJuXG4gICAgICAvLyB0aGVyZSBiZWNhdXNlIHdlIGFscmVhZHkgd2FybmVkIGZvciB0aGUgY29ycmVzcG9uZGluZyBsaWZlY3ljbGUgbWV0aG9kLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNhbGxlck5hbWUsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY3RvciAmJiAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICclcyguLi4pOiBDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzICcgKyAnd2l0aGluIGByZW5kZXJgIG9yIGFub3RoZXIgY29tcG9uZW50XFwncyBjb25zdHJ1Y3RvcikuIFJlbmRlciBtZXRob2RzICcgKyAnc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7IGNvbnN0cnVjdG9yICcgKyAnc2lkZS1lZmZlY3RzIGFyZSBhbiBhbnRpLXBhdHRlcm4sIGJ1dCBjYW4gYmUgbW92ZWQgdG8gJyArICdgY29tcG9uZW50V2lsbE1vdW50YC4nLCBjYWxsZXJOYW1lKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiBpbnRlcm5hbEluc3RhbmNlO1xufVxuXG4vKipcbiAqIFJlYWN0VXBkYXRlUXVldWUgYWxsb3dzIGZvciBzdGF0ZSB1cGRhdGVzIHRvIGJlIHNjaGVkdWxlZCBpbnRvIGEgbGF0ZXJcbiAqIHJlY29uY2lsaWF0aW9uIHN0ZXAuXG4gKi9cbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgICAgaWYgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgICAgb3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSk7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIC8vIER1cmluZyBjb21wb25lbnRXaWxsTW91bnQgYW5kIHJlbmRlciB0aGlzIHdpbGwgc3RpbGwgYmUgbnVsbCBidXQgYWZ0ZXJcbiAgICAgIC8vIHRoYXQgd2lsbCBhbHdheXMgcmVuZGVyIHRvIHNvbWV0aGluZy4gQXQgbGVhc3QgZm9yIG5vdy4gU28gd2UgY2FuIHVzZVxuICAgICAgLy8gdGhpcyBoYWNrLlxuICAgICAgcmV0dXJuICEhaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2FsbGVyTmFtZSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIFJlYWN0VXBkYXRlUXVldWUudmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjaywgY2FsbGVyTmFtZSk7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UpO1xuXG4gICAgLy8gUHJldmlvdXNseSB3ZSB3b3VsZCB0aHJvdyBhbiBlcnJvciBpZiB3ZSBkaWRuJ3QgaGF2ZSBhbiBpbnRlcm5hbFxuICAgIC8vIGluc3RhbmNlLiBTaW5jZSB3ZSB3YW50IHRvIG1ha2UgaXQgYSBuby1vcCBpbnN0ZWFkLCB3ZSBtaXJyb3IgdGhlIHNhbWVcbiAgICAvLyBiZWhhdmlvciB3ZSBoYXZlIGluIG90aGVyIGVucXVldWUqIG1ldGhvZHMuXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIGlnbm9yZSBjYWxsYmFja3MgaW4gY29tcG9uZW50V2lsbE1vdW50LiBTZWVcbiAgICAvLyBlbnF1ZXVlVXBkYXRlcy5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gICAgLy8gVE9ETzogVGhlIGNhbGxiYWNrIGhlcmUgaXMgaWdub3JlZCB3aGVuIHNldFN0YXRlIGlzIGNhbGxlZCBmcm9tXG4gICAgLy8gY29tcG9uZW50V2lsbE1vdW50LiBFaXRoZXIgZml4IGl0IG9yIGRpc2FsbG93IGRvaW5nIHNvIGNvbXBsZXRlbHkgaW5cbiAgICAvLyBmYXZvciBvZiBnZXRJbml0aWFsU3RhdGUuIEFsdGVybmF0aXZlbHksIHdlIGNhbiBkaXNhbGxvd1xuICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBkdXJpbmcgc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IHRydWU7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW2NvbXBsZXRlU3RhdGVdO1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSB0cnVlO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0U3RhdGUoKTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHBhcnRpYWxTdGF0ZSAhPSBudWxsLCAnc2V0U3RhdGUoLi4uKTogWW91IHBhc3NlZCBhbiB1bmRlZmluZWQgb3IgbnVsbCBzdGF0ZSBvYmplY3Q7ICcgKyAnaW5zdGVhZCwgdXNlIGZvcmNlVXBkYXRlKCkuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHF1ZXVlID0gaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgfHwgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW10pO1xuICAgIHF1ZXVlLnB1c2gocGFydGlhbFN0YXRlKTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5leHRFbGVtZW50LCBuZXh0Q29udGV4dCkge1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgLy8gVE9ETzogaW50cm9kdWNlIF9wZW5kaW5nQ29udGV4dCBpbnN0ZWFkIG9mIHNldHRpbmcgaXQgZGlyZWN0bHkuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fY29udGV4dCA9IG5leHRDb250ZXh0O1xuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgdmFsaWRhdGVDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgISghY2FsbGJhY2sgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChjYWxsYmFjaykpIDogX3Byb2RJbnZhcmlhbnQoJzEyMicsIGNhbGxlck5hbWUsIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChjYWxsYmFjaykpIDogdm9pZCAwO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RVcGRhdGVRdWV1ZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb3V0c2lkZSBjb21wb25lbnRXaWxsTW91bnQoKSBvbiB0aGUgc2VydmVyLiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcycpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgdXBkYXRlIHF1ZXVlIHVzZWQgZm9yIHNlcnZlciByZW5kZXJpbmcuXG4gKiBJdCBkZWxlZ2F0ZXMgdG8gUmVhY3RVcGRhdGVRdWV1ZSB3aGlsZSBzZXJ2ZXIgcmVuZGVyaW5nIGlzIGluIHByb2dyZXNzIGFuZFxuICogc3dpdGNoZXMgdG8gUmVhY3ROb29wVXBkYXRlUXVldWUgYWZ0ZXIgdGhlIHRyYW5zYWN0aW9uIGhhcyBjb21wbGV0ZWQuXG4gKiBAY2xhc3MgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZVxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqL1xuXG52YXIgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSh0cmFuc2FjdGlvbikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlKTtcblxuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuaXNNb3VudGVkID0gZnVuY3Rpb24gaXNNb3VudGVkKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbCB0aGUgcGVuZGluZyB1cGRhdGVzXG4gICAqIGhhdmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0byB1c2UgYXMgYHRoaXNgIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZUNhbGxiYWNrID0gZnVuY3Rpb24gZW5xdWV1ZUNhbGxiYWNrKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFjayhwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZUZvcmNlVXBkYXRlID0gZnVuY3Rpb24gZW5xdWV1ZUZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaXNJblRyYW5zYWN0aW9uKCkpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlUmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gZW5xdWV1ZVJlcGxhY2VTdGF0ZShwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVSZXBsYWNlU3RhdGUocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlU2V0U3RhdGUgPSBmdW5jdGlvbiBlbnF1ZXVlU2V0U3RhdGUocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVTZXRTdGF0ZShwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFNlcnZlclVwZGF0ZVF1ZXVlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZScpO1xuXG4vKipcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXG4gKiBlYWNoIG90aGVyLlxuICovXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbXTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVFJBTlNBQ1RJT05fV1JBUFBFUlMucHVzaCh7XG4gICAgaW5pdGlhbGl6ZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5GbHVzaCxcbiAgICBjbG9zZTogUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uRW5kRmx1c2hcbiAgfSk7XG59XG5cbnZhciBub29wQ2FsbGJhY2tRdWV1ZSA9IHtcbiAgZW5xdWV1ZTogZnVuY3Rpb24gKCkge31cbn07XG5cbi8qKlxuICogQGNsYXNzIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVuZGVyVG9TdGF0aWNNYXJrdXBcbiAqL1xuZnVuY3Rpb24gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbihyZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSByZW5kZXJUb1N0YXRpY01hcmt1cDtcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gZmFsc2U7XG4gIHRoaXMudXBkYXRlUXVldWUgPSBuZXcgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSh0aGlzKTtcbn1cblxudmFyIE1peGluID0ge1xuICAvKipcbiAgICogQHNlZSBUcmFuc2FjdGlvblxuICAgKiBAYWJzdHJhY3RcbiAgICogQGZpbmFsXG4gICAqIEByZXR1cm4ge2FycmF5fSBFbXB0eSBsaXN0IG9mIG9wZXJhdGlvbiB3cmFwIHByb2NlZHVyZXMuXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IGBvbkRPTVJlYWR5YCBjYWxsYmFja3Mgd2l0aC5cbiAgICovXG4gIGdldFJlYWN0TW91bnRSZWFkeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBub29wQ2FsbGJhY2tRdWV1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBSZWFjdCBhc3luYyBldmVudHMuXG4gICAqL1xuICBnZXRVcGRhdGVRdWV1ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZVF1ZXVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXVzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7fSxcblxuICBjaGVja3BvaW50OiBmdW5jdGlvbiAoKSB7fSxcblxuICByb2xsYmFjazogZnVuY3Rpb24gKCkge31cbn07XG5cbl9hc3NpZ24oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLCBNaXhpbik7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG4gIHZhciBzcGVjaWFsVGFncyA9IFsnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZXRhaWxzJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ25hdicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdwJywgJ3BhcmFtJywgJ3BsYWludGV4dCcsICdwcmUnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NvdXJjZScsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3VsJywgJ3dicicsICd4bXAnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICB2YXIgaW5TY29wZVRhZ3MgPSBbJ2FwcGxldCcsICdjYXB0aW9uJywgJ2h0bWwnLCAndGFibGUnLCAndGQnLCAndGgnLCAnbWFycXVlZScsICdvYmplY3QnLCAndGVtcGxhdGUnLFxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuXG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gZnVuY3Rpb24gKG9sZEluZm8sIHRhZywgaW5zdGFuY2UpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gX2Fzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGluZm8gPSB7IHRhZzogdGFnLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdhJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnRUYWcpIHtcbiAgICAvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbiAgICBzd2l0Y2ggKHBhcmVudFRhZykge1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluc2VsZWN0XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICdvcHRncm91cCcgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgY2FzZSAnb3B0Z3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBTdHJpY3RseSBzcGVha2luZywgc2VlaW5nIGFuIDxvcHRpb24+IGRvZXNuJ3QgbWVhbiB3ZSdyZSBpbiBhIDxzZWxlY3Q+XG4gICAgICAvLyBidXRcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG4gICAgICAvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuICAgICAgLy8gYWxsIGV4Y2VwdCBzcGVjaWFsIHRhYmxlIG5vZGVzIHdoaWNoIGNhdXNlIGJhZCBwYXJzaW5nIGJlaGF2aW9yIGFueXdheS5cblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RoJyB8fCB0YWcgPT09ICd0ZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50Ym9keVxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndHInIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY2FwdGlvbicgfHwgdGFnID09PSAnY29sZ3JvdXAnIHx8IHRhZyA9PT0gJ3Rib2R5JyB8fCB0YWcgPT09ICd0Zm9vdCcgfHwgdGFnID09PSAndGhlYWQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluaGVhZFxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdiYXNlJyB8fCB0YWcgPT09ICdiYXNlZm9udCcgfHwgdGFnID09PSAnYmdzb3VuZCcgfHwgdGFnID09PSAnbGluaycgfHwgdGFnID09PSAnbWV0YScgfHwgdGFnID09PSAndGl0bGUnIHx8IHRhZyA9PT0gJ25vc2NyaXB0JyB8fCB0YWcgPT09ICdub2ZyYW1lcycgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtaHRtbC1lbGVtZW50XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2hlYWQnIHx8IHRhZyA9PT0gJ2JvZHknO1xuICAgICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2h0bWwnO1xuICAgIH1cblxuICAgIC8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3NcbiAgICAvLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuXG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG5cbiAgICAgIGNhc2UgJ3RhYmxlJzpcblxuICAgICAgY2FzZSAnaHInOlxuXG4gICAgICBjYXNlICd4bXAnOlxuXG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmZvcm1UYWcgfHwgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdsaSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnZGQnOlxuICAgICAgY2FzZSAnZHQnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAvLyBTcGVjIHNheXMgc29tZXRoaW5nIGFib3V0IHN0b3JpbmcgYSBsaXN0IG9mIG1hcmtlcnMsIGJ1dCBpdCBzb3VuZHNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGlzIGNoZWNrLlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdub2JyJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gYSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCBpbnN0YW5jZSwgcmV0dXJuIGEgbGlzdCBvZiBpdHMgcmVjdXJzaXZlXG4gICAqIG93bmVycywgc3RhcnRpbmcgYXQgdGhlIHJvb3QgYW5kIGVuZGluZyB3aXRoIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICB2YXIgZmluZE93bmVyU3RhY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgZG8ge1xuICAgICAgc3RhY2sucHVzaChpbnN0YW5jZSk7XG4gICAgfSB3aGlsZSAoaW5zdGFuY2UgPSBpbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcbiAgICBzdGFjay5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIHZhciBkaWRXYXJuID0ge307XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKGNoaWxkVGFnLCBjaGlsZFRleHQsIGNoaWxkSW5zdGFuY2UsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuXG4gICAgaWYgKGNoaWxkVGV4dCAhPSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhjaGlsZFRhZyA9PSBudWxsLCAndmFsaWRhdGVET01OZXN0aW5nOiB3aGVuIGNoaWxkVGV4dCBpcyBwYXNzZWQsIGNoaWxkVGFnIHNob3VsZCBiZSBudWxsJykgOiB2b2lkIDA7XG4gICAgICBjaGlsZFRhZyA9ICcjdGV4dCc7XG4gICAgfVxuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIHByb2JsZW1hdGljID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG5cbiAgICBpZiAocHJvYmxlbWF0aWMpIHtcbiAgICAgIHZhciBhbmNlc3RvclRhZyA9IHByb2JsZW1hdGljLnRhZztcbiAgICAgIHZhciBhbmNlc3Rvckluc3RhbmNlID0gcHJvYmxlbWF0aWMuaW5zdGFuY2U7XG5cbiAgICAgIHZhciBjaGlsZE93bmVyID0gY2hpbGRJbnN0YW5jZSAmJiBjaGlsZEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lciA9IGFuY2VzdG9ySW5zdGFuY2UgJiYgYW5jZXN0b3JJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuXG4gICAgICB2YXIgY2hpbGRPd25lcnMgPSBmaW5kT3duZXJTdGFjayhjaGlsZE93bmVyKTtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVycyA9IGZpbmRPd25lclN0YWNrKGFuY2VzdG9yT3duZXIpO1xuXG4gICAgICB2YXIgbWluU3RhY2tMZW4gPSBNYXRoLm1pbihjaGlsZE93bmVycy5sZW5ndGgsIGFuY2VzdG9yT3duZXJzLmxlbmd0aCk7XG4gICAgICB2YXIgaTtcblxuICAgICAgdmFyIGRlZXBlc3RDb21tb24gPSAtMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5TdGFja0xlbjsgaSsrKSB7XG4gICAgICAgIGlmIChjaGlsZE93bmVyc1tpXSA9PT0gYW5jZXN0b3JPd25lcnNbaV0pIHtcbiAgICAgICAgICBkZWVwZXN0Q29tbW9uID0gaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgVU5LTk9XTiA9ICcodW5rbm93biknO1xuICAgICAgdmFyIGNoaWxkT3duZXJOYW1lcyA9IGNoaWxkT3duZXJzLnNsaWNlKGRlZXBlc3RDb21tb24gKyAxKS5tYXAoZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuZ2V0TmFtZSgpIHx8IFVOS05PV047XG4gICAgICB9KTtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVyTmFtZXMgPSBhbmNlc3Rvck93bmVycy5zbGljZShkZWVwZXN0Q29tbW9uICsgMSkubWFwKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIHJldHVybiBpbnN0LmdldE5hbWUoKSB8fCBVTktOT1dOO1xuICAgICAgfSk7XG4gICAgICB2YXIgb3duZXJJbmZvID0gW10uY29uY2F0KFxuICAgICAgLy8gSWYgdGhlIHBhcmVudCBhbmQgY2hpbGQgaW5zdGFuY2VzIGhhdmUgYSBjb21tb24gb3duZXIgYW5jZXN0b3IsIHN0YXJ0XG4gICAgICAvLyB3aXRoIHRoYXQgLS0gb3RoZXJ3aXNlIHdlIGp1c3Qgc3RhcnQgd2l0aCB0aGUgcGFyZW50J3Mgb3duZXJzLlxuICAgICAgZGVlcGVzdENvbW1vbiAhPT0gLTEgPyBjaGlsZE93bmVyc1tkZWVwZXN0Q29tbW9uXS5nZXROYW1lKCkgfHwgVU5LTk9XTiA6IFtdLCBhbmNlc3Rvck93bmVyTmFtZXMsIGFuY2VzdG9yVGFnLFxuICAgICAgLy8gSWYgd2UncmUgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIChub24tcGFyZW50KSBhbmNlc3RyeSwgYWRkICcuLi4nXG4gICAgICBpbnZhbGlkQW5jZXN0b3IgPyBbJy4uLiddIDogW10sIGNoaWxkT3duZXJOYW1lcywgY2hpbGRUYWcpLmpvaW4oJyA+ICcpO1xuXG4gICAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBvd25lckluZm87XG4gICAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgICAgdmFyIHRhZ0Rpc3BsYXlOYW1lID0gY2hpbGRUYWc7XG4gICAgICB2YXIgd2hpdGVzcGFjZUluZm8gPSAnJztcbiAgICAgIGlmIChjaGlsZFRhZyA9PT0gJyN0ZXh0Jykge1xuICAgICAgICBpZiAoL1xcUy8udGVzdChjaGlsZFRleHQpKSB7XG4gICAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnVGV4dCBub2Rlcyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnV2hpdGVzcGFjZSB0ZXh0IG5vZGVzJztcbiAgICAgICAgICB3aGl0ZXNwYWNlSW5mbyA9ICcgTWFrZSBzdXJlIHlvdSBkb25cXCd0IGhhdmUgYW55IGV4dHJhIHdoaXRlc3BhY2UgYmV0d2VlbiB0YWdzIG9uICcgKyAnZWFjaCBsaW5lIG9mIHlvdXIgc291cmNlIGNvZGUuJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnPCcgKyBjaGlsZFRhZyArICc+JztcbiAgICAgIH1cblxuICAgICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgICAgaW5mbyArPSAnIEFkZCBhIDx0Ym9keT4gdG8geW91ciBjb2RlIHRvIG1hdGNoIHRoZSBET00gdHJlZSBnZW5lcmF0ZWQgYnkgJyArICd0aGUgYnJvd3Nlci4nO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBjaGlsZCBvZiA8JXM+LiVzICcgKyAnU2VlICVzLiVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCB3aGl0ZXNwYWNlSW5mbywgb3duZXJJbmZvLCBpbmZvKSA6IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4gU2VlICVzLicsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgb3duZXJJbmZvKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvO1xuXG4gIC8vIEZvciB0ZXN0aW5nXG4gIHZhbGlkYXRlRE9NTmVzdGluZy5pc1RhZ1ZhbGlkSW5Db250ZXh0ID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG4gICAgcmV0dXJuIGlzVGFnVmFsaWRXaXRoUGFyZW50KHRhZywgcGFyZW50VGFnKSAmJiAhZmluZEludmFsaWRBbmNlc3RvckZvclRhZyh0YWcsIGFuY2VzdG9ySW5mbyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRhdGVET01OZXN0aW5nOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4vKiBnbG9iYWwgaGFzT3duUHJvcGVydHk6dHJ1ZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIEF1dG9Gb2N1c1V0aWxzID0gcmVxdWlyZSgnLi9BdXRvRm9jdXNVdGlscycpO1xudmFyIENTU1Byb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgRE9NTmFtZXNwYWNlcyA9IHJlcXVpcmUoJy4vRE9NTmFtZXNwYWNlcycpO1xudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRGbGFncycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01JbnB1dCA9IHJlcXVpcmUoJy4vUmVhY3RET01JbnB1dCcpO1xudmFyIFJlYWN0RE9NT3B0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERPTU9wdGlvbicpO1xudmFyIFJlYWN0RE9NU2VsZWN0ID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdCcpO1xudmFyIFJlYWN0RE9NVGV4dGFyZWEgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dGFyZWEnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcbnZhciBSZWFjdE11bHRpQ2hpbGQgPSByZXF1aXJlKCcuL1JlYWN0TXVsdGlDaGlsZCcpO1xudmFyIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24nKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50U3VwcG9ydGVkJyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgRmxhZ3MgPSBSZWFjdERPTUNvbXBvbmVudEZsYWdzO1xudmFyIGRlbGV0ZUxpc3RlbmVyID0gRXZlbnRQbHVnaW5IdWIuZGVsZXRlTGlzdGVuZXI7XG52YXIgZ2V0Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlO1xudmFyIGxpc3RlblRvID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmxpc3RlblRvO1xudmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcztcblxuLy8gRm9yIHF1aWNrbHkgbWF0Y2hpbmcgY2hpbGRyZW4gdHlwZSwgdG8gdGVzdCBpZiBjYW4gYmUgdHJlYXRlZCBhcyBjb250ZW50LlxudmFyIENPTlRFTlRfVFlQRVMgPSB7ICdzdHJpbmcnOiB0cnVlLCAnbnVtYmVyJzogdHJ1ZSB9O1xuXG52YXIgU1RZTEUgPSAnc3R5bGUnO1xudmFyIEhUTUwgPSAnX19odG1sJztcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiBudWxsLFxuICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IG51bGxcbn07XG5cbi8vIE5vZGUgdHlwZSBmb3IgZG9jdW1lbnQgZnJhZ21lbnRzIChOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpLlxudmFyIERPQ19GUkFHTUVOVF9UWVBFID0gMTE7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShpbnRlcm5hbEluc3RhbmNlKSB7XG4gIGlmIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgdmFyIG93bmVyID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyIHx8IG51bGw7XG4gICAgaWYgKG93bmVyKSB7XG4gICAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnIFRoaXMgRE9NIG5vZGUgd2FzIHJlbmRlcmVkIGJ5IGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZnJpZW5kbHlTdHJpbmdpZnkob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHJldHVybiAnWycgKyBvYmoubWFwKGZyaWVuZGx5U3RyaW5naWZ5KS5qb2luKCcsICcpICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICB2YXIga2V5RXNjYXBlZCA9IC9eW2EteiRfXVtcXHckX10qJC9pLnRlc3Qoa2V5KSA/IGtleSA6IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgICAgICAgcGFpcnMucHVzaChrZXlFc2NhcGVkICsgJzogJyArIGZyaWVuZGx5U3RyaW5naWZ5KG9ialtrZXldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAneycgKyBwYWlycy5qb2luKCcsICcpICsgJ30nO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gJ1tmdW5jdGlvbiBvYmplY3RdJztcbiAgfVxuICAvLyBEaWZmZXJzIGZyb20gSlNPTi5zdHJpbmdpZnkgaW4gdGhhdCB1bmRlZmluZWQgYmVjYXVzZSB1bmRlZmluZWQgYW5kIHRoYXRcbiAgLy8gaW5mIGFuZCBuYW4gZG9uJ3QgYmVjb21lIG51bGxcbiAgcmV0dXJuIFN0cmluZyhvYmopO1xufVxuXG52YXIgc3R5bGVNdXRhdGlvbldhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHN0eWxlMSwgc3R5bGUyLCBjb21wb25lbnQpIHtcbiAgaWYgKHN0eWxlMSA9PSBudWxsIHx8IHN0eWxlMiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzaGFsbG93RXF1YWwoc3R5bGUxLCBzdHlsZTIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuX3RhZztcbiAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gIHZhciBvd25lck5hbWU7XG4gIGlmIChvd25lcikge1xuICAgIG93bmVyTmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgfVxuXG4gIHZhciBoYXNoID0gb3duZXJOYW1lICsgJ3wnICsgY29tcG9uZW50TmFtZTtcblxuICBpZiAoc3R5bGVNdXRhdGlvbldhcm5pbmcuaGFzT3duUHJvcGVydHkoaGFzaCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdHlsZU11dGF0aW9uV2FybmluZ1toYXNoXSA9IHRydWU7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgJXNgIHdhcyBwYXNzZWQgYSBzdHlsZSBvYmplY3QgdGhhdCBoYXMgcHJldmlvdXNseSBiZWVuIG11dGF0ZWQuICcgKyAnTXV0YXRpbmcgYHN0eWxlYCBpcyBkZXByZWNhdGVkLiBDb25zaWRlciBjbG9uaW5nIGl0IGJlZm9yZWhhbmQuIENoZWNrICcgKyAndGhlIGByZW5kZXJgICVzLiBQcmV2aW91cyBzdHlsZTogJXMuIE11dGF0ZWQgc3R5bGU6ICVzLicsIGNvbXBvbmVudE5hbWUsIG93bmVyID8gJ29mIGAnICsgb3duZXJOYW1lICsgJ2AnIDogJ3VzaW5nIDwnICsgY29tcG9uZW50TmFtZSArICc+JywgZnJpZW5kbHlTdHJpbmdpZnkoc3R5bGUxKSwgZnJpZW5kbHlTdHJpbmdpZnkoc3R5bGUyKSkgOiB2b2lkIDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBwcm9wc1xuICovXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BzKGNvbXBvbmVudCwgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICBpZiAodm9pZEVsZW1lbnRUYWdzW2NvbXBvbmVudC5fdGFnXSkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgY29tcG9uZW50Ll90YWcsIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyID8gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAnICsgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nIDogJycpIDogX3Byb2RJbnZhcmlhbnQoJzEzNycsIGNvbXBvbmVudC5fdGFnLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJyArIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJyA6ICcnKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiBfcHJvZEludmFyaWFudCgnNjAnKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YXJpYW50LWRhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogX3Byb2RJbnZhcmlhbnQoJzYxJykgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5pbm5lckhUTUwgPT0gbnVsbCwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgfHwgIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fCBwcm9wcy5jaGlsZHJlbiA9PSBudWxsLCAnQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLm9uRm9jdXNJbiA9PSBudWxsICYmIHByb3BzLm9uRm9jdXNPdXQgPT0gbnVsbCwgJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJykgOiB2b2lkIDA7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArIFxcJ2VtXFwnfX0gd2hlbiB1c2luZyBKU1guJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiBfcHJvZEludmFyaWFudCgnNjInLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGVucXVldWVQdXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lciwgdHJhbnNhY3Rpb24pIHtcbiAgaWYgKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIElFOCBoYXMgbm8gQVBJIGZvciBldmVudCBjYXB0dXJpbmcgYW5kIHRoZSBgb25TY3JvbGxgIGV2ZW50IGRvZXNuJ3RcbiAgICAvLyBidWJibGUuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocmVnaXN0cmF0aW9uTmFtZSAhPT0gJ29uU2Nyb2xsJyB8fCBpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSwgJ1RoaXMgYnJvd3NlciBkb2VzblxcJ3Qgc3VwcG9ydCB0aGUgYG9uU2Nyb2xsYCBldmVudCcpIDogdm9pZCAwO1xuICB9XG4gIHZhciBjb250YWluZXJJbmZvID0gaW5zdC5faG9zdENvbnRhaW5lckluZm87XG4gIHZhciBpc0RvY3VtZW50RnJhZ21lbnQgPSBjb250YWluZXJJbmZvLl9ub2RlICYmIGNvbnRhaW5lckluZm8uX25vZGUubm9kZVR5cGUgPT09IERPQ19GUkFHTUVOVF9UWVBFO1xuICB2YXIgZG9jID0gaXNEb2N1bWVudEZyYWdtZW50ID8gY29udGFpbmVySW5mby5fbm9kZSA6IGNvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGRvYyk7XG4gIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUocHV0TGlzdGVuZXIsIHtcbiAgICBpbnN0OiBpbnN0LFxuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IHJlZ2lzdHJhdGlvbk5hbWUsXG4gICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwdXRMaXN0ZW5lcigpIHtcbiAgdmFyIGxpc3RlbmVyVG9QdXQgPSB0aGlzO1xuICBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcihsaXN0ZW5lclRvUHV0Lmluc3QsIGxpc3RlbmVyVG9QdXQucmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXJUb1B1dC5saXN0ZW5lcik7XG59XG5cbmZ1bmN0aW9uIGlucHV0UG9zdE1vdW50KCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIFJlYWN0RE9NSW5wdXQucG9zdE1vdW50V3JhcHBlcihpbnN0KTtcbn1cblxuZnVuY3Rpb24gdGV4dGFyZWFQb3N0TW91bnQoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgUmVhY3RET01UZXh0YXJlYS5wb3N0TW91bnRXcmFwcGVyKGluc3QpO1xufVxuXG5mdW5jdGlvbiBvcHRpb25Qb3N0TW91bnQoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgUmVhY3RET01PcHRpb24ucG9zdE1vdW50V3JhcHBlcihpbnN0KTtcbn1cblxudmFyIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2ID0gZW1wdHlGdW5jdGlvbjtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2ID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICB2YXIgaGFzRXhpc3RpbmdDb250ZW50ID0gdGhpcy5fY29udGVudERlYnVnSUQgIT0gbnVsbDtcbiAgICB2YXIgZGVidWdJRCA9IHRoaXMuX2RlYnVnSUQ7XG4gICAgLy8gVGhpcyBJRCByZXByZXNlbnRzIHRoZSBpbmxpbmVkIGNoaWxkIHRoYXQgaGFzIG5vIGJhY2tpbmcgaW5zdGFuY2U6XG4gICAgdmFyIGNvbnRlbnREZWJ1Z0lEID0gLWRlYnVnSUQ7XG5cbiAgICBpZiAoY29udGVudCA9PSBudWxsKSB7XG4gICAgICBpZiAoaGFzRXhpc3RpbmdDb250ZW50KSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVubW91bnRDb21wb25lbnQodGhpcy5fY29udGVudERlYnVnSUQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29udGVudERlYnVnSUQgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCBTdHJpbmcoY29udGVudCksIHRoaXMsIHRoaXMuX2FuY2VzdG9ySW5mbyk7XG4gICAgdGhpcy5fY29udGVudERlYnVnSUQgPSBjb250ZW50RGVidWdJRDtcbiAgICBpZiAoaGFzRXhpc3RpbmdDb250ZW50KSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoY29udGVudERlYnVnSUQsIGNvbnRlbnQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVXBkYXRlQ29tcG9uZW50KGNvbnRlbnREZWJ1Z0lEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlTW91bnRDb21wb25lbnQoY29udGVudERlYnVnSUQsIGNvbnRlbnQsIGRlYnVnSUQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uTW91bnRDb21wb25lbnQoY29udGVudERlYnVnSUQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4oZGVidWdJRCwgW2NvbnRlbnREZWJ1Z0lEXSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBUaGVyZSBhcmUgc28gbWFueSBtZWRpYSBldmVudHMsIGl0IG1ha2VzIHNlbnNlIHRvIGp1c3Rcbi8vIG1haW50YWluIGEgbGlzdCByYXRoZXIgdGhhbiBjcmVhdGUgYSBgdHJhcEJ1YmJsZWRFdmVudGAgZm9yIGVhY2hcbnZhciBtZWRpYUV2ZW50cyA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJ1xufTtcblxuZnVuY3Rpb24gdHJhcEJ1YmJsZWRFdmVudHNMb2NhbCgpIHtcbiAgdmFyIGluc3QgPSB0aGlzO1xuICAvLyBJZiBhIGNvbXBvbmVudCByZW5kZXJzIHRvIG51bGwgb3IgaWYgYW5vdGhlciBjb21wb25lbnQgZmF0YWxzIGFuZCBjYXVzZXNcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSB0cmVlIHRvIGJlIGNvcnJ1cHRlZCwgYG5vZGVgIGhlcmUgY2FuIGJlIG51bGwuXG4gICFpbnN0Ll9yb290Tm9kZUlEID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ011c3QgYmUgbW91bnRlZCB0byB0cmFwIGV2ZW50cycpIDogX3Byb2RJbnZhcmlhbnQoJzYzJykgOiB2b2lkIDA7XG4gIHZhciBub2RlID0gZ2V0Tm9kZShpbnN0KTtcbiAgIW5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndHJhcEJ1YmJsZWRFdmVudCguLi4pOiBSZXF1aXJlcyBub2RlIHRvIGJlIHJlbmRlcmVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzY0JykgOiB2b2lkIDA7XG5cbiAgc3dpdGNoIChpbnN0Ll90YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuXG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW107XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRzKSB7XG4gICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzLnB1c2goUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoZXZlbnQsIG1lZGlhRXZlbnRzW2V2ZW50XSwgbm9kZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBub2RlKSwgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBub2RlKSwgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFN1Ym1pdCcsICdzdWJtaXQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0VXBkYXRlU2VsZWN0V3JhcHBlcigpIHtcbiAgUmVhY3RET01TZWxlY3QucG9zdFVwZGF0ZVdyYXBwZXIodGhpcyk7XG59XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3Mgc2hvdWxkIG9taXQgdGhlaXIgY2xvc2UgdGFnLiBXZSBrZWVwIGEgd2hpdGVsaXN0IGZvclxuLy8gdGhvc2Ugc3BlY2lhbC1jYXNlIHRhZ3MuXG5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICAnYXJlYSc6IHRydWUsXG4gICdiYXNlJzogdHJ1ZSxcbiAgJ2JyJzogdHJ1ZSxcbiAgJ2NvbCc6IHRydWUsXG4gICdlbWJlZCc6IHRydWUsXG4gICdocic6IHRydWUsXG4gICdpbWcnOiB0cnVlLFxuICAnaW5wdXQnOiB0cnVlLFxuICAna2V5Z2VuJzogdHJ1ZSxcbiAgJ2xpbmsnOiB0cnVlLFxuICAnbWV0YSc6IHRydWUsXG4gICdwYXJhbSc6IHRydWUsXG4gICdzb3VyY2UnOiB0cnVlLFxuICAndHJhY2snOiB0cnVlLFxuICAnd2JyJzogdHJ1ZVxufTtcblxudmFyIG5ld2xpbmVFYXRpbmdUYWdzID0ge1xuICAnbGlzdGluZyc6IHRydWUsXG4gICdwcmUnOiB0cnVlLFxuICAndGV4dGFyZWEnOiB0cnVlXG59O1xuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIGNhbm5vdCBoYXZlIGNoaWxkcmVuLiBUaGlzIGhhcyB0aGUgc2FtZSBwdXJwb3NlIGFzXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgJ21lbnVpdGVtJzogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbi8vIFdlIGFjY2VwdCBhbnkgdGFnIHRvIGJlIHJlbmRlcmVkIGJ1dCBzaW5jZSB0aGlzIGdldHMgaW5qZWN0ZWQgaW50byBhcmJpdHJhcnlcbi8vIEhUTUwsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBhIHNhZmUgdGFnLlxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVxuXG52YXIgVkFMSURfVEFHX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVo6X1xcLlxcLVxcZF0qJC87IC8vIFNpbXBsaWZpZWQgc3Vic2V0XG52YXIgdmFsaWRhdGVkVGFnQ2FjaGUgPSB7fTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpIHtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZFRhZ0NhY2hlLCB0YWcpKSB7XG4gICAgIVZBTElEX1RBR19SRUdFWC50ZXN0KHRhZykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCB0YWc6ICVzJywgdGFnKSA6IF9wcm9kSW52YXJpYW50KCc2NScsIHRhZykgOiB2b2lkIDA7XG4gICAgdmFsaWRhdGVkVGFnQ2FjaGVbdGFnXSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDdXN0b21Db21wb25lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgcmV0dXJuIHRhZ05hbWUuaW5kZXhPZignLScpID49IDAgfHwgcHJvcHMuaXMgIT0gbnVsbDtcbn1cblxudmFyIGdsb2JhbElkQ291bnRlciA9IDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBSZWFjdCBjbGFzcyB0aGF0IGlzIGlkZW1wb3RlbnQgYW5kIGNhcGFibGUgb2YgY29udGFpbmluZyBvdGhlclxuICogUmVhY3QgY29tcG9uZW50cy4gSXQgYWNjZXB0cyBldmVudCBsaXN0ZW5lcnMgYW5kIERPTSBwcm9wZXJ0aWVzIHRoYXQgYXJlXG4gKiB2YWxpZCBhY2NvcmRpbmcgdG8gYERPTVByb3BlcnR5YC5cbiAqXG4gKiAgLSBFdmVudCBsaXN0ZW5lcnM6IGBvbkNsaWNrYCwgYG9uTW91c2VEb3duYCwgZXRjLlxuICogIC0gRE9NIHByb3BlcnRpZXM6IGBjbGFzc05hbWVgLCBgbmFtZWAsIGB0aXRsZWAsIGV0Yy5cbiAqXG4gKiBUaGUgYHN0eWxlYCBwcm9wZXJ0eSBmdW5jdGlvbnMgZGlmZmVyZW50bHkgZnJvbSB0aGUgRE9NIEFQSS4gSXQgYWNjZXB0cyBhblxuICogb2JqZWN0IG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yIFJlYWN0RE9NQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdE11bHRpQ2hpbGRcbiAqL1xuZnVuY3Rpb24gUmVhY3RET01Db21wb25lbnQoZWxlbWVudCkge1xuICB2YXIgdGFnID0gZWxlbWVudC50eXBlO1xuICB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpO1xuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMuX3RhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICB0aGlzLl9uYW1lc3BhY2VVUkkgPSBudWxsO1xuICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbnVsbDtcbiAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgdGhpcy5faG9zdE5vZGUgPSBudWxsO1xuICB0aGlzLl9ob3N0UGFyZW50ID0gbnVsbDtcbiAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XG4gIHRoaXMuX2RvbUlEID0gMDtcbiAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBudWxsO1xuICB0aGlzLl93cmFwcGVyU3RhdGUgPSBudWxsO1xuICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuICB0aGlzLl9mbGFncyA9IDA7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdGhpcy5fYW5jZXN0b3JJbmZvID0gbnVsbDtcbiAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIG51bGwpO1xuICB9XG59XG5cblJlYWN0RE9NQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ1JlYWN0RE9NQ29tcG9uZW50JztcblxuUmVhY3RET01Db21wb25lbnQuTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyByb290IHRhZyBtYXJrdXAgdGhlbiByZWN1cnNlcy4gVGhpcyBtZXRob2QgaGFzIHNpZGUgZWZmZWN0cyBhbmRcbiAgICogaXMgbm90IGlkZW1wb3RlbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHs/UmVhY3RET01Db21wb25lbnR9IHRoZSBwYXJlbnQgY29tcG9uZW50IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gaW5mbyBhYm91dCB0aGUgaG9zdCBjb250YWluZXJcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29tcHV0ZWQgbWFya3VwLlxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQpIHtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gZ2xvYmFsSWRDb3VudGVyKys7XG4gICAgdGhpcy5fZG9tSUQgPSBob3N0Q29udGFpbmVySW5mby5faWRDb3VudGVyKys7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBob3N0Q29udGFpbmVySW5mbztcblxuICAgIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgY2FzZSAnaWZyYW1lJzpcbiAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICBjYXNlICdsaW5rJzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICB0aGlzLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgICAgICAgbGlzdGVuZXJzOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBSZWFjdERPTUlucHV0Lm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01JbnB1dC5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIFJlYWN0RE9NT3B0aW9uLm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBSZWFjdERPTVNlbGVjdC5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBSZWFjdERPTVRleHRhcmVhLm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMsIHByb3BzKTtcblxuICAgIC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgICAvLyB0YWdzIGdldCBubyBuYW1lc3BhY2UuXG4gICAgdmFyIG5hbWVzcGFjZVVSSTtcbiAgICB2YXIgcGFyZW50VGFnO1xuICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgIG5hbWVzcGFjZVVSSSA9IGhvc3RQYXJlbnQuX25hbWVzcGFjZVVSSTtcbiAgICAgIHBhcmVudFRhZyA9IGhvc3RQYXJlbnQuX3RhZztcbiAgICB9IGVsc2UgaWYgKGhvc3RDb250YWluZXJJbmZvLl90YWcpIHtcbiAgICAgIG5hbWVzcGFjZVVSSSA9IGhvc3RDb250YWluZXJJbmZvLl9uYW1lc3BhY2VVUkk7XG4gICAgICBwYXJlbnRUYWcgPSBob3N0Q29udGFpbmVySW5mby5fdGFnO1xuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlVVJJID09IG51bGwgfHwgbmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLnN2ZyAmJiBwYXJlbnRUYWcgPT09ICdmb3JlaWdub2JqZWN0Jykge1xuICAgICAgbmFtZXNwYWNlVVJJID0gRE9NTmFtZXNwYWNlcy5odG1sO1xuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLmh0bWwpIHtcbiAgICAgIGlmICh0aGlzLl90YWcgPT09ICdzdmcnKSB7XG4gICAgICAgIG5hbWVzcGFjZVVSSSA9IERPTU5hbWVzcGFjZXMuc3ZnO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl90YWcgPT09ICdtYXRoJykge1xuICAgICAgICBuYW1lc3BhY2VVUkkgPSBET01OYW1lc3BhY2VzLm1hdGhtbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbmFtZXNwYWNlVVJJID0gbmFtZXNwYWNlVVJJO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXJlbnRJbmZvO1xuICAgICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdFBhcmVudC5fYW5jZXN0b3JJbmZvO1xuICAgICAgfSBlbHNlIGlmIChob3N0Q29udGFpbmVySW5mby5fdGFnKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0Q29udGFpbmVySW5mby5fYW5jZXN0b3JJbmZvO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudEluZm8pIHtcbiAgICAgICAgLy8gcGFyZW50SW5mbyBzaG91bGQgYWx3YXlzIGJlIHByZXNlbnQgZXhjZXB0IGZvciB0aGUgdG9wLWxldmVsXG4gICAgICAgIC8vIGNvbXBvbmVudCB3aGVuIHNlcnZlciByZW5kZXJpbmdcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nKHRoaXMuX3RhZywgbnVsbCwgdGhpcywgcGFyZW50SW5mbyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9hbmNlc3RvckluZm8gPSB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyhwYXJlbnRJbmZvLCB0aGlzLl90YWcsIHRoaXMpO1xuICAgIH1cblxuICAgIHZhciBtb3VudEltYWdlO1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGhvc3RDb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xuICAgICAgdmFyIGVsO1xuICAgICAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5odG1sKSB7XG4gICAgICAgIGlmICh0aGlzLl90YWcgPT09ICdzY3JpcHQnKSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIHRoZSBzY3JpcHQgdmlhIC5pbm5lckhUTUwgc28gaXRzIFwicGFyc2VyLWluc2VydGVkXCIgZmxhZyBpc1xuICAgICAgICAgIC8vIHNldCB0byB0cnVlIGFuZCBpdCBkb2VzIG5vdCBleGVjdXRlXG4gICAgICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSAnPCcgKyB0eXBlICsgJz48LycgKyB0eXBlICsgJz4nO1xuICAgICAgICAgIGVsID0gZGl2LnJlbW92ZUNoaWxkKGRpdi5maXJzdENoaWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5pcykge1xuICAgICAgICAgIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUsIHByb3BzLmlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY3Vhc2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbiAgICAgICAgICAvLyBTZWUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC82ODk2XG4gICAgICAgICAgLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxuICAgICAgICAgIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSk7XG4gICAgICB9XG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKHRoaXMsIGVsKTtcbiAgICAgIHRoaXMuX2ZsYWdzIHw9IEZsYWdzLmhhc0NhY2hlZENoaWxkTm9kZXM7XG4gICAgICBpZiAoIXRoaXMuX2hvc3RQYXJlbnQpIHtcbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldEF0dHJpYnV0ZUZvclJvb3QoZWwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdXBkYXRlRE9NUHJvcGVydGllcyhudWxsLCBwcm9wcywgdHJhbnNhY3Rpb24pO1xuICAgICAgdmFyIGxhenlUcmVlID0gRE9NTGF6eVRyZWUoZWwpO1xuICAgICAgdGhpcy5fY3JlYXRlSW5pdGlhbENoaWxkcmVuKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCwgbGF6eVRyZWUpO1xuICAgICAgbW91bnRJbWFnZSA9IGxhenlUcmVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGFnT3BlbiA9IHRoaXMuX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnModHJhbnNhY3Rpb24sIHByb3BzKTtcbiAgICAgIHZhciB0YWdDb250ZW50ID0gdGhpcy5fY3JlYXRlQ29udGVudE1hcmt1cCh0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgaWYgKCF0YWdDb250ZW50ICYmIG9taXR0ZWRDbG9zZVRhZ3NbdGhpcy5fdGFnXSkge1xuICAgICAgICBtb3VudEltYWdlID0gdGFnT3BlbiArICcvPic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb3VudEltYWdlID0gdGFnT3BlbiArICc+JyArIHRhZ0NvbnRlbnQgKyAnPC8nICsgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSArICc+JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGlucHV0UG9zdE1vdW50LCB0aGlzKTtcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRleHRhcmVhUG9zdE1vdW50LCB0aGlzKTtcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgaWYgKHByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoQXV0b0ZvY3VzVXRpbHMuZm9jdXNET01Db21wb25lbnQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShvcHRpb25Qb3N0TW91bnQsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gbW91bnRJbWFnZTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBvcGVuIHRhZyBhbmQgYWxsIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYmVjYXVzZSBldmVudHMgZ2V0IHJlZ2lzdGVyZWQuXG4gICAqXG4gICAqIEl0ZXJhdGluZyBvdmVyIG9iamVjdCBwcm9wZXJ0aWVzIGlzIGZhc3RlciB0aGFuIGl0ZXJhdGluZyBvdmVyIGFycmF5cy5cbiAgICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9vYmotdnMtYXJyLWl0ZXJhdGlvblxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIG9mIG9wZW5pbmcgdGFnLlxuICAgKi9cbiAgX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnM6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJvcHMpIHtcbiAgICB2YXIgcmV0ID0gJzwnICsgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKHByb3BWYWx1ZSkge1xuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLCBwcm9wS2V5LCBwcm9wVmFsdWUsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgICAgaWYgKHByb3BWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gU2VlIGBfdXBkYXRlRE9NUHJvcGVydGllc2AuIHN0eWxlIGJsb2NrXG4gICAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wVmFsdWUgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IF9hc3NpZ24oe30sIHByb3BzLnN0eWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvcFZhbHVlID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclN0eWxlcyhwcm9wVmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrdXAgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fdGFnICE9IG51bGwgJiYgaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBwcm9wcykpIHtcbiAgICAgICAgICBpZiAoIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgICAgICBtYXJrdXAgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yQ3VzdG9tQXR0cmlidXRlKHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcmt1cCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eShwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrdXApIHtcbiAgICAgICAgICByZXQgKz0gJyAnICsgbWFya3VwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9yIHN0YXRpYyBwYWdlcywgbm8gbmVlZCB0byBwdXQgUmVhY3QgSUQgYW5kIGNoZWNrc3VtLiBTYXZlcyBsb3RzIG9mXG4gICAgLy8gYnl0ZXMuXG4gICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGlmICghdGhpcy5faG9zdFBhcmVudCkge1xuICAgICAgcmV0ICs9ICcgJyArIERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JSb290KCk7XG4gICAgfVxuICAgIHJldCArPSAnICcgKyBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9ySUQodGhpcy5fZG9tSUQpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgY29udGVudCBiZXR3ZWVuIHRoZSB0YWdzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29udGVudCBtYXJrdXAuXG4gICAqL1xuICBfY3JlYXRlQ29udGVudE1hcmt1cDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCkge1xuICAgIHZhciByZXQgPSAnJztcblxuICAgIC8vIEludGVudGlvbmFsIHVzZSBvZiAhPSB0byBhdm9pZCBjYXRjaGluZyB6ZXJvL2ZhbHNlLlxuICAgIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcbiAgICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAgIGlmIChpbm5lckhUTUwuX19odG1sICE9IG51bGwpIHtcbiAgICAgICAgcmV0ID0gaW5uZXJIVE1MLl9faHRtbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRlbnRUb1VzZSA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIHByb3BzLmNoaWxkcmVuXSA/IHByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICAgIHZhciBjaGlsZHJlblRvVXNlID0gY29udGVudFRvVXNlICE9IG51bGwgPyBudWxsIDogcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY29udGVudFRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcbiAgICAgICAgcmV0ID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKGNvbnRlbnRUb1VzZSk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgc2V0QW5kVmFsaWRhdGVDb250ZW50Q2hpbGREZXYuY2FsbCh0aGlzLCBjb250ZW50VG9Vc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuVG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbW91bnRJbWFnZXMgPSB0aGlzLm1vdW50Q2hpbGRyZW4oY2hpbGRyZW5Ub1VzZSwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICByZXQgPSBtb3VudEltYWdlcy5qb2luKCcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5ld2xpbmVFYXRpbmdUYWdzW3RoaXMuX3RhZ10gJiYgcmV0LmNoYXJBdCgwKSA9PT0gJ1xcbicpIHtcbiAgICAgIC8vIHRleHQvaHRtbCBpZ25vcmVzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlc2UgdGFncyBpZiBpdCdzIGEgbmV3bGluZVxuICAgICAgLy8gUHJlZmVyIHRvIGJyZWFrIGFwcGxpY2F0aW9uL3htbCBvdmVyIHRleHQvaHRtbCAoZm9yIG5vdykgYnkgYWRkaW5nXG4gICAgICAvLyBhIG5ld2xpbmUgc3BlY2lmaWNhbGx5IHRvIGdldCBlYXRlbiBieSB0aGUgcGFyc2VyLiAoQWx0ZXJuYXRlbHkgZm9yXG4gICAgICAvLyB0ZXh0YXJlYXMsIHJlcGxhY2luZyBcIl5cXG5cIiB3aXRoIFwiXFxyXFxuXCIgZG9lc24ndCBnZXQgZWF0ZW4sIGFuZCB0aGUgZmlyc3RcbiAgICAgIC8vIFxcciBpcyBub3JtYWxpemVkIG91dCBieSBIVE1MVGV4dEFyZWFFbGVtZW50I3ZhbHVlLilcbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwtcG9seWdsb3QvI25ld2xpbmVzLWluLXRleHRhcmVhLWFuZC1wcmU+XG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNlbGVtZW50LXJlc3RyaWN0aW9ucz5cbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI25ld2xpbmVzPlxuICAgICAgLy8gU2VlOiBQYXJzaW5nIG9mIFwidGV4dGFyZWFcIiBcImxpc3RpbmdcIiBhbmQgXCJwcmVcIiBlbGVtZW50c1xuICAgICAgLy8gIGZyb20gPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHk+XG4gICAgICByZXR1cm4gJ1xcbicgKyByZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LFxuXG4gIF9jcmVhdGVJbml0aWFsQ2hpbGRyZW46IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQsIGxhenlUcmVlKSB7XG4gICAgLy8gSW50ZW50aW9uYWwgdXNlIG9mICE9IHRvIGF2b2lkIGNhdGNoaW5nIHplcm8vZmFsc2UuXG4gICAgdmFyIGlubmVySFRNTCA9IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuICAgIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgICBET01MYXp5VHJlZS5xdWV1ZUhUTUwobGF6eVRyZWUsIGlubmVySFRNTC5fX2h0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGVudFRvVXNlID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgcHJvcHMuY2hpbGRyZW5dID8gcHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgdmFyIGNoaWxkcmVuVG9Vc2UgPSBjb250ZW50VG9Vc2UgIT0gbnVsbCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSB0aGF0IHRleHQgaXMgYWxsb3dlZCBhcyBhIGNoaWxkIG9mIHRoaXMgbm9kZVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgY29udGVudFRvVXNlKTtcbiAgICAgICAgfVxuICAgICAgICBET01MYXp5VHJlZS5xdWV1ZVRleHQobGF6eVRyZWUsIGNvbnRlbnRUb1VzZSk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuVG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbW91bnRJbWFnZXMgPSB0aGlzLm1vdW50Q2hpbGRyZW4oY2hpbGRyZW5Ub1VzZSwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vdW50SW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgbW91bnRJbWFnZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNlaXZlcyBhIG5leHQgZWxlbWVudCBhbmQgdXBkYXRlcyB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBET00gY29tcG9uZW50IGFmdGVyIGl0IGhhcyBhbHJlYWR5IGJlZW4gYWxsb2NhdGVkIGFuZFxuICAgKiBhdHRhY2hlZCB0byB0aGUgRE9NLiBSZWNvbmNpbGVzIHRoZSByb290IERPTSBub2RlLCB0aGVuIHJlY3Vyc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBwcmV2RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgY29udGV4dCkge1xuICAgIHZhciBsYXN0UHJvcHMgPSBwcmV2RWxlbWVudC5wcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXRIb3N0UHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgdGhpcy5fdXBkYXRlRE9NUHJvcGVydGllcyhsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24pO1xuICAgIHRoaXMuX3VwZGF0ZURPTUNoaWxkcmVuKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZXIgYXJvdW5kIGlucHV0cyAqYWZ0ZXIqIHVwZGF0aW5nIHByb3BzLiBUaGlzIGhhcyB0b1xuICAgICAgICAvLyBoYXBwZW4gYWZ0ZXIgYF91cGRhdGVET01Qcm9wZXJ0aWVzYC4gT3RoZXJ3aXNlIEhUTUw1IGlucHV0IHZhbGlkYXRpb25zXG4gICAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgICAgUmVhY3RET01JbnB1dC51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgUmVhY3RET01UZXh0YXJlYS51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgICAvLyByZWNvbmNpbGlhdGlvblxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBwcm9wZXJ0aWVzIGJ5IGRldGVjdGluZyBkaWZmZXJlbmNlcyBpbiBwcm9wZXJ0eSB2YWx1ZXMgYW5kXG4gICAqIHVwZGF0aW5nIHRoZSBET00gYXMgbmVjZXNzYXJ5LiBUaGlzIGZ1bmN0aW9uIGlzIHByb2JhYmx5IHRoZSBzaW5nbGUgbW9zdFxuICAgKiBjcml0aWNhbCBwYXRoIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAqXG4gICAqIFRPRE86IEJlbmNobWFyayB3aGV0aGVyIGNoZWNraW5nIGZvciBjaGFuZ2VkIHZhbHVlcyBpbiBtZW1vcnkgYWN0dWFsbHlcbiAgICogICAgICAgaW1wcm92ZXMgcGVyZm9ybWFuY2UgKGVzcGVjaWFsbHkgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnRzKS5cbiAgICogVE9ETzogQmVuY2htYXJrIHRoZSBlZmZlY3RzIG9mIHB1dHRpbmcgdGhpcyBhdCB0aGUgdG9wIHNpbmNlIDk5JSBvZiBwcm9wc1xuICAgKiAgICAgICBkbyBub3QgY2hhbmdlIGZvciBhIGdpdmVuIHJlY29uY2lsaWF0aW9uLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgYXJlYXMgdGhhdCBjYW4gYmUgaW1wcm92ZWQgd2l0aCBjYWNoaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZVxuICAgKi9cbiAgX3VwZGF0ZURPTVByb3BlcnRpZXM6IGZ1bmN0aW9uIChsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgcHJvcEtleTtcbiAgICB2YXIgc3R5bGVOYW1lO1xuICAgIHZhciBzdHlsZVVwZGF0ZXM7XG4gICAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgICAgaWYgKG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCAhbGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IGxhc3RQcm9wc1twcm9wS2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIHZhciBsYXN0U3R5bGUgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weTtcbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFN0eWxlKSB7XG4gICAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChsYXN0UHJvcHNbcHJvcEtleV0pIHtcbiAgICAgICAgICAvLyBPbmx5IGNhbGwgZGVsZXRlTGlzdGVuZXIgaWYgdGhlcmUgd2FzIGEgbGlzdGVuZXIgcHJldmlvdXNseSBvclxuICAgICAgICAgIC8vIGVsc2Ugd2lsbERlbGV0ZUxpc3RlbmVyIGdldHMgY2FsbGVkIHdoZW4gdGhlcmUgd2Fzbid0IGFjdHVhbGx5IGFcbiAgICAgICAgICAvLyBsaXN0ZW5lciAoZS5nLiwgb25DbGljaz17bnVsbH0pXG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcywgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBsYXN0UHJvcHMpKSB7XG4gICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkucHJvcGVydGllc1twcm9wS2V5XSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShwcm9wS2V5KSkge1xuICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShnZXROb2RlKHRoaXMpLCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgICAgdmFyIGxhc3RQcm9wID0gcHJvcEtleSA9PT0gU1RZTEUgPyB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA6IGxhc3RQcm9wcyAhPSBudWxsID8gbGFzdFByb3BzW3Byb3BLZXldIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wIHx8IG5leHRQcm9wID09IG51bGwgJiYgbGFzdFByb3AgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5LCB0aGlzLl9wcmV2aW91c1N0eWxlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBuZXh0UHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dFByb3AgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IF9hc3NpZ24oe30sIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgLy8gVW5zZXQgc3R5bGVzIG9uIGBsYXN0UHJvcGAgYnV0IG5vdCBvbiBgbmV4dFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXG4gICAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9IG5leHRQcm9wW3N0eWxlTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLCBwcm9wS2V5LCBuZXh0UHJvcCwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcywgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBuZXh0UHJvcHMpKSB7XG4gICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBnZXROb2RlKHRoaXMpO1xuICAgICAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGVudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgICBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JTdHlsZXMoZ2V0Tm9kZSh0aGlzKSwgc3R5bGVVcGRhdGVzLCB0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY29uY2lsZXMgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHZhcmlvdXMgcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0aGVcbiAgICogY2hpbGRyZW4gY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGxhc3RQcm9wc1xuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICovXG4gIF91cGRhdGVET01DaGlsZHJlbjogZnVuY3Rpb24gKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBsYXN0Q29udGVudCA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIGxhc3RQcm9wcy5jaGlsZHJlbl0gPyBsYXN0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgIHZhciBuZXh0Q29udGVudCA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIG5leHRQcm9wcy5jaGlsZHJlbl0gPyBuZXh0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuXG4gICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmIGxhc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG4gICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmIG5leHRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG5cbiAgICAvLyBOb3RlIHRoZSB1c2Ugb2YgYCE9YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICAgIHZhciBsYXN0Q2hpbGRyZW4gPSBsYXN0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IGxhc3RQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dENvbnRlbnQgIT0gbnVsbCA/IG51bGwgOiBuZXh0UHJvcHMuY2hpbGRyZW47XG5cbiAgICAvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgZnJvbSBjaGlsZHJlbiB0byBjb250ZW50L2h0bWwgb3IgdmljZSB2ZXJzYSwgcmVtb3ZlXG4gICAgLy8gdGhlIG9sZCBjb250ZW50XG4gICAgdmFyIGxhc3RIYXNDb250ZW50T3JIdG1sID0gbGFzdENvbnRlbnQgIT0gbnVsbCB8fCBsYXN0SHRtbCAhPSBudWxsO1xuICAgIHZhciBuZXh0SGFzQ29udGVudE9ySHRtbCA9IG5leHRDb250ZW50ICE9IG51bGwgfHwgbmV4dEh0bWwgIT0gbnVsbDtcbiAgICBpZiAobGFzdENoaWxkcmVuICE9IG51bGwgJiYgbmV4dENoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obnVsbCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAobGFzdEhhc0NvbnRlbnRPckh0bWwgJiYgIW5leHRIYXNDb250ZW50T3JIdG1sKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIFtdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmV4dENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RDb250ZW50ICE9PSBuZXh0Q29udGVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnICsgbmV4dENvbnRlbnQpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgbmV4dENvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICBpZiAobGFzdEh0bWwgIT09IG5leHRIdG1sKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTWFya3VwKCcnICsgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4odGhpcy5fZGVidWdJRCwgW10pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldE5vZGUodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFsbCBldmVudCByZWdpc3RyYXRpb25zIGZvciB0aGlzIGluc3RhbmNlLiBEb2VzIG5vdCByZW1vdmUgZnJvbVxuICAgKiB0aGUgRE9NLiBUaGF0IG11c3QgYmUgZG9uZSBieSB0aGUgcGFyZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChzYWZlbHkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICBjYXNlICdpZnJhbWUnOlxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl93cmFwcGVyU3RhdGUubGlzdGVuZXJzO1xuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wb25lbnRzIGxpa2UgPGh0bWw+IDxoZWFkPiBhbmQgPGJvZHk+IGNhbid0IGJlIHJlbW92ZWQgb3IgYWRkZWRcbiAgICAgICAgICogZWFzaWx5IGluIGEgY3Jvc3MtYnJvd3NlciB3YXksIGhvd2V2ZXIgaXQncyB2YWx1YWJsZSB0byBiZSBhYmxlIHRvXG4gICAgICAgICAqIHRha2UgYWR2YW50YWdlIG9mIFJlYWN0J3MgcmVjb25jaWxpYXRpb24gZm9yIHN0eWxpbmcgYW5kIDx0aXRsZT5cbiAgICAgICAgICogbWFuYWdlbWVudC4gU28gd2UganVzdCBkb2N1bWVudCBpdCBhbmQgdGhyb3cgaW4gZGFuZ2Vyb3VzIGNhc2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJzwlcz4gdHJpZWQgdG8gdW5tb3VudC4gQmVjYXVzZSBvZiBjcm9zcy1icm93c2VyIHF1aXJrcyBpdCBpcyBpbXBvc3NpYmxlIHRvIHVubW91bnQgc29tZSB0b3AtbGV2ZWwgY29tcG9uZW50cyAoZWcgPGh0bWw+LCA8aGVhZD4sIGFuZCA8Ym9keT4pIHJlbGlhYmx5IGFuZCBlZmZpY2llbnRseS4gVG8gZml4IHRoaXMsIGhhdmUgYSBzaW5nbGUgdG9wLWxldmVsIGNvbXBvbmVudCB0aGF0IG5ldmVyIHVubW91bnRzIHJlbmRlciB0aGVzZSBlbGVtZW50cy4nLCB0aGlzLl90YWcpIDogX3Byb2RJbnZhcmlhbnQoJzY2JywgdGhpcy5fdGFnKSA6IHZvaWQgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy51bm1vdW50Q2hpbGRyZW4oc2FmZWx5KTtcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUudW5jYWNoZU5vZGUodGhpcyk7XG4gICAgRXZlbnRQbHVnaW5IdWIuZGVsZXRlQWxsTGlzdGVuZXJzKHRoaXMpO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSAwO1xuICAgIHRoaXMuX2RvbUlEID0gMDtcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUgPSBudWxsO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgbnVsbCk7XG4gICAgfVxuICB9LFxuXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldE5vZGUodGhpcyk7XG4gIH1cblxufTtcblxuX2Fzc2lnbihSZWFjdERPTUNvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0RE9NQ29tcG9uZW50Lk1peGluLCBSZWFjdE11bHRpQ2hpbGQuTWl4aW4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRE9NTGF6eVRyZWUgPSByZXF1aXJlKCcuL0RPTUxhenlUcmVlJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxudmFyIFJlYWN0RE9NRW1wdHlDb21wb25lbnQgPSBmdW5jdGlvbiAoaW5zdGFudGlhdGUpIHtcbiAgLy8gUmVhY3RDb21wb3NpdGVDb21wb25lbnQgdXNlcyB0aGlzOlxuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG51bGw7XG4gIC8vIFJlYWN0RE9NQ29tcG9uZW50VHJlZSB1c2VzIHRoZXNlOlxuICB0aGlzLl9ob3N0Tm9kZSA9IG51bGw7XG4gIHRoaXMuX2hvc3RQYXJlbnQgPSBudWxsO1xuICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IG51bGw7XG4gIHRoaXMuX2RvbUlEID0gMDtcbn07XG5fYXNzaWduKFJlYWN0RE9NRW1wdHlDb21wb25lbnQucHJvdG90eXBlLCB7XG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgdmFyIGRvbUlEID0gaG9zdENvbnRhaW5lckluZm8uX2lkQ291bnRlcisrO1xuICAgIHRoaXMuX2RvbUlEID0gZG9tSUQ7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBob3N0Q29udGFpbmVySW5mbztcblxuICAgIHZhciBub2RlVmFsdWUgPSAnIHJlYWN0LWVtcHR5OiAnICsgdGhpcy5fZG9tSUQgKyAnICc7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gaG9zdENvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gICAgICB2YXIgbm9kZSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudChub2RlVmFsdWUpO1xuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZSh0aGlzLCBub2RlKTtcbiAgICAgIHJldHVybiBET01MYXp5VHJlZShub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICAgIC8vIE5vcm1hbGx5IHdlJ2QgaW5zZXJ0IGEgY29tbWVudCBub2RlLCBidXQgc2luY2UgdGhpcyBpcyBhIHNpdHVhdGlvblxuICAgICAgICAvLyB3aGVyZSBSZWFjdCB3b24ndCB0YWtlIG92ZXIgKHN0YXRpYyBwYWdlcyksIHdlIGNhbiBzaW1wbHkgcmV0dXJuXG4gICAgICAgIC8vIG5vdGhpbmcuXG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnPCEtLScgKyBub2RlVmFsdWUgKyAnLS0+JztcbiAgICB9XG4gIH0sXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHt9LFxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcbiAgfSxcbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS51bmNhY2hlTm9kZSh0aGlzKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01FbXB0eUNvbXBvbmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdEEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzMnKSA6IHZvaWQgMDtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczMycpIDogdm9pZCAwO1xuXG4gIHZhciBkZXB0aEEgPSAwO1xuICBmb3IgKHZhciB0ZW1wQSA9IGluc3RBOyB0ZW1wQTsgdGVtcEEgPSB0ZW1wQS5faG9zdFBhcmVudCkge1xuICAgIGRlcHRoQSsrO1xuICB9XG4gIHZhciBkZXB0aEIgPSAwO1xuICBmb3IgKHZhciB0ZW1wQiA9IGluc3RCOyB0ZW1wQjsgdGVtcEIgPSB0ZW1wQi5faG9zdFBhcmVudCkge1xuICAgIGRlcHRoQisrO1xuICB9XG5cbiAgLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhBIC0gZGVwdGhCID4gMCkge1xuICAgIGluc3RBID0gaW5zdEEuX2hvc3RQYXJlbnQ7XG4gICAgZGVwdGhBLS07XG4gIH1cblxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEIgLSBkZXB0aEEgPiAwKSB7XG4gICAgaW5zdEIgPSBpbnN0Qi5faG9zdFBhcmVudDtcbiAgICBkZXB0aEItLTtcbiAgfVxuXG4gIC8vIFdhbGsgaW4gbG9ja3N0ZXAgdW50aWwgd2UgZmluZCBhIG1hdGNoLlxuICB2YXIgZGVwdGggPSBkZXB0aEE7XG4gIHdoaWxlIChkZXB0aC0tKSB7XG4gICAgaWYgKGluc3RBID09PSBpbnN0Qikge1xuICAgICAgcmV0dXJuIGluc3RBO1xuICAgIH1cbiAgICBpbnN0QSA9IGluc3RBLl9ob3N0UGFyZW50O1xuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIGlmIEEgaXMgYW4gYW5jZXN0b3Igb2YgQi5cbiAqL1xuZnVuY3Rpb24gaXNBbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaXNBbmNlc3RvcjogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNScpIDogdm9pZCAwO1xuICAhKCdfaG9zdE5vZGUnIGluIGluc3RCKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpc0FuY2VzdG9yOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM1JykgOiB2b2lkIDA7XG5cbiAgd2hpbGUgKGluc3RCKSB7XG4gICAgaWYgKGluc3RCID09PSBpbnN0QSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcGFyZW50IGluc3RhbmNlIG9mIHRoZSBwYXNzZWQtaW4gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudEluc3RhbmNlKGluc3QpIHtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXRQYXJlbnRJbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNicpIDogdm9pZCAwO1xuXG4gIHJldHVybiBpbnN0Ll9ob3N0UGFyZW50O1xufVxuXG4vKipcbiAqIFNpbXVsYXRlcyB0aGUgdHJhdmVyc2FsIG9mIGEgdHdvLXBoYXNlLCBjYXB0dXJlL2J1YmJsZSBldmVudCBkaXNwYXRjaC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VUd29QaGFzZShpbnN0LCBmbiwgYXJnKSB7XG4gIHZhciBwYXRoID0gW107XG4gIHdoaWxlIChpbnN0KSB7XG4gICAgcGF0aC5wdXNoKGluc3QpO1xuICAgIGluc3QgPSBpbnN0Ll9ob3N0UGFyZW50O1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSBwYXRoLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoW2ldLCAnY2FwdHVyZWQnLCBhcmcpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aFtpXSwgJ2J1YmJsZWQnLCBhcmcpO1xuICB9XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gKlxuICogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSBub3RoaW5nXG4gKiBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gIHZhciBjb21tb24gPSBmcm9tICYmIHRvID8gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoZnJvbSwgdG8pIDogbnVsbDtcbiAgdmFyIHBhdGhGcm9tID0gW107XG4gIHdoaWxlIChmcm9tICYmIGZyb20gIT09IGNvbW1vbikge1xuICAgIHBhdGhGcm9tLnB1c2goZnJvbSk7XG4gICAgZnJvbSA9IGZyb20uX2hvc3RQYXJlbnQ7XG4gIH1cbiAgdmFyIHBhdGhUbyA9IFtdO1xuICB3aGlsZSAodG8gJiYgdG8gIT09IGNvbW1vbikge1xuICAgIHBhdGhUby5wdXNoKHRvKTtcbiAgICB0byA9IHRvLl9ob3N0UGFyZW50O1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgcGF0aEZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoRnJvbVtpXSwgJ2J1YmJsZWQnLCBhcmdGcm9tKTtcbiAgfVxuICBmb3IgKGkgPSBwYXRoVG8ubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgIGZuKHBhdGhUb1tpXSwgJ2NhcHR1cmVkJywgYXJnVG8pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FuY2VzdG9yOiBpc0FuY2VzdG9yLFxuICBnZXRMb3dlc3RDb21tb25BbmNlc3RvcjogZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IsXG4gIGdldFBhcmVudEluc3RhbmNlOiBnZXRQYXJlbnRJbnN0YW5jZSxcbiAgdHJhdmVyc2VUd29QaGFzZTogdHJhdmVyc2VUd29QaGFzZSxcbiAgdHJhdmVyc2VFbnRlckxlYXZlOiB0cmF2ZXJzZUVudGVyTGVhdmVcbn07IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xuXG4vKipcbiAqIFRleHQgbm9kZXMgdmlvbGF0ZSBhIGNvdXBsZSBhc3N1bXB0aW9ucyB0aGF0IFJlYWN0IG1ha2VzIGFib3V0IGNvbXBvbmVudHM6XG4gKlxuICogIC0gV2hlbiBtb3VudGluZyB0ZXh0IGludG8gdGhlIERPTSwgYWRqYWNlbnQgdGV4dCBub2RlcyBhcmUgbWVyZ2VkLlxuICogIC0gVGV4dCBub2RlcyBjYW5ub3QgYmUgYXNzaWduZWQgYSBSZWFjdCByb290IElELlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGlzIHVzZWQgdG8gd3JhcCBzdHJpbmdzIGJldHdlZW4gY29tbWVudCBub2RlcyBzbyB0aGF0IHRoZXlcbiAqIGNhbiB1bmRlcmdvIHRoZSBzYW1lIHJlY29uY2lsaWF0aW9uIHRoYXQgaXMgYXBwbGllZCB0byBlbGVtZW50cy5cbiAqXG4gKiBUT0RPOiBJbnZlc3RpZ2F0ZSByZXByZXNlbnRpbmcgUmVhY3QgY29tcG9uZW50cyBpbiB0aGUgRE9NIHdpdGggdGV4dCBub2Rlcy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdENvbXBvbmVudFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAvLyBUT0RPOiBUaGlzIGlzIHJlYWxseSBhIFJlYWN0VGV4dCAoUmVhY3ROb2RlKSwgbm90IGEgUmVhY3RFbGVtZW50XG4gIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gdGV4dDtcbiAgdGhpcy5fc3RyaW5nVGV4dCA9ICcnICsgdGV4dDtcbiAgLy8gUmVhY3RET01Db21wb25lbnRUcmVlIHVzZXMgdGhlc2U6XG4gIHRoaXMuX2hvc3ROb2RlID0gbnVsbDtcbiAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG5cbiAgLy8gUHJvcGVydGllc1xuICB0aGlzLl9kb21JRCA9IDA7XG4gIHRoaXMuX21vdW50SW5kZXggPSAwO1xuICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IG51bGw7XG4gIHRoaXMuX2NvbW1lbnROb2RlcyA9IG51bGw7XG59O1xuXG5fYXNzaWduKFJlYWN0RE9NVGV4dENvbXBvbmVudC5wcm90b3R5cGUsIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgbWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS4gVGhpcyBub2RlIGlzIG5vdCBpbnRlbmRlZCB0byBoYXZlXG4gICAqIGFueSBmZWF0dXJlcyBiZXNpZGVzIGNvbnRhaW5pbmcgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgZm9yIHRoaXMgdGV4dCBub2RlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwYXJlbnRJbmZvO1xuICAgICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdFBhcmVudC5fYW5jZXN0b3JJbmZvO1xuICAgICAgfSBlbHNlIGlmIChob3N0Q29udGFpbmVySW5mbyAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0Q29udGFpbmVySW5mby5fYW5jZXN0b3JJbmZvO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudEluZm8pIHtcbiAgICAgICAgLy8gcGFyZW50SW5mbyBzaG91bGQgYWx3YXlzIGJlIHByZXNlbnQgZXhjZXB0IGZvciB0aGUgdG9wLWxldmVsXG4gICAgICAgIC8vIGNvbXBvbmVudCB3aGVuIHNlcnZlciByZW5kZXJpbmdcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nKG51bGwsIHRoaXMuX3N0cmluZ1RleHQsIHRoaXMsIHBhcmVudEluZm8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkb21JRCA9IGhvc3RDb250YWluZXJJbmZvLl9pZENvdW50ZXIrKztcbiAgICB2YXIgb3BlbmluZ1ZhbHVlID0gJyByZWFjdC10ZXh0OiAnICsgZG9tSUQgKyAnICc7XG4gICAgdmFyIGNsb3NpbmdWYWx1ZSA9ICcgL3JlYWN0LXRleHQgJztcbiAgICB0aGlzLl9kb21JRCA9IGRvbUlEO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGhvc3RDb250YWluZXJJbmZvLl9vd25lckRvY3VtZW50O1xuICAgICAgdmFyIG9wZW5pbmdDb21tZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KG9wZW5pbmdWYWx1ZSk7XG4gICAgICB2YXIgY2xvc2luZ0NvbW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY2xvc2luZ1ZhbHVlKTtcbiAgICAgIHZhciBsYXp5VHJlZSA9IERPTUxhenlUcmVlKG93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpKTtcbiAgICAgIERPTUxhenlUcmVlLnF1ZXVlQ2hpbGQobGF6eVRyZWUsIERPTUxhenlUcmVlKG9wZW5pbmdDb21tZW50KSk7XG4gICAgICBpZiAodGhpcy5fc3RyaW5nVGV4dCkge1xuICAgICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBET01MYXp5VHJlZShvd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuX3N0cmluZ1RleHQpKSk7XG4gICAgICB9XG4gICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBET01MYXp5VHJlZShjbG9zaW5nQ29tbWVudCkpO1xuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZSh0aGlzLCBvcGVuaW5nQ29tbWVudCk7XG4gICAgICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IGNsb3NpbmdDb21tZW50O1xuICAgICAgcmV0dXJuIGxhenlUcmVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXNjYXBlZFRleHQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGhpcy5fc3RyaW5nVGV4dCk7XG5cbiAgICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgICAvLyBOb3JtYWxseSB3ZSdkIHdyYXAgdGhpcyBiZXR3ZWVuIGNvbW1lbnQgbm9kZXMgZm9yIHRoZSByZWFzb25zIHN0YXRlZFxuICAgICAgICAvLyBhYm92ZSwgYnV0IHNpbmNlIHRoaXMgaXMgYSBzaXR1YXRpb24gd2hlcmUgUmVhY3Qgd29uJ3QgdGFrZSBvdmVyXG4gICAgICAgIC8vIChzdGF0aWMgcGFnZXMpLCB3ZSBjYW4gc2ltcGx5IHJldHVybiB0aGUgdGV4dCBhcyBpdCBpcy5cbiAgICAgICAgcmV0dXJuIGVzY2FwZWRUZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJzwhLS0nICsgb3BlbmluZ1ZhbHVlICsgJy0tPicgKyBlc2NhcGVkVGV4dCArICc8IS0tJyArIGNsb3NpbmdWYWx1ZSArICctLT4nO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGNvbXBvbmVudCBieSB1cGRhdGluZyB0aGUgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0VGV4dH0gbmV4dFRleHQgVGhlIG5leHQgdGV4dCBjb250ZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dFRleHQsIHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKG5leHRUZXh0ICE9PSB0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0VGV4dDtcbiAgICAgIHZhciBuZXh0U3RyaW5nVGV4dCA9ICcnICsgbmV4dFRleHQ7XG4gICAgICBpZiAobmV4dFN0cmluZ1RleHQgIT09IHRoaXMuX3N0cmluZ1RleHQpIHtcbiAgICAgICAgLy8gVE9ETzogU2F2ZSB0aGlzIGFzIHBlbmRpbmcgcHJvcHMgYW5kIHVzZSBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnlcbiAgICAgICAgLy8gYW5kL29yIHVwZGF0ZUNvbXBvbmVudCB0byBkbyB0aGUgYWN0dWFsIHVwZGF0ZSBmb3IgY29uc2lzdGVuY3kgd2l0aFxuICAgICAgICAvLyBvdGhlciBjb21wb25lbnQgdHlwZXM/XG4gICAgICAgIHRoaXMuX3N0cmluZ1RleHQgPSBuZXh0U3RyaW5nVGV4dDtcbiAgICAgICAgdmFyIGNvbW1lbnROb2RlcyA9IHRoaXMuZ2V0SG9zdE5vZGUoKTtcbiAgICAgICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnJlcGxhY2VEZWxpbWl0ZWRUZXh0KGNvbW1lbnROb2Rlc1swXSwgY29tbWVudE5vZGVzWzFdLCBuZXh0U3RyaW5nVGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhvc3ROb2RlID0gdGhpcy5fY29tbWVudE5vZGVzO1xuICAgIGlmIChob3N0Tm9kZSkge1xuICAgICAgcmV0dXJuIGhvc3ROb2RlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2Nsb3NpbmdDb21tZW50KSB7XG4gICAgICB2YXIgb3BlbmluZ0NvbW1lbnQgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZSh0aGlzKTtcbiAgICAgIHZhciBub2RlID0gb3BlbmluZ0NvbW1lbnQubmV4dFNpYmxpbmc7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAhKG5vZGUgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWlzc2luZyBjbG9zaW5nIGNvbW1lbnQgZm9yIHRleHQgY29tcG9uZW50ICVzJywgdGhpcy5fZG9tSUQpIDogX3Byb2RJbnZhcmlhbnQoJzY3JywgdGhpcy5fZG9tSUQpIDogdm9pZCAwO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyAvcmVhY3QtdGV4dCAnKSB7XG4gICAgICAgICAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBub2RlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBob3N0Tm9kZSA9IFt0aGlzLl9ob3N0Tm9kZSwgdGhpcy5fY2xvc2luZ0NvbW1lbnRdO1xuICAgIHRoaXMuX2NvbW1lbnROb2RlcyA9IGhvc3ROb2RlO1xuICAgIHJldHVybiBob3N0Tm9kZTtcbiAgfSxcblxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX2NvbW1lbnROb2RlcyA9IG51bGw7XG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVGV4dENvbXBvbmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xuXG52YXIgUkVTRVRfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgfVxufTtcblxudmFyIEZMVVNIX0JBVENIRURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZW1wdHlGdW5jdGlvbixcbiAgY2xvc2U6IFJlYWN0VXBkYXRlcy5mbHVzaEJhdGNoZWRVcGRhdGVzLmJpbmQoUmVhY3RVcGRhdGVzKVxufTtcblxudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW0ZMVVNIX0JBVENIRURfVVBEQVRFUywgUkVTRVRfQkFUQ0hFRF9VUERBVEVTXTtcblxuZnVuY3Rpb24gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uKCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG59XG5cbl9hc3NpZ24oUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfVxufSk7XG5cbnZhciB0cmFuc2FjdGlvbiA9IG5ldyBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKTtcblxudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSB7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzOiBmYWxzZSxcblxuICAvKipcbiAgICogQ2FsbCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaW4gYSBjb250ZXh0IHdpdGhpbiB3aGljaCBjYWxscyB0byBgc2V0U3RhdGVgXG4gICAqIGFuZCBmcmllbmRzIGFyZSBiYXRjaGVkIHN1Y2ggdGhhdCBjb21wb25lbnRzIGFyZW4ndCB1cGRhdGVkIHVubmVjZXNzYXJpbHkuXG4gICAqL1xuICBiYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKSB7XG4gICAgdmFyIGFscmVhZHlCYXRjaGluZ1VwZGF0ZXMgPSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzO1xuXG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG5cbiAgICAvLyBUaGUgY29kZSBpcyB3cml0dGVuIHRoaXMgd2F5IHRvIGF2b2lkIGV4dHJhIGFsbG9jYXRpb25zXG4gICAgaWYgKGFscmVhZHlCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhhLCBiLCBjLCBkLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uLnBlcmZvcm0oY2FsbGJhY2ssIG51bGwsIGEsIGIsIGMsIGQsIGUpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5OyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogVXBzdHJlYW0gdmVyc2lvbiBvZiBldmVudCBsaXN0ZW5lci4gRG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgc3BlY2lmaWNcbiAqIG5hdHVyZSBvZiBwbGF0Zm9ybS5cbiAqL1xudmFyIEV2ZW50TGlzdGVuZXIgPSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hdHRhY2hFdmVudCkge1xuICAgICAgdGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgY2FwdHVyZTogZnVuY3Rpb24gY2FwdHVyZSh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F0dGVtcHRlZCB0byBsaXN0ZW4gdG8gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZSBvbiBhICcgKyAnYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhlIGNhcHR1cmUgcGhhc2UuIFlvdXIgYXBwbGljYXRpb24gJyArICd3aWxsIG5vdCByZWNlaXZlIHNvbWUgZXZlbnRzLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBlbXB0eUZ1bmN0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICByZWdpc3RlckRlZmF1bHQ6IGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdCgpIHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TGlzdGVuZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldHMgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgc3VwcGxpZWQgZWxlbWVudCBvciB3aW5kb3cuXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZXMgYXJlIHVuYm91bmRlZCwgdW5saWtlIGBnZXRTY3JvbGxQb3NpdGlvbmAuIFRoaXMgbWVhbnMgdGhleVxuICogbWF5IGJlIG5lZ2F0aXZlIG9yIGV4Y2VlZCB0aGUgZWxlbWVudCBib3VuZGFyaWVzICh3aGljaCBpcyBwb3NzaWJsZSB1c2luZ1xuICogaW5lcnRpYWwgc2Nyb2xsaW5nKS5cbiAqXG4gKiBAcGFyYW0ge0RPTVdpbmRvd3xET01FbGVtZW50fSBzY3JvbGxhYmxlXG4gKiBAcmV0dXJuIHtvYmplY3R9IE1hcCB3aXRoIGB4YCBhbmQgYHlgIGtleXMuXG4gKi9cblxuZnVuY3Rpb24gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24oc2Nyb2xsYWJsZSkge1xuICBpZiAoc2Nyb2xsYWJsZSA9PT0gd2luZG93KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHNjcm9sbGFibGUuc2Nyb2xsTGVmdCxcbiAgICB5OiBzY3JvbGxhYmxlLnNjcm9sbFRvcFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG52YXIgZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbicpO1xuXG4vKipcbiAqIEZpbmQgdGhlIGRlZXBlc3QgUmVhY3QgY29tcG9uZW50IGNvbXBsZXRlbHkgY29udGFpbmluZyB0aGUgcm9vdCBvZiB0aGVcbiAqIHBhc3NlZC1pbiBpbnN0YW5jZSAoZm9yIHVzZSB3aGVuIGVudGlyZSBSZWFjdCB0cmVlcyBhcmUgbmVzdGVkIHdpdGhpbiBlYWNoXG4gKiBvdGhlcikuIElmIFJlYWN0IHRyZWVzIGFyZSBub3QgbmVzdGVkLCByZXR1cm5zIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGZpbmRQYXJlbnQoaW5zdCkge1xuICAvLyBUT0RPOiBJdCBtYXkgYmUgYSBnb29kIGlkZWEgdG8gY2FjaGUgdGhpcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IERPTVxuICAvLyB0cmF2ZXJzYWwsIGJ1dCBjYWNoaW5nIGlzIGRpZmZpY3VsdCB0byBkbyBjb3JyZWN0bHkgd2l0aG91dCB1c2luZyBhXG4gIC8vIG11dGF0aW9uIG9ic2VydmVyIHRvIGxpc3RlbiBmb3IgYWxsIERPTSBjaGFuZ2VzLlxuICB3aGlsZSAoaW5zdC5faG9zdFBhcmVudCkge1xuICAgIGluc3QgPSBpbnN0Ll9ob3N0UGFyZW50O1xuICB9XG4gIHZhciByb290Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICB2YXIgY29udGFpbmVyID0gcm9vdE5vZGUucGFyZW50Tm9kZTtcbiAgcmV0dXJuIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShjb250YWluZXIpO1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHRoaXMudG9wTGV2ZWxUeXBlID0gdG9wTGV2ZWxUeXBlO1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gIHRoaXMuYW5jZXN0b3JzID0gW107XG59XG5fYXNzaWduKFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmFuY2VzdG9ycy5sZW5ndGggPSAwO1xuICB9XG59KTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcsIFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxJbXBsKGJvb2tLZWVwaW5nKSB7XG4gIHZhciBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50KTtcbiAgdmFyIHRhcmdldEluc3QgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgaGllcmFyY2h5LCBpbiBjYXNlIHRoZXJlJ3MgYW55IG5lc3RlZCBjb21wb25lbnRzLlxuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIGJ1aWxkIHRoZSBhcnJheSBvZiBhbmNlc3RvcnMgYmVmb3JlIGNhbGxpbmcgYW55XG4gIC8vIGV2ZW50IGhhbmRsZXJzLCBiZWNhdXNlIGV2ZW50IGhhbmRsZXJzIGNhbiBtb2RpZnkgdGhlIERPTSwgbGVhZGluZyB0b1xuICAvLyBpbmNvbnNpc3RlbmNpZXMgd2l0aCBSZWFjdE1vdW50J3Mgbm9kZSBjYWNoZS4gU2VlICMxMTA1LlxuICB2YXIgYW5jZXN0b3IgPSB0YXJnZXRJbnN0O1xuICBkbyB7XG4gICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgIGFuY2VzdG9yID0gYW5jZXN0b3IgJiYgZmluZFBhcmVudChhbmNlc3Rvcik7XG4gIH0gd2hpbGUgKGFuY2VzdG9yKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHRhcmdldEluc3QgPSBib29rS2VlcGluZy5hbmNlc3RvcnNbaV07XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFZhbHVlTW9uaXRvcihjYikge1xuICB2YXIgc2Nyb2xsUG9zaXRpb24gPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbih3aW5kb3cpO1xuICBjYihzY3JvbGxQb3NpdGlvbik7XG59XG5cbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSB7XG4gIF9lbmFibGVkOiB0cnVlLFxuICBfaGFuZGxlVG9wTGV2ZWw6IG51bGwsXG5cbiAgV0lORE9XX0hBTkRMRTogRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gd2luZG93IDogbnVsbCxcblxuICBzZXRIYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKGhhbmRsZVRvcExldmVsKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbCA9IGhhbmRsZVRvcExldmVsO1xuICB9LFxuXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkID0gISFlbmFibGVkO1xuICB9LFxuXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIHRvcC1sZXZlbCBldmVudHMgYnkgdXNpbmcgZXZlbnQgYnViYmxpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmxpc3RlbihlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnQgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhcENhcHR1cmVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmNhcHR1cmUoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xuICB9LFxuXG4gIG1vbml0b3JTY3JvbGxWYWx1ZTogZnVuY3Rpb24gKHJlZnJlc2gpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBzY3JvbGxWYWx1ZU1vbml0b3IuYmluZChudWxsLCByZWZyZXNoKTtcbiAgICBFdmVudExpc3RlbmVyLmxpc3Rlbih3aW5kb3csICdzY3JvbGwnLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIVJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBib29rS2VlcGluZyA9IFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5nZXRQb29sZWQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEV2ZW50IHF1ZXVlIGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgc2FtZSBjeWNsZSBhbGxvd3NcbiAgICAgIC8vIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWxJbXBsLCBib29rS2VlcGluZyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5yZWxlYXNlKGJvb2tLZWVwaW5nKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudExpc3RlbmVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0SG9zdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RIb3N0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIFJlYWN0SW5qZWN0aW9uID0ge1xuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuaW5qZWN0aW9uLFxuICBET01Qcm9wZXJ0eTogRE9NUHJvcGVydHkuaW5qZWN0aW9uLFxuICBFbXB0eUNvbXBvbmVudDogUmVhY3RFbXB0eUNvbXBvbmVudC5pbmplY3Rpb24sXG4gIEV2ZW50UGx1Z2luSHViOiBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24sXG4gIEV2ZW50UGx1Z2luVXRpbHM6IEV2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLFxuICBFdmVudEVtaXR0ZXI6IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pbmplY3Rpb24sXG4gIEhvc3RDb21wb25lbnQ6IFJlYWN0SG9zdENvbXBvbmVudC5pbmplY3Rpb24sXG4gIFVwZGF0ZXM6IFJlYWN0VXBkYXRlcy5pbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbmplY3Rpb247IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQgPSByZXF1aXJlKCcuL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQnKTtcbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yJyk7XG5cbi8qKlxuICogV2hpbGUgYGlzQ29sbGFwc2VkYCBpcyBhdmFpbGFibGUgb24gdGhlIFNlbGVjdGlvbiBvYmplY3QgYW5kIGBjb2xsYXBzZWRgXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIFJhbmdlIG9iamVjdCwgSUUxMSBzb21ldGltZXMgZ2V0cyB0aGVtIHdyb25nLlxuICogSWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhbmQgb2Zmc2V0cyBhcmUgdGhlIHNhbWUsIHRoZSByYW5nZSBpcyBjb2xsYXBzZWQuXG4gKi9cbmZ1bmN0aW9uIGlzQ29sbGFwc2VkKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICByZXR1cm4gYW5jaG9yTm9kZSA9PT0gZm9jdXNOb2RlICYmIGFuY2hvck9mZnNldCA9PT0gZm9jdXNPZmZzZXQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBhcHByb3ByaWF0ZSBhbmNob3IgYW5kIGZvY3VzIG5vZGUvb2Zmc2V0IHBhaXJzIGZvciBJRS5cbiAqXG4gKiBUaGUgY2F0Y2ggaGVyZSBpcyB0aGF0IElFJ3Mgc2VsZWN0aW9uIEFQSSBkb2Vzbid0IHByb3ZpZGUgaW5mb3JtYXRpb25cbiAqIGFib3V0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBmb3J3YXJkIG9yIGJhY2t3YXJkLCBzbyB3ZSBoYXZlIHRvXG4gKiBiZWhhdmUgYXMgdGhvdWdoIGl0J3MgYWx3YXlzIGZvcndhcmQuXG4gKlxuICogSUUgdGV4dCBkaWZmZXJzIGZyb20gbW9kZXJuIHNlbGVjdGlvbiBpbiB0aGF0IGl0IGJlaGF2ZXMgYXMgdGhvdWdoXG4gKiBibG9jayBlbGVtZW50cyBlbmQgd2l0aCBhIG5ldyBsaW5lLiBUaGlzIG1lYW5zIGNoYXJhY3RlciBvZmZzZXRzIHdpbGxcbiAqIGRpZmZlciBiZXR3ZWVuIHRoZSB0d28gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0SUVPZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGRvY3VtZW50LnNlbGVjdGlvbjtcbiAgdmFyIHNlbGVjdGVkUmFuZ2UgPSBzZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgdmFyIHNlbGVjdGVkTGVuZ3RoID0gc2VsZWN0ZWRSYW5nZS50ZXh0Lmxlbmd0aDtcblxuICAvLyBEdXBsaWNhdGUgc2VsZWN0aW9uIHNvIHdlIGNhbiBtb3ZlIHJhbmdlIHdpdGhvdXQgYnJlYWtpbmcgdXNlciBzZWxlY3Rpb24uXG4gIHZhciBmcm9tU3RhcnQgPSBzZWxlY3RlZFJhbmdlLmR1cGxpY2F0ZSgpO1xuICBmcm9tU3RhcnQubW92ZVRvRWxlbWVudFRleHQobm9kZSk7XG4gIGZyb21TdGFydC5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHNlbGVjdGVkUmFuZ2UpO1xuXG4gIHZhciBzdGFydE9mZnNldCA9IGZyb21TdGFydC50ZXh0Lmxlbmd0aDtcbiAgdmFyIGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgc2VsZWN0ZWRMZW5ndGg7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnRPZmZzZXQsXG4gICAgZW5kOiBlbmRPZmZzZXRcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVybk9mZnNldHMobm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiAmJiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gIHZhciBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICB2YXIgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgdmFyIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gIHZhciBjdXJyZW50UmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcblxuICAvLyBJbiBGaXJlZm94LCByYW5nZS5zdGFydENvbnRhaW5lciBhbmQgcmFuZ2UuZW5kQ29udGFpbmVyIGNhbiBiZSBcImFub255bW91c1xuICAvLyBkaXZzXCIsIGUuZy4gdGhlIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzXG4gIC8vIGRpdnMgZG8gbm90IHNlZW0gdG8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkXG4gIC8vIGVycm9yXCIgaWYgYW55IG9mIGl0cyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlXG4gIC8vIHdheSB0byBhdm9pZCBlcnJvcmluZyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3JcbiAgLy8gbm9uLWFub255bW91cyBkaXZzIGFuZCBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG4gIHRyeSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgY3VycmVudFJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlO1xuICAgIGN1cnJlbnRSYW5nZS5lbmRDb250YWluZXIubm9kZVR5cGU7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSWYgdGhlIG5vZGUgYW5kIG9mZnNldCB2YWx1ZXMgYXJlIHRoZSBzYW1lLCB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZC5cbiAgLy8gYFNlbGVjdGlvbi5pc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG5hdGl2ZWx5LCBidXQgSUUgc29tZXRpbWVzIGdldHNcbiAgLy8gdGhpcyB2YWx1ZSB3cm9uZy5cbiAgdmFyIGlzU2VsZWN0aW9uQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQoc2VsZWN0aW9uLmFuY2hvck5vZGUsIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsIHNlbGVjdGlvbi5mb2N1c05vZGUsIHNlbGVjdGlvbi5mb2N1c09mZnNldCk7XG5cbiAgdmFyIHJhbmdlTGVuZ3RoID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQgPyAwIDogY3VycmVudFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuXG4gIHZhciB0ZW1wUmFuZ2UgPSBjdXJyZW50UmFuZ2UuY2xvbmVSYW5nZSgpO1xuICB0ZW1wUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICB0ZW1wUmFuZ2Uuc2V0RW5kKGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lciwgY3VycmVudFJhbmdlLnN0YXJ0T2Zmc2V0KTtcblxuICB2YXIgaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPSBpc0NvbGxhcHNlZCh0ZW1wUmFuZ2Uuc3RhcnRDb250YWluZXIsIHRlbXBSYW5nZS5zdGFydE9mZnNldCwgdGVtcFJhbmdlLmVuZENvbnRhaW5lciwgdGVtcFJhbmdlLmVuZE9mZnNldCk7XG5cbiAgdmFyIHN0YXJ0ID0gaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPyAwIDogdGVtcFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuICB2YXIgZW5kID0gc3RhcnQgKyByYW5nZUxlbmd0aDtcblxuICAvLyBEZXRlY3Qgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkLlxuICB2YXIgZGV0ZWN0aW9uUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRTdGFydChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRFbmQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG4gIHZhciBpc0JhY2t3YXJkID0gZGV0ZWN0aW9uUmFuZ2UuY29sbGFwc2VkO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGlzQmFja3dhcmQgPyBlbmQgOiBzdGFydCxcbiAgICBlbmQ6IGlzQmFja3dhcmQgPyBzdGFydCA6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0SUVPZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkuZHVwbGljYXRlKCk7XG4gIHZhciBzdGFydCwgZW5kO1xuXG4gIGlmIChvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9IGVsc2UgaWYgKG9mZnNldHMuc3RhcnQgPiBvZmZzZXRzLmVuZCkge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5lbmQ7XG4gICAgZW5kID0gb2Zmc2V0cy5zdGFydDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gIH1cblxuICByYW5nZS5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcbiAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gIHJhbmdlLnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0JywgcmFuZ2UpO1xuICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gIHJhbmdlLnNlbGVjdCgpO1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0TW9kZXJuT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlW2dldFRleHRDb250ZW50QWNjZXNzb3IoKV0ubGVuZ3RoO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogTWF0aC5taW4ob2Zmc2V0cy5lbmQsIGxlbmd0aCk7XG5cbiAgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cbiAgaWYgKCFzZWxlY3Rpb24uZXh0ZW5kICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgdmFyIHRlbXAgPSBlbmQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSB0ZW1wO1xuICB9XG5cbiAgdmFyIHN0YXJ0TWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBzdGFydCk7XG4gIHZhciBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIGVuZCk7XG5cbiAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlcikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciB1c2VJRU9mZnNldHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ3NlbGVjdGlvbicgaW4gZG9jdW1lbnQgJiYgISgnZ2V0U2VsZWN0aW9uJyBpbiB3aW5kb3cpO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICovXG4gIGdldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IGdldElFT2Zmc2V0cyA6IGdldE1vZGVybk9mZnNldHMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICAgKi9cbiAgc2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gc2V0SUVPZmZzZXRzIDogc2V0TW9kZXJuT2Zmc2V0c1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdGlvbjsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xuICByZXR1cm4gISEob2JqZWN0ICYmICh0eXBlb2YgTm9kZSA9PT0gJ2Z1bmN0aW9uJyA/IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgOiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9kZTsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL2lzTm9kZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZShvYmplY3QpIHtcbiAgcmV0dXJuIGlzTm9kZShvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA9PSAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dE5vZGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKCcuL2lzVGV4dE5vZGUnKTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gRE9NIG5vZGUgY29udGFpbnMgb3IgaXMgYW5vdGhlciBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnNOb2RlOyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgZmItd3d3L3R5cGVvZi11bmRlZmluZWQgKi9cblxuLyoqXG4gKiBTYW1lIGFzIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYnV0IHdyYXBzIGluIGEgdHJ5LWNhdGNoIGJsb2NrLiBJbiBJRSBpdCBpc1xuICogbm90IHNhZmUgdG8gY2FsbCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlmIHRoZXJlIGlzIG5vdGhpbmcgZm9jdXNlZC5cbiAqXG4gKiBUaGUgYWN0aXZlRWxlbWVudCB3aWxsIGJlIG51bGwgb25seSBpZiB0aGUgZG9jdW1lbnQgb3IgZG9jdW1lbnQgYm9keSBpcyBub3RcbiAqIHlldCBkZWZpbmVkLlxuICovXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KCkgLyo/RE9NRWxlbWVudCove1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWN0aXZlRWxlbWVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0aW9uJyk7XG5cbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xuXG5mdW5jdGlvbiBpc0luRG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gY29udGFpbnNOb2RlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbi8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovXG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHtcblxuICBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXM6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8IGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xuICB9LFxuXG4gIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgIHJldHVybiB7XG4gICAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgICBzZWxlY3Rpb25SYW5nZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZm9jdXNlZEVsZW0pID8gUmVhY3RJbnB1dFNlbGVjdGlvbi5nZXRTZWxlY3Rpb24oZm9jdXNlZEVsZW0pIDogbnVsbFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXN0b3JlU2VsZWN0aW9uOiBJZiBhbnkgc2VsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBwb3RlbnRpYWxseSBsb3N0LFxuICAgKiByZXN0b3JlIGl0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyB0aGF0IGNvdWxkIHJlbW92ZSBkb21cbiAgICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gICAqL1xuICByZXN0b3JlU2VsZWN0aW9uOiBmdW5jdGlvbiAocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICAgIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gICAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICAgIGlmIChjdXJGb2N1c2VkRWxlbSAhPT0gcHJpb3JGb2N1c2VkRWxlbSAmJiBpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIGlmIChSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgICBSZWFjdElucHV0U2VsZWN0aW9uLnNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGZvY3VzTm9kZShwcmlvckZvY3VzZWRFbGVtKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICAgKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAgICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcbiAgICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gICAqL1xuICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBzZWxlY3Rpb247XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgLy8gTW9kZXJuIGJyb3dzZXIgd2l0aCBpbnB1dCBvciB0ZXh0YXJlYS5cbiAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICBlbmQ6IGlucHV0LnNlbGVjdGlvbkVuZFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBpbnB1dC5ub2RlTmFtZSAmJiBpbnB1dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICAvLyBJRTggaW5wdXQuXG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBzZWxlY3Rpb24gcGVyIGRvY3VtZW50IGluIElFLCBzbyBpdCBtdXN0XG4gICAgICAvLyBiZSBpbiBvdXIgZWxlbWVudC5cbiAgICAgIGlmIChyYW5nZS5wYXJlbnRFbGVtZW50KCkgPT09IGlucHV0KSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgICBzdGFydDogLXJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgZW5kOiAtcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSBSZWFjdERPTVNlbGVjdGlvbi5nZXRPZmZzZXRzKGlucHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0aW9uIHx8IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAgICogdGhlIGlucHV0LlxuICAgKiAtQGlucHV0ICAgICBTZXQgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0IG9yIHRleHRhcmVhXG4gICAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAgICovXG4gIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gKGlucHV0LCBvZmZzZXRzKSB7XG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICB9XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBpbnB1dC5ub2RlTmFtZSAmJiBpbnB1dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBpbnB1dC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RET01TZWxlY3Rpb24uc2V0T2Zmc2V0cyhpbnB1dCwgb2Zmc2V0cyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5wdXRTZWxlY3Rpb247IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZSgnLi9DYWxsYmFja1F1ZXVlJyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdElucHV0U2VsZWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xuXG4vKipcbiAqIEVuc3VyZXMgdGhhdCwgd2hlbiBwb3NzaWJsZSwgdGhlIHNlbGVjdGlvbiByYW5nZSAoY3VycmVudGx5IHNlbGVjdGVkIHRleHRcbiAqIGlucHV0KSBpcyBub3QgZGlzdHVyYmVkIGJ5IHBlcmZvcm1pbmcgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgU0VMRUNUSU9OX1JFU1RPUkFUSU9OID0ge1xuICAvKipcbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBTZWxlY3Rpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBpbml0aWFsaXplOiBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbkluZm9ybWF0aW9uLFxuICAvKipcbiAgICogQHBhcmFtIHtTZWxlY3Rpb259IHNlbCBTZWxlY3Rpb24gaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBgaW5pdGlhbGl6ZWAuXG4gICAqL1xuICBjbG9zZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5yZXN0b3JlU2VsZWN0aW9uXG59O1xuXG4vKipcbiAqIFN1cHByZXNzZXMgZXZlbnRzIChibHVyL2ZvY3VzKSB0aGF0IGNvdWxkIGJlIGluYWR2ZXJ0ZW50bHkgZGlzcGF0Y2hlZCBkdWUgdG9cbiAqIGhpZ2ggbGV2ZWwgRE9NIG1hbmlwdWxhdGlvbnMgKGxpa2UgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgYSB0ZXh0IGlucHV0IGZyb20gdGhlXG4gKiBET00pLlxuICovXG52YXIgRVZFTlRfU1VQUFJFU1NJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZW5hYmxlZCBzdGF0dXMgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgYmVmb3JlXG4gICAqIHRoZSByZWNvbmNpbGlhdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudGx5RW5hYmxlZCA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pc0VuYWJsZWQoKTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc2V0RW5hYmxlZChmYWxzZSk7XG4gICAgcmV0dXJuIGN1cnJlbnRseUVuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldmlvdXNseUVuYWJsZWQgRW5hYmxlZCBzdGF0dXMgb2ZcbiAgICogICBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmUgdGhlIHJlY29uY2lsaWF0aW9uIG9jY3VycmVkLiBgY2xvc2VgXG4gICAqICAgcmVzdG9yZXMgdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uIChwcmV2aW91c2x5RW5hYmxlZCkge1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKHByZXZpb3VzbHlFbmFibGVkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIHF1ZXVlIGZvciBjb2xsZWN0aW5nIGBjb21wb25lbnREaWRNb3VudGAgYW5kXG4gKiBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgZHVyaW5nIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIE9OX0RPTV9SRUFEWV9RVUVVRUlORyA9IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBgb25ET01SZWFkeWAgcXVldWUuXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkucmVzZXQoKTtcbiAgfSxcblxuICAvKipcbiAgICogQWZ0ZXIgRE9NIGlzIGZsdXNoZWQsIGludm9rZSBhbGwgcmVnaXN0ZXJlZCBgb25ET01SZWFkeWAgY2FsbGJhY2tzLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5ub3RpZnlBbGwoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW1NFTEVDVElPTl9SRVNUT1JBVElPTiwgRVZFTlRfU1VQUFJFU1NJT04sIE9OX0RPTV9SRUFEWV9RVUVVRUlOR107XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRSQU5TQUNUSU9OX1dSQVBQRVJTLnB1c2goe1xuICAgIGluaXRpYWxpemU6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2gsXG4gICAgY2xvc2U6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoXG4gIH0pO1xufVxuXG4vKipcbiAqIEN1cnJlbnRseTpcbiAqIC0gVGhlIG9yZGVyIHRoYXQgdGhlc2UgYXJlIGxpc3RlZCBpbiB0aGUgdHJhbnNhY3Rpb24gaXMgY3JpdGljYWw6XG4gKiAtIFN1cHByZXNzZXMgZXZlbnRzLlxuICogLSBSZXN0b3JlcyBzZWxlY3Rpb24gcmFuZ2UuXG4gKlxuICogRnV0dXJlOlxuICogLSBSZXN0b3JlIGRvY3VtZW50L292ZXJmbG93IHNjcm9sbCBwb3NpdGlvbnMgdGhhdCB3ZXJlIHVuaW50ZW50aW9uYWxseVxuICogICBtb2RpZmllZCB2aWEgRE9NIGluc2VydGlvbnMgYWJvdmUgdGhlIHRvcCB2aWV3cG9ydCBib3VuZGFyeS5cbiAqIC0gSW1wbGVtZW50L2ludGVncmF0ZSB3aXRoIGN1c3RvbWl6ZWQgY29uc3RyYWludCBiYXNlZCBsYXlvdXQgc3lzdGVtIGFuZCBrZWVwXG4gKiAgIHRyYWNrIG9mIHdoaWNoIGRpbWVuc2lvbnMgbXVzdCBiZSByZW1lYXN1cmVkLlxuICpcbiAqIEBjbGFzcyBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24odXNlQ3JlYXRlRWxlbWVudCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIC8vIE9ubHkgc2VydmVyLXNpZGUgcmVuZGVyaW5nIHJlYWxseSBuZWVkcyB0aGlzIG9wdGlvbiAoc2VlXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ2ApLCBidXQgc2VydmVyLXNpZGUgdXNlc1xuICAvLyBgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbmAgaW5zdGVhZC4gVGhpcyBvcHRpb24gaXMgaGVyZSBzbyB0aGF0IGl0J3NcbiAgLy8gYWNjZXNzaWJsZSBhbmQgZGVmYXVsdHMgdG8gZmFsc2Ugd2hlbiBgUmVhY3RET01Db21wb25lbnRgIGFuZFxuICAvLyBgUmVhY3RET01UZXh0Q29tcG9uZW50YCBjaGVja3MgaXQgaW4gYG1vdW50Q29tcG9uZW50YC5gXG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSBmYWxzZTtcbiAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZChudWxsKTtcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gdXNlQ3JlYXRlRWxlbWVudDtcbn1cblxudmFyIE1peGluID0ge1xuICAvKipcbiAgICogQHNlZSBUcmFuc2FjdGlvblxuICAgKiBAYWJzdHJhY3RcbiAgICogQGZpbmFsXG4gICAqIEByZXR1cm4ge2FycmF5PG9iamVjdD59IExpc3Qgb2Ygb3BlcmF0aW9uIHdyYXAgcHJvY2VkdXJlcy5cbiAgICogICBUT0RPOiBjb252ZXJ0IHRvIGFycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcyB3aXRoLlxuICAgKi9cbiAgZ2V0UmVhY3RNb3VudFJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IFJlYWN0IGFzeW5jIGV2ZW50cy5cbiAgICovXG4gIGdldFVwZGF0ZVF1ZXVlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0VXBkYXRlUXVldWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhdmUgY3VycmVudCB0cmFuc2FjdGlvbiBzdGF0ZSAtLSBpZiB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhpcyBtZXRob2QgaXNcbiAgICogcGFzc2VkIHRvIGByb2xsYmFja2AsIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHJlc2V0IHRvIHRoYXQgc3RhdGUuXG4gICAqL1xuICBjaGVja3BvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmVhY3RNb3VudFJlYWR5IGlzIHRoZSBvdXIgb25seSBzdGF0ZWZ1bCB3cmFwcGVyXG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5LmNoZWNrcG9pbnQoKTtcbiAgfSxcblxuICByb2xsYmFjazogZnVuY3Rpb24gKGNoZWNrcG9pbnQpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yb2xsYmFjayhjaGVja3BvaW50KTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmV1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLnJlYWN0TW91bnRSZWFkeSk7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBudWxsO1xuICB9XG59O1xuXG5fYXNzaWduKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTlMgPSB7XG4gIHhsaW5rOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gIHhtbDogJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSdcbn07XG5cbi8vIFdlIHVzZSBhdHRyaWJ1dGVzIGZvciBldmVyeXRoaW5nIFNWRyBzbyBsZXQncyBhdm9pZCBzb21lIGR1cGxpY2F0aW9uIGFuZCBydW5cbi8vIGNvZGUgaW5zdGVhZC5cbi8vIFRoZSBmb2xsb3dpbmcgYXJlIGFsbCBzcGVjaWZpZWQgaW4gdGhlIEhUTUwgY29uZmlnIGFscmVhZHkgc28gd2UgZXhjbHVkZSBoZXJlLlxuLy8gLSBjbGFzcyAoYXMgY2xhc3NOYW1lKVxuLy8gLSBjb2xvclxuLy8gLSBoZWlnaHRcbi8vIC0gaWRcbi8vIC0gbGFuZ1xuLy8gLSBtYXhcbi8vIC0gbWVkaWFcbi8vIC0gbWV0aG9kXG4vLyAtIG1pblxuLy8gLSBuYW1lXG4vLyAtIHN0eWxlXG4vLyAtIHRhcmdldFxuLy8gLSB0eXBlXG4vLyAtIHdpZHRoXG52YXIgQVRUUlMgPSB7XG4gIGFjY2VudEhlaWdodDogJ2FjY2VudC1oZWlnaHQnLFxuICBhY2N1bXVsYXRlOiAwLFxuICBhZGRpdGl2ZTogMCxcbiAgYWxpZ25tZW50QmFzZWxpbmU6ICdhbGlnbm1lbnQtYmFzZWxpbmUnLFxuICBhbGxvd1Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAwLFxuICBhbXBsaXR1ZGU6IDAsXG4gIGFyYWJpY0Zvcm06ICdhcmFiaWMtZm9ybScsXG4gIGFzY2VudDogMCxcbiAgYXR0cmlidXRlTmFtZTogJ2F0dHJpYnV0ZU5hbWUnLFxuICBhdHRyaWJ1dGVUeXBlOiAnYXR0cmlidXRlVHlwZScsXG4gIGF1dG9SZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICBhemltdXRoOiAwLFxuICBiYXNlRnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXG4gIGJhc2VQcm9maWxlOiAnYmFzZVByb2ZpbGUnLFxuICBiYXNlbGluZVNoaWZ0OiAnYmFzZWxpbmUtc2hpZnQnLFxuICBiYm94OiAwLFxuICBiZWdpbjogMCxcbiAgYmlhczogMCxcbiAgYnk6IDAsXG4gIGNhbGNNb2RlOiAnY2FsY01vZGUnLFxuICBjYXBIZWlnaHQ6ICdjYXAtaGVpZ2h0JyxcbiAgY2xpcDogMCxcbiAgY2xpcFBhdGg6ICdjbGlwLXBhdGgnLFxuICBjbGlwUnVsZTogJ2NsaXAtcnVsZScsXG4gIGNsaXBQYXRoVW5pdHM6ICdjbGlwUGF0aFVuaXRzJyxcbiAgY29sb3JJbnRlcnBvbGF0aW9uOiAnY29sb3ItaW50ZXJwb2xhdGlvbicsXG4gIGNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnM6ICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLFxuICBjb2xvclByb2ZpbGU6ICdjb2xvci1wcm9maWxlJyxcbiAgY29sb3JSZW5kZXJpbmc6ICdjb2xvci1yZW5kZXJpbmcnLFxuICBjb250ZW50U2NyaXB0VHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgY29udGVudFN0eWxlVHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICBjdXJzb3I6IDAsXG4gIGN4OiAwLFxuICBjeTogMCxcbiAgZDogMCxcbiAgZGVjZWxlcmF0ZTogMCxcbiAgZGVzY2VudDogMCxcbiAgZGlmZnVzZUNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAwLFxuICBkaXNwbGF5OiAwLFxuICBkaXZpc29yOiAwLFxuICBkb21pbmFudEJhc2VsaW5lOiAnZG9taW5hbnQtYmFzZWxpbmUnLFxuICBkdXI6IDAsXG4gIGR4OiAwLFxuICBkeTogMCxcbiAgZWRnZU1vZGU6ICdlZGdlTW9kZScsXG4gIGVsZXZhdGlvbjogMCxcbiAgZW5hYmxlQmFja2dyb3VuZDogJ2VuYWJsZS1iYWNrZ3JvdW5kJyxcbiAgZW5kOiAwLFxuICBleHBvbmVudDogMCxcbiAgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICBmaWxsOiAwLFxuICBmaWxsT3BhY2l0eTogJ2ZpbGwtb3BhY2l0eScsXG4gIGZpbGxSdWxlOiAnZmlsbC1ydWxlJyxcbiAgZmlsdGVyOiAwLFxuICBmaWx0ZXJSZXM6ICdmaWx0ZXJSZXMnLFxuICBmaWx0ZXJVbml0czogJ2ZpbHRlclVuaXRzJyxcbiAgZmxvb2RDb2xvcjogJ2Zsb29kLWNvbG9yJyxcbiAgZmxvb2RPcGFjaXR5OiAnZmxvb2Qtb3BhY2l0eScsXG4gIGZvY3VzYWJsZTogMCxcbiAgZm9udEZhbWlseTogJ2ZvbnQtZmFtaWx5JyxcbiAgZm9udFNpemU6ICdmb250LXNpemUnLFxuICBmb250U2l6ZUFkanVzdDogJ2ZvbnQtc2l6ZS1hZGp1c3QnLFxuICBmb250U3RyZXRjaDogJ2ZvbnQtc3RyZXRjaCcsXG4gIGZvbnRTdHlsZTogJ2ZvbnQtc3R5bGUnLFxuICBmb250VmFyaWFudDogJ2ZvbnQtdmFyaWFudCcsXG4gIGZvbnRXZWlnaHQ6ICdmb250LXdlaWdodCcsXG4gIGZvcm1hdDogMCxcbiAgZnJvbTogMCxcbiAgZng6IDAsXG4gIGZ5OiAwLFxuICBnMTogMCxcbiAgZzI6IDAsXG4gIGdseXBoTmFtZTogJ2dseXBoLW5hbWUnLFxuICBnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbDogJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnLFxuICBnbHlwaE9yaWVudGF0aW9uVmVydGljYWw6ICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsXG4gIGdseXBoUmVmOiAnZ2x5cGhSZWYnLFxuICBncmFkaWVudFRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgZ3JhZGllbnRVbml0czogJ2dyYWRpZW50VW5pdHMnLFxuICBoYW5naW5nOiAwLFxuICBob3JpekFkdlg6ICdob3Jpei1hZHYteCcsXG4gIGhvcml6T3JpZ2luWDogJ2hvcml6LW9yaWdpbi14JyxcbiAgaWRlb2dyYXBoaWM6IDAsXG4gIGltYWdlUmVuZGVyaW5nOiAnaW1hZ2UtcmVuZGVyaW5nJyxcbiAgJ2luJzogMCxcbiAgaW4yOiAwLFxuICBpbnRlcmNlcHQ6IDAsXG4gIGs6IDAsXG4gIGsxOiAwLFxuICBrMjogMCxcbiAgazM6IDAsXG4gIGs0OiAwLFxuICBrZXJuZWxNYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxuICBrZXJuZWxVbml0TGVuZ3RoOiAna2VybmVsVW5pdExlbmd0aCcsXG4gIGtlcm5pbmc6IDAsXG4gIGtleVBvaW50czogJ2tleVBvaW50cycsXG4gIGtleVNwbGluZXM6ICdrZXlTcGxpbmVzJyxcbiAga2V5VGltZXM6ICdrZXlUaW1lcycsXG4gIGxlbmd0aEFkanVzdDogJ2xlbmd0aEFkanVzdCcsXG4gIGxldHRlclNwYWNpbmc6ICdsZXR0ZXItc3BhY2luZycsXG4gIGxpZ2h0aW5nQ29sb3I6ICdsaWdodGluZy1jb2xvcicsXG4gIGxpbWl0aW5nQ29uZUFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogMCxcbiAgbWFya2VyRW5kOiAnbWFya2VyLWVuZCcsXG4gIG1hcmtlck1pZDogJ21hcmtlci1taWQnLFxuICBtYXJrZXJTdGFydDogJ21hcmtlci1zdGFydCcsXG4gIG1hcmtlckhlaWdodDogJ21hcmtlckhlaWdodCcsXG4gIG1hcmtlclVuaXRzOiAnbWFya2VyVW5pdHMnLFxuICBtYXJrZXJXaWR0aDogJ21hcmtlcldpZHRoJyxcbiAgbWFzazogMCxcbiAgbWFza0NvbnRlbnRVbml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrVW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6IDAsXG4gIG1vZGU6IDAsXG4gIG51bU9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAwLFxuICBvcGFjaXR5OiAwLFxuICBvcGVyYXRvcjogMCxcbiAgb3JkZXI6IDAsXG4gIG9yaWVudDogMCxcbiAgb3JpZW50YXRpb246IDAsXG4gIG9yaWdpbjogMCxcbiAgb3ZlcmZsb3c6IDAsXG4gIG92ZXJsaW5lUG9zaXRpb246ICdvdmVybGluZS1wb3NpdGlvbicsXG4gIG92ZXJsaW5lVGhpY2tuZXNzOiAnb3ZlcmxpbmUtdGhpY2tuZXNzJyxcbiAgcGFpbnRPcmRlcjogJ3BhaW50LW9yZGVyJyxcbiAgcGFub3NlMTogJ3Bhbm9zZS0xJyxcbiAgcGF0aExlbmd0aDogJ3BhdGhMZW5ndGgnLFxuICBwYXR0ZXJuQ29udGVudFVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gIHBhdHRlcm5UcmFuc2Zvcm06ICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgcGF0dGVyblVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgcG9pbnRlckV2ZW50czogJ3BvaW50ZXItZXZlbnRzJyxcbiAgcG9pbnRzOiAwLFxuICBwb2ludHNBdFg6ICdwb2ludHNBdFgnLFxuICBwb2ludHNBdFk6ICdwb2ludHNBdFknLFxuICBwb2ludHNBdFo6ICdwb2ludHNBdFonLFxuICBwcmVzZXJ2ZUFscGhhOiAncHJlc2VydmVBbHBoYScsXG4gIHByZXNlcnZlQXNwZWN0UmF0aW86ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgcHJpbWl0aXZlVW5pdHM6ICdwcmltaXRpdmVVbml0cycsXG4gIHI6IDAsXG4gIHJhZGl1czogMCxcbiAgcmVmWDogJ3JlZlgnLFxuICByZWZZOiAncmVmWScsXG4gIHJlbmRlcmluZ0ludGVudDogJ3JlbmRlcmluZy1pbnRlbnQnLFxuICByZXBlYXRDb3VudDogJ3JlcGVhdENvdW50JyxcbiAgcmVwZWF0RHVyOiAncmVwZWF0RHVyJyxcbiAgcmVxdWlyZWRFeHRlbnNpb25zOiAncmVxdWlyZWRFeHRlbnNpb25zJyxcbiAgcmVxdWlyZWRGZWF0dXJlczogJ3JlcXVpcmVkRmVhdHVyZXMnLFxuICByZXN0YXJ0OiAwLFxuICByZXN1bHQ6IDAsXG4gIHJvdGF0ZTogMCxcbiAgcng6IDAsXG4gIHJ5OiAwLFxuICBzY2FsZTogMCxcbiAgc2VlZDogMCxcbiAgc2hhcGVSZW5kZXJpbmc6ICdzaGFwZS1yZW5kZXJpbmcnLFxuICBzbG9wZTogMCxcbiAgc3BhY2luZzogMCxcbiAgc3BlY3VsYXJDb25zdGFudDogJ3NwZWN1bGFyQ29uc3RhbnQnLFxuICBzcGVjdWxhckV4cG9uZW50OiAnc3BlY3VsYXJFeHBvbmVudCcsXG4gIHNwZWVkOiAwLFxuICBzcHJlYWRNZXRob2Q6ICdzcHJlYWRNZXRob2QnLFxuICBzdGFydE9mZnNldDogJ3N0YXJ0T2Zmc2V0JyxcbiAgc3RkRGV2aWF0aW9uOiAnc3RkRGV2aWF0aW9uJyxcbiAgc3RlbWg6IDAsXG4gIHN0ZW12OiAwLFxuICBzdGl0Y2hUaWxlczogJ3N0aXRjaFRpbGVzJyxcbiAgc3RvcENvbG9yOiAnc3RvcC1jb2xvcicsXG4gIHN0b3BPcGFjaXR5OiAnc3RvcC1vcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaFBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbicsXG4gIHN0cmlrZXRocm91Z2hUaGlja25lc3M6ICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsXG4gIHN0cmluZzogMCxcbiAgc3Ryb2tlOiAwLFxuICBzdHJva2VEYXNoYXJyYXk6ICdzdHJva2UtZGFzaGFycmF5JyxcbiAgc3Ryb2tlRGFzaG9mZnNldDogJ3N0cm9rZS1kYXNob2Zmc2V0JyxcbiAgc3Ryb2tlTGluZWNhcDogJ3N0cm9rZS1saW5lY2FwJyxcbiAgc3Ryb2tlTGluZWpvaW46ICdzdHJva2UtbGluZWpvaW4nLFxuICBzdHJva2VNaXRlcmxpbWl0OiAnc3Ryb2tlLW1pdGVybGltaXQnLFxuICBzdHJva2VPcGFjaXR5OiAnc3Ryb2tlLW9wYWNpdHknLFxuICBzdHJva2VXaWR0aDogJ3N0cm9rZS13aWR0aCcsXG4gIHN1cmZhY2VTY2FsZTogJ3N1cmZhY2VTY2FsZScsXG4gIHN5c3RlbUxhbmd1YWdlOiAnc3lzdGVtTGFuZ3VhZ2UnLFxuICB0YWJsZVZhbHVlczogJ3RhYmxlVmFsdWVzJyxcbiAgdGFyZ2V0WDogJ3RhcmdldFgnLFxuICB0YXJnZXRZOiAndGFyZ2V0WScsXG4gIHRleHRBbmNob3I6ICd0ZXh0LWFuY2hvcicsXG4gIHRleHREZWNvcmF0aW9uOiAndGV4dC1kZWNvcmF0aW9uJyxcbiAgdGV4dFJlbmRlcmluZzogJ3RleHQtcmVuZGVyaW5nJyxcbiAgdGV4dExlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0bzogMCxcbiAgdHJhbnNmb3JtOiAwLFxuICB1MTogMCxcbiAgdTI6IDAsXG4gIHVuZGVybGluZVBvc2l0aW9uOiAndW5kZXJsaW5lLXBvc2l0aW9uJyxcbiAgdW5kZXJsaW5lVGhpY2tuZXNzOiAndW5kZXJsaW5lLXRoaWNrbmVzcycsXG4gIHVuaWNvZGU6IDAsXG4gIHVuaWNvZGVCaWRpOiAndW5pY29kZS1iaWRpJyxcbiAgdW5pY29kZVJhbmdlOiAndW5pY29kZS1yYW5nZScsXG4gIHVuaXRzUGVyRW06ICd1bml0cy1wZXItZW0nLFxuICB2QWxwaGFiZXRpYzogJ3YtYWxwaGFiZXRpYycsXG4gIHZIYW5naW5nOiAndi1oYW5naW5nJyxcbiAgdklkZW9ncmFwaGljOiAndi1pZGVvZ3JhcGhpYycsXG4gIHZNYXRoZW1hdGljYWw6ICd2LW1hdGhlbWF0aWNhbCcsXG4gIHZhbHVlczogMCxcbiAgdmVjdG9yRWZmZWN0OiAndmVjdG9yLWVmZmVjdCcsXG4gIHZlcnNpb246IDAsXG4gIHZlcnRBZHZZOiAndmVydC1hZHYteScsXG4gIHZlcnRPcmlnaW5YOiAndmVydC1vcmlnaW4teCcsXG4gIHZlcnRPcmlnaW5ZOiAndmVydC1vcmlnaW4teScsXG4gIHZpZXdCb3g6ICd2aWV3Qm94JyxcbiAgdmlld1RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAwLFxuICB3aWR0aHM6IDAsXG4gIHdvcmRTcGFjaW5nOiAnd29yZC1zcGFjaW5nJyxcbiAgd3JpdGluZ01vZGU6ICd3cml0aW5nLW1vZGUnLFxuICB4OiAwLFxuICB4SGVpZ2h0OiAneC1oZWlnaHQnLFxuICB4MTogMCxcbiAgeDI6IDAsXG4gIHhDaGFubmVsU2VsZWN0b3I6ICd4Q2hhbm5lbFNlbGVjdG9yJyxcbiAgeGxpbmtBY3R1YXRlOiAneGxpbms6YWN0dWF0ZScsXG4gIHhsaW5rQXJjcm9sZTogJ3hsaW5rOmFyY3JvbGUnLFxuICB4bGlua0hyZWY6ICd4bGluazpocmVmJyxcbiAgeGxpbmtSb2xlOiAneGxpbms6cm9sZScsXG4gIHhsaW5rU2hvdzogJ3hsaW5rOnNob3cnLFxuICB4bGlua1RpdGxlOiAneGxpbms6dGl0bGUnLFxuICB4bGlua1R5cGU6ICd4bGluazp0eXBlJyxcbiAgeG1sQmFzZTogJ3htbDpiYXNlJyxcbiAgeG1sbnM6IDAsXG4gIHhtbG5zWGxpbms6ICd4bWxuczp4bGluaycsXG4gIHhtbExhbmc6ICd4bWw6bGFuZycsXG4gIHhtbFNwYWNlOiAneG1sOnNwYWNlJyxcbiAgeTogMCxcbiAgeTE6IDAsXG4gIHkyOiAwLFxuICB5Q2hhbm5lbFNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6IDAsXG4gIHpvb21BbmRQYW46ICd6b29tQW5kUGFuJ1xufTtcblxudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0ge1xuICBQcm9wZXJ0aWVzOiB7fSxcbiAgRE9NQXR0cmlidXRlTmFtZXNwYWNlczoge1xuICAgIHhsaW5rQWN0dWF0ZTogTlMueGxpbmssXG4gICAgeGxpbmtBcmNyb2xlOiBOUy54bGluayxcbiAgICB4bGlua0hyZWY6IE5TLnhsaW5rLFxuICAgIHhsaW5rUm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtTaG93OiBOUy54bGluayxcbiAgICB4bGlua1RpdGxlOiBOUy54bGluayxcbiAgICB4bGlua1R5cGU6IE5TLnhsaW5rLFxuICAgIHhtbEJhc2U6IE5TLnhtbCxcbiAgICB4bWxMYW5nOiBOUy54bWwsXG4gICAgeG1sU3BhY2U6IE5TLnhtbFxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge31cbn07XG5cbk9iamVjdC5rZXlzKEFUVFJTKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuUHJvcGVydGllc1trZXldID0gMDtcbiAgaWYgKEFUVFJTW2tleV0pIHtcbiAgICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc1trZXldID0gQVRUUlNba2V5XTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU1ZHRE9NUHJvcGVydHlDb25maWc7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdElucHV0U2VsZWN0aW9uJyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xudmFyIGlzVGV4dElucHV0RWxlbWVudCA9IHJlcXVpcmUoJy4vaXNUZXh0SW5wdXRFbGVtZW50Jyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG5cbnZhciBza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDw9IDExO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgc2VsZWN0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvblNlbGVjdCcsXG4gICAgICBjYXB0dXJlZDogJ29uU2VsZWN0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbnRleHRNZW51JywgJ3RvcEZvY3VzJywgJ3RvcEtleURvd24nLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJywgJ3RvcE1vdXNlVXAnLCAndG9wU2VsZWN0aW9uQ2hhbmdlJ11cbiAgfVxufTtcblxudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcblxuLy8gVHJhY2sgd2hldGhlciBhIGxpc3RlbmVyIGV4aXN0cyBmb3IgdGhpcyBwbHVnaW4uIElmIG5vbmUgZXhpc3QsIHdlIGRvXG4vLyBub3QgZXh0cmFjdCBldmVudHMuIFNlZSAjMzYzOS5cbnZhciBoYXNMaXN0ZW5lciA9IGZhbHNlO1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgd2hpY2ggaXMgYSB1bmlxdWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBub3QgYmUgY29uc2lzdGVudCBhY3Jvc3Mgbm9kZXMgb3IgYnJvd3NlcnMsIGJ1dFxuICogdHdvIGlkZW50aWNhbCBzZWxlY3Rpb25zIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCByZXR1cm4gaWRlbnRpY2FsIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMobm9kZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IG5vZGUuc2VsZWN0aW9uU3RhcnQsXG4gICAgICBlbmQ6IG5vZGUuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yTm9kZTogc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQ6IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGU6IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldDogc2VsZWN0aW9uLmZvY3VzT2Zmc2V0XG4gICAgfTtcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGFyZW50RWxlbWVudDogcmFuZ2UucGFyZW50RWxlbWVudCgpLFxuICAgICAgdGV4dDogcmFuZ2UudGV4dCxcbiAgICAgIHRvcDogcmFuZ2UuYm91bmRpbmdUb3AsXG4gICAgICBsZWZ0OiByYW5nZS5ib3VuZGluZ0xlZnRcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4gIC8vIHNlbGVjdGlvbiAodGhpcyBtYXRjaGVzIG5hdGl2ZSBgc2VsZWN0YCBldmVudCBiZWhhdmlvcikuIEluIEhUTUw1LCBzZWxlY3RcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuICAvLyB3b24ndCBkaXNwYXRjaC5cbiAgaWYgKG1vdXNlRG93biB8fCBhY3RpdmVFbGVtZW50ID09IG51bGwgfHwgYWN0aXZlRWxlbWVudCAhPT0gZ2V0QWN0aXZlRWxlbWVudCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKGFjdGl2ZUVsZW1lbnQpO1xuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuXG4gICAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuc2VsZWN0LCBhY3RpdmVFbGVtZW50SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICAgIHN5bnRoZXRpY0V2ZW50LnR5cGUgPSAnc2VsZWN0JztcbiAgICBzeW50aGV0aWNFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50O1xuXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHN5bnRoZXRpY0V2ZW50KTtcblxuICAgIHJldHVybiBzeW50aGV0aWNFdmVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIGlmICghaGFzTGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIC8vIFRyYWNrIHRoZSBpbnB1dCBub2RlIHRoYXQgaGFzIGZvY3VzLlxuICAgICAgY2FzZSAndG9wRm9jdXMnOlxuICAgICAgICBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpIHx8IHRhcmdldE5vZGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gICAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgICAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZy4gVGhpcyBtYXRjaGVzIHRoZVxuICAgICAgLy8gc2VtYW50aWNzIG9mIHRoZSBuYXRpdmUgc2VsZWN0IGV2ZW50LlxuICAgICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDb250ZXh0TWVudSc6XG4gICAgICBjYXNlICd0b3BNb3VzZVVwJzpcbiAgICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XG4gICAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAgIC8vXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG4gICAgICBjYXNlICd0b3BTZWxlY3Rpb25DaGFuZ2UnOlxuICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICBkaWRQdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvblNlbGVjdCcpIHtcbiAgICAgIGhhc0xpc3RlbmVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0RXZlbnRQbHVnaW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1hbmltYXRpb25zLyNBbmltYXRpb25FdmVudC1pbnRlcmZhY2VcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbkV2ZW50XG4gKi9cbnZhciBBbmltYXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgYW5pbWF0aW9uTmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNBbmltYXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNBbmltYXRpb25FdmVudCwgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50LCBDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEZvY3VzRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRm9jdXNFdmVudEludGVyZmFjZSA9IHtcbiAgcmVsYXRlZFRhcmdldDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRm9jdXNFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRm9jdXNFdmVudCwgRm9jdXNFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRm9jdXNFdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5cbmZ1bmN0aW9uIGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGNoYXJDb2RlO1xuICB2YXIga2V5Q29kZSA9IG5hdGl2ZUV2ZW50LmtleUNvZGU7XG5cbiAgaWYgKCdjaGFyQ29kZScgaW4gbmF0aXZlRXZlbnQpIHtcbiAgICBjaGFyQ29kZSA9IG5hdGl2ZUV2ZW50LmNoYXJDb2RlO1xuXG4gICAgLy8gRkYgZG9lcyBub3Qgc2V0IGBjaGFyQ29kZWAgZm9yIHRoZSBFbnRlci1rZXksIGNoZWNrIGFnYWluc3QgYGtleUNvZGVgLlxuICAgIGlmIChjaGFyQ29kZSA9PT0gMCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgY2hhckNvZGUgPSAxMztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBgY2hhckNvZGVgLCBidXQgYGtleUNvZGVgIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICBjaGFyQ29kZSA9IGtleUNvZGU7XG4gIH1cblxuICAvLyBTb21lIG5vbi1wcmludGFibGUga2V5cyBhcmUgcmVwb3J0ZWQgaW4gYGNoYXJDb2RlYC9ga2V5Q29kZWAsIGRpc2NhcmQgdGhlbS5cbiAgLy8gTXVzdCBub3QgZGlzY2FyZCB0aGUgKG5vbi0pcHJpbnRhYmxlIEVudGVyLWtleS5cbiAgaWYgKGNoYXJDb2RlID49IDMyIHx8IGNoYXJDb2RlID09PSAxMykge1xuICAgIHJldHVybiBjaGFyQ29kZTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50Q2hhckNvZGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICAnRXNjJzogJ0VzY2FwZScsXG4gICdTcGFjZWJhcic6ICcgJyxcbiAgJ0xlZnQnOiAnQXJyb3dMZWZ0JyxcbiAgJ1VwJzogJ0Fycm93VXAnLFxuICAnUmlnaHQnOiAnQXJyb3dSaWdodCcsXG4gICdEb3duJzogJ0Fycm93RG93bicsXG4gICdEZWwnOiAnRGVsZXRlJyxcbiAgJ1dpbic6ICdPUycsXG4gICdNZW51JzogJ0NvbnRleHRNZW51JyxcbiAgJ0FwcHMnOiAnQ29udGV4dE1lbnUnLFxuICAnU2Nyb2xsJzogJ1Njcm9sbExvY2snLFxuICAnTW96UHJpbnRhYmxlS2V5JzogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gIDg6ICdCYWNrc3BhY2UnLFxuICA5OiAnVGFiJyxcbiAgMTI6ICdDbGVhcicsXG4gIDEzOiAnRW50ZXInLFxuICAxNjogJ1NoaWZ0JyxcbiAgMTc6ICdDb250cm9sJyxcbiAgMTg6ICdBbHQnLFxuICAxOTogJ1BhdXNlJyxcbiAgMjA6ICdDYXBzTG9jaycsXG4gIDI3OiAnRXNjYXBlJyxcbiAgMzI6ICcgJyxcbiAgMzM6ICdQYWdlVXAnLFxuICAzNDogJ1BhZ2VEb3duJyxcbiAgMzU6ICdFbmQnLFxuICAzNjogJ0hvbWUnLFxuICAzNzogJ0Fycm93TGVmdCcsXG4gIDM4OiAnQXJyb3dVcCcsXG4gIDM5OiAnQXJyb3dSaWdodCcsXG4gIDQwOiAnQXJyb3dEb3duJyxcbiAgNDU6ICdJbnNlcnQnLFxuICA0NjogJ0RlbGV0ZScsXG4gIDExMjogJ0YxJywgMTEzOiAnRjInLCAxMTQ6ICdGMycsIDExNTogJ0Y0JywgMTE2OiAnRjUnLCAxMTc6ICdGNicsXG4gIDExODogJ0Y3JywgMTE5OiAnRjgnLCAxMjA6ICdGOScsIDEyMTogJ0YxMCcsIDEyMjogJ0YxMScsIDEyMzogJ0YxMicsXG4gIDE0NDogJ051bUxvY2snLFxuICAxNDU6ICdTY3JvbGxMb2NrJyxcbiAgMjI0OiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudEtleTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xudmFyIGdldEV2ZW50S2V5ID0gcmVxdWlyZSgnLi9nZXRFdmVudEtleScpO1xudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBLZXlib2FyZEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGtleTogZ2V0RXZlbnRLZXksXG4gIGxvY2F0aW9uOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICByZXBlYXQ6IG51bGwsXG4gIGxvY2FsZTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICAvLyBMZWdhY3kgSW50ZXJmYWNlXG4gIGNoYXJDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgY2hhckNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlQcmVzcyBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgYWN0dWFsIHByaW50YWJsZSBjaGFyYWN0ZXIuXG5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAga2V5Q29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGtleUNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlEb3duL1VwIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHBoeXNpY2FsIGtleWJvYXJkIGtleS5cblxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICB3aGljaDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYHdoaWNoYCBpcyBhbiBhbGlhcyBmb3IgZWl0aGVyIGBrZXlDb2RlYCBvciBgY2hhckNvZGVgIGRlcGVuZGluZyBvbiB0aGVcbiAgICAvLyB0eXBlIG9mIHRoZSBldmVudC5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljS2V5Ym9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljS2V5Ym9hcmRFdmVudCwgS2V5Ym9hcmRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRHJhZ0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIERyYWdFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YVRyYW5zZmVyOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNEcmFnRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0RyYWdFdmVudCwgRHJhZ0V2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNEcmFnRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RvdWNoRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1jc3MzLXRyYW5zaXRpb25zLTIwMDkwMzIwLyN0cmFuc2l0aW9uLWV2ZW50cy1cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zaXRpb25FdmVudFxuICovXG52YXIgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBwcm9wZXJ0eU5hbWU6IG51bGwsXG4gIGVsYXBzZWRUaW1lOiBudWxsLFxuICBwc2V1ZG9FbGVtZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCwgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgV2hlZWxFdmVudEludGVyZmFjZSA9IHtcbiAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMDtcbiAgfSxcbiAgZGVsdGFaOiBudWxsLFxuXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNXaGVlbEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNXaGVlbEV2ZW50LCBXaGVlbEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNXaGVlbEV2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgU3ludGhldGljQW5pbWF0aW9uRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0FuaW1hdGlvbkV2ZW50Jyk7XG52YXIgU3ludGhldGljQ2xpcGJvYXJkRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50Jyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG52YXIgU3ludGhldGljRm9jdXNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRm9jdXNFdmVudCcpO1xudmFyIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQnKTtcbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNNb3VzZUV2ZW50Jyk7XG52YXIgU3ludGhldGljRHJhZ0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNEcmFnRXZlbnQnKTtcbnZhciBTeW50aGV0aWNUb3VjaEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNUb3VjaEV2ZW50Jyk7XG52YXIgU3ludGhldGljVHJhbnNpdGlvbkV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQnKTtcbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG52YXIgU3ludGhldGljV2hlZWxFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljV2hlZWxFdmVudCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogVHVybnNcbiAqIFsnYWJvcnQnLCAuLi5dXG4gKiBpbnRvXG4gKiBldmVudFR5cGVzID0ge1xuICogICAnYWJvcnQnOiB7XG4gKiAgICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAqICAgICAgIGJ1YmJsZWQ6ICdvbkFib3J0JyxcbiAqICAgICAgIGNhcHR1cmVkOiAnb25BYm9ydENhcHR1cmUnLFxuICogICAgIH0sXG4gKiAgICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEFib3J0J10sXG4gKiAgIH0sXG4gKiAgIC4uLlxuICogfTtcbiAqIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyA9IHtcbiAqICAgJ3RvcEFib3J0JzogeyBzYW1lQ29uZmlnIH1cbiAqIH07XG4gKi9cbnZhciBldmVudFR5cGVzID0ge307XG52YXIgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge307XG5bJ2Fib3J0JywgJ2FuaW1hdGlvbkVuZCcsICdhbmltYXRpb25JdGVyYXRpb24nLCAnYW5pbWF0aW9uU3RhcnQnLCAnYmx1cicsICdjYW5QbGF5JywgJ2NhblBsYXlUaHJvdWdoJywgJ2NsaWNrJywgJ2NvbnRleHRNZW51JywgJ2NvcHknLCAnY3V0JywgJ2RvdWJsZUNsaWNrJywgJ2RyYWcnLCAnZHJhZ0VuZCcsICdkcmFnRW50ZXInLCAnZHJhZ0V4aXQnLCAnZHJhZ0xlYXZlJywgJ2RyYWdPdmVyJywgJ2RyYWdTdGFydCcsICdkcm9wJywgJ2R1cmF0aW9uQ2hhbmdlJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2ZvY3VzJywgJ2lucHV0JywgJ2ludmFsaWQnLCAna2V5RG93bicsICdrZXlQcmVzcycsICdrZXlVcCcsICdsb2FkJywgJ2xvYWRlZERhdGEnLCAnbG9hZGVkTWV0YWRhdGEnLCAnbG9hZFN0YXJ0JywgJ21vdXNlRG93bicsICdtb3VzZU1vdmUnLCAnbW91c2VPdXQnLCAnbW91c2VPdmVyJywgJ21vdXNlVXAnLCAncGFzdGUnLCAncGF1c2UnLCAncGxheScsICdwbGF5aW5nJywgJ3Byb2dyZXNzJywgJ3JhdGVDaGFuZ2UnLCAncmVzZXQnLCAnc2Nyb2xsJywgJ3NlZWtlZCcsICdzZWVraW5nJywgJ3N0YWxsZWQnLCAnc3VibWl0JywgJ3N1c3BlbmQnLCAndGltZVVwZGF0ZScsICd0b3VjaENhbmNlbCcsICd0b3VjaEVuZCcsICd0b3VjaE1vdmUnLCAndG91Y2hTdGFydCcsICd0cmFuc2l0aW9uRW5kJywgJ3ZvbHVtZUNoYW5nZScsICd3YWl0aW5nJywgJ3doZWVsJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIGNhcGl0YWxpemVkRXZlbnQgPSBldmVudFswXS50b1VwcGVyQ2FzZSgpICsgZXZlbnQuc2xpY2UoMSk7XG4gIHZhciBvbkV2ZW50ID0gJ29uJyArIGNhcGl0YWxpemVkRXZlbnQ7XG4gIHZhciB0b3BFdmVudCA9ICd0b3AnICsgY2FwaXRhbGl6ZWRFdmVudDtcblxuICB2YXIgdHlwZSA9IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogb25FdmVudCxcbiAgICAgIGNhcHR1cmVkOiBvbkV2ZW50ICsgJ0NhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BFdmVudF1cbiAgfTtcbiAgZXZlbnRUeXBlc1tldmVudF0gPSB0eXBlO1xuICB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wRXZlbnRdID0gdHlwZTtcbn0pO1xuXG52YXIgb25DbGlja0xpc3RlbmVycyA9IHt9O1xuXG5mdW5jdGlvbiBnZXREaWN0aW9uYXJ5S2V5KGluc3QpIHtcbiAgLy8gUHJldmVudHMgVjggcGVyZm9ybWFuY2UgaXNzdWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcbiAgcmV0dXJuICcuJyArIGluc3QuX3Jvb3ROb2RlSUQ7XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJhY3RpdmUodGFnKSB7XG4gIHJldHVybiB0YWcgPT09ICdidXR0b24nIHx8IHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICdzZWxlY3QnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJztcbn1cblxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcExldmVsVHlwZV07XG4gICAgaWYgKCFkaXNwYXRjaENvbmZpZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBFdmVudENvbnN0cnVjdG9yO1xuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICBjYXNlICd0b3BBYm9ydCc6XG4gICAgICBjYXNlICd0b3BDYW5QbGF5JzpcbiAgICAgIGNhc2UgJ3RvcENhblBsYXlUaHJvdWdoJzpcbiAgICAgIGNhc2UgJ3RvcER1cmF0aW9uQ2hhbmdlJzpcbiAgICAgIGNhc2UgJ3RvcEVtcHRpZWQnOlxuICAgICAgY2FzZSAndG9wRW5jcnlwdGVkJzpcbiAgICAgIGNhc2UgJ3RvcEVuZGVkJzpcbiAgICAgIGNhc2UgJ3RvcEVycm9yJzpcbiAgICAgIGNhc2UgJ3RvcElucHV0JzpcbiAgICAgIGNhc2UgJ3RvcEludmFsaWQnOlxuICAgICAgY2FzZSAndG9wTG9hZCc6XG4gICAgICBjYXNlICd0b3BMb2FkZWREYXRhJzpcbiAgICAgIGNhc2UgJ3RvcExvYWRlZE1ldGFkYXRhJzpcbiAgICAgIGNhc2UgJ3RvcExvYWRTdGFydCc6XG4gICAgICBjYXNlICd0b3BQYXVzZSc6XG4gICAgICBjYXNlICd0b3BQbGF5JzpcbiAgICAgIGNhc2UgJ3RvcFBsYXlpbmcnOlxuICAgICAgY2FzZSAndG9wUHJvZ3Jlc3MnOlxuICAgICAgY2FzZSAndG9wUmF0ZUNoYW5nZSc6XG4gICAgICBjYXNlICd0b3BSZXNldCc6XG4gICAgICBjYXNlICd0b3BTZWVrZWQnOlxuICAgICAgY2FzZSAndG9wU2Vla2luZyc6XG4gICAgICBjYXNlICd0b3BTdGFsbGVkJzpcbiAgICAgIGNhc2UgJ3RvcFN1Ym1pdCc6XG4gICAgICBjYXNlICd0b3BTdXNwZW5kJzpcbiAgICAgIGNhc2UgJ3RvcFRpbWVVcGRhdGUnOlxuICAgICAgY2FzZSAndG9wVm9sdW1lQ2hhbmdlJzpcbiAgICAgIGNhc2UgJ3RvcFdhaXRpbmcnOlxuICAgICAgICAvLyBIVE1MIEV2ZW50c1xuICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZGV4Lmh0bWwjZXZlbnRzLTBcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgICAgLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy4gRW50ZXIgaXMgaG93ZXZlciBib3RoIHByaW50YWJsZSBhbmRcbiAgICAgICAgLy8gbm9uLXByaW50YWJsZS4gT25lIHdvdWxkIGV4cGVjdCBUYWIgdG8gYmUgYXMgd2VsbCAoYnV0IGl0IGlzbid0KS5cbiAgICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgIGNhc2UgJ3RvcEZvY3VzJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ2xpY2snOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcbiAgICAgICAgLy8gdW53YW50ZWQgY2xpY2sgZXZlbnRzLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcERvdWJsZUNsaWNrJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICBjYXNlICd0b3BNb3VzZU1vdmUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAvLyBUT0RPOiBEaXNhYmxlZCBlbGVtZW50cyBzaG91bGQgbm90IHJlc3BvbmQgdG8gbW91c2UgZXZlbnRzXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BNb3VzZU91dCc6XG4gICAgICBjYXNlICd0b3BNb3VzZU92ZXInOlxuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljTW91c2VFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BEcmFnJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFbmQnOlxuICAgICAgY2FzZSAndG9wRHJhZ0VudGVyJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFeGl0JzpcbiAgICAgIGNhc2UgJ3RvcERyYWdMZWF2ZSc6XG4gICAgICBjYXNlICd0b3BEcmFnT3Zlcic6XG4gICAgICBjYXNlICd0b3BEcmFnU3RhcnQnOlxuICAgICAgY2FzZSAndG9wRHJvcCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wVG91Y2hDYW5jZWwnOlxuICAgICAgY2FzZSAndG9wVG91Y2hFbmQnOlxuICAgICAgY2FzZSAndG9wVG91Y2hNb3ZlJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoU3RhcnQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVG91Y2hFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25FbmQnOlxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uSXRlcmF0aW9uJzpcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvblN0YXJ0JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFRyYW5zaXRpb25FbmQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFNjcm9sbCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFdoZWVsJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ29weSc6XG4gICAgICBjYXNlICd0b3BDdXQnOlxuICAgICAgY2FzZSAndG9wUGFzdGUnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAhRXZlbnRDb25zdHJ1Y3RvciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTaW1wbGVFdmVudFBsdWdpbjogVW5oYW5kbGVkIGV2ZW50IHR5cGUsIGAlc2AuJywgdG9wTGV2ZWxUeXBlKSA6IF9wcm9kSW52YXJpYW50KCc4NicsIHRvcExldmVsVHlwZSkgOiB2b2lkIDA7XG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIC8vIE1vYmlsZSBTYWZhcmkgZG9lcyBub3QgZmlyZSBwcm9wZXJseSBidWJibGUgY2xpY2sgZXZlbnRzIG9uXG4gICAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAgIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgICAvLyBsaXN0ZW5lciBvbiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uQ2xpY2snICYmICFpc0ludGVyYWN0aXZlKGluc3QuX3RhZykpIHtcbiAgICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICAgIGlmICghb25DbGlja0xpc3RlbmVyc1trZXldKSB7XG4gICAgICAgIG9uQ2xpY2tMaXN0ZW5lcnNba2V5XSA9IEV2ZW50TGlzdGVuZXIubGlzdGVuKG5vZGUsICdjbGljaycsIGVtcHR5RnVuY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB3aWxsRGVsZXRlTGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvbkNsaWNrJyAmJiAhaXNJbnRlcmFjdGl2ZShpbnN0Ll90YWcpKSB7XG4gICAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICAgIG9uQ2xpY2tMaXN0ZW5lcnNba2V5XS5yZW1vdmUoKTtcbiAgICAgIGRlbGV0ZSBvbkNsaWNrTGlzdGVuZXJzW2tleV07XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2ltcGxlRXZlbnRQbHVnaW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEFSSUFET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vQVJJQURPTVByb3BlcnR5Q29uZmlnJyk7XG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vQmVmb3JlSW5wdXRFdmVudFBsdWdpbicpO1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9DaGFuZ2VFdmVudFBsdWdpbicpO1xudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gcmVxdWlyZSgnLi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlcicpO1xudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vRW50ZXJMZWF2ZUV2ZW50UGx1Z2luJyk7XG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0gcmVxdWlyZSgnLi9IVE1MRE9NUHJvcGVydHlDb25maWcnKTtcbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnQnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NRW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NRW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdERPTVRyZWVUcmF2ZXJzYWwgPSByZXF1aXJlKCcuL1JlYWN0RE9NVHJlZVRyYXZlcnNhbCcpO1xudmFyIFJlYWN0RE9NVGV4dENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01UZXh0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneScpO1xudmFyIFJlYWN0RXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJy4vUmVhY3RFdmVudExpc3RlbmVyJyk7XG52YXIgUmVhY3RJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbicpO1xudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0gcmVxdWlyZSgnLi9TVkdET01Qcm9wZXJ0eUNvbmZpZycpO1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9TZWxlY3RFdmVudFBsdWdpbicpO1xudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0gcmVxdWlyZSgnLi9TaW1wbGVFdmVudFBsdWdpbicpO1xuXG52YXIgYWxyZWFkeUluamVjdGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGluamVjdCgpIHtcbiAgaWYgKGFscmVhZHlJbmplY3RlZCkge1xuICAgIC8vIFRPRE86IFRoaXMgaXMgY3VycmVudGx5IHRydWUgYmVjYXVzZSB0aGVzZSBpbmplY3Rpb25zIGFyZSBzaGFyZWQgYmV0d2VlblxuICAgIC8vIHRoZSBjbGllbnQgYW5kIHRoZSBzZXJ2ZXIgcGFja2FnZS4gVGhleSBzaG91bGQgYmUgYnVpbHQgaW5kZXBlbmRlbnRseVxuICAgIC8vIGFuZCBub3Qgc2hhcmUgYW55IGluamVjdGlvbiBzdGF0ZS4gVGhlbiB0aGlzIHByb2JsZW0gd2lsbCBiZSBzb2x2ZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIGFscmVhZHlJbmplY3RlZCA9IHRydWU7XG5cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRFbWl0dGVyLmluamVjdFJlYWN0RXZlbnRMaXN0ZW5lcihSZWFjdEV2ZW50TGlzdGVuZXIpO1xuXG4gIC8qKlxuICAgKiBJbmplY3QgbW9kdWxlcyBmb3IgcmVzb2x2aW5nIERPTSBoaWVyYXJjaHkgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAgICovXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIpO1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpblV0aWxzLmluamVjdENvbXBvbmVudFRyZWUoUmVhY3RET01Db21wb25lbnRUcmVlKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5VdGlscy5pbmplY3RUcmVlVHJhdmVyc2FsKFJlYWN0RE9NVHJlZVRyYXZlcnNhbCk7XG5cbiAgLyoqXG4gICAqIFNvbWUgaW1wb3J0YW50IGV2ZW50IHBsdWdpbnMgaW5jbHVkZWQgYnkgZGVmYXVsdCAod2l0aG91dCBoYXZpbmcgdG8gcmVxdWlyZVxuICAgKiB0aGVtKS5cbiAgICovXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSh7XG4gICAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICAgIEVudGVyTGVhdmVFdmVudFBsdWdpbjogRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLFxuICAgIENoYW5nZUV2ZW50UGx1Z2luOiBDaGFuZ2VFdmVudFBsdWdpbixcbiAgICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gICAgQmVmb3JlSW5wdXRFdmVudFBsdWdpbjogQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuICB9KTtcblxuICBSZWFjdEluamVjdGlvbi5Ib3N0Q29tcG9uZW50LmluamVjdEdlbmVyaWNDb21wb25lbnRDbGFzcyhSZWFjdERPTUNvbXBvbmVudCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uSG9zdENvbXBvbmVudC5pbmplY3RUZXh0Q29tcG9uZW50Q2xhc3MoUmVhY3RET01UZXh0Q29tcG9uZW50KTtcblxuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhBUklBRE9NUHJvcGVydHlDb25maWcpO1xuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhIVE1MRE9NUHJvcGVydHlDb25maWcpO1xuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhTVkdET01Qcm9wZXJ0eUNvbmZpZyk7XG5cbiAgUmVhY3RJbmplY3Rpb24uRW1wdHlDb21wb25lbnQuaW5qZWN0RW1wdHlDb21wb25lbnRGYWN0b3J5KGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICAgIHJldHVybiBuZXcgUmVhY3RET01FbXB0eUNvbXBvbmVudChpbnN0YW50aWF0ZSk7XG4gIH0pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5KTtcblxuICBSZWFjdEluamVjdGlvbi5Db21wb25lbnQuaW5qZWN0RW52aXJvbm1lbnQoUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5qZWN0OiBpbmplY3Rcbn07IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG5cbnZhciBET0NfTk9ERV9UWVBFID0gOTtcblxuZnVuY3Rpb24gUmVhY3RET01Db250YWluZXJJbmZvKHRvcExldmVsV3JhcHBlciwgbm9kZSkge1xuICB2YXIgaW5mbyA9IHtcbiAgICBfdG9wTGV2ZWxXcmFwcGVyOiB0b3BMZXZlbFdyYXBwZXIsXG4gICAgX2lkQ291bnRlcjogMSxcbiAgICBfb3duZXJEb2N1bWVudDogbm9kZSA/IG5vZGUubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUgPyBub2RlIDogbm9kZS5vd25lckRvY3VtZW50IDogbnVsbCxcbiAgICBfbm9kZTogbm9kZSxcbiAgICBfdGFnOiBub2RlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIDogbnVsbCxcbiAgICBfbmFtZXNwYWNlVVJJOiBub2RlID8gbm9kZS5uYW1lc3BhY2VVUkkgOiBudWxsXG4gIH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaW5mby5fYW5jZXN0b3JJbmZvID0gbm9kZSA/IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIGluZm8uX3RhZywgbnVsbCkgOiBudWxsO1xuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29udGFpbmVySW5mbzsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSB7XG4gIHVzZUNyZWF0ZUVsZW1lbnQ6IHRydWUsXG4gIHVzZUZpYmVyOiBmYWxzZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUZlYXR1cmVGbGFnczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBNT0QgPSA2NTUyMTtcblxuLy8gYWRsZXIzMiBpcyBub3QgY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nLCBhbmQgaXMgb25seSB1c2VkIHRvIHNhbml0eSBjaGVjayB0aGF0XG4vLyBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSBzZXJ2ZXIgbWF0Y2hlcyB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgY2xpZW50LlxuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiAoYSBtb2RpZmllZCB2ZXJzaW9uIG9mIHRoZSBTaGVldEpTIHZlcnNpb24pIGhhcyBiZWVuIG9wdGltaXplZFxuLy8gZm9yIG91ciB1c2UgY2FzZSwgYXQgdGhlIGV4cGVuc2Ugb2YgY29uZm9ybWluZyB0byB0aGUgYWRsZXIzMiBzcGVjaWZpY2F0aW9uXG4vLyBmb3Igbm9uLWFzY2lpIGlucHV0cy5cbmZ1bmN0aW9uIGFkbGVyMzIoZGF0YSkge1xuICB2YXIgYSA9IDE7XG4gIHZhciBiID0gMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGRhdGEubGVuZ3RoO1xuICB2YXIgbSA9IGwgJiB+MHgzO1xuICB3aGlsZSAoaSA8IG0pIHtcbiAgICB2YXIgbiA9IE1hdGgubWluKGkgKyA0MDk2LCBtKTtcbiAgICBmb3IgKDsgaSA8IG47IGkgKz0gNCkge1xuICAgICAgYiArPSAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSkpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAxKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDIpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMykpO1xuICAgIH1cbiAgICBhICU9IE1PRDtcbiAgICBiICU9IE1PRDtcbiAgfVxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGIgKz0gYSArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgYSAlPSBNT0Q7XG4gIGIgJT0gTU9EO1xuICByZXR1cm4gYSB8IGIgPDwgMTY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xuXG52YXIgVEFHX0VORCA9IC9cXC8/Pi87XG52YXIgQ09NTUVOVF9TVEFSVCA9IC9ePFxcIVxcLVxcLS87XG5cbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0ge1xuICBDSEVDS1NVTV9BVFRSX05BTUU6ICdkYXRhLXJlYWN0LWNoZWNrc3VtJyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgc3RyaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZyB3aXRoIGNoZWNrc3VtIGF0dHJpYnV0ZSBhdHRhY2hlZFxuICAgKi9cbiAgYWRkQ2hlY2tzdW1Ub01hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgIHZhciBjaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcblxuICAgIC8vIEFkZCBjaGVja3N1bSAoaGFuZGxlIGJvdGggcGFyZW50IHRhZ3MsIGNvbW1lbnRzIGFuZCBzZWxmLWNsb3NpbmcgdGFncylcbiAgICBpZiAoQ09NTUVOVF9TVEFSVC50ZXN0KG1hcmt1cCkpIHtcbiAgICAgIHJldHVybiBtYXJrdXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtYXJrdXAucmVwbGFjZShUQUdfRU5ELCAnICcgKyBSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSArICc9XCInICsgY2hlY2tzdW0gKyAnXCIkJicpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCB0byB1c2VcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHJvb3QgUmVhY3QgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBvciBub3QgdGhlIG1hcmt1cCBpcyB0aGUgc2FtZVxuICAgKi9cbiAgY2FuUmV1c2VNYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXAsIGVsZW1lbnQpIHtcbiAgICB2YXIgZXhpc3RpbmdDaGVja3N1bSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcbiAgICBleGlzdGluZ0NoZWNrc3VtID0gZXhpc3RpbmdDaGVja3N1bSAmJiBwYXJzZUludChleGlzdGluZ0NoZWNrc3VtLCAxMCk7XG4gICAgdmFyIG1hcmt1cENoZWNrc3VtID0gYWRsZXIzMihtYXJrdXApO1xuICAgIHJldHVybiBtYXJrdXBDaGVja3N1bSA9PT0gZXhpc3RpbmdDaGVja3N1bTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1hcmt1cENoZWNrc3VtOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdCcpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NQ29udGFpbmVySW5mbyA9IHJlcXVpcmUoJy4vUmVhY3RET01Db250YWluZXJJbmZvJyk7XG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RGZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSByZXF1aXJlKCcuL1JlYWN0TWFya3VwQ2hlY2tzdW0nKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBBVFRSX05BTUUgPSBET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRTtcbnZhciBST09UX0FUVFJfTkFNRSA9IERPTVByb3BlcnR5LlJPT1RfQVRUUklCVVRFX05BTUU7XG5cbnZhciBFTEVNRU5UX05PREVfVFlQRSA9IDE7XG52YXIgRE9DX05PREVfVFlQRSA9IDk7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFID0gMTE7XG5cbnZhciBpbnN0YW5jZXNCeVJlYWN0Um9vdElEID0ge307XG5cbi8qKlxuICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAqIHRoYXQncyBub3QgY29tbW9uIGJldHdlZW4gdGhlIHR3byBnaXZlbiBzdHJpbmdzLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgd2hlcmUgdGhlIHN0cmluZ3MgZGl2ZXJnZVxuICovXG5mdW5jdGlvbiBmaXJzdERpZmZlcmVuY2VJbmRleChzdHJpbmcxLCBzdHJpbmcyKSB7XG4gIHZhciBtaW5MZW4gPSBNYXRoLm1pbihzdHJpbmcxLmxlbmd0aCwgc3RyaW5nMi5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbkxlbjsgaSsrKSB7XG4gICAgaWYgKHN0cmluZzEuY2hhckF0KGkpICE9PSBzdHJpbmcyLmNoYXJBdChpKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJpbmcxLmxlbmd0aCA9PT0gc3RyaW5nMi5sZW5ndGggPyAtMSA6IG1pbkxlbjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NRG9jdW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0aGF0IG1heSBjb250YWluXG4gKiBhIFJlYWN0IGNvbXBvbmVudFxuICogQHJldHVybiB7Pyp9IERPTSBlbGVtZW50IHRoYXQgbWF5IGhhdmUgdGhlIHJlYWN0Um9vdCBJRCwgb3IgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcm5hbEdldElEKG5vZGUpIHtcbiAgLy8gSWYgbm9kZSBpcyBzb21ldGhpbmcgbGlrZSBhIHdpbmRvdywgZG9jdW1lbnQsIG9yIHRleHQgbm9kZSwgbm9uZSBvZlxuICAvLyB3aGljaCBzdXBwb3J0IGF0dHJpYnV0ZXMgb3IgYSAuZ2V0QXR0cmlidXRlIG1ldGhvZCwgZ3JhY2VmdWxseSByZXR1cm5cbiAgLy8gdGhlIGVtcHR5IHN0cmluZywgYXMgaWYgdGhlIGF0dHJpYnV0ZSB3ZXJlIG1pc3NpbmcuXG4gIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShBVFRSX05BTUUpIHx8ICcnO1xufVxuXG4vKipcbiAqIE1vdW50cyB0aGlzIGNvbXBvbmVudCBhbmQgaW5zZXJ0cyBpdCBpbnRvIHRoZSBET00uXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50SW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIG1vdW50LlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gbW91bnQgaW50by5cbiAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgSWYgdHJ1ZSwgZG8gbm90IGluc2VydCBtYXJrdXBcbiAqL1xuZnVuY3Rpb24gbW91bnRDb21wb25lbnRJbnRvTm9kZSh3cmFwcGVySW5zdGFuY2UsIGNvbnRhaW5lciwgdHJhbnNhY3Rpb24sIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gIHZhciBtYXJrZXJOYW1lO1xuICBpZiAoUmVhY3RGZWF0dXJlRmxhZ3MubG9nVG9wTGV2ZWxSZW5kZXJzKSB7XG4gICAgdmFyIHdyYXBwZWRFbGVtZW50ID0gd3JhcHBlckluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5wcm9wcy5jaGlsZDtcbiAgICB2YXIgdHlwZSA9IHdyYXBwZWRFbGVtZW50LnR5cGU7XG4gICAgbWFya2VyTmFtZSA9ICdSZWFjdCBtb3VudDogJyArICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlIDogdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUpO1xuICAgIGNvbnNvbGUudGltZShtYXJrZXJOYW1lKTtcbiAgfVxuXG4gIHZhciBtYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQod3JhcHBlckluc3RhbmNlLCB0cmFuc2FjdGlvbiwgbnVsbCwgUmVhY3RET01Db250YWluZXJJbmZvKHdyYXBwZXJJbnN0YW5jZSwgY29udGFpbmVyKSwgY29udGV4dCwgMCAvKiBwYXJlbnREZWJ1Z0lEICovXG4gICk7XG5cbiAgaWYgKG1hcmtlck5hbWUpIHtcbiAgICBjb25zb2xlLnRpbWVFbmQobWFya2VyTmFtZSk7XG4gIH1cblxuICB3cmFwcGVySW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50Ll90b3BMZXZlbFdyYXBwZXIgPSB3cmFwcGVySW5zdGFuY2U7XG4gIFJlYWN0TW91bnQuX21vdW50SW1hZ2VJbnRvTm9kZShtYXJrdXAsIGNvbnRhaW5lciwgd3JhcHBlckluc3RhbmNlLCBzaG91bGRSZXVzZU1hcmt1cCwgdHJhbnNhY3Rpb24pO1xufVxuXG4vKipcbiAqIEJhdGNoZWQgbW91bnQuXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50SW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIG1vdW50LlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gbW91bnQgaW50by5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgSWYgdHJ1ZSwgZG8gbm90IGluc2VydCBtYXJrdXBcbiAqL1xuZnVuY3Rpb24gYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUoY29tcG9uZW50SW5zdGFuY2UsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKFxuICAvKiB1c2VDcmVhdGVFbGVtZW50ICovXG4gICFzaG91bGRSZXVzZU1hcmt1cCAmJiBSZWFjdERPTUZlYXR1cmVGbGFncy51c2VDcmVhdGVFbGVtZW50KTtcbiAgdHJhbnNhY3Rpb24ucGVyZm9ybShtb3VudENvbXBvbmVudEludG9Ob2RlLCBudWxsLCBjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyLCB0cmFuc2FjdGlvbiwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpO1xuICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbn1cblxuLyoqXG4gKiBVbm1vdW50cyBhIGNvbXBvbmVudCBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBET00uXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW5zdGFuY2UgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlLlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gdW5tb3VudCBmcm9tLlxuICogQGZpbmFsXG4gKiBAaW50ZXJuYWxcbiAqIEBzZWUge1JlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEZyb21Ob2RlKGluc3RhbmNlLCBjb250YWluZXIsIHNhZmVseSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2goKTtcbiAgfVxuICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChpbnN0YW5jZSwgc2FmZWx5KTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRGbHVzaCgpO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyBodHRwOi8vanNwZXJmLmNvbS9lbXB0eWluZy1hLW5vZGVcbiAgd2hpbGUgKGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmxhc3RDaGlsZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBoYXMgYSBkaXJlY3QgUmVhY3QtcmVuZGVyZWQgY2hpbGQgdGhhdCBpc1xuICogbm90IGEgUmVhY3Qgcm9vdCBlbGVtZW50LiBVc2VmdWwgZm9yIHdhcm5pbmcgaW4gYHJlbmRlcmAsXG4gKiBgdW5tb3VudENvbXBvbmVudEF0Tm9kZWAsIGV0Yy5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gZWxlbWVudCBjb250YWlucyBhIGRpcmVjdCBjaGlsZCB0aGF0IHdhc1xuICogcmVuZGVyZWQgYnkgUmVhY3QgYnV0IGlzIG5vdCBhIHJvb3QgZWxlbWVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICBpZiAocm9vdEVsKSB7XG4gICAgdmFyIGluc3QgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpO1xuICAgIHJldHVybiAhIShpbnN0ICYmIGluc3QuX2hvc3RQYXJlbnQpO1xuICB9XG59XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaXMgYSBSZWFjdCBET00gZWxlbWVudCBhbmRcbiAqIGl0IGhhcyBiZWVuIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaGFzIGJlZW4gcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0XG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gbm9kZUlzUmVuZGVyZWRCeU90aGVySW5zdGFuY2UoY29udGFpbmVyKSB7XG4gIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuICEhKHJvb3RFbCAmJiBpc1JlYWN0Tm9kZShyb290RWwpICYmICFSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpKTtcbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIG5vZGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBET00gbm9kZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpIHtcbiAgcmV0dXJuICEhKG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSk7XG59XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaXMgYSB2YWxpZCBSZWFjdCBub2RlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGlzIGEgdmFsaWQgUmVhY3QgRE9NIG5vZGUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNSZWFjdE5vZGUobm9kZSkge1xuICByZXR1cm4gaXNWYWxpZENvbnRhaW5lcihub2RlKSAmJiAobm9kZS5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSX05BTUUpIHx8IG5vZGUuaGFzQXR0cmlidXRlKEFUVFJfTkFNRSkpO1xufVxuXG5mdW5jdGlvbiBnZXRIb3N0Um9vdEluc3RhbmNlSW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgdmFyIHByZXZIb3N0SW5zdGFuY2UgPSByb290RWwgJiYgUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKTtcbiAgcmV0dXJuIHByZXZIb3N0SW5zdGFuY2UgJiYgIXByZXZIb3N0SW5zdGFuY2UuX2hvc3RQYXJlbnQgPyBwcmV2SG9zdEluc3RhbmNlIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VG9wTGV2ZWxXcmFwcGVySW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIHZhciByb290ID0gZ2V0SG9zdFJvb3RJbnN0YW5jZUluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiByb290ID8gcm9vdC5faG9zdENvbnRhaW5lckluZm8uX3RvcExldmVsV3JhcHBlciA6IG51bGw7XG59XG5cbi8qKlxuICogVGVtcG9yYXJ5ICg/KSBoYWNrIHNvIHRoYXQgd2UgY2FuIHN0b3JlIGFsbCB0b3AtbGV2ZWwgcGVuZGluZyB1cGRhdGVzIG9uXG4gKiBjb21wb3NpdGVzIGluc3RlYWQgb2YgaGF2aW5nIHRvIHdvcnJ5IGFib3V0IGRpZmZlcmVudCB0eXBlcyBvZiBjb21wb25lbnRzXG4gKiBoZXJlLlxuICovXG52YXIgdG9wTGV2ZWxSb290Q291bnRlciA9IDE7XG52YXIgVG9wTGV2ZWxXcmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJvb3RJRCA9IHRvcExldmVsUm9vdENvdW50ZXIrKztcbn07XG5Ub3BMZXZlbFdyYXBwZXIucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRvcExldmVsV3JhcHBlci5kaXNwbGF5TmFtZSA9ICdUb3BMZXZlbFdyYXBwZXInO1xufVxuVG9wTGV2ZWxXcmFwcGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnByb3BzLmNoaWxkO1xufTtcblRvcExldmVsV3JhcHBlci5pc1JlYWN0VG9wTGV2ZWxXcmFwcGVyID0gdHJ1ZTtcblxuLyoqXG4gKiBNb3VudGluZyBpcyB0aGUgcHJvY2VzcyBvZiBpbml0aWFsaXppbmcgYSBSZWFjdCBjb21wb25lbnQgYnkgY3JlYXRpbmcgaXRzXG4gKiByZXByZXNlbnRhdGl2ZSBET00gZWxlbWVudHMgYW5kIGluc2VydGluZyB0aGVtIGludG8gYSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAqIEFueSBwcmlvciBjb250ZW50IGluc2lkZSBgY29udGFpbmVyYCBpcyBkZXN0cm95ZWQgaW4gdGhlIHByb2Nlc3MuXG4gKlxuICogICBSZWFjdE1vdW50LnJlbmRlcihcbiAqICAgICBjb21wb25lbnQsXG4gKiAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpXG4gKiAgICk7XG4gKlxuICogICA8ZGl2IGlkPVwiY29udGFpbmVyXCI+ICAgICAgICAgICAgICAgICAgIDwtLSBTdXBwbGllZCBgY29udGFpbmVyYC5cbiAqICAgICA8ZGl2IGRhdGEtcmVhY3RpZD1cIi4zXCI+ICAgICAgICAgICAgICA8LS0gUmVuZGVyZWQgcmVhY3RSb290IG9mIFJlYWN0XG4gKiAgICAgICAvLyAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuXG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvZGl2PlxuICpcbiAqIEluc2lkZSBvZiBgY29udGFpbmVyYCwgdGhlIGZpcnN0IGVsZW1lbnQgcmVuZGVyZWQgaXMgdGhlIFwicmVhY3RSb290XCIuXG4gKi9cbnZhciBSZWFjdE1vdW50ID0ge1xuXG4gIFRvcExldmVsV3JhcHBlcjogVG9wTGV2ZWxXcmFwcGVyLFxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGRldnRvb2xzLiBUaGUga2V5cyBhcmUgbm90IGltcG9ydGFudC5cbiAgICovXG4gIF9pbnN0YW5jZXNCeVJlYWN0Um9vdElEOiBpbnN0YW5jZXNCeVJlYWN0Um9vdElELFxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgaG9vayBwcm92aWRlZCB0byBzdXBwb3J0IHJlbmRlcmluZyBSZWFjdCBjb21wb25lbnRzIHdoaWxlXG4gICAqIGVuc3VyaW5nIHRoYXQgdGhlIGFwcGFyZW50IHNjcm9sbCBwb3NpdGlvbiBvZiBpdHMgYGNvbnRhaW5lcmAgZG9lcyBub3RcbiAgICogY2hhbmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBUaGUgYGNvbnRhaW5lcmAgYmVpbmcgcmVuZGVyZWQgaW50by5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gcmVuZGVyQ2FsbGJhY2sgVGhpcyBtdXN0IGJlIGNhbGxlZCBvbmNlIHRvIGRvIHRoZSByZW5kZXIuXG4gICAqL1xuICBzY3JvbGxNb25pdG9yOiBmdW5jdGlvbiAoY29udGFpbmVyLCByZW5kZXJDYWxsYmFjaykge1xuICAgIHJlbmRlckNhbGxiYWNrKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRha2UgYSBjb21wb25lbnQgdGhhdCdzIGFscmVhZHkgbW91bnRlZCBpbnRvIHRoZSBET00gYW5kIHJlcGxhY2UgaXRzIHByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IHByZXZDb21wb25lbnQgY29tcG9uZW50IGluc3RhbmNlIGFscmVhZHkgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgY29tcG9uZW50IGluc3RhbmNlIHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqL1xuICBfdXBkYXRlUm9vdENvbXBvbmVudDogZnVuY3Rpb24gKHByZXZDb21wb25lbnQsIG5leHRFbGVtZW50LCBuZXh0Q29udGV4dCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIFJlYWN0TW91bnQuc2Nyb2xsTW9uaXRvcihjb250YWluZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbChwcmV2Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgbmV4dENvbnRleHQpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWwocHJldkNvbXBvbmVudCwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByZXZDb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIG5ldyBjb21wb25lbnQgaW50byB0aGUgRE9NLiBIb29rZWQgYnkgaG9va3MhXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBlbGVtZW50IHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBpZiB3ZSBzaG91bGQgc2tpcCB0aGUgbWFya3VwIGluc2VydGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gbmV4dENvbXBvbmVudFxuICAgKi9cbiAgX3JlbmRlck5ld1Jvb3RDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICAgIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAgIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAgIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICdfcmVuZGVyTmV3Um9vdENvbXBvbmVudCgpOiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgKyAnb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tICcgKyAncmVuZGVyIGlzIG5vdCBhbGxvd2VkLiBJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gJyArICdjb21wb25lbnREaWRVcGRhdGUuIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ19yZWdpc3RlckNvbXBvbmVudCguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM3JykgOiB2b2lkIDA7XG5cbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZW5zdXJlU2Nyb2xsVmFsdWVNb25pdG9yaW5nKCk7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0RWxlbWVudCwgZmFsc2UpO1xuXG4gICAgLy8gVGhlIGluaXRpYWwgcmVuZGVyIGlzIHN5bmNocm9ub3VzIGJ1dCBhbnkgdXBkYXRlcyB0aGF0IGhhcHBlbiBkdXJpbmdcbiAgICAvLyByZW5kZXJpbmcsIGluIGNvbXBvbmVudFdpbGxNb3VudCBvciBjb21wb25lbnREaWRNb3VudCwgd2lsbCBiZSBiYXRjaGVkXG4gICAgLy8gYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IGJhdGNoaW5nIHN0cmF0ZWd5LlxuXG4gICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKGJhdGNoZWRNb3VudENvbXBvbmVudEludG9Ob2RlLCBjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCk7XG5cbiAgICB2YXIgd3JhcHBlcklEID0gY29tcG9uZW50SW5zdGFuY2UuX2luc3RhbmNlLnJvb3RJRDtcbiAgICBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3dyYXBwZXJJRF0gPSBjb21wb25lbnRJbnN0YW5jZTtcblxuICAgIHJldHVybiBjb21wb25lbnRJbnN0YW5jZTtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVycyBhIFJlYWN0IGNvbXBvbmVudCBpbnRvIHRoZSBET00gaW4gdGhlIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICAgKlxuICAgKiBJZiB0aGUgUmVhY3QgY29tcG9uZW50IHdhcyBwcmV2aW91c2x5IHJlbmRlcmVkIGludG8gYGNvbnRhaW5lcmAsIHRoaXMgd2lsbFxuICAgKiBwZXJmb3JtIGFuIHVwZGF0ZSBvbiBpdCBhbmQgb25seSBtdXRhdGUgdGhlIERPTSBhcyBuZWNlc3NhcnkgdG8gcmVmbGVjdCB0aGVcbiAgICogbGF0ZXN0IFJlYWN0IGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gcGFyZW50Q29tcG9uZW50IFRoZSBjb25jZXB0dWFsIHBhcmVudCBvZiB0aGlzIHJlbmRlciB0cmVlLlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgQ29tcG9uZW50IGVsZW1lbnQgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBDb21wb25lbnQgaW5zdGFuY2UgcmVuZGVyZWQgaW4gYGNvbnRhaW5lcmAuXG4gICAqL1xuICByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAhKHBhcmVudENvbXBvbmVudCAhPSBudWxsICYmIFJlYWN0SW5zdGFuY2VNYXAuaGFzKHBhcmVudENvbXBvbmVudCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3BhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMzgnKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5fcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIFJlYWN0VXBkYXRlUXVldWUudmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjaywgJ1JlYWN0RE9NLnJlbmRlcicpO1xuICAgICFSZWFjdC5pc1ZhbGlkRWxlbWVudChuZXh0RWxlbWVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET00ucmVuZGVyKCk6IEludmFsaWQgY29tcG9uZW50IGVsZW1lbnQuJXMnLCB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdzdHJpbmcnID8gJyBJbnN0ZWFkIG9mIHBhc3NpbmcgYSBzdHJpbmcgbGlrZSBcXCdkaXZcXCcsIHBhc3MgJyArICdSZWFjdC5jcmVhdGVFbGVtZW50KFxcJ2RpdlxcJykgb3IgPGRpdiAvPi4nIDogdHlwZW9mIG5leHRFbGVtZW50ID09PSAnZnVuY3Rpb24nID8gJyBJbnN0ZWFkIG9mIHBhc3NpbmcgYSBjbGFzcyBsaWtlIEZvbywgcGFzcyAnICsgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9vKSBvciA8Rm9vIC8+LicgOlxuICAgIC8vIENoZWNrIGlmIGl0IHF1YWNrcyBsaWtlIGFuIGVsZW1lbnRcbiAgICBuZXh0RWxlbWVudCAhPSBudWxsICYmIG5leHRFbGVtZW50LnByb3BzICE9PSB1bmRlZmluZWQgPyAnIFRoaXMgbWF5IGJlIGNhdXNlZCBieSB1bmludGVudGlvbmFsbHkgbG9hZGluZyB0d28gaW5kZXBlbmRlbnQgJyArICdjb3BpZXMgb2YgUmVhY3QuJyA6ICcnKSA6IF9wcm9kSW52YXJpYW50KCczOScsIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ3N0cmluZycgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIHN0cmluZyBsaWtlIFxcJ2RpdlxcJywgcGFzcyAnICsgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoXFwnZGl2XFwnKSBvciA8ZGl2IC8+LicgOiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdmdW5jdGlvbicgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIGNsYXNzIGxpa2UgRm9vLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChGb28pIG9yIDxGb28gLz4uJyA6IG5leHRFbGVtZW50ICE9IG51bGwgJiYgbmV4dEVsZW1lbnQucHJvcHMgIT09IHVuZGVmaW5lZCA/ICcgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHVuaW50ZW50aW9uYWxseSBsb2FkaW5nIHR3byBpbmRlcGVuZGVudCAnICsgJ2NvcGllcyBvZiBSZWFjdC4nIDogJycpIDogdm9pZCAwO1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lciB8fCAhY29udGFpbmVyLnRhZ05hbWUgfHwgY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0JPRFknLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKSA6IHZvaWQgMDtcblxuICAgIHZhciBuZXh0V3JhcHBlZEVsZW1lbnQgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFRvcExldmVsV3JhcHBlciwgeyBjaGlsZDogbmV4dEVsZW1lbnQgfSk7XG5cbiAgICB2YXIgbmV4dENvbnRleHQ7XG4gICAgaWYgKHBhcmVudENvbXBvbmVudCkge1xuICAgICAgdmFyIHBhcmVudEluc3QgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwYXJlbnRDb21wb25lbnQpO1xuICAgICAgbmV4dENvbnRleHQgPSBwYXJlbnRJbnN0Ll9wcm9jZXNzQ2hpbGRDb250ZXh0KHBhcmVudEluc3QuX2NvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0Q29udGV4dCA9IGVtcHR5T2JqZWN0O1xuICAgIH1cblxuICAgIHZhciBwcmV2Q29tcG9uZW50ID0gZ2V0VG9wTGV2ZWxXcmFwcGVySW5Db250YWluZXIoY29udGFpbmVyKTtcblxuICAgIGlmIChwcmV2Q29tcG9uZW50KSB7XG4gICAgICB2YXIgcHJldldyYXBwZWRFbGVtZW50ID0gcHJldkNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB2YXIgcHJldkVsZW1lbnQgPSBwcmV2V3JhcHBlZEVsZW1lbnQucHJvcHMuY2hpbGQ7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSkge1xuICAgICAgICB2YXIgcHVibGljSW5zdCA9IHByZXZDb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgICAgIHZhciB1cGRhdGVkQ2FsbGJhY2sgPSBjYWxsYmFjayAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbChwdWJsaWNJbnN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVhY3RNb3VudC5fdXBkYXRlUm9vdENvbXBvbmVudChwcmV2Q29tcG9uZW50LCBuZXh0V3JhcHBlZEVsZW1lbnQsIG5leHRDb250ZXh0LCBjb250YWluZXIsIHVwZGF0ZWRDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBwdWJsaWNJbnN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlKGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlYWN0Um9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgY29udGFpbmVySGFzUmVhY3RNYXJrdXAgPSByZWFjdFJvb3RFbGVtZW50ICYmICEhaW50ZXJuYWxHZXRJRChyZWFjdFJvb3RFbGVtZW50KTtcbiAgICB2YXIgY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCwgJ3JlbmRlciguLi4pOiBSZXBsYWNpbmcgUmVhY3QtcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG5ldyByb290ICcgKyAnY29tcG9uZW50LiBJZiB5b3UgaW50ZW5kZWQgdG8gdXBkYXRlIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsICcgKyAneW91IHNob3VsZCBpbnN0ZWFkIGhhdmUgdGhlIGV4aXN0aW5nIGNoaWxkcmVuIHVwZGF0ZSB0aGVpciBzdGF0ZSAnICsgJ2FuZCByZW5kZXIgdGhlIG5ldyBjb21wb25lbnRzIGluc3RlYWQgb2YgY2FsbGluZyBSZWFjdERPTS5yZW5kZXIuJykgOiB2b2lkIDA7XG5cbiAgICAgIGlmICghY29udGFpbmVySGFzUmVhY3RNYXJrdXAgfHwgcmVhY3RSb290RWxlbWVudC5uZXh0U2libGluZykge1xuICAgICAgICB2YXIgcm9vdEVsZW1lbnRTaWJsaW5nID0gcmVhY3RSb290RWxlbWVudDtcbiAgICAgICAgd2hpbGUgKHJvb3RFbGVtZW50U2libGluZykge1xuICAgICAgICAgIGlmIChpbnRlcm5hbEdldElEKHJvb3RFbGVtZW50U2libGluZykpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvb3RFbGVtZW50U2libGluZyA9IHJvb3RFbGVtZW50U2libGluZy5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaG91bGRSZXVzZU1hcmt1cCA9IGNvbnRhaW5lckhhc1JlYWN0TWFya3VwICYmICFwcmV2Q29tcG9uZW50ICYmICFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZDtcbiAgICB2YXIgY29tcG9uZW50ID0gUmVhY3RNb3VudC5fcmVuZGVyTmV3Um9vdENvbXBvbmVudChuZXh0V3JhcHBlZEVsZW1lbnQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIG5leHRDb250ZXh0KS5fcmVuZGVyZWRDb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY29tcG9uZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVycyBhIFJlYWN0IGNvbXBvbmVudCBpbnRvIHRoZSBET00gaW4gdGhlIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3Rkb20ucmVuZGVyXG4gICAqXG4gICAqIElmIHRoZSBSZWFjdCBjb21wb25lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBgY29udGFpbmVyYCwgdGhpcyB3aWxsXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxuICAgKiBsYXRlc3QgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgQ29tcG9uZW50IGVsZW1lbnQgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBDb21wb25lbnQgaW5zdGFuY2UgcmVuZGVyZWQgaW4gYGNvbnRhaW5lcmAuXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBSZWFjdE1vdW50Ll9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubW91bnRzIGFuZCBkZXN0cm95cyB0aGUgUmVhY3QgY29tcG9uZW50IHJlbmRlcmVkIGluIHRoZSBgY29udGFpbmVyYC5cbiAgICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0ZG9tLnVubW91bnRjb21wb25lbnRhdG5vZGVcbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgY29udGFpbmluZyBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIGNvbXBvbmVudCB3YXMgZm91bmQgaW4gYW5kIHVubW91bnRlZCBmcm9tXG4gICAqICAgICAgICAgICAgICAgICAgIGBjb250YWluZXJgXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gICAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoU3RyaWN0bHkgc3BlYWtpbmcsIHVubW91bnRpbmcgd29uJ3QgY2F1c2UgYVxuICAgIC8vIHJlbmRlciBidXQgd2Ugc3RpbGwgZG9uJ3QgZXhwZWN0IHRvIGJlIGluIGEgcmVuZGVyIGNhbGwgaGVyZS4pXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgKyAnb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciAnICsgJ2lzIG5vdCBhbGxvd2VkLiBJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gJyArICdjb21wb25lbnREaWRVcGRhdGUuIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCc0MCcpIDogdm9pZCAwO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFub2RlSXNSZW5kZXJlZEJ5T3RoZXJJbnN0YW5jZShjb250YWluZXIpLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgJyArICd3YXMgcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBwcmV2Q29tcG9uZW50ID0gZ2V0VG9wTGV2ZWxXcmFwcGVySW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICBpZiAoIXByZXZDb21wb25lbnQpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBub2RlIGJlaW5nIHVubW91bnRlZCB3YXMgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCBpc24ndCBhXG4gICAgICAvLyByb290IG5vZGUuXG4gICAgICB2YXIgY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cbiAgICAgIHZhciBpc0NvbnRhaW5lclJlYWN0Um9vdCA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gMSAmJiBjb250YWluZXIuaGFzQXR0cmlidXRlKFJPT1RfQVRUUl9OQU1FKTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgJyArICd3YXMgcmVuZGVyZWQgYnkgUmVhY3QgYW5kIGlzIG5vdCBhIHRvcC1sZXZlbCBjb250YWluZXIuICVzJywgaXNDb250YWluZXJSZWFjdFJvb3QgPyAnWW91IG1heSBoYXZlIGFjY2lkZW50YWxseSBwYXNzZWQgaW4gYSBSZWFjdCByb290IG5vZGUgaW5zdGVhZCAnICsgJ29mIGl0cyBjb250YWluZXIuJyA6ICdJbnN0ZWFkLCBoYXZlIHRoZSBwYXJlbnQgY29tcG9uZW50IHVwZGF0ZSBpdHMgc3RhdGUgYW5kICcgKyAncmVyZW5kZXIgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50LicpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlbGV0ZSBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3ByZXZDb21wb25lbnQuX2luc3RhbmNlLnJvb3RJRF07XG4gICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKHVubW91bnRDb21wb25lbnRGcm9tTm9kZSwgcHJldkNvbXBvbmVudCwgY29udGFpbmVyLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgX21vdW50SW1hZ2VJbnRvTm9kZTogZnVuY3Rpb24gKG1hcmt1cCwgY29udGFpbmVyLCBpbnN0YW5jZSwgc2hvdWxkUmV1c2VNYXJrdXAsIHRyYW5zYWN0aW9uKSB7XG4gICAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtb3VudENvbXBvbmVudEludG9Ob2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IHZhbGlkLicpIDogX3Byb2RJbnZhcmlhbnQoJzQxJykgOiB2b2lkIDA7XG5cbiAgICBpZiAoc2hvdWxkUmV1c2VNYXJrdXApIHtcbiAgICAgIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgaWYgKFJlYWN0TWFya3VwQ2hlY2tzdW0uY2FuUmV1c2VNYXJrdXAobWFya3VwLCByb290RWxlbWVudCkpIHtcbiAgICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZShpbnN0YW5jZSwgcm9vdEVsZW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2hlY2tzdW0gPSByb290RWxlbWVudC5nZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuICAgICAgICByb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuXG4gICAgICAgIHZhciByb290TWFya3VwID0gcm9vdEVsZW1lbnQub3V0ZXJIVE1MO1xuICAgICAgICByb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUsIGNoZWNrc3VtKTtcblxuICAgICAgICB2YXIgbm9ybWFsaXplZE1hcmt1cCA9IG1hcmt1cDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAvLyBiZWNhdXNlIHJvb3RNYXJrdXAgaXMgcmV0cmlldmVkIGZyb20gdGhlIERPTSwgdmFyaW91cyBub3JtYWxpemF0aW9uc1xuICAgICAgICAgIC8vIHdpbGwgaGF2ZSBvY2N1cnJlZCB3aGljaCB3aWxsIG5vdCBiZSBwcmVzZW50IGluIGBtYXJrdXBgLiBIZXJlLFxuICAgICAgICAgIC8vIGluc2VydCBtYXJrdXAgaW50byBhIDxkaXY+IG9yIDxpZnJhbWU+IGRlcGVuZGluZyBvbiB0aGUgY29udGFpbmVyXG4gICAgICAgICAgLy8gdHlwZSB0byBwZXJmb3JtIHRoZSBzYW1lIG5vcm1hbGl6YXRpb25zIGJlZm9yZSBjb21wYXJpbmcuXG4gICAgICAgICAgdmFyIG5vcm1hbGl6ZXI7XG4gICAgICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIuaW5uZXJIVE1MID0gbWFya3VwO1xuICAgICAgICAgICAgbm9ybWFsaXplZE1hcmt1cCA9IG5vcm1hbGl6ZXIuaW5uZXJIVE1MO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub3JtYWxpemVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vcm1hbGl6ZXIpO1xuICAgICAgICAgICAgbm9ybWFsaXplci5jb250ZW50RG9jdW1lbnQud3JpdGUobWFya3VwKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRNYXJrdXAgPSBub3JtYWxpemVyLmNvbnRlbnREb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub3V0ZXJIVE1MO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChub3JtYWxpemVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlmZkluZGV4ID0gZmlyc3REaWZmZXJlbmNlSW5kZXgobm9ybWFsaXplZE1hcmt1cCwgcm9vdE1hcmt1cCk7XG4gICAgICAgIHZhciBkaWZmZXJlbmNlID0gJyAoY2xpZW50KSAnICsgbm9ybWFsaXplZE1hcmt1cC5zdWJzdHJpbmcoZGlmZkluZGV4IC0gMjAsIGRpZmZJbmRleCArIDIwKSArICdcXG4gKHNlcnZlcikgJyArIHJvb3RNYXJrdXAuc3Vic3RyaW5nKGRpZmZJbmRleCAtIDIwLCBkaWZmSW5kZXggKyAyMCk7XG5cbiAgICAgICAgIShjb250YWluZXIubm9kZVR5cGUgIT09IERPQ19OT0RFX1RZUEUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1lvdVxcJ3JlIHRyeWluZyB0byByZW5kZXIgYSBjb21wb25lbnQgdG8gdGhlIGRvY3VtZW50IHVzaW5nIHNlcnZlciByZW5kZXJpbmcgYnV0IHRoZSBjaGVja3N1bSB3YXMgaW52YWxpZC4gVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSByZW5kZXJlZCBhIGRpZmZlcmVudCBjb21wb25lbnQgdHlwZSBvciBwcm9wcyBvbiB0aGUgY2xpZW50IGZyb20gdGhlIG9uZSBvbiB0aGUgc2VydmVyLCBvciB5b3VyIHJlbmRlcigpIG1ldGhvZHMgYXJlIGltcHVyZS4gUmVhY3QgY2Fubm90IGhhbmRsZSB0aGlzIGNhc2UgZHVlIHRvIGNyb3NzLWJyb3dzZXIgcXVpcmtzIGJ5IHJlbmRlcmluZyBhdCB0aGUgZG9jdW1lbnQgcm9vdC4gWW91IHNob3VsZCBsb29rIGZvciBlbnZpcm9ubWVudCBkZXBlbmRlbnQgY29kZSBpbiB5b3VyIGNvbXBvbmVudHMgYW5kIGVuc3VyZSB0aGUgcHJvcHMgYXJlIHRoZSBzYW1lIGNsaWVudCBhbmQgc2VydmVyIHNpZGU6XFxuJXMnLCBkaWZmZXJlbmNlKSA6IF9wcm9kSW52YXJpYW50KCc0MicsIGRpZmZlcmVuY2UpIDogdm9pZCAwO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdCBhdHRlbXB0ZWQgdG8gcmV1c2UgbWFya3VwIGluIGEgY29udGFpbmVyIGJ1dCB0aGUgJyArICdjaGVja3N1bSB3YXMgaW52YWxpZC4gVGhpcyBnZW5lcmFsbHkgbWVhbnMgdGhhdCB5b3UgYXJlICcgKyAndXNpbmcgc2VydmVyIHJlbmRlcmluZyBhbmQgdGhlIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlICcgKyAnc2VydmVyIHdhcyBub3Qgd2hhdCB0aGUgY2xpZW50IHdhcyBleHBlY3RpbmcuIFJlYWN0IGluamVjdGVkICcgKyAnbmV3IG1hcmt1cCB0byBjb21wZW5zYXRlIHdoaWNoIHdvcmtzIGJ1dCB5b3UgaGF2ZSBsb3N0IG1hbnkgJyArICdvZiB0aGUgYmVuZWZpdHMgb2Ygc2VydmVyIHJlbmRlcmluZy4gSW5zdGVhZCwgZmlndXJlIG91dCAnICsgJ3doeSB0aGUgbWFya3VwIGJlaW5nIGdlbmVyYXRlZCBpcyBkaWZmZXJlbnQgb24gdGhlIGNsaWVudCAnICsgJ29yIHNlcnZlcjpcXG4lcycsIGRpZmZlcmVuY2UpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShjb250YWluZXIubm9kZVR5cGUgIT09IERPQ19OT0RFX1RZUEUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1lvdVxcJ3JlIHRyeWluZyB0byByZW5kZXIgYSBjb21wb25lbnQgdG8gdGhlIGRvY3VtZW50IGJ1dCB5b3UgZGlkblxcJ3QgdXNlIHNlcnZlciByZW5kZXJpbmcuIFdlIGNhblxcJ3QgZG8gdGhpcyB3aXRob3V0IHVzaW5nIHNlcnZlciByZW5kZXJpbmcgZHVlIHRvIGNyb3NzLWJyb3dzZXIgcXVpcmtzLiBTZWUgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKSBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IF9wcm9kSW52YXJpYW50KCc0MycpIDogdm9pZCAwO1xuXG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHdoaWxlIChjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIubGFzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIERPTUxhenlUcmVlLmluc2VydFRyZWVCZWZvcmUoY29udGFpbmVyLCBtYXJrdXAsIG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRJbm5lckhUTUwoY29udGFpbmVyLCBtYXJrdXApO1xuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZShpbnN0YW5jZSwgY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgaG9zdE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICBpZiAoaG9zdE5vZGUuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgaW5zdGFuY2VJRDogaG9zdE5vZGUuX2RlYnVnSUQsXG4gICAgICAgICAgdHlwZTogJ21vdW50JyxcbiAgICAgICAgICBwYXlsb2FkOiBtYXJrdXAudG9TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNb3VudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICcxNS40LjEnOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE5vZGVUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3ROb2RlVHlwZXMnKTtcblxuZnVuY3Rpb24gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCkge1xuICB2YXIgdHlwZTtcblxuICB3aGlsZSAoKHR5cGUgPSBpbnN0Ll9yZW5kZXJlZE5vZGVUeXBlKSA9PT0gUmVhY3ROb2RlVHlwZXMuQ09NUE9TSVRFKSB7XG4gICAgaW5zdCA9IGluc3QuX3JlbmRlcmVkQ29tcG9uZW50O1xuICB9XG5cbiAgaWYgKHR5cGUgPT09IFJlYWN0Tm9kZVR5cGVzLkhPU1QpIHtcbiAgICByZXR1cm4gaW5zdC5fcmVuZGVyZWRDb21wb25lbnQ7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gUmVhY3ROb2RlVHlwZXMuRU1QVFkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xuXG52YXIgZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUgPSByZXF1aXJlKCcuL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBET00gbm9kZSByZW5kZXJlZCBieSB0aGlzIGVsZW1lbnQuXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0ZG9tLmZpbmRkb21ub2RlXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudHxET01FbGVtZW50fSBjb21wb25lbnRPckVsZW1lbnRcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fSBUaGUgcm9vdCBub2RlIG9mIHRoaXMgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gZmluZERPTU5vZGUoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgb3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gIH1cblxuICB2YXIgaW5zdCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KGNvbXBvbmVudE9yRWxlbWVudCk7XG4gIGlmIChpbnN0KSB7XG4gICAgaW5zdCA9IGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlKGluc3QpO1xuICAgIHJldHVybiBpbnN0ID8gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkgOiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2ZpbmRET01Ob2RlIHdhcyBjYWxsZWQgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IF9wcm9kSW52YXJpYW50KCc0NCcpIDogdm9pZCAwO1xuICB9IGVsc2Uge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IGFwcGVhcnMgdG8gYmUgbmVpdGhlciBSZWFjdENvbXBvbmVudCBub3IgRE9NTm9kZSAoa2V5czogJXMpJywgT2JqZWN0LmtleXMoY29tcG9uZW50T3JFbGVtZW50KSkgOiBfcHJvZEludmFyaWFudCgnNDUnLCBPYmplY3Qua2V5cyhjb21wb25lbnRPckVsZW1lbnQpKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRET01Ob2RlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNb3VudC5yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHJlYWN0UHJvcHMgPSB7XG4gICAgY2hpbGRyZW46IHRydWUsXG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHRydWUsXG4gICAga2V5OiB0cnVlLFxuICAgIHJlZjogdHJ1ZSxcblxuICAgIGF1dG9Gb2N1czogdHJ1ZSxcbiAgICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gICAgdmFsdWVMaW5rOiB0cnVlLFxuICAgIGRlZmF1bHRDaGVja2VkOiB0cnVlLFxuICAgIGNoZWNrZWRMaW5rOiB0cnVlLFxuICAgIGlubmVySFRNTDogdHJ1ZSxcbiAgICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWUsXG4gICAgb25Gb2N1c0luOiB0cnVlLFxuICAgIG9uRm9jdXNPdXQ6IHRydWVcbiAgfTtcbiAgdmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcblxuICB2YXIgdmFsaWRhdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBuYW1lLCBkZWJ1Z0lEKSB7XG4gICAgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocmVhY3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiByZWFjdFByb3BzW25hbWVdIHx8IHdhcm5lZFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gZGF0YS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb25cbiAgICB2YXIgc3RhbmRhcmROYW1lID0gRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICBpZiAoc3RhbmRhcmROYW1lICE9IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBET00gcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZ3Vlc3Mgd2hpY2ggcHJvcCB0aGUgdXNlciBpbnRlbmRlZC5cbiAgICAgIC8vIEl0IGlzIGxpa2VseSB0aGF0IHRoZSB1c2VyIHdhcyBqdXN0IGJsaW5kbHkgc3ByZWFkaW5nL2ZvcndhcmRpbmcgcHJvcHNcbiAgICAgIC8vIENvbXBvbmVudHMgc2hvdWxkIGJlIGNhcmVmdWwgdG8gb25seSByZW5kZXIgdmFsaWQgcHJvcHMvYXR0cmlidXRlcy5cbiAgICAgIC8vIFdhcm5pbmcgd2lsbCBiZSBpbnZva2VkIGluIHdhcm5Vbmtub3duUHJvcGVydGllcyB0byBhbGxvdyBncm91cGluZy5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVW5rbm93blByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICB2YXIgdW5rbm93blByb3BzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBlbGVtZW50LnByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KGVsZW1lbnQudHlwZSwga2V5LCBkZWJ1Z0lEKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHVua25vd25Qcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gdW5rbm93blByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuXG4gIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIHByb3AgJXMgb24gPCVzPiB0YWcuIFJlbW92ZSB0aGlzIHByb3AgZnJvbSB0aGUgZWxlbWVudC4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtdW5rbm93bi1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gUmVtb3ZlIHRoZXNlIHByb3BzIGZyb20gdGhlIGVsZW1lbnQuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXVua25vd24tcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIGVsZW1lbnQudHlwZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PSBudWxsIHx8IHR5cGVvZiBlbGVtZW50LnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50LnR5cGUuaW5kZXhPZignLScpID49IDAgfHwgZWxlbWVudC5wcm9wcy5pcykge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuVW5rbm93blByb3BlcnRpZXMoZGVidWdJRCwgZWxlbWVudCk7XG59XG5cbnZhciBSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2sgPSB7XG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2s7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcblxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQudHlwZSAhPT0gJ2lucHV0JyAmJiBlbGVtZW50LnR5cGUgIT09ICd0ZXh0YXJlYScgJiYgZWxlbWVudC50eXBlICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC5wcm9wcyAhPSBudWxsICYmIGVsZW1lbnQucHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyB0aGUgZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJXMnLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuXG4gICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG4gIH1cbn1cblxudmFyIFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayA9IHtcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vazsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xudmFyIHJBUklBID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSwgZGVidWdJRCkge1xuICBpZiAod2FybmVkUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAockFSSUEudGVzdChuYW1lKSkge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgc3RhbmRhcmROYW1lID0gRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgIC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cbiAgICBpZiAoc3RhbmRhcmROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gc3RhbmRhcmROYW1lKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3YXJuSW52YWxpZEFSSUFQcm9wcyhkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIHZhciBpbnZhbGlkUHJvcHMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gZWxlbWVudC5wcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eShlbGVtZW50LnR5cGUsIGtleSwgZGVidWdJRCk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcblxuICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmlhIHByb3AgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL2ludmFsaWQtYXJpYS1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgfSBlbHNlIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIGVsZW1lbnQudHlwZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwgfHwgdHlwZW9mIGVsZW1lbnQudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQudHlwZS5pbmRleE9mKCctJykgPj0gMCB8fCBlbGVtZW50LnByb3BzLmlzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2FybkludmFsaWRBUklBUHJvcHMoZGVidWdJRCwgZWxlbWVudCk7XG59XG5cbnZhciBSZWFjdERPTUludmFsaWRBUklBSG9vayA9IHtcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KTtcbiAgICB9XG4gIH0sXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUludmFsaWRBUklBSG9vazsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuLyogZ2xvYmFscyBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RGVmYXVsdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xuXG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKCcuL2ZpbmRET01Ob2RlJyk7XG52YXIgZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUgPSByZXF1aXJlKCcuL2dldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlJyk7XG52YXIgcmVuZGVyU3VidHJlZUludG9Db250YWluZXIgPSByZXF1aXJlKCcuL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuUmVhY3REZWZhdWx0SW5qZWN0aW9uLmluamVjdCgpO1xuXG52YXIgUmVhY3RET00gPSB7XG4gIGZpbmRET01Ob2RlOiBmaW5kRE9NTm9kZSxcbiAgcmVuZGVyOiBSZWFjdE1vdW50LnJlbmRlcixcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMsXG4gIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lclxufTtcblxuLy8gSW5qZWN0IHRoZSBydW50aW1lIGludG8gYSBkZXZ0b29scyBnbG9iYWwgaG9vayByZWdhcmRsZXNzIG9mIGJyb3dzZXIuXG4vLyBBbGxvd3MgZm9yIGRlYnVnZ2luZyB3aGVuIHRoZSBob29rIGlzIGluamVjdGVkIG9uIHRoZSBwYWdlLlxuaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3Qoe1xuICAgIENvbXBvbmVudFRyZWU6IHtcbiAgICAgIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gICAgICBnZXROb2RlRnJvbUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICAvLyBpbnN0IGlzIGFuIGludGVybmFsIGluc3RhbmNlIChidXQgY291bGQgYmUgYSBjb21wb3NpdGUpXG4gICAgICAgIGlmIChpbnN0Ll9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgICAgICAgIGluc3QgPSBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZShpbnN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zdCkge1xuICAgICAgICAgIHJldHVybiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgTW91bnQ6IFJlYWN0TW91bnQsXG4gICAgUmVjb25jaWxlcjogUmVhY3RSZWNvbmNpbGVyXG4gIH0pO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuICBpZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG5cbiAgICAvLyBGaXJzdCBjaGVjayBpZiBkZXZ0b29scyBpcyBub3QgaW5zdGFsbGVkXG4gICAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUgb3IgRmlyZWZveCwgcHJvdmlkZSBhIGRvd25sb2FkIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID4gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPT09IC0xIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID4gLTEpIHtcbiAgICAgICAgLy8gRmlyZWZveCBkb2VzIG5vdCBoYXZlIHRoZSBpc3N1ZSB3aXRoIGRldnRvb2xzIGxvYWRlZCBvdmVyIGZpbGU6Ly9cbiAgICAgICAgdmFyIHNob3dGaWxlVXJsTWVzc2FnZSA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbC5pbmRleE9mKCdodHRwJykgPT09IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcgKyAoc2hvd0ZpbGVVcmxNZXNzYWdlID8gJ2FuZCB1c2UgYW4gSFRUUCBzZXJ2ZXIgKGluc3RlYWQgb2YgYSBmaWxlOiBVUkwpICcgOiAnJykgKyAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0ZXN0RnVuYyA9IGZ1bmN0aW9uIHRlc3RGbigpIHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCh0ZXN0RnVuYy5uYW1lIHx8IHRlc3RGdW5jLnRvU3RyaW5nKCkpLmluZGV4T2YoJ3Rlc3RGbicpICE9PSAtMSwgJ0l0IGxvb2tzIGxpa2UgeW91XFwncmUgdXNpbmcgYSBtaW5pZmllZCBjb3B5IG9mIHRoZSBkZXZlbG9wbWVudCBidWlsZCAnICsgJ29mIFJlYWN0LiBXaGVuIGRlcGxveWluZyBSZWFjdCBhcHBzIHRvIHByb2R1Y3Rpb24sIG1ha2Ugc3VyZSB0byB1c2UgJyArICd0aGUgcHJvZHVjdGlvbiBidWlsZCB3aGljaCBza2lwcyBkZXZlbG9wbWVudCB3YXJuaW5ncyBhbmQgaXMgZmFzdGVyLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LW1pbmlmaWNhdGlvbiBmb3IgbW9yZSBkZXRhaWxzLicpIDogdm9pZCAwO1xuXG4gICAgLy8gSWYgd2UncmUgaW4gSUU4LCBjaGVjayB0byBzZWUgaWYgd2UgYXJlIGluIGNvbXBhdGliaWxpdHkgbW9kZSBhbmQgcHJvdmlkZVxuICAgIC8vIGluZm9ybWF0aW9uIG9uIHByZXZlbnRpbmcgY29tcGF0aWJpbGl0eSBtb2RlXG4gICAgdmFyIGllQ29tcGF0aWJpbGl0eU1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDwgODtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpZUNvbXBhdGliaWxpdHlNb2RlLCAnSW50ZXJuZXQgRXhwbG9yZXIgaXMgcnVubmluZyBpbiBjb21wYXRpYmlsaXR5IG1vZGU7IHBsZWFzZSBhZGQgdGhlICcgKyAnZm9sbG93aW5nIHRhZyB0byB5b3VyIEhUTUwgdG8gcHJldmVudCB0aGlzIGZyb20gaGFwcGVuaW5nOiAnICsgJzxtZXRhIGh0dHAtZXF1aXY9XCJYLVVBLUNvbXBhdGlibGVcIiBjb250ZW50PVwiSUU9ZWRnZVwiIC8+JykgOiB2b2lkIDA7XG5cbiAgICB2YXIgZXhwZWN0ZWRGZWF0dXJlcyA9IFtcbiAgICAvLyBzaGltc1xuICAgIEFycmF5LmlzQXJyYXksIEFycmF5LnByb3RvdHlwZS5ldmVyeSwgQXJyYXkucHJvdG90eXBlLmZvckVhY2gsIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLCBBcnJheS5wcm90b3R5cGUubWFwLCBEYXRlLm5vdywgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQsIE9iamVjdC5rZXlzLCBTdHJpbmcucHJvdG90eXBlLnRyaW1dO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZEZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWV4cGVjdGVkRmVhdHVyZXNbaV0pIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdPbmUgb3IgbW9yZSBFUzUgc2hpbXMgZXhwZWN0ZWQgYnkgUmVhY3QgYXJlIG5vdCBhdmFpbGFibGU6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLXBvbHlmaWxscycpIDogdm9pZCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xuICB2YXIgUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rID0gcmVxdWlyZSgnLi9SZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2snKTtcbiAgdmFyIFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rJyk7XG4gIHZhciBSZWFjdERPTUludmFsaWRBUklBSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RET01JbnZhbGlkQVJJQUhvb2snKTtcblxuICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2spO1xuICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2spO1xuICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdERPTUludmFsaWRBUklBSG9vayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET007IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL1JlYWN0RE9NJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9pc1BsYWNlaG9sZGVyKGEpIHtcbiAgcmV0dXJuIGEgIT0gbnVsbCAmJlxuICAgICAgICAgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICBhWydAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXInXSA9PT0gdHJ1ZTtcbn07XG4iLCJ2YXIgX2lzUGxhY2Vob2xkZXIgPSByZXF1aXJlKCcuL19pc1BsYWNlaG9sZGVyJyk7XG5cblxuLyoqXG4gKiBPcHRpbWl6ZWQgaW50ZXJuYWwgb25lLWFyaXR5IGN1cnJ5IGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfY3VycnkxKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmMShhKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgX2lzUGxhY2Vob2xkZXIoYSkpIHtcbiAgICAgIHJldHVybiBmMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xufTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9fY3VycnkxJyk7XG52YXIgX2lzUGxhY2Vob2xkZXIgPSByZXF1aXJlKCcuL19pc1BsYWNlaG9sZGVyJyk7XG5cblxuLyoqXG4gKiBPcHRpbWl6ZWQgaW50ZXJuYWwgdHdvLWFyaXR5IGN1cnJ5IGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfY3VycnkyKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmMihhLCBiKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBmMjtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpID8gZjJcbiAgICAgICAgICAgICA6IF9jdXJyeTEoZnVuY3Rpb24oX2IpIHsgcmV0dXJuIGZuKGEsIF9iKTsgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYikgPyBmMlxuICAgICAgICAgICAgIDogX2lzUGxhY2Vob2xkZXIoYSkgPyBfY3VycnkxKGZ1bmN0aW9uKF9hKSB7IHJldHVybiBmbihfYSwgYik7IH0pXG4gICAgICAgICAgICAgOiBfaXNQbGFjZWhvbGRlcihiKSA/IF9jdXJyeTEoZnVuY3Rpb24oX2IpIHsgcmV0dXJuIGZuKGEsIF9iKTsgfSlcbiAgICAgICAgICAgICA6IGZuKGEsIGIpO1xuICAgIH1cbiAgfTtcbn07XG4iLCIvKipcbiAqIEFuIG9wdGltaXplZCwgcHJpdmF0ZSBhcnJheSBgc2xpY2VgIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FyZ3VtZW50c3xBcnJheX0gYXJncyBUaGUgYXJyYXkgb3IgYXJndW1lbnRzIG9iamVjdCB0byBjb25zaWRlci5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbZnJvbT0wXSBUaGUgYXJyYXkgaW5kZXggdG8gc2xpY2UgZnJvbSwgaW5jbHVzaXZlLlxuICogQHBhcmFtIHtOdW1iZXJ9IFt0bz1hcmdzLmxlbmd0aF0gVGhlIGFycmF5IGluZGV4IHRvIHNsaWNlIHRvLCBleGNsdXNpdmUuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcsIHNsaWNlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBfc2xpY2UoWzEsIDIsIDMsIDQsIDVdLCAxLCAzKTsgLy89PiBbMiwgM11cbiAqXG4gKiAgICAgIHZhciBmaXJzdFRocmVlQXJncyA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQpIHtcbiAqICAgICAgICByZXR1cm4gX3NsaWNlKGFyZ3VtZW50cywgMCwgMyk7XG4gKiAgICAgIH07XG4gKiAgICAgIGZpcnN0VGhyZWVBcmdzKDEsIDIsIDMsIDQpOyAvLz0+IFsxLCAyLCAzXVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9zbGljZShhcmdzLCBmcm9tLCB0bykge1xuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBfc2xpY2UoYXJncywgMCwgYXJncy5sZW5ndGgpO1xuICAgIGNhc2UgMjogcmV0dXJuIF9zbGljZShhcmdzLCBmcm9tLCBhcmdzLmxlbmd0aCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBsaXN0ID0gW107XG4gICAgICB2YXIgaWR4ID0gMDtcbiAgICAgIHZhciBsZW4gPSBNYXRoLm1heCgwLCBNYXRoLm1pbihhcmdzLmxlbmd0aCwgdG8pIC0gZnJvbSk7XG4gICAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICAgIGxpc3RbaWR4XSA9IGFyZ3NbZnJvbSArIGlkeF07XG4gICAgICAgIGlkeCArPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3Q7XG4gIH1cbn07XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9zbGljZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3NsaWNlJyk7XG5cblxuLyoqXG4gKiBTb3J0cyB0aGUgbGlzdCBhY2NvcmRpbmcgdG8gdGhlIHN1cHBsaWVkIGZ1bmN0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIE9yZCBiID0+IChhIC0+IGIpIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIHNvcnQuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgbGlzdCBzb3J0ZWQgYnkgdGhlIGtleXMgZ2VuZXJhdGVkIGJ5IGBmbmAuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIHNvcnRCeUZpcnN0SXRlbSA9IFIuc29ydEJ5KFIucHJvcCgwKSk7XG4gKiAgICAgIHZhciBzb3J0QnlOYW1lQ2FzZUluc2Vuc2l0aXZlID0gUi5zb3J0QnkoUi5jb21wb3NlKFIudG9Mb3dlciwgUi5wcm9wKCduYW1lJykpKTtcbiAqICAgICAgdmFyIHBhaXJzID0gW1stMSwgMV0sIFstMiwgMl0sIFstMywgM11dO1xuICogICAgICBzb3J0QnlGaXJzdEl0ZW0ocGFpcnMpOyAvLz0+IFtbLTMsIDNdLCBbLTIsIDJdLCBbLTEsIDFdXVxuICogICAgICB2YXIgYWxpY2UgPSB7XG4gKiAgICAgICAgbmFtZTogJ0FMSUNFJyxcbiAqICAgICAgICBhZ2U6IDEwMVxuICogICAgICB9O1xuICogICAgICB2YXIgYm9iID0ge1xuICogICAgICAgIG5hbWU6ICdCb2InLFxuICogICAgICAgIGFnZTogLTEwXG4gKiAgICAgIH07XG4gKiAgICAgIHZhciBjbGFyYSA9IHtcbiAqICAgICAgICBuYW1lOiAnY2xhcmEnLFxuICogICAgICAgIGFnZTogMzE0LjE1OVxuICogICAgICB9O1xuICogICAgICB2YXIgcGVvcGxlID0gW2NsYXJhLCBib2IsIGFsaWNlXTtcbiAqICAgICAgc29ydEJ5TmFtZUNhc2VJbnNlbnNpdGl2ZShwZW9wbGUpOyAvLz0+IFthbGljZSwgYm9iLCBjbGFyYV1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHNvcnRCeShmbiwgbGlzdCkge1xuICByZXR1cm4gX3NsaWNlKGxpc3QpLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBhYSA9IGZuKGEpO1xuICAgIHZhciBiYiA9IGZuKGIpO1xuICAgIHJldHVybiBhYSA8IGJiID8gLTEgOiBhYSA+IGJiID8gMSA6IDA7XG4gIH0pO1xufSk7XG4iLCIvKipcbiAqIFRlc3RzIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBpcyBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWwgVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB2YWxgIGlzIGFuIGFycmF5LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBfaXNBcnJheShbXSk7IC8vPT4gdHJ1ZVxuICogICAgICBfaXNBcnJheShudWxsKTsgLy89PiBmYWxzZVxuICogICAgICBfaXNBcnJheSh7fSk7IC8vPT4gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIF9pc0FycmF5KHZhbCkge1xuICByZXR1cm4gKHZhbCAhPSBudWxsICYmXG4gICAgICAgICAgdmFsLmxlbmd0aCA+PSAwICYmXG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XScpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2lzVHJhbnNmb3JtZXIob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqWydAQHRyYW5zZHVjZXIvc3RlcCddID09PSAnZnVuY3Rpb24nO1xufTtcbiIsInZhciBfaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzQXJyYXknKTtcbnZhciBfaXNUcmFuc2Zvcm1lciA9IHJlcXVpcmUoJy4vX2lzVHJhbnNmb3JtZXInKTtcbnZhciBfc2xpY2UgPSByZXF1aXJlKCcuL19zbGljZScpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZGlzcGF0Y2hlcyB3aXRoIGRpZmZlcmVudCBzdHJhdGVnaWVzIGJhc2VkIG9uIHRoZVxuICogb2JqZWN0IGluIGxpc3QgcG9zaXRpb24gKGxhc3QgYXJndW1lbnQpLiBJZiBpdCBpcyBhbiBhcnJheSwgZXhlY3V0ZXMgW2ZuXS5cbiAqIE90aGVyd2lzZSwgaWYgaXQgaGFzIGEgZnVuY3Rpb24gd2l0aCBbbWV0aG9kbmFtZV0sIGl0IHdpbGwgZXhlY3V0ZSB0aGF0XG4gKiBmdW5jdGlvbiAoZnVuY3RvciBjYXNlKS4gT3RoZXJ3aXNlLCBpZiBpdCBpcyBhIHRyYW5zZm9ybWVyLCB1c2VzIHRyYW5zZHVjZXJcbiAqIFt4Zl0gdG8gcmV0dXJuIGEgbmV3IHRyYW5zZm9ybWVyICh0cmFuc2R1Y2VyIGNhc2UpLiBPdGhlcndpc2UsIGl0IHdpbGxcbiAqIGRlZmF1bHQgdG8gZXhlY3V0aW5nIFtmbl0uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RuYW1lIHByb3BlcnR5IHRvIGNoZWNrIGZvciBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0geGYgdHJhbnNkdWNlciB0byBpbml0aWFsaXplIGlmIG9iamVjdCBpcyB0cmFuc2Zvcm1lclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gZGVmYXVsdCByYW1kYSBpbXBsZW1lbnRhdGlvblxuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCBkaXNwYXRjaGVzIG9uIG9iamVjdCBpbiBsaXN0IHBvc2l0aW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2Rpc3BhdGNoYWJsZShtZXRob2RuYW1lLCB4ZiwgZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH1cbiAgICB2YXIgb2JqID0gYXJndW1lbnRzW2xlbmd0aCAtIDFdO1xuICAgIGlmICghX2lzQXJyYXkob2JqKSkge1xuICAgICAgdmFyIGFyZ3MgPSBfc2xpY2UoYXJndW1lbnRzLCAwLCBsZW5ndGggLSAxKTtcbiAgICAgIGlmICh0eXBlb2Ygb2JqW21ldGhvZG5hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBvYmpbbWV0aG9kbmFtZV0uYXBwbHkob2JqLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIGlmIChfaXNUcmFuc2Zvcm1lcihvYmopKSB7XG4gICAgICAgIHZhciB0cmFuc2R1Y2VyID0geGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIHJldHVybiB0cmFuc2R1Y2VyKG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2ZpbHRlcihmbiwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGlmIChmbihsaXN0W2lkeF0pKSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBsaXN0W2lkeF07XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfaXNPYmplY3QoeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBPYmplY3RdJztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gWFdyYXAoZm4pIHtcbiAgICB0aGlzLmYgPSBmbjtcbiAgfVxuICBYV3JhcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2luaXQgbm90IGltcGxlbWVudGVkIG9uIFhXcmFwJyk7XG4gIH07XG4gIFhXcmFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24oYWNjKSB7IHJldHVybiBhY2M7IH07XG4gIFhXcmFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKGFjYywgeCkge1xuICAgIHJldHVybiB0aGlzLmYoYWNjLCB4KTtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gX3h3cmFwKGZuKSB7IHJldHVybiBuZXcgWFdyYXAoZm4pOyB9O1xufSgpKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2FyaXR5KG4sIGZuKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gIHN3aXRjaCAobikge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhMCkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhMCwgYTEpIHsgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMikgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMykgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDU6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQpIHsgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgY2FzZSA2OiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDc6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNikgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDg6IHJldHVybiBmdW5jdGlvbihhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpIHsgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgY2FzZSA5OiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCkgeyByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgICBjYXNlIDEwOiByZXR1cm4gZnVuY3Rpb24oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpIHsgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byBfYXJpdHkgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIG5vIGdyZWF0ZXIgdGhhbiB0ZW4nKTtcbiAgfVxufTtcbiIsInZhciBfYXJpdHkgPSByZXF1aXJlKCcuL2ludGVybmFsL19hcml0eScpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIGJvdW5kIHRvIGEgY29udGV4dC5cbiAqIE5vdGU6IGBSLmJpbmRgIGRvZXMgbm90IHByb3ZpZGUgdGhlIGFkZGl0aW9uYWwgYXJndW1lbnQtYmluZGluZyBjYXBhYmlsaXRpZXMgb2ZcbiAqIFtGdW5jdGlvbi5wcm90b3R5cGUuYmluZF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vYmluZCkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNi4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgKCogLT4gKikgLT4geyp9IC0+ICgqIC0+ICopXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYmluZCB0byBjb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc09iaiBUaGUgY29udGV4dCB0byBiaW5kIGBmbmAgdG9cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBleGVjdXRlIGluIHRoZSBjb250ZXh0IG9mIGB0aGlzT2JqYC5cbiAqIEBzZWUgUi5wYXJ0aWFsXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGxvZyA9IFIuYmluZChjb25zb2xlLmxvZywgY29uc29sZSk7XG4gKiAgICAgIFIucGlwZShSLmFzc29jKCdhJywgMiksIFIudGFwKGxvZyksIFIuYXNzb2MoJ2EnLCAzKSkoe2E6IDF9KTsgLy89PiB7YTogM31cbiAqICAgICAgLy8gbG9ncyB7YTogMn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNPYmopIHtcbiAgcmV0dXJuIF9hcml0eShmbi5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzT2JqLCBhcmd1bWVudHMpO1xuICB9KTtcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfaXNTdHJpbmcoeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBTdHJpbmddJztcbn07XG4iLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MScpO1xudmFyIF9pc0FycmF5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNBcnJheScpO1xudmFyIF9pc1N0cmluZyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lzU3RyaW5nJyk7XG5cblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgaXMgc2ltaWxhciB0byBhbiBhcnJheS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC41LjBcbiAqIEBjYXRlZ29yeSBUeXBlXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAqIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0geCBUaGUgb2JqZWN0IHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYHhgIGhhcyBhIG51bWVyaWMgbGVuZ3RoIHByb3BlcnR5IGFuZCBleHRyZW1lIGluZGljZXMgZGVmaW5lZDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5pc0FycmF5TGlrZShbXSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzQXJyYXlMaWtlKHRydWUpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaXNBcnJheUxpa2Uoe30pOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaXNBcnJheUxpa2Uoe2xlbmd0aDogMTB9KTsgLy89PiBmYWxzZVxuICogICAgICBSLmlzQXJyYXlMaWtlKHswOiAnemVybycsIDk6ICduaW5lJywgbGVuZ3RoOiAxMH0pOyAvLz0+IHRydWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkxKGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHgpIHtcbiAgaWYgKF9pc0FycmF5KHgpKSB7IHJldHVybiB0cnVlOyB9XG4gIGlmICgheCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHR5cGVvZiB4ICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKF9pc1N0cmluZyh4KSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHgubm9kZVR5cGUgPT09IDEpIHsgcmV0dXJuICEheC5sZW5ndGg7IH1cbiAgaWYgKHgubGVuZ3RoID09PSAwKSB7IHJldHVybiB0cnVlOyB9XG4gIGlmICh4Lmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4geC5oYXNPd25Qcm9wZXJ0eSgwKSAmJiB4Lmhhc093blByb3BlcnR5KHgubGVuZ3RoIC0gMSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufSk7XG4iLCJ2YXIgX3h3cmFwID0gcmVxdWlyZSgnLi9feHdyYXAnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vYmluZCcpO1xudmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaXNBcnJheUxpa2UnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gX2FycmF5UmVkdWNlKHhmLCBhY2MsIGxpc3QpIHtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgYWNjID0geGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10oYWNjLCBsaXN0W2lkeF0pO1xuICAgICAgaWYgKGFjYyAmJiBhY2NbJ0BAdHJhbnNkdWNlci9yZWR1Y2VkJ10pIHtcbiAgICAgICAgYWNjID0gYWNjWydAQHRyYW5zZHVjZXIvdmFsdWUnXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZHggKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10oYWNjKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pdGVyYWJsZVJlZHVjZSh4ZiwgYWNjLCBpdGVyKSB7XG4gICAgdmFyIHN0ZXAgPSBpdGVyLm5leHQoKTtcbiAgICB3aGlsZSAoIXN0ZXAuZG9uZSkge1xuICAgICAgYWNjID0geGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10oYWNjLCBzdGVwLnZhbHVlKTtcbiAgICAgIGlmIChhY2MgJiYgYWNjWydAQHRyYW5zZHVjZXIvcmVkdWNlZCddKSB7XG4gICAgICAgIGFjYyA9IGFjY1snQEB0cmFuc2R1Y2VyL3ZhbHVlJ107XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RlcCA9IGl0ZXIubmV4dCgpO1xuICAgIH1cbiAgICByZXR1cm4geGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShhY2MpO1xuICB9XG5cbiAgZnVuY3Rpb24gX21ldGhvZFJlZHVjZSh4ZiwgYWNjLCBvYmopIHtcbiAgICByZXR1cm4geGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShvYmoucmVkdWNlKGJpbmQoeGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10sIHhmKSwgYWNjKSk7XG4gIH1cblxuICB2YXIgc3ltSXRlcmF0b3IgPSAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcpID8gU3ltYm9sLml0ZXJhdG9yIDogJ0BAaXRlcmF0b3InO1xuICByZXR1cm4gZnVuY3Rpb24gX3JlZHVjZShmbiwgYWNjLCBsaXN0KSB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZm4gPSBfeHdyYXAoZm4pO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheUxpa2UobGlzdCkpIHtcbiAgICAgIHJldHVybiBfYXJyYXlSZWR1Y2UoZm4sIGFjYywgbGlzdCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbGlzdC5yZWR1Y2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBfbWV0aG9kUmVkdWNlKGZuLCBhY2MsIGxpc3QpO1xuICAgIH1cbiAgICBpZiAobGlzdFtzeW1JdGVyYXRvcl0gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIF9pdGVyYWJsZVJlZHVjZShmbiwgYWNjLCBsaXN0W3N5bUl0ZXJhdG9yXSgpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsaXN0Lm5leHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBfaXRlcmFibGVSZWR1Y2UoZm4sIGFjYywgbGlzdCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlZHVjZTogbGlzdCBtdXN0IGJlIGFycmF5IG9yIGl0ZXJhYmxlJyk7XG4gIH07XG59KCkpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvaW5pdCddKCk7XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICB9XG59O1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL19jdXJyeTInKTtcbnZhciBfeGZCYXNlID0gcmVxdWlyZSgnLi9feGZCYXNlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFhGaWx0ZXIoZiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5mID0gZjtcbiAgfVxuICBYRmlsdGVyLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWEZpbHRlci5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuICBYRmlsdGVyLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKHJlc3VsdCwgaW5wdXQpIHtcbiAgICByZXR1cm4gdGhpcy5mKGlucHV0KSA/IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCkgOiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hmaWx0ZXIoZiwgeGYpIHsgcmV0dXJuIG5ldyBYRmlsdGVyKGYsIHhmKTsgfSk7XG59KCkpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfaGFzKHByb3AsIG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59O1xuIiwidmFyIF9oYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXScgP1xuICAgIGZ1bmN0aW9uIF9pc0FyZ3VtZW50cyh4KSB7IHJldHVybiB0b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcmd1bWVudHNdJzsgfSA6XG4gICAgZnVuY3Rpb24gX2lzQXJndW1lbnRzKHgpIHsgcmV0dXJuIF9oYXMoJ2NhbGxlZScsIHgpOyB9O1xufSgpKTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgX2hhcyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2hhcycpO1xudmFyIF9pc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lzQXJndW1lbnRzJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgdGhlIGVudW1lcmFibGUgb3duIHByb3BlcnRpZXMgb2ZcbiAqIHRoZSBzdXBwbGllZCBvYmplY3QuXG4gKiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZSBvdXRwdXQgYXJyYXkgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgY29uc2lzdGVudFxuICogYWNyb3NzIGRpZmZlcmVudCBKUyBwbGF0Zm9ybXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtrOiB2fSAtPiBba11cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IHByb3BlcnRpZXMgZnJvbVxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIHRoZSBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmtleXMoe2E6IDEsIGI6IDIsIGM6IDN9KTsgLy89PiBbJ2EnLCAnYicsICdjJ11cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIC8vIGNvdmVyIElFIDwgOSBrZXlzIGlzc3Vlc1xuICB2YXIgaGFzRW51bUJ1ZyA9ICEoe3RvU3RyaW5nOiBudWxsfSkucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG4gIHZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ2NvbnN0cnVjdG9yJywgJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XG4gIC8vIFNhZmFyaSBidWdcbiAgdmFyIGhhc0FyZ3NFbnVtQnVnID0gKGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICByZXR1cm4gYXJndW1lbnRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKCdsZW5ndGgnKTtcbiAgfSgpKTtcblxuICB2YXIgY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyhsaXN0LCBpdGVtKSB7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgd2hpbGUgKGlkeCA8IGxpc3QubGVuZ3RoKSB7XG4gICAgICBpZiAobGlzdFtpZHhdID09PSBpdGVtKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICByZXR1cm4gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmICFoYXNBcmdzRW51bUJ1ZyA/XG4gICAgX2N1cnJ5MShmdW5jdGlvbiBrZXlzKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdChvYmopICE9PSBvYmogPyBbXSA6IE9iamVjdC5rZXlzKG9iaik7XG4gICAgfSkgOlxuICAgIF9jdXJyeTEoZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgICAgIGlmIChPYmplY3Qob2JqKSAhPT0gb2JqKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wLCBuSWR4O1xuICAgICAgdmFyIGtzID0gW107XG4gICAgICB2YXIgY2hlY2tBcmdzTGVuZ3RoID0gaGFzQXJnc0VudW1CdWcgJiYgX2lzQXJndW1lbnRzKG9iaik7XG4gICAgICBmb3IgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgIGlmIChfaGFzKHByb3AsIG9iaikgJiYgKCFjaGVja0FyZ3NMZW5ndGggfHwgcHJvcCAhPT0gJ2xlbmd0aCcpKSB7XG4gICAgICAgICAga3Nba3MubGVuZ3RoXSA9IHByb3A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXNFbnVtQnVnKSB7XG4gICAgICAgIG5JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKG5JZHggPj0gMCkge1xuICAgICAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbklkeF07XG4gICAgICAgICAgaWYgKF9oYXMocHJvcCwgb2JqKSAmJiAhY29udGFpbnMoa3MsIHByb3ApKSB7XG4gICAgICAgICAgICBrc1trcy5sZW5ndGhdID0gcHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbklkeCAtPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ga3M7XG4gICAgfSk7XG59KCkpO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcbnZhciBfZGlzcGF0Y2hhYmxlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlJyk7XG52YXIgX2ZpbHRlciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2ZpbHRlcicpO1xudmFyIF9pc09iamVjdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lzT2JqZWN0Jyk7XG52YXIgX3JlZHVjZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3JlZHVjZScpO1xudmFyIF94ZmlsdGVyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9feGZpbHRlcicpO1xudmFyIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuXG4vKipcbiAqIFRha2VzIGEgcHJlZGljYXRlIGFuZCBhIFwiZmlsdGVyYWJsZVwiLCBhbmQgcmV0dXJucyBhIG5ldyBmaWx0ZXJhYmxlIG9mIHRoZVxuICogc2FtZSB0eXBlIGNvbnRhaW5pbmcgdGhlIG1lbWJlcnMgb2YgdGhlIGdpdmVuIGZpbHRlcmFibGUgd2hpY2ggc2F0aXNmeSB0aGVcbiAqIGdpdmVuIHByZWRpY2F0ZS5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgZmlsdGVyYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBGaWx0ZXJhYmxlIGYgPT4gKGEgLT4gQm9vbGVhbikgLT4gZiBhIC0+IGYgYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZFxuICogQHBhcmFtIHtBcnJheX0gZmlsdGVyYWJsZVxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAc2VlIFIucmVqZWN0LCBSLnRyYW5zZHVjZSwgUi5hZGRJbmRleFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBpc0V2ZW4gPSBuID0+IG4gJSAyID09PSAwO1xuICpcbiAqICAgICAgUi5maWx0ZXIoaXNFdmVuLCBbMSwgMiwgMywgNF0pOyAvLz0+IFsyLCA0XVxuICpcbiAqICAgICAgUi5maWx0ZXIoaXNFdmVuLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHtiOiAyLCBkOiA0fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZSgnZmlsdGVyJywgX3hmaWx0ZXIsIGZ1bmN0aW9uKHByZWQsIGZpbHRlcmFibGUpIHtcbiAgcmV0dXJuIChcbiAgICBfaXNPYmplY3QoZmlsdGVyYWJsZSkgP1xuICAgICAgX3JlZHVjZShmdW5jdGlvbihhY2MsIGtleSkge1xuICAgICAgICBpZiAocHJlZChmaWx0ZXJhYmxlW2tleV0pKSB7XG4gICAgICAgICAgYWNjW2tleV0gPSBmaWx0ZXJhYmxlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9LCBrZXlzKGZpbHRlcmFibGUpKSA6XG4gICAgLy8gZWxzZVxuICAgICAgX2ZpbHRlcihwcmVkLCBmaWx0ZXJhYmxlKVxuICApO1xufSkpO1xuIiwidmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTInKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdoZW4gc3VwcGxpZWQgYW4gb2JqZWN0IHJldHVybnMgdGhlIGluZGljYXRlZFxuICogcHJvcGVydHkgb2YgdGhhdCBvYmplY3QsIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgcyAtPiB7czogYX0gLT4gYSB8IFVuZGVmaW5lZFxuICogQHBhcmFtIHtTdHJpbmd9IHAgVGhlIHByb3BlcnR5IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBxdWVyeVxuICogQHJldHVybiB7Kn0gVGhlIHZhbHVlIGF0IGBvYmoucGAuXG4gKiBAc2VlIFIucGF0aFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucHJvcCgneCcsIHt4OiAxMDB9KTsgLy89PiAxMDBcbiAqICAgICAgUi5wcm9wKCd4Jywge30pOyAvLz0+IHVuZGVmaW5lZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gcHJvcChwLCBvYmopIHsgcmV0dXJuIG9ialtwXTsgfSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9tYXAoZm4sIGZ1bmN0b3IpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBmdW5jdG9yLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbik7XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICByZXN1bHRbaWR4XSA9IGZuKGZ1bmN0b3JbaWR4XSk7XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vX2N1cnJ5MicpO1xudmFyIF94ZkJhc2UgPSByZXF1aXJlKCcuL194ZkJhc2UnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gWE1hcChmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICB9XG4gIFhNYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYTWFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gX3hmQmFzZS5yZXN1bHQ7XG4gIFhNYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdGhpcy5mKGlucHV0KSk7XG4gIH07XG5cbiAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3htYXAoZiwgeGYpIHsgcmV0dXJuIG5ldyBYTWFwKGYsIHhmKTsgfSk7XG59KCkpO1xuIiwidmFyIF9hcml0eSA9IHJlcXVpcmUoJy4vX2FyaXR5Jyk7XG52YXIgX2lzUGxhY2Vob2xkZXIgPSByZXF1aXJlKCcuL19pc1BsYWNlaG9sZGVyJyk7XG5cblxuLyoqXG4gKiBJbnRlcm5hbCBjdXJyeU4gZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgYXJpdHkgb2YgdGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0FycmF5fSByZWNlaXZlZCBBbiBhcnJheSBvZiBhcmd1bWVudHMgcmVjZWl2ZWQgdGh1cyBmYXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2N1cnJ5TihsZW5ndGgsIHJlY2VpdmVkLCBmbikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbWJpbmVkID0gW107XG4gICAgdmFyIGFyZ3NJZHggPSAwO1xuICAgIHZhciBsZWZ0ID0gbGVuZ3RoO1xuICAgIHZhciBjb21iaW5lZElkeCA9IDA7XG4gICAgd2hpbGUgKGNvbWJpbmVkSWR4IDwgcmVjZWl2ZWQubGVuZ3RoIHx8IGFyZ3NJZHggPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKGNvbWJpbmVkSWR4IDwgcmVjZWl2ZWQubGVuZ3RoICYmXG4gICAgICAgICAgKCFfaXNQbGFjZWhvbGRlcihyZWNlaXZlZFtjb21iaW5lZElkeF0pIHx8XG4gICAgICAgICAgIGFyZ3NJZHggPj0gYXJndW1lbnRzLmxlbmd0aCkpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZWRbY29tYmluZWRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gYXJndW1lbnRzW2FyZ3NJZHhdO1xuICAgICAgICBhcmdzSWR4ICs9IDE7XG4gICAgICB9XG4gICAgICBjb21iaW5lZFtjb21iaW5lZElkeF0gPSByZXN1bHQ7XG4gICAgICBpZiAoIV9pc1BsYWNlaG9sZGVyKHJlc3VsdCkpIHtcbiAgICAgICAgbGVmdCAtPSAxO1xuICAgICAgfVxuICAgICAgY29tYmluZWRJZHggKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQgPD0gMCA/IGZuLmFwcGx5KHRoaXMsIGNvbWJpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgOiBfYXJpdHkobGVmdCwgX2N1cnJ5TihsZW5ndGgsIGNvbWJpbmVkLCBmbikpO1xuICB9O1xufTtcbiIsInZhciBfYXJpdHkgPSByZXF1aXJlKCcuL2ludGVybmFsL19hcml0eScpO1xudmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcbnZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2N1cnJ5TiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5TicpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIGN1cnJpZWQgZXF1aXZhbGVudCBvZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb24sIHdpdGggdGhlIHNwZWNpZmllZFxuICogYXJpdHkuIFRoZSBjdXJyaWVkIGZ1bmN0aW9uIGhhcyB0d28gdW51c3VhbCBjYXBhYmlsaXRpZXMuIEZpcnN0LCBpdHNcbiAqIGFyZ3VtZW50cyBuZWVkbid0IGJlIHByb3ZpZGVkIG9uZSBhdCBhIHRpbWUuIElmIGBnYCBpcyBgUi5jdXJyeU4oMywgZilgLCB0aGVcbiAqIGZvbGxvd2luZyBhcmUgZXF1aXZhbGVudDpcbiAqXG4gKiAgIC0gYGcoMSkoMikoMylgXG4gKiAgIC0gYGcoMSkoMiwgMylgXG4gKiAgIC0gYGcoMSwgMikoMylgXG4gKiAgIC0gYGcoMSwgMiwgMylgXG4gKlxuICogU2Vjb25kbHksIHRoZSBzcGVjaWFsIHBsYWNlaG9sZGVyIHZhbHVlIGBSLl9fYCBtYXkgYmUgdXNlZCB0byBzcGVjaWZ5XG4gKiBcImdhcHNcIiwgYWxsb3dpbmcgcGFydGlhbCBhcHBsaWNhdGlvbiBvZiBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzLFxuICogcmVnYXJkbGVzcyBvZiB0aGVpciBwb3NpdGlvbnMuIElmIGBnYCBpcyBhcyBhYm92ZSBhbmQgYF9gIGlzIGBSLl9fYCwgdGhlXG4gKiBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAtIGBnKDEsIDIsIDMpYFxuICogICAtIGBnKF8sIDIsIDMpKDEpYFxuICogICAtIGBnKF8sIF8sIDMpKDEpKDIpYFxuICogICAtIGBnKF8sIF8sIDMpKDEsIDIpYFxuICogICAtIGBnKF8sIDIpKDEpKDMpYFxuICogICAtIGBnKF8sIDIpKDEsIDMpYFxuICogICAtIGBnKF8sIDIpKF8sIDMpKDEpYFxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjUuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIE51bWJlciAtPiAoKiAtPiBhKSAtPiAoKiAtPiBhKVxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgYXJpdHkgZm9yIHRoZSByZXR1cm5lZCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldywgY3VycmllZCBmdW5jdGlvbi5cbiAqIEBzZWUgUi5jdXJyeVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBzdW1BcmdzID0gKC4uLmFyZ3MpID0+IFIuc3VtKGFyZ3MpO1xuICpcbiAqICAgICAgdmFyIGN1cnJpZWRBZGRGb3VyTnVtYmVycyA9IFIuY3VycnlOKDQsIHN1bUFyZ3MpO1xuICogICAgICB2YXIgZiA9IGN1cnJpZWRBZGRGb3VyTnVtYmVycygxLCAyKTtcbiAqICAgICAgdmFyIGcgPSBmKDMpO1xuICogICAgICBnKDQpOyAvLz0+IDEwXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihmdW5jdGlvbiBjdXJyeU4obGVuZ3RoLCBmbikge1xuICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIF9jdXJyeTEoZm4pO1xuICB9XG4gIHJldHVybiBfYXJpdHkobGVuZ3RoLCBfY3VycnlOKGxlbmd0aCwgW10sIGZuKSk7XG59KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgX2Rpc3BhdGNoYWJsZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZScpO1xudmFyIF9tYXAgPSByZXF1aXJlKCcuL2ludGVybmFsL19tYXAnKTtcbnZhciBfcmVkdWNlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fcmVkdWNlJyk7XG52YXIgX3htYXAgPSByZXF1aXJlKCcuL2ludGVybmFsL194bWFwJyk7XG52YXIgY3VycnlOID0gcmVxdWlyZSgnLi9jdXJyeU4nKTtcbnZhciBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cblxuLyoqXG4gKiBUYWtlcyBhIGZ1bmN0aW9uIGFuZFxuICogYSBbZnVuY3Rvcl0oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNmdW5jdG9yKSxcbiAqIGFwcGxpZXMgdGhlIGZ1bmN0aW9uIHRvIGVhY2ggb2YgdGhlIGZ1bmN0b3IncyB2YWx1ZXMsIGFuZCByZXR1cm5zXG4gKiBhIGZ1bmN0b3Igb2YgdGhlIHNhbWUgc2hhcGUuXG4gKlxuICogUmFtZGEgcHJvdmlkZXMgc3VpdGFibGUgYG1hcGAgaW1wbGVtZW50YXRpb25zIGZvciBgQXJyYXlgIGFuZCBgT2JqZWN0YCxcbiAqIHNvIHRoaXMgZnVuY3Rpb24gbWF5IGJlIGFwcGxpZWQgdG8gYFsxLCAyLCAzXWAgb3IgYHt4OiAxLCB5OiAyLCB6OiAzfWAuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYG1hcGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEFsc28gdHJlYXRzIGZ1bmN0aW9ucyBhcyBmdW5jdG9ycyBhbmQgd2lsbCBjb21wb3NlIHRoZW0gdG9nZXRoZXIuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBGdW5jdG9yIGYgPT4gKGEgLT4gYikgLT4gZiBhIC0+IGYgYlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBldmVyeSBlbGVtZW50IG9mIHRoZSBpbnB1dCBgbGlzdGAuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGJlIGl0ZXJhdGVkIG92ZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIG5ldyBsaXN0LlxuICogQHNlZSBSLnRyYW5zZHVjZSwgUi5hZGRJbmRleFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBkb3VibGUgPSB4ID0+IHggKiAyO1xuICpcbiAqICAgICAgUi5tYXAoZG91YmxlLCBbMSwgMiwgM10pOyAvLz0+IFsyLCA0LCA2XVxuICpcbiAqICAgICAgUi5tYXAoZG91YmxlLCB7eDogMSwgeTogMiwgejogM30pOyAvLz0+IHt4OiAyLCB5OiA0LCB6OiA2fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoX2Rpc3BhdGNoYWJsZSgnbWFwJywgX3htYXAsIGZ1bmN0aW9uIG1hcChmbiwgZnVuY3Rvcikge1xuICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChmdW5jdG9yKSkge1xuICAgIGNhc2UgJ1tvYmplY3QgRnVuY3Rpb25dJzpcbiAgICAgIHJldHVybiBjdXJyeU4oZnVuY3Rvci5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBmdW5jdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfSk7XG4gICAgY2FzZSAnW29iamVjdCBPYmplY3RdJzpcbiAgICAgIHJldHVybiBfcmVkdWNlKGZ1bmN0aW9uKGFjYywga2V5KSB7XG4gICAgICAgIGFjY1trZXldID0gZm4oZnVuY3RvcltrZXldKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9LCBrZXlzKGZ1bmN0b3IpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIF9tYXAoZm4sIGZ1bmN0b3IpO1xuICB9XG59KSk7XG4iLCJ2YXIgX2N1cnJ5MSA9IHJlcXVpcmUoJy4vX2N1cnJ5MScpO1xudmFyIF9jdXJyeTIgPSByZXF1aXJlKCcuL19jdXJyeTInKTtcbnZhciBfaXNQbGFjZWhvbGRlciA9IHJlcXVpcmUoJy4vX2lzUGxhY2Vob2xkZXInKTtcblxuXG4vKipcbiAqIE9wdGltaXplZCBpbnRlcm5hbCB0aHJlZS1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2N1cnJ5Myhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gZjMoYSwgYiwgYykge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gZjM7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBfaXNQbGFjZWhvbGRlcihhKSA/IGYzXG4gICAgICAgICAgICAgOiBfY3VycnkyKGZ1bmN0aW9uKF9iLCBfYykgeyByZXR1cm4gZm4oYSwgX2IsIF9jKTsgfSk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBfaXNQbGFjZWhvbGRlcihhKSAmJiBfaXNQbGFjZWhvbGRlcihiKSA/IGYzXG4gICAgICAgICAgICAgOiBfaXNQbGFjZWhvbGRlcihhKSA/IF9jdXJyeTIoZnVuY3Rpb24oX2EsIF9jKSB7IHJldHVybiBmbihfYSwgYiwgX2MpOyB9KVxuICAgICAgICAgICAgIDogX2lzUGxhY2Vob2xkZXIoYikgPyBfY3VycnkyKGZ1bmN0aW9uKF9iLCBfYykgeyByZXR1cm4gZm4oYSwgX2IsIF9jKTsgfSlcbiAgICAgICAgICAgICA6IF9jdXJyeTEoZnVuY3Rpb24oX2MpIHsgcmV0dXJuIGZuKGEsIGIsIF9jKTsgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYikgJiYgX2lzUGxhY2Vob2xkZXIoYykgPyBmM1xuICAgICAgICAgICAgIDogX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYikgPyBfY3VycnkyKGZ1bmN0aW9uKF9hLCBfYikgeyByZXR1cm4gZm4oX2EsIF9iLCBjKTsgfSlcbiAgICAgICAgICAgICA6IF9pc1BsYWNlaG9sZGVyKGEpICYmIF9pc1BsYWNlaG9sZGVyKGMpID8gX2N1cnJ5MihmdW5jdGlvbihfYSwgX2MpIHsgcmV0dXJuIGZuKF9hLCBiLCBfYyk7IH0pXG4gICAgICAgICAgICAgOiBfaXNQbGFjZWhvbGRlcihiKSAmJiBfaXNQbGFjZWhvbGRlcihjKSA/IF9jdXJyeTIoZnVuY3Rpb24oX2IsIF9jKSB7IHJldHVybiBmbihhLCBfYiwgX2MpOyB9KVxuICAgICAgICAgICAgIDogX2lzUGxhY2Vob2xkZXIoYSkgPyBfY3VycnkxKGZ1bmN0aW9uKF9hKSB7IHJldHVybiBmbihfYSwgYiwgYyk7IH0pXG4gICAgICAgICAgICAgOiBfaXNQbGFjZWhvbGRlcihiKSA/IF9jdXJyeTEoZnVuY3Rpb24oX2IpIHsgcmV0dXJuIGZuKGEsIF9iLCBjKTsgfSlcbiAgICAgICAgICAgICA6IF9pc1BsYWNlaG9sZGVyKGMpID8gX2N1cnJ5MShmdW5jdGlvbihfYykgeyByZXR1cm4gZm4oYSwgYiwgX2MpOyB9KVxuICAgICAgICAgICAgIDogZm4oYSwgYiwgYyk7XG4gICAgfVxuICB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2FycmF5RnJvbUl0ZXJhdG9yKGl0ZXIpIHtcbiAgdmFyIGxpc3QgPSBbXTtcbiAgdmFyIG5leHQ7XG4gIHdoaWxlICghKG5leHQgPSBpdGVyLm5leHQoKSkuZG9uZSkge1xuICAgIGxpc3QucHVzaChuZXh0LnZhbHVlKTtcbiAgfVxuICByZXR1cm4gbGlzdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9mdW5jdGlvbk5hbWUoZikge1xuICAvLyBTdHJpbmcoeCA9PiB4KSBldmFsdWF0ZXMgdG8gXCJ4ID0+IHhcIiwgc28gdGhlIHBhdHRlcm4gbWF5IG5vdCBtYXRjaC5cbiAgdmFyIG1hdGNoID0gU3RyaW5nKGYpLm1hdGNoKC9eZnVuY3Rpb24gKFxcdyopLyk7XG4gIHJldHVybiBtYXRjaCA9PSBudWxsID8gJycgOiBtYXRjaFsxXTtcbn07XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGl0cyBhcmd1bWVudHMgYXJlIGlkZW50aWNhbCwgZmFsc2Ugb3RoZXJ3aXNlLiBWYWx1ZXMgYXJlXG4gKiBpZGVudGljYWwgaWYgdGhleSByZWZlcmVuY2UgdGhlIHNhbWUgbWVtb3J5LiBgTmFOYCBpcyBpZGVudGljYWwgdG8gYE5hTmA7XG4gKiBgMGAgYW5kIGAtMGAgYXJlIG5vdCBpZGVudGljYWwuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTUuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIGEgLT4gYSAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbyA9IHt9O1xuICogICAgICBSLmlkZW50aWNhbChvLCBvKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaWRlbnRpY2FsKDEsIDEpOyAvLz0+IHRydWVcbiAqICAgICAgUi5pZGVudGljYWwoMSwgJzEnKTsgLy89PiBmYWxzZVxuICogICAgICBSLmlkZW50aWNhbChbXSwgW10pOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaWRlbnRpY2FsKDAsIC0wKTsgLy89PiBmYWxzZVxuICogICAgICBSLmlkZW50aWNhbChOYU4sIE5hTik7IC8vPT4gdHJ1ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gaWRlbnRpY2FsKGEsIGIpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoYSA9PT0gYikgeyAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG4gIH1cbn0pO1xuIiwidmFyIF9jdXJyeTEgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTEnKTtcblxuXG4vKipcbiAqIEdpdmVzIGEgc2luZ2xlLXdvcmQgc3RyaW5nIGRlc2NyaXB0aW9uIG9mIHRoZSAobmF0aXZlKSB0eXBlIG9mIGEgdmFsdWUsXG4gKiByZXR1cm5pbmcgc3VjaCBhbnN3ZXJzIGFzICdPYmplY3QnLCAnTnVtYmVyJywgJ0FycmF5Jywgb3IgJ051bGwnLiBEb2VzIG5vdFxuICogYXR0ZW1wdCB0byBkaXN0aW5ndWlzaCB1c2VyIE9iamVjdCB0eXBlcyBhbnkgZnVydGhlciwgcmVwb3J0aW5nIHRoZW0gYWxsIGFzXG4gKiAnT2JqZWN0Jy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC44LjBcbiAqIEBjYXRlZ29yeSBUeXBlXG4gKiBAc2lnICgqIC0+IHsqfSkgLT4gU3RyaW5nXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudHlwZSh7fSk7IC8vPT4gXCJPYmplY3RcIlxuICogICAgICBSLnR5cGUoMSk7IC8vPT4gXCJOdW1iZXJcIlxuICogICAgICBSLnR5cGUoZmFsc2UpOyAvLz0+IFwiQm9vbGVhblwiXG4gKiAgICAgIFIudHlwZSgncycpOyAvLz0+IFwiU3RyaW5nXCJcbiAqICAgICAgUi50eXBlKG51bGwpOyAvLz0+IFwiTnVsbFwiXG4gKiAgICAgIFIudHlwZShbXSk7IC8vPT4gXCJBcnJheVwiXG4gKiAgICAgIFIudHlwZSgvW0Etel0vKTsgLy89PiBcIlJlZ0V4cFwiXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiB0eXBlKHZhbCkge1xuICByZXR1cm4gdmFsID09PSBudWxsICAgICAgPyAnTnVsbCcgICAgICA6XG4gICAgICAgICB2YWwgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDpcbiAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpLnNsaWNlKDgsIC0xKTtcbn0pO1xuIiwidmFyIF9hcnJheUZyb21JdGVyYXRvciA9IHJlcXVpcmUoJy4vX2FycmF5RnJvbUl0ZXJhdG9yJyk7XG52YXIgX2Z1bmN0aW9uTmFtZSA9IHJlcXVpcmUoJy4vX2Z1bmN0aW9uTmFtZScpO1xudmFyIF9oYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBpZGVudGljYWwgPSByZXF1aXJlKCcuLi9pZGVudGljYWwnKTtcbnZhciBrZXlzID0gcmVxdWlyZSgnLi4va2V5cycpO1xudmFyIHR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfZXF1YWxzKGEsIGIsIHN0YWNrQSwgc3RhY2tCKSB7XG4gIGlmIChpZGVudGljYWwoYSwgYikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlKGEpICE9PSB0eXBlKGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGEuZXF1YWxzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBiLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlb2YgYS5lcXVhbHMgPT09ICdmdW5jdGlvbicgJiYgYS5lcXVhbHMoYikgJiZcbiAgICAgICAgICAgdHlwZW9mIGIuZXF1YWxzID09PSAnZnVuY3Rpb24nICYmIGIuZXF1YWxzKGEpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKGEpKSB7XG4gICAgY2FzZSAnQXJndW1lbnRzJzpcbiAgICBjYXNlICdBcnJheSc6XG4gICAgY2FzZSAnT2JqZWN0JzpcbiAgICAgIGlmICh0eXBlb2YgYS5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgIF9mdW5jdGlvbk5hbWUoYS5jb25zdHJ1Y3RvcikgPT09ICdQcm9taXNlJykge1xuICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgIGNhc2UgJ051bWJlcic6XG4gICAgY2FzZSAnU3RyaW5nJzpcbiAgICAgIGlmICghKHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBpZGVudGljYWwoYS52YWx1ZU9mKCksIGIudmFsdWVPZigpKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnRGF0ZSc6XG4gICAgICBpZiAoIWlkZW50aWNhbChhLnZhbHVlT2YoKSwgYi52YWx1ZU9mKCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0Vycm9yJzpcbiAgICAgIHJldHVybiBhLm5hbWUgPT09IGIubmFtZSAmJiBhLm1lc3NhZ2UgPT09IGIubWVzc2FnZTtcbiAgICBjYXNlICdSZWdFeHAnOlxuICAgICAgaWYgKCEoYS5zb3VyY2UgPT09IGIuc291cmNlICYmXG4gICAgICAgICAgICBhLmdsb2JhbCA9PT0gYi5nbG9iYWwgJiZcbiAgICAgICAgICAgIGEuaWdub3JlQ2FzZSA9PT0gYi5pZ25vcmVDYXNlICYmXG4gICAgICAgICAgICBhLm11bHRpbGluZSA9PT0gYi5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgIGEuc3RpY2t5ID09PSBiLnN0aWNreSAmJlxuICAgICAgICAgICAgYS51bmljb2RlID09PSBiLnVuaWNvZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ01hcCc6XG4gICAgY2FzZSAnU2V0JzpcbiAgICAgIGlmICghX2VxdWFscyhfYXJyYXlGcm9tSXRlcmF0b3IoYS5lbnRyaWVzKCkpLCBfYXJyYXlGcm9tSXRlcmF0b3IoYi5lbnRyaWVzKCkpLCBzdGFja0EsIHN0YWNrQikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnSW50OEFycmF5JzpcbiAgICBjYXNlICdVaW50OEFycmF5JzpcbiAgICBjYXNlICdVaW50OENsYW1wZWRBcnJheSc6XG4gICAgY2FzZSAnSW50MTZBcnJheSc6XG4gICAgY2FzZSAnVWludDE2QXJyYXknOlxuICAgIGNhc2UgJ0ludDMyQXJyYXknOlxuICAgIGNhc2UgJ1VpbnQzMkFycmF5JzpcbiAgICBjYXNlICdGbG9hdDMyQXJyYXknOlxuICAgIGNhc2UgJ0Zsb2F0NjRBcnJheSc6XG4gICAgICBicmVhaztcbiAgICBjYXNlICdBcnJheUJ1ZmZlcic6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gVmFsdWVzIG9mIG90aGVyIHR5cGVzIGFyZSBvbmx5IGVxdWFsIGlmIGlkZW50aWNhbC5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IGtleXMoYSk7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXMoYikubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGlkeCA9IHN0YWNrQS5sZW5ndGggLSAxO1xuICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICBpZiAoc3RhY2tBW2lkeF0gPT09IGEpIHtcbiAgICAgIHJldHVybiBzdGFja0JbaWR4XSA9PT0gYjtcbiAgICB9XG4gICAgaWR4IC09IDE7XG4gIH1cblxuICBzdGFja0EucHVzaChhKTtcbiAgc3RhY2tCLnB1c2goYik7XG4gIGlkeCA9IGtleXNBLmxlbmd0aCAtIDE7XG4gIHdoaWxlIChpZHggPj0gMCkge1xuICAgIHZhciBrZXkgPSBrZXlzQVtpZHhdO1xuICAgIGlmICghKF9oYXMoa2V5LCBiKSAmJiBfZXF1YWxzKGJba2V5XSwgYVtrZXldLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlkeCAtPSAxO1xuICB9XG4gIHN0YWNrQS5wb3AoKTtcbiAgc3RhY2tCLnBvcCgpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9lcXVhbHMgPSByZXF1aXJlKCcuL2ludGVybmFsL19lcXVhbHMnKTtcblxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIGl0cyBhcmd1bWVudHMgYXJlIGVxdWl2YWxlbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLiBIYW5kbGVzXG4gKiBjeWNsaWNhbCBkYXRhIHN0cnVjdHVyZXMuXG4gKlxuICogRGlzcGF0Y2hlcyBzeW1tZXRyaWNhbGx5IHRvIHRoZSBgZXF1YWxzYCBtZXRob2RzIG9mIGJvdGggYXJndW1lbnRzLCBpZlxuICogcHJlc2VudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgYSAtPiBiIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0gYVxuICogQHBhcmFtIHsqfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZXF1YWxzKDEsIDEpOyAvLz0+IHRydWVcbiAqICAgICAgUi5lcXVhbHMoMSwgJzEnKTsgLy89PiBmYWxzZVxuICogICAgICBSLmVxdWFscyhbMSwgMiwgM10sIFsxLCAyLCAzXSk7IC8vPT4gdHJ1ZVxuICpcbiAqICAgICAgdmFyIGEgPSB7fTsgYS52ID0gYTtcbiAqICAgICAgdmFyIGIgPSB7fTsgYi52ID0gYjtcbiAqICAgICAgUi5lcXVhbHMoYSwgYik7IC8vPT4gdHJ1ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIF9lcXVhbHMoYSwgYiwgW10sIFtdKTtcbn0pO1xuIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcbnZhciBlcXVhbHMgPSByZXF1aXJlKCcuL2VxdWFscycpO1xuXG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgcHJvcGVydHkgaXMgZXF1YWwsIGluIGBSLmVxdWFsc2BcbiAqIHRlcm1zLCB0byB0aGUgZ2l2ZW4gdmFsdWU7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIFN0cmluZyAtPiBhIC0+IE9iamVjdCAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLmVxdWFscywgUi5wcm9wU2F0aXNmaWVzXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGFiYnkgPSB7bmFtZTogJ0FiYnknLCBhZ2U6IDcsIGhhaXI6ICdibG9uZCd9O1xuICogICAgICB2YXIgZnJlZCA9IHtuYW1lOiAnRnJlZCcsIGFnZTogMTIsIGhhaXI6ICdicm93bid9O1xuICogICAgICB2YXIgcnVzdHkgPSB7bmFtZTogJ1J1c3R5JywgYWdlOiAxMCwgaGFpcjogJ2Jyb3duJ307XG4gKiAgICAgIHZhciBhbG9pcyA9IHtuYW1lOiAnQWxvaXMnLCBhZ2U6IDE1LCBkaXNwb3NpdGlvbjogJ3N1cmx5J307XG4gKiAgICAgIHZhciBraWRzID0gW2FiYnksIGZyZWQsIHJ1c3R5LCBhbG9pc107XG4gKiAgICAgIHZhciBoYXNCcm93bkhhaXIgPSBSLnByb3BFcSgnaGFpcicsICdicm93bicpO1xuICogICAgICBSLmZpbHRlcihoYXNCcm93bkhhaXIsIGtpZHMpOyAvLz0+IFtmcmVkLCBydXN0eV1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIHByb3BFcShuYW1lLCB2YWwsIG9iaikge1xuICByZXR1cm4gZXF1YWxzKHZhbCwgb2JqW25hbWVdKTtcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfcmVkdWNlZCh4KSB7XG4gIHJldHVybiB4ICYmIHhbJ0BAdHJhbnNkdWNlci9yZWR1Y2VkJ10gPyB4IDpcbiAgICB7XG4gICAgICAnQEB0cmFuc2R1Y2VyL3ZhbHVlJzogeCxcbiAgICAgICdAQHRyYW5zZHVjZXIvcmVkdWNlZCc6IHRydWVcbiAgICB9O1xufTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9fY3VycnkyJyk7XG52YXIgX3JlZHVjZWQgPSByZXF1aXJlKCcuL19yZWR1Y2VkJyk7XG52YXIgX3hmQmFzZSA9IHJlcXVpcmUoJy4vX3hmQmFzZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBYRmluZChmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICAgIHRoaXMuZm91bmQgPSBmYWxzZTtcbiAgfVxuICBYRmluZC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhGaW5kLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgaWYgKCF0aGlzLmZvdW5kKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdm9pZCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICB9O1xuICBYRmluZC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGlucHV0KSB7XG4gICAgaWYgKHRoaXMuZihpbnB1dCkpIHtcbiAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgcmVzdWx0ID0gX3JlZHVjZWQodGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIF9jdXJyeTIoZnVuY3Rpb24gX3hmaW5kKGYsIHhmKSB7IHJldHVybiBuZXcgWEZpbmQoZiwgeGYpOyB9KTtcbn0oKSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9kaXNwYXRjaGFibGUgPSByZXF1aXJlKCcuL2ludGVybmFsL19kaXNwYXRjaGFibGUnKTtcbnZhciBfeGZpbmQgPSByZXF1aXJlKCcuL2ludGVybmFsL194ZmluZCcpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgbGlzdCB3aGljaCBtYXRjaGVzIHRoZSBwcmVkaWNhdGUsIG9yXG4gKiBgdW5kZWZpbmVkYCBpZiBubyBlbGVtZW50IG1hdGNoZXMuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGZpbmRgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBhIHwgdW5kZWZpbmVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBlbGVtZW50IGlzIHRoZVxuICogICAgICAgIGRlc2lyZWQgb25lLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBlbGVtZW50IGZvdW5kLCBvciBgdW5kZWZpbmVkYC5cbiAqIEBzZWUgUi50cmFuc2R1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgeHMgPSBbe2E6IDF9LCB7YTogMn0sIHthOiAzfV07XG4gKiAgICAgIFIuZmluZChSLnByb3BFcSgnYScsIDIpKSh4cyk7IC8vPT4ge2E6IDJ9XG4gKiAgICAgIFIuZmluZChSLnByb3BFcSgnYScsIDQpKSh4cyk7IC8vPT4gdW5kZWZpbmVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MihfZGlzcGF0Y2hhYmxlKCdmaW5kJywgX3hmaW5kLCBmdW5jdGlvbiBmaW5kKGZuLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBpZiAoZm4obGlzdFtpZHhdKSkge1xuICAgICAgcmV0dXJuIGxpc3RbaWR4XTtcbiAgICB9XG4gICAgaWR4ICs9IDE7XG4gIH1cbn0pKTtcbiIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG52YXIgX2hhcyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2hhcycpO1xuXG5cbi8qKlxuICogSWYgdGhlIGdpdmVuLCBub24tbnVsbCBvYmplY3QgaGFzIGFuIG93biBwcm9wZXJ0eSB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSxcbiAqIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoYXQgcHJvcGVydHkuIE90aGVyd2lzZSByZXR1cm5zIHRoZSBwcm92aWRlZCBkZWZhdWx0XG4gKiB2YWx1ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC42LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgYSAtPiBTdHJpbmcgLT4gT2JqZWN0IC0+IGFcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSBkZWZhdWx0IHZhbHVlLlxuICogQHBhcmFtIHtTdHJpbmd9IHAgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJldHVybi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZSBvZiBnaXZlbiBwcm9wZXJ0eSBvZiB0aGUgc3VwcGxpZWQgb2JqZWN0IG9yIHRoZSBkZWZhdWx0IHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBhbGljZSA9IHtcbiAqICAgICAgICBuYW1lOiAnQUxJQ0UnLFxuICogICAgICAgIGFnZTogMTAxXG4gKiAgICAgIH07XG4gKiAgICAgIHZhciBmYXZvcml0ZSA9IFIucHJvcCgnZmF2b3JpdGVMaWJyYXJ5Jyk7XG4gKiAgICAgIHZhciBmYXZvcml0ZVdpdGhEZWZhdWx0ID0gUi5wcm9wT3IoJ1JhbWRhJywgJ2Zhdm9yaXRlTGlicmFyeScpO1xuICpcbiAqICAgICAgZmF2b3JpdGUoYWxpY2UpOyAgLy89PiB1bmRlZmluZWRcbiAqICAgICAgZmF2b3JpdGVXaXRoRGVmYXVsdChhbGljZSk7ICAvLz0+ICdSYW1kYSdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIHByb3BPcih2YWwsIHAsIG9iaikge1xuICByZXR1cm4gKG9iaiAhPSBudWxsICYmIF9oYXMocCwgb2JqKSkgPyBvYmpbcF0gOiB2YWw7XG59KTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX3BpcGUoZiwgZykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGcuY2FsbCh0aGlzLCBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufTtcbiIsInZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG52YXIgX3JlZHVjZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX3JlZHVjZScpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhIHNpbmdsZSBpdGVtIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIHRoZSBsaXN0LCBzdWNjZXNzaXZlbHkgY2FsbGluZ1xuICogdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIGFuZCBwYXNzaW5nIGl0IGFuIGFjY3VtdWxhdG9yIHZhbHVlIGFuZCB0aGUgY3VycmVudFxuICogdmFsdWUgZnJvbSB0aGUgYXJyYXksIGFuZCB0aGVuIHBhc3NpbmcgdGhlIHJlc3VsdCB0byB0aGUgbmV4dCBjYWxsLlxuICpcbiAqIFRoZSBpdGVyYXRvciBmdW5jdGlvbiByZWNlaXZlcyB0d28gdmFsdWVzOiAqKGFjYywgdmFsdWUpKi4gSXQgbWF5IHVzZVxuICogYFIucmVkdWNlZGAgdG8gc2hvcnRjdXQgdGhlIGl0ZXJhdGlvbi5cbiAqXG4gKiBOb3RlOiBgUi5yZWR1Y2VgIGRvZXMgbm90IHNraXAgZGVsZXRlZCBvciB1bmFzc2lnbmVkIGluZGljZXMgKHNwYXJzZVxuICogYXJyYXlzKSwgdW5saWtlIHRoZSBuYXRpdmUgYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZC4gRm9yIG1vcmUgZGV0YWlsc1xuICogb24gdGhpcyBiZWhhdmlvciwgc2VlOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcmVkdWNlI0Rlc2NyaXB0aW9uXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYHJlZHVjZWAgbWV0aG9kIG9mIHRoZSB0aGlyZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICgoYSwgYikgLT4gYSkgLT4gYSAtPiBbYl0gLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLiBSZWNlaXZlcyB0d28gdmFsdWVzLCB0aGUgYWNjdW11bGF0b3IgYW5kIHRoZVxuICogICAgICAgIGN1cnJlbnQgZWxlbWVudCBmcm9tIHRoZSBhcnJheS5cbiAqIEBwYXJhbSB7Kn0gYWNjIFRoZSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7Kn0gVGhlIGZpbmFsLCBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBzZWUgUi5yZWR1Y2VkLCBSLmFkZEluZGV4XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIG51bWJlcnMgPSBbMSwgMiwgM107XG4gKiAgICAgIHZhciBwbHVzID0gKGEsIGIpID0+IGEgKyBiO1xuICpcbiAqICAgICAgUi5yZWR1Y2UocGx1cywgMTAsIG51bWJlcnMpOyAvLz0+IDE2XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MyhfcmVkdWNlKTtcbiIsInZhciBfaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzQXJyYXknKTtcbnZhciBfc2xpY2UgPSByZXF1aXJlKCcuL19zbGljZScpO1xuXG5cbi8qKlxuICogU2ltaWxhciB0byBoYXNNZXRob2QsIHRoaXMgY2hlY2tzIHdoZXRoZXIgYSBmdW5jdGlvbiBoYXMgYSBbbWV0aG9kbmFtZV1cbiAqIGZ1bmN0aW9uLiBJZiBpdCBpc24ndCBhbiBhcnJheSBpdCB3aWxsIGV4ZWN1dGUgdGhhdCBmdW5jdGlvbiBvdGhlcndpc2UgaXRcbiAqIHdpbGwgZGVmYXVsdCB0byB0aGUgcmFtZGEgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIHJhbWRhIGltcGxlbXRhdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZG5hbWUgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uXG4gKiBAcmV0dXJuIHtPYmplY3R9IFdoYXRldmVyIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIG1ldGhvZCBpcy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfY2hlY2tGb3JNZXRob2QobWV0aG9kbmFtZSwgZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH1cbiAgICB2YXIgb2JqID0gYXJndW1lbnRzW2xlbmd0aCAtIDFdO1xuICAgIHJldHVybiAoX2lzQXJyYXkob2JqKSB8fCB0eXBlb2Ygb2JqW21ldGhvZG5hbWVdICE9PSAnZnVuY3Rpb24nKSA/XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDpcbiAgICAgIG9ialttZXRob2RuYW1lXS5hcHBseShvYmosIF9zbGljZShhcmd1bWVudHMsIDAsIGxlbmd0aCAtIDEpKTtcbiAgfTtcbn07XG4iLCJ2YXIgX2NoZWNrRm9yTWV0aG9kID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY2hlY2tGb3JNZXRob2QnKTtcbnZhciBfY3VycnkzID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkzJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gbGlzdCBvciBzdHJpbmcgKG9yIG9iamVjdCB3aXRoIGEgYHNsaWNlYFxuICogbWV0aG9kKSBmcm9tIGBmcm9tSW5kZXhgIChpbmNsdXNpdmUpIHRvIGB0b0luZGV4YCAoZXhjbHVzaXZlKS5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgc2xpY2VgIG1ldGhvZCBvZiB0aGUgdGhpcmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS40XG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IFthXSAtPiBbYV1cbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gZnJvbUluZGV4IFRoZSBzdGFydCBpbmRleCAoaW5jbHVzaXZlKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0b0luZGV4IFRoZSBlbmQgaW5kZXggKGV4Y2x1c2l2ZSkuXG4gKiBAcGFyYW0geyp9IGxpc3RcbiAqIEByZXR1cm4geyp9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5zbGljZSgxLCAzLCBbJ2EnLCAnYicsICdjJywgJ2QnXSk7ICAgICAgICAvLz0+IFsnYicsICdjJ11cbiAqICAgICAgUi5zbGljZSgxLCBJbmZpbml0eSwgWydhJywgJ2InLCAnYycsICdkJ10pOyAvLz0+IFsnYicsICdjJywgJ2QnXVxuICogICAgICBSLnNsaWNlKDAsIC0xLCBbJ2EnLCAnYicsICdjJywgJ2QnXSk7ICAgICAgIC8vPT4gWydhJywgJ2InLCAnYyddXG4gKiAgICAgIFIuc2xpY2UoLTMsIC0xLCBbJ2EnLCAnYicsICdjJywgJ2QnXSk7ICAgICAgLy89PiBbJ2InLCAnYyddXG4gKiAgICAgIFIuc2xpY2UoMCwgMywgJ3JhbWRhJyk7ICAgICAgICAgICAgICAgICAgICAgLy89PiAncmFtJ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTMoX2NoZWNrRm9yTWV0aG9kKCdzbGljZScsIGZ1bmN0aW9uIHNsaWNlKGZyb21JbmRleCwgdG9JbmRleCwgbGlzdCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgZnJvbUluZGV4LCB0b0luZGV4KTtcbn0pKTtcbiIsInZhciBfY2hlY2tGb3JNZXRob2QgPSByZXF1aXJlKCcuL2ludGVybmFsL19jaGVja0Zvck1ldGhvZCcpO1xudmFyIHNsaWNlID0gcmVxdWlyZSgnLi9zbGljZScpO1xuXG5cbi8qKlxuICogUmV0dXJucyBhbGwgYnV0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBsaXN0IG9yIHN0cmluZyAob3Igb2JqZWN0XG4gKiB3aXRoIGEgYHRhaWxgIG1ldGhvZCkuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYHNsaWNlYCBtZXRob2Qgb2YgdGhlIGZpcnN0IGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IFthXVxuICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0geyp9IGxpc3RcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIuaGVhZCwgUi5pbml0LCBSLmxhc3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRhaWwoWzEsIDIsIDNdKTsgIC8vPT4gWzIsIDNdXG4gKiAgICAgIFIudGFpbChbMSwgMl0pOyAgICAgLy89PiBbMl1cbiAqICAgICAgUi50YWlsKFsxXSk7ICAgICAgICAvLz0+IFtdXG4gKiAgICAgIFIudGFpbChbXSk7ICAgICAgICAgLy89PiBbXVxuICpcbiAqICAgICAgUi50YWlsKCdhYmMnKTsgIC8vPT4gJ2JjJ1xuICogICAgICBSLnRhaWwoJ2FiJyk7ICAgLy89PiAnYidcbiAqICAgICAgUi50YWlsKCdhJyk7ICAgIC8vPT4gJydcbiAqICAgICAgUi50YWlsKCcnKTsgICAgIC8vPT4gJydcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY2hlY2tGb3JNZXRob2QoJ3RhaWwnLCBzbGljZSgxLCBJbmZpbml0eSkpO1xuIiwidmFyIF9hcml0eSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2FyaXR5Jyk7XG52YXIgX3BpcGUgPSByZXF1aXJlKCcuL2ludGVybmFsL19waXBlJyk7XG52YXIgcmVkdWNlID0gcmVxdWlyZSgnLi9yZWR1Y2UnKTtcbnZhciB0YWlsID0gcmVxdWlyZSgnLi90YWlsJyk7XG5cblxuLyoqXG4gKiBQZXJmb3JtcyBsZWZ0LXRvLXJpZ2h0IGZ1bmN0aW9uIGNvbXBvc2l0aW9uLiBUaGUgbGVmdG1vc3QgZnVuY3Rpb24gbWF5IGhhdmVcbiAqIGFueSBhcml0eTsgdGhlIHJlbWFpbmluZyBmdW5jdGlvbnMgbXVzdCBiZSB1bmFyeS5cbiAqXG4gKiBJbiBzb21lIGxpYnJhcmllcyB0aGlzIGZ1bmN0aW9uIGlzIG5hbWVkIGBzZXF1ZW5jZWAuXG4gKlxuICogKipOb3RlOioqIFRoZSByZXN1bHQgb2YgcGlwZSBpcyBub3QgYXV0b21hdGljYWxseSBjdXJyaWVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgoKGEsIGIsIC4uLiwgbikgLT4gbyksIChvIC0+IHApLCAuLi4sICh4IC0+IHkpLCAoeSAtPiB6KSkgLT4gKChhLCBiLCAuLi4sIG4pIC0+IHopXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHNlZSBSLmNvbXBvc2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZiA9IFIucGlwZShNYXRoLnBvdywgUi5uZWdhdGUsIFIuaW5jKTtcbiAqXG4gKiAgICAgIGYoMywgNCk7IC8vIC0oM140KSArIDFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwaXBlKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGlwZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQnKTtcbiAgfVxuICByZXR1cm4gX2FyaXR5KGFyZ3VtZW50c1swXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcmVkdWNlKF9waXBlLCBhcmd1bWVudHNbMF0sIHRhaWwoYXJndW1lbnRzKSkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIHNpemVyU3R5bGUgPSB7IHBvc2l0aW9uOiAnYWJzb2x1dGUnLCB0b3A6IDAsIGxlZnQ6IDAsIHZpc2liaWxpdHk6ICdoaWRkZW4nLCBoZWlnaHQ6IDAsIG92ZXJmbG93OiAnc2Nyb2xsJywgd2hpdGVTcGFjZTogJ3ByZScgfTtcblxudmFyIEF1dG9zaXplSW5wdXQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cdGRpc3BsYXlOYW1lOiAnQXV0b3NpemVJbnB1dCcsXG5cblx0cHJvcFR5cGVzOiB7XG5cdFx0Y2xhc3NOYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLCAvLyBjbGFzc05hbWUgZm9yIHRoZSBvdXRlciBlbGVtZW50XG5cdFx0ZGVmYXVsdFZhbHVlOiBSZWFjdC5Qcm9wVHlwZXMuYW55LCAvLyBkZWZhdWx0IGZpZWxkIHZhbHVlXG5cdFx0aW5wdXRDbGFzc05hbWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsIC8vIGNsYXNzTmFtZSBmb3IgdGhlIGlucHV0IGVsZW1lbnRcblx0XHRpbnB1dFN0eWxlOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LCAvLyBjc3Mgc3R5bGVzIGZvciB0aGUgaW5wdXQgZWxlbWVudFxuXHRcdG1pbldpZHRoOiBSZWFjdC5Qcm9wVHlwZXMub25lT2ZUeXBlKFsvLyBtaW5pbXVtIHdpZHRoIGZvciBpbnB1dCBlbGVtZW50XG5cdFx0UmVhY3QuUHJvcFR5cGVzLm51bWJlciwgUmVhY3QuUHJvcFR5cGVzLnN0cmluZ10pLFxuXHRcdG9uQ2hhbmdlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYywgLy8gb25DaGFuZ2UgaGFuZGxlcjogZnVuY3Rpb24obmV3VmFsdWUpIHt9XG5cdFx0cGxhY2Vob2xkZXI6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcsIC8vIHBsYWNlaG9sZGVyIHRleHRcblx0XHRwbGFjZWhvbGRlcklzTWluV2lkdGg6IFJlYWN0LlByb3BUeXBlcy5ib29sLCAvLyBkb24ndCBjb2xsYXBzZSBzaXplIHRvIGxlc3MgdGhhbiB0aGUgcGxhY2Vob2xkZXJcblx0XHRzdHlsZTogUmVhY3QuUHJvcFR5cGVzLm9iamVjdCwgLy8gY3NzIHN0eWxlcyBmb3IgdGhlIG91dGVyIGVsZW1lbnRcblx0XHR2YWx1ZTogUmVhY3QuUHJvcFR5cGVzLmFueSB9LFxuXHQvLyBmaWVsZCB2YWx1ZVxuXHRnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bWluV2lkdGg6IDFcblx0XHR9O1xuXHR9LFxuXHRnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0aW5wdXRXaWR0aDogdGhpcy5wcm9wcy5taW5XaWR0aFxuXHRcdH07XG5cdH0sXG5cdGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHR0aGlzLmNvcHlJbnB1dFN0eWxlcygpO1xuXHRcdHRoaXMudXBkYXRlSW5wdXRXaWR0aCgpO1xuXHR9LFxuXHRjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcblx0XHR0aGlzLnVwZGF0ZUlucHV0V2lkdGgoKTtcblx0fSxcblx0Y29weUlucHV0U3R5bGVzOiBmdW5jdGlvbiBjb3B5SW5wdXRTdHlsZXMoKSB7XG5cdFx0aWYgKCF0aGlzLmlzTW91bnRlZCgpIHx8ICF3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgaW5wdXRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMucmVmcy5pbnB1dCk7XG5cdFx0aWYgKCFpbnB1dFN0eWxlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciB3aWR0aE5vZGUgPSB0aGlzLnJlZnMuc2l6ZXI7XG5cdFx0d2lkdGhOb2RlLnN0eWxlLmZvbnRTaXplID0gaW5wdXRTdHlsZS5mb250U2l6ZTtcblx0XHR3aWR0aE5vZGUuc3R5bGUuZm9udEZhbWlseSA9IGlucHV0U3R5bGUuZm9udEZhbWlseTtcblx0XHR3aWR0aE5vZGUuc3R5bGUuZm9udFdlaWdodCA9IGlucHV0U3R5bGUuZm9udFdlaWdodDtcblx0XHR3aWR0aE5vZGUuc3R5bGUuZm9udFN0eWxlID0gaW5wdXRTdHlsZS5mb250U3R5bGU7XG5cdFx0d2lkdGhOb2RlLnN0eWxlLmxldHRlclNwYWNpbmcgPSBpbnB1dFN0eWxlLmxldHRlclNwYWNpbmc7XG5cdFx0aWYgKHRoaXMucHJvcHMucGxhY2Vob2xkZXIpIHtcblx0XHRcdHZhciBwbGFjZWhvbGRlck5vZGUgPSB0aGlzLnJlZnMucGxhY2Vob2xkZXJTaXplcjtcblx0XHRcdHBsYWNlaG9sZGVyTm9kZS5zdHlsZS5mb250U2l6ZSA9IGlucHV0U3R5bGUuZm9udFNpemU7XG5cdFx0XHRwbGFjZWhvbGRlck5vZGUuc3R5bGUuZm9udEZhbWlseSA9IGlucHV0U3R5bGUuZm9udEZhbWlseTtcblx0XHRcdHBsYWNlaG9sZGVyTm9kZS5zdHlsZS5mb250V2VpZ2h0ID0gaW5wdXRTdHlsZS5mb250V2VpZ2h0O1xuXHRcdFx0cGxhY2Vob2xkZXJOb2RlLnN0eWxlLmZvbnRTdHlsZSA9IGlucHV0U3R5bGUuZm9udFN0eWxlO1xuXHRcdFx0cGxhY2Vob2xkZXJOb2RlLnN0eWxlLmxldHRlclNwYWNpbmcgPSBpbnB1dFN0eWxlLmxldHRlclNwYWNpbmc7XG5cdFx0fVxuXHR9LFxuXHR1cGRhdGVJbnB1dFdpZHRoOiBmdW5jdGlvbiB1cGRhdGVJbnB1dFdpZHRoKCkge1xuXHRcdGlmICghdGhpcy5pc01vdW50ZWQoKSB8fCB0eXBlb2YgdGhpcy5yZWZzLnNpemVyLnNjcm9sbFdpZHRoID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgbmV3SW5wdXRXaWR0aCA9IHVuZGVmaW5lZDtcblx0XHRpZiAodGhpcy5wcm9wcy5wbGFjZWhvbGRlciAmJiAoIXRoaXMucHJvcHMudmFsdWUgfHwgdGhpcy5wcm9wcy52YWx1ZSAmJiB0aGlzLnByb3BzLnBsYWNlaG9sZGVySXNNaW5XaWR0aCkpIHtcblx0XHRcdG5ld0lucHV0V2lkdGggPSBNYXRoLm1heCh0aGlzLnJlZnMuc2l6ZXIuc2Nyb2xsV2lkdGgsIHRoaXMucmVmcy5wbGFjZWhvbGRlclNpemVyLnNjcm9sbFdpZHRoKSArIDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld0lucHV0V2lkdGggPSB0aGlzLnJlZnMuc2l6ZXIuc2Nyb2xsV2lkdGggKyAyO1xuXHRcdH1cblx0XHRpZiAobmV3SW5wdXRXaWR0aCA8IHRoaXMucHJvcHMubWluV2lkdGgpIHtcblx0XHRcdG5ld0lucHV0V2lkdGggPSB0aGlzLnByb3BzLm1pbldpZHRoO1xuXHRcdH1cblx0XHRpZiAobmV3SW5wdXRXaWR0aCAhPT0gdGhpcy5zdGF0ZS5pbnB1dFdpZHRoKSB7XG5cdFx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdFx0aW5wdXRXaWR0aDogbmV3SW5wdXRXaWR0aFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXHRnZXRJbnB1dDogZnVuY3Rpb24gZ2V0SW5wdXQoKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVmcy5pbnB1dDtcblx0fSxcblx0Zm9jdXM6IGZ1bmN0aW9uIGZvY3VzKCkge1xuXHRcdHRoaXMucmVmcy5pbnB1dC5mb2N1cygpO1xuXHR9LFxuXHRibHVyOiBmdW5jdGlvbiBibHVyKCkge1xuXHRcdHRoaXMucmVmcy5pbnB1dC5ibHVyKCk7XG5cdH0sXG5cdHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0KCkge1xuXHRcdHRoaXMucmVmcy5pbnB1dC5zZWxlY3QoKTtcblx0fSxcblx0cmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG5cdFx0dmFyIHNpemVyVmFsdWUgPSB0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZSB8fCB0aGlzLnByb3BzLnZhbHVlIHx8ICcnO1xuXHRcdHZhciB3cmFwcGVyU3R5bGUgPSB0aGlzLnByb3BzLnN0eWxlIHx8IHt9O1xuXHRcdGlmICghd3JhcHBlclN0eWxlLmRpc3BsYXkpIHdyYXBwZXJTdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG5cdFx0dmFyIGlucHV0U3R5bGUgPSBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcy5pbnB1dFN0eWxlKTtcblx0XHRpbnB1dFN0eWxlLndpZHRoID0gdGhpcy5zdGF0ZS5pbnB1dFdpZHRoICsgJ3B4Jztcblx0XHRpbnB1dFN0eWxlLmJveFNpemluZyA9ICdjb250ZW50LWJveCc7XG5cdFx0dmFyIGlucHV0UHJvcHMgPSBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcyk7XG5cdFx0aW5wdXRQcm9wcy5jbGFzc05hbWUgPSB0aGlzLnByb3BzLmlucHV0Q2xhc3NOYW1lO1xuXHRcdGlucHV0UHJvcHMuc3R5bGUgPSBpbnB1dFN0eWxlO1xuXHRcdC8vIGVuc3VyZSBwcm9wcyBtZWFudCBmb3IgYEF1dG9zaXplSW5wdXRgIGRvbid0IGVuZCB1cCBvbiB0aGUgYGlucHV0YFxuXHRcdGRlbGV0ZSBpbnB1dFByb3BzLmlucHV0Q2xhc3NOYW1lO1xuXHRcdGRlbGV0ZSBpbnB1dFByb3BzLmlucHV0U3R5bGU7XG5cdFx0ZGVsZXRlIGlucHV0UHJvcHMubWluV2lkdGg7XG5cdFx0ZGVsZXRlIGlucHV0UHJvcHMucGxhY2Vob2xkZXJJc01pbldpZHRoO1xuXHRcdHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuXHRcdFx0J2RpdicsXG5cdFx0XHR7IGNsYXNzTmFtZTogdGhpcy5wcm9wcy5jbGFzc05hbWUsIHN0eWxlOiB3cmFwcGVyU3R5bGUgfSxcblx0XHRcdFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgX2V4dGVuZHMoe30sIGlucHV0UHJvcHMsIHsgcmVmOiAnaW5wdXQnIH0pKSxcblx0XHRcdFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRcdCdkaXYnLFxuXHRcdFx0XHR7IHJlZjogJ3NpemVyJywgc3R5bGU6IHNpemVyU3R5bGUgfSxcblx0XHRcdFx0c2l6ZXJWYWx1ZVxuXHRcdFx0KSxcblx0XHRcdHRoaXMucHJvcHMucGxhY2Vob2xkZXIgPyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuXHRcdFx0XHQnZGl2Jyxcblx0XHRcdFx0eyByZWY6ICdwbGFjZWhvbGRlclNpemVyJywgc3R5bGU6IHNpemVyU3R5bGUgfSxcblx0XHRcdFx0dGhpcy5wcm9wcy5wbGFjZWhvbGRlclxuXHRcdFx0KSA6IG51bGxcblx0XHQpO1xuXHR9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdXRvc2l6ZUlucHV0OyIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTYgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGFycm93UmVuZGVyZXI7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbmZ1bmN0aW9uIGFycm93UmVuZGVyZXIoX3JlZikge1xuXHR2YXIgb25Nb3VzZURvd24gPSBfcmVmLm9uTW91c2VEb3duO1xuXG5cdHJldHVybiBfcmVhY3QyW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG5cdFx0Y2xhc3NOYW1lOiBcIlNlbGVjdC1hcnJvd1wiLFxuXHRcdG9uTW91c2VEb3duOiBvbk1vdXNlRG93blxuXHR9KTtcbn1cblxuO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXAgPSBbeyAnYmFzZSc6ICdBJywgJ2xldHRlcnMnOiAvW1xcdTAwNDFcXHUyNEI2XFx1RkYyMVxcdTAwQzBcXHUwMEMxXFx1MDBDMlxcdTFFQTZcXHUxRUE0XFx1MUVBQVxcdTFFQThcXHUwMEMzXFx1MDEwMFxcdTAxMDJcXHUxRUIwXFx1MUVBRVxcdTFFQjRcXHUxRUIyXFx1MDIyNlxcdTAxRTBcXHUwMEM0XFx1MDFERVxcdTFFQTJcXHUwMEM1XFx1MDFGQVxcdTAxQ0RcXHUwMjAwXFx1MDIwMlxcdTFFQTBcXHUxRUFDXFx1MUVCNlxcdTFFMDBcXHUwMTA0XFx1MDIzQVxcdTJDNkZdL2cgfSwgeyAnYmFzZSc6ICdBQScsICdsZXR0ZXJzJzogL1tcXHVBNzMyXS9nIH0sIHsgJ2Jhc2UnOiAnQUUnLCAnbGV0dGVycyc6IC9bXFx1MDBDNlxcdTAxRkNcXHUwMUUyXS9nIH0sIHsgJ2Jhc2UnOiAnQU8nLCAnbGV0dGVycyc6IC9bXFx1QTczNF0vZyB9LCB7ICdiYXNlJzogJ0FVJywgJ2xldHRlcnMnOiAvW1xcdUE3MzZdL2cgfSwgeyAnYmFzZSc6ICdBVicsICdsZXR0ZXJzJzogL1tcXHVBNzM4XFx1QTczQV0vZyB9LCB7ICdiYXNlJzogJ0FZJywgJ2xldHRlcnMnOiAvW1xcdUE3M0NdL2cgfSwgeyAnYmFzZSc6ICdCJywgJ2xldHRlcnMnOiAvW1xcdTAwNDJcXHUyNEI3XFx1RkYyMlxcdTFFMDJcXHUxRTA0XFx1MUUwNlxcdTAyNDNcXHUwMTgyXFx1MDE4MV0vZyB9LCB7ICdiYXNlJzogJ0MnLCAnbGV0dGVycyc6IC9bXFx1MDA0M1xcdTI0QjhcXHVGRjIzXFx1MDEwNlxcdTAxMDhcXHUwMTBBXFx1MDEwQ1xcdTAwQzdcXHUxRTA4XFx1MDE4N1xcdTAyM0JcXHVBNzNFXS9nIH0sIHsgJ2Jhc2UnOiAnRCcsICdsZXR0ZXJzJzogL1tcXHUwMDQ0XFx1MjRCOVxcdUZGMjRcXHUxRTBBXFx1MDEwRVxcdTFFMENcXHUxRTEwXFx1MUUxMlxcdTFFMEVcXHUwMTEwXFx1MDE4QlxcdTAxOEFcXHUwMTg5XFx1QTc3OV0vZyB9LCB7ICdiYXNlJzogJ0RaJywgJ2xldHRlcnMnOiAvW1xcdTAxRjFcXHUwMUM0XS9nIH0sIHsgJ2Jhc2UnOiAnRHonLCAnbGV0dGVycyc6IC9bXFx1MDFGMlxcdTAxQzVdL2cgfSwgeyAnYmFzZSc6ICdFJywgJ2xldHRlcnMnOiAvW1xcdTAwNDVcXHUyNEJBXFx1RkYyNVxcdTAwQzhcXHUwMEM5XFx1MDBDQVxcdTFFQzBcXHUxRUJFXFx1MUVDNFxcdTFFQzJcXHUxRUJDXFx1MDExMlxcdTFFMTRcXHUxRTE2XFx1MDExNFxcdTAxMTZcXHUwMENCXFx1MUVCQVxcdTAxMUFcXHUwMjA0XFx1MDIwNlxcdTFFQjhcXHUxRUM2XFx1MDIyOFxcdTFFMUNcXHUwMTE4XFx1MUUxOFxcdTFFMUFcXHUwMTkwXFx1MDE4RV0vZyB9LCB7ICdiYXNlJzogJ0YnLCAnbGV0dGVycyc6IC9bXFx1MDA0NlxcdTI0QkJcXHVGRjI2XFx1MUUxRVxcdTAxOTFcXHVBNzdCXS9nIH0sIHsgJ2Jhc2UnOiAnRycsICdsZXR0ZXJzJzogL1tcXHUwMDQ3XFx1MjRCQ1xcdUZGMjdcXHUwMUY0XFx1MDExQ1xcdTFFMjBcXHUwMTFFXFx1MDEyMFxcdTAxRTZcXHUwMTIyXFx1MDFFNFxcdTAxOTNcXHVBN0EwXFx1QTc3RFxcdUE3N0VdL2cgfSwgeyAnYmFzZSc6ICdIJywgJ2xldHRlcnMnOiAvW1xcdTAwNDhcXHUyNEJEXFx1RkYyOFxcdTAxMjRcXHUxRTIyXFx1MUUyNlxcdTAyMUVcXHUxRTI0XFx1MUUyOFxcdTFFMkFcXHUwMTI2XFx1MkM2N1xcdTJDNzVcXHVBNzhEXS9nIH0sIHsgJ2Jhc2UnOiAnSScsICdsZXR0ZXJzJzogL1tcXHUwMDQ5XFx1MjRCRVxcdUZGMjlcXHUwMENDXFx1MDBDRFxcdTAwQ0VcXHUwMTI4XFx1MDEyQVxcdTAxMkNcXHUwMTMwXFx1MDBDRlxcdTFFMkVcXHUxRUM4XFx1MDFDRlxcdTAyMDhcXHUwMjBBXFx1MUVDQVxcdTAxMkVcXHUxRTJDXFx1MDE5N10vZyB9LCB7ICdiYXNlJzogJ0onLCAnbGV0dGVycyc6IC9bXFx1MDA0QVxcdTI0QkZcXHVGRjJBXFx1MDEzNFxcdTAyNDhdL2cgfSwgeyAnYmFzZSc6ICdLJywgJ2xldHRlcnMnOiAvW1xcdTAwNEJcXHUyNEMwXFx1RkYyQlxcdTFFMzBcXHUwMUU4XFx1MUUzMlxcdTAxMzZcXHUxRTM0XFx1MDE5OFxcdTJDNjlcXHVBNzQwXFx1QTc0MlxcdUE3NDRcXHVBN0EyXS9nIH0sIHsgJ2Jhc2UnOiAnTCcsICdsZXR0ZXJzJzogL1tcXHUwMDRDXFx1MjRDMVxcdUZGMkNcXHUwMTNGXFx1MDEzOVxcdTAxM0RcXHUxRTM2XFx1MUUzOFxcdTAxM0JcXHUxRTNDXFx1MUUzQVxcdTAxNDFcXHUwMjNEXFx1MkM2MlxcdTJDNjBcXHVBNzQ4XFx1QTc0NlxcdUE3ODBdL2cgfSwgeyAnYmFzZSc6ICdMSicsICdsZXR0ZXJzJzogL1tcXHUwMUM3XS9nIH0sIHsgJ2Jhc2UnOiAnTGonLCAnbGV0dGVycyc6IC9bXFx1MDFDOF0vZyB9LCB7ICdiYXNlJzogJ00nLCAnbGV0dGVycyc6IC9bXFx1MDA0RFxcdTI0QzJcXHVGRjJEXFx1MUUzRVxcdTFFNDBcXHUxRTQyXFx1MkM2RVxcdTAxOUNdL2cgfSwgeyAnYmFzZSc6ICdOJywgJ2xldHRlcnMnOiAvW1xcdTAwNEVcXHUyNEMzXFx1RkYyRVxcdTAxRjhcXHUwMTQzXFx1MDBEMVxcdTFFNDRcXHUwMTQ3XFx1MUU0NlxcdTAxNDVcXHUxRTRBXFx1MUU0OFxcdTAyMjBcXHUwMTlEXFx1QTc5MFxcdUE3QTRdL2cgfSwgeyAnYmFzZSc6ICdOSicsICdsZXR0ZXJzJzogL1tcXHUwMUNBXS9nIH0sIHsgJ2Jhc2UnOiAnTmonLCAnbGV0dGVycyc6IC9bXFx1MDFDQl0vZyB9LCB7ICdiYXNlJzogJ08nLCAnbGV0dGVycyc6IC9bXFx1MDA0RlxcdTI0QzRcXHVGRjJGXFx1MDBEMlxcdTAwRDNcXHUwMEQ0XFx1MUVEMlxcdTFFRDBcXHUxRUQ2XFx1MUVENFxcdTAwRDVcXHUxRTRDXFx1MDIyQ1xcdTFFNEVcXHUwMTRDXFx1MUU1MFxcdTFFNTJcXHUwMTRFXFx1MDIyRVxcdTAyMzBcXHUwMEQ2XFx1MDIyQVxcdTFFQ0VcXHUwMTUwXFx1MDFEMVxcdTAyMENcXHUwMjBFXFx1MDFBMFxcdTFFRENcXHUxRURBXFx1MUVFMFxcdTFFREVcXHUxRUUyXFx1MUVDQ1xcdTFFRDhcXHUwMUVBXFx1MDFFQ1xcdTAwRDhcXHUwMUZFXFx1MDE4NlxcdTAxOUZcXHVBNzRBXFx1QTc0Q10vZyB9LCB7ICdiYXNlJzogJ09JJywgJ2xldHRlcnMnOiAvW1xcdTAxQTJdL2cgfSwgeyAnYmFzZSc6ICdPTycsICdsZXR0ZXJzJzogL1tcXHVBNzRFXS9nIH0sIHsgJ2Jhc2UnOiAnT1UnLCAnbGV0dGVycyc6IC9bXFx1MDIyMl0vZyB9LCB7ICdiYXNlJzogJ1AnLCAnbGV0dGVycyc6IC9bXFx1MDA1MFxcdTI0QzVcXHVGRjMwXFx1MUU1NFxcdTFFNTZcXHUwMUE0XFx1MkM2M1xcdUE3NTBcXHVBNzUyXFx1QTc1NF0vZyB9LCB7ICdiYXNlJzogJ1EnLCAnbGV0dGVycyc6IC9bXFx1MDA1MVxcdTI0QzZcXHVGRjMxXFx1QTc1NlxcdUE3NThcXHUwMjRBXS9nIH0sIHsgJ2Jhc2UnOiAnUicsICdsZXR0ZXJzJzogL1tcXHUwMDUyXFx1MjRDN1xcdUZGMzJcXHUwMTU0XFx1MUU1OFxcdTAxNThcXHUwMjEwXFx1MDIxMlxcdTFFNUFcXHUxRTVDXFx1MDE1NlxcdTFFNUVcXHUwMjRDXFx1MkM2NFxcdUE3NUFcXHVBN0E2XFx1QTc4Ml0vZyB9LCB7ICdiYXNlJzogJ1MnLCAnbGV0dGVycyc6IC9bXFx1MDA1M1xcdTI0QzhcXHVGRjMzXFx1MUU5RVxcdTAxNUFcXHUxRTY0XFx1MDE1Q1xcdTFFNjBcXHUwMTYwXFx1MUU2NlxcdTFFNjJcXHUxRTY4XFx1MDIxOFxcdTAxNUVcXHUyQzdFXFx1QTdBOFxcdUE3ODRdL2cgfSwgeyAnYmFzZSc6ICdUJywgJ2xldHRlcnMnOiAvW1xcdTAwNTRcXHUyNEM5XFx1RkYzNFxcdTFFNkFcXHUwMTY0XFx1MUU2Q1xcdTAyMUFcXHUwMTYyXFx1MUU3MFxcdTFFNkVcXHUwMTY2XFx1MDFBQ1xcdTAxQUVcXHUwMjNFXFx1QTc4Nl0vZyB9LCB7ICdiYXNlJzogJ1RaJywgJ2xldHRlcnMnOiAvW1xcdUE3MjhdL2cgfSwgeyAnYmFzZSc6ICdVJywgJ2xldHRlcnMnOiAvW1xcdTAwNTVcXHUyNENBXFx1RkYzNVxcdTAwRDlcXHUwMERBXFx1MDBEQlxcdTAxNjhcXHUxRTc4XFx1MDE2QVxcdTFFN0FcXHUwMTZDXFx1MDBEQ1xcdTAxREJcXHUwMUQ3XFx1MDFENVxcdTAxRDlcXHUxRUU2XFx1MDE2RVxcdTAxNzBcXHUwMUQzXFx1MDIxNFxcdTAyMTZcXHUwMUFGXFx1MUVFQVxcdTFFRThcXHUxRUVFXFx1MUVFQ1xcdTFFRjBcXHUxRUU0XFx1MUU3MlxcdTAxNzJcXHUxRTc2XFx1MUU3NFxcdTAyNDRdL2cgfSwgeyAnYmFzZSc6ICdWJywgJ2xldHRlcnMnOiAvW1xcdTAwNTZcXHUyNENCXFx1RkYzNlxcdTFFN0NcXHUxRTdFXFx1MDFCMlxcdUE3NUVcXHUwMjQ1XS9nIH0sIHsgJ2Jhc2UnOiAnVlknLCAnbGV0dGVycyc6IC9bXFx1QTc2MF0vZyB9LCB7ICdiYXNlJzogJ1cnLCAnbGV0dGVycyc6IC9bXFx1MDA1N1xcdTI0Q0NcXHVGRjM3XFx1MUU4MFxcdTFFODJcXHUwMTc0XFx1MUU4NlxcdTFFODRcXHUxRTg4XFx1MkM3Ml0vZyB9LCB7ICdiYXNlJzogJ1gnLCAnbGV0dGVycyc6IC9bXFx1MDA1OFxcdTI0Q0RcXHVGRjM4XFx1MUU4QVxcdTFFOENdL2cgfSwgeyAnYmFzZSc6ICdZJywgJ2xldHRlcnMnOiAvW1xcdTAwNTlcXHUyNENFXFx1RkYzOVxcdTFFRjJcXHUwMEREXFx1MDE3NlxcdTFFRjhcXHUwMjMyXFx1MUU4RVxcdTAxNzhcXHUxRUY2XFx1MUVGNFxcdTAxQjNcXHUwMjRFXFx1MUVGRV0vZyB9LCB7ICdiYXNlJzogJ1onLCAnbGV0dGVycyc6IC9bXFx1MDA1QVxcdTI0Q0ZcXHVGRjNBXFx1MDE3OVxcdTFFOTBcXHUwMTdCXFx1MDE3RFxcdTFFOTJcXHUxRTk0XFx1MDFCNVxcdTAyMjRcXHUyQzdGXFx1MkM2QlxcdUE3NjJdL2cgfSwgeyAnYmFzZSc6ICdhJywgJ2xldHRlcnMnOiAvW1xcdTAwNjFcXHUyNEQwXFx1RkY0MVxcdTFFOUFcXHUwMEUwXFx1MDBFMVxcdTAwRTJcXHUxRUE3XFx1MUVBNVxcdTFFQUJcXHUxRUE5XFx1MDBFM1xcdTAxMDFcXHUwMTAzXFx1MUVCMVxcdTFFQUZcXHUxRUI1XFx1MUVCM1xcdTAyMjdcXHUwMUUxXFx1MDBFNFxcdTAxREZcXHUxRUEzXFx1MDBFNVxcdTAxRkJcXHUwMUNFXFx1MDIwMVxcdTAyMDNcXHUxRUExXFx1MUVBRFxcdTFFQjdcXHUxRTAxXFx1MDEwNVxcdTJDNjVcXHUwMjUwXS9nIH0sIHsgJ2Jhc2UnOiAnYWEnLCAnbGV0dGVycyc6IC9bXFx1QTczM10vZyB9LCB7ICdiYXNlJzogJ2FlJywgJ2xldHRlcnMnOiAvW1xcdTAwRTZcXHUwMUZEXFx1MDFFM10vZyB9LCB7ICdiYXNlJzogJ2FvJywgJ2xldHRlcnMnOiAvW1xcdUE3MzVdL2cgfSwgeyAnYmFzZSc6ICdhdScsICdsZXR0ZXJzJzogL1tcXHVBNzM3XS9nIH0sIHsgJ2Jhc2UnOiAnYXYnLCAnbGV0dGVycyc6IC9bXFx1QTczOVxcdUE3M0JdL2cgfSwgeyAnYmFzZSc6ICdheScsICdsZXR0ZXJzJzogL1tcXHVBNzNEXS9nIH0sIHsgJ2Jhc2UnOiAnYicsICdsZXR0ZXJzJzogL1tcXHUwMDYyXFx1MjREMVxcdUZGNDJcXHUxRTAzXFx1MUUwNVxcdTFFMDdcXHUwMTgwXFx1MDE4M1xcdTAyNTNdL2cgfSwgeyAnYmFzZSc6ICdjJywgJ2xldHRlcnMnOiAvW1xcdTAwNjNcXHUyNEQyXFx1RkY0M1xcdTAxMDdcXHUwMTA5XFx1MDEwQlxcdTAxMERcXHUwMEU3XFx1MUUwOVxcdTAxODhcXHUwMjNDXFx1QTczRlxcdTIxODRdL2cgfSwgeyAnYmFzZSc6ICdkJywgJ2xldHRlcnMnOiAvW1xcdTAwNjRcXHUyNEQzXFx1RkY0NFxcdTFFMEJcXHUwMTBGXFx1MUUwRFxcdTFFMTFcXHUxRTEzXFx1MUUwRlxcdTAxMTFcXHUwMThDXFx1MDI1NlxcdTAyNTdcXHVBNzdBXS9nIH0sIHsgJ2Jhc2UnOiAnZHonLCAnbGV0dGVycyc6IC9bXFx1MDFGM1xcdTAxQzZdL2cgfSwgeyAnYmFzZSc6ICdlJywgJ2xldHRlcnMnOiAvW1xcdTAwNjVcXHUyNEQ0XFx1RkY0NVxcdTAwRThcXHUwMEU5XFx1MDBFQVxcdTFFQzFcXHUxRUJGXFx1MUVDNVxcdTFFQzNcXHUxRUJEXFx1MDExM1xcdTFFMTVcXHUxRTE3XFx1MDExNVxcdTAxMTdcXHUwMEVCXFx1MUVCQlxcdTAxMUJcXHUwMjA1XFx1MDIwN1xcdTFFQjlcXHUxRUM3XFx1MDIyOVxcdTFFMURcXHUwMTE5XFx1MUUxOVxcdTFFMUJcXHUwMjQ3XFx1MDI1QlxcdTAxRERdL2cgfSwgeyAnYmFzZSc6ICdmJywgJ2xldHRlcnMnOiAvW1xcdTAwNjZcXHUyNEQ1XFx1RkY0NlxcdTFFMUZcXHUwMTkyXFx1QTc3Q10vZyB9LCB7ICdiYXNlJzogJ2cnLCAnbGV0dGVycyc6IC9bXFx1MDA2N1xcdTI0RDZcXHVGRjQ3XFx1MDFGNVxcdTAxMURcXHUxRTIxXFx1MDExRlxcdTAxMjFcXHUwMUU3XFx1MDEyM1xcdTAxRTVcXHUwMjYwXFx1QTdBMVxcdTFENzlcXHVBNzdGXS9nIH0sIHsgJ2Jhc2UnOiAnaCcsICdsZXR0ZXJzJzogL1tcXHUwMDY4XFx1MjREN1xcdUZGNDhcXHUwMTI1XFx1MUUyM1xcdTFFMjdcXHUwMjFGXFx1MUUyNVxcdTFFMjlcXHUxRTJCXFx1MUU5NlxcdTAxMjdcXHUyQzY4XFx1MkM3NlxcdTAyNjVdL2cgfSwgeyAnYmFzZSc6ICdodicsICdsZXR0ZXJzJzogL1tcXHUwMTk1XS9nIH0sIHsgJ2Jhc2UnOiAnaScsICdsZXR0ZXJzJzogL1tcXHUwMDY5XFx1MjREOFxcdUZGNDlcXHUwMEVDXFx1MDBFRFxcdTAwRUVcXHUwMTI5XFx1MDEyQlxcdTAxMkRcXHUwMEVGXFx1MUUyRlxcdTFFQzlcXHUwMUQwXFx1MDIwOVxcdTAyMEJcXHUxRUNCXFx1MDEyRlxcdTFFMkRcXHUwMjY4XFx1MDEzMV0vZyB9LCB7ICdiYXNlJzogJ2onLCAnbGV0dGVycyc6IC9bXFx1MDA2QVxcdTI0RDlcXHVGRjRBXFx1MDEzNVxcdTAxRjBcXHUwMjQ5XS9nIH0sIHsgJ2Jhc2UnOiAnaycsICdsZXR0ZXJzJzogL1tcXHUwMDZCXFx1MjREQVxcdUZGNEJcXHUxRTMxXFx1MDFFOVxcdTFFMzNcXHUwMTM3XFx1MUUzNVxcdTAxOTlcXHUyQzZBXFx1QTc0MVxcdUE3NDNcXHVBNzQ1XFx1QTdBM10vZyB9LCB7ICdiYXNlJzogJ2wnLCAnbGV0dGVycyc6IC9bXFx1MDA2Q1xcdTI0REJcXHVGRjRDXFx1MDE0MFxcdTAxM0FcXHUwMTNFXFx1MUUzN1xcdTFFMzlcXHUwMTNDXFx1MUUzRFxcdTFFM0JcXHUwMTdGXFx1MDE0MlxcdTAxOUFcXHUwMjZCXFx1MkM2MVxcdUE3NDlcXHVBNzgxXFx1QTc0N10vZyB9LCB7ICdiYXNlJzogJ2xqJywgJ2xldHRlcnMnOiAvW1xcdTAxQzldL2cgfSwgeyAnYmFzZSc6ICdtJywgJ2xldHRlcnMnOiAvW1xcdTAwNkRcXHUyNERDXFx1RkY0RFxcdTFFM0ZcXHUxRTQxXFx1MUU0M1xcdTAyNzFcXHUwMjZGXS9nIH0sIHsgJ2Jhc2UnOiAnbicsICdsZXR0ZXJzJzogL1tcXHUwMDZFXFx1MjRERFxcdUZGNEVcXHUwMUY5XFx1MDE0NFxcdTAwRjFcXHUxRTQ1XFx1MDE0OFxcdTFFNDdcXHUwMTQ2XFx1MUU0QlxcdTFFNDlcXHUwMTlFXFx1MDI3MlxcdTAxNDlcXHVBNzkxXFx1QTdBNV0vZyB9LCB7ICdiYXNlJzogJ25qJywgJ2xldHRlcnMnOiAvW1xcdTAxQ0NdL2cgfSwgeyAnYmFzZSc6ICdvJywgJ2xldHRlcnMnOiAvW1xcdTAwNkZcXHUyNERFXFx1RkY0RlxcdTAwRjJcXHUwMEYzXFx1MDBGNFxcdTFFRDNcXHUxRUQxXFx1MUVEN1xcdTFFRDVcXHUwMEY1XFx1MUU0RFxcdTAyMkRcXHUxRTRGXFx1MDE0RFxcdTFFNTFcXHUxRTUzXFx1MDE0RlxcdTAyMkZcXHUwMjMxXFx1MDBGNlxcdTAyMkJcXHUxRUNGXFx1MDE1MVxcdTAxRDJcXHUwMjBEXFx1MDIwRlxcdTAxQTFcXHUxRUREXFx1MUVEQlxcdTFFRTFcXHUxRURGXFx1MUVFM1xcdTFFQ0RcXHUxRUQ5XFx1MDFFQlxcdTAxRURcXHUwMEY4XFx1MDFGRlxcdTAyNTRcXHVBNzRCXFx1QTc0RFxcdTAyNzVdL2cgfSwgeyAnYmFzZSc6ICdvaScsICdsZXR0ZXJzJzogL1tcXHUwMUEzXS9nIH0sIHsgJ2Jhc2UnOiAnb3UnLCAnbGV0dGVycyc6IC9bXFx1MDIyM10vZyB9LCB7ICdiYXNlJzogJ29vJywgJ2xldHRlcnMnOiAvW1xcdUE3NEZdL2cgfSwgeyAnYmFzZSc6ICdwJywgJ2xldHRlcnMnOiAvW1xcdTAwNzBcXHUyNERGXFx1RkY1MFxcdTFFNTVcXHUxRTU3XFx1MDFBNVxcdTFEN0RcXHVBNzUxXFx1QTc1M1xcdUE3NTVdL2cgfSwgeyAnYmFzZSc6ICdxJywgJ2xldHRlcnMnOiAvW1xcdTAwNzFcXHUyNEUwXFx1RkY1MVxcdTAyNEJcXHVBNzU3XFx1QTc1OV0vZyB9LCB7ICdiYXNlJzogJ3InLCAnbGV0dGVycyc6IC9bXFx1MDA3MlxcdTI0RTFcXHVGRjUyXFx1MDE1NVxcdTFFNTlcXHUwMTU5XFx1MDIxMVxcdTAyMTNcXHUxRTVCXFx1MUU1RFxcdTAxNTdcXHUxRTVGXFx1MDI0RFxcdTAyN0RcXHVBNzVCXFx1QTdBN1xcdUE3ODNdL2cgfSwgeyAnYmFzZSc6ICdzJywgJ2xldHRlcnMnOiAvW1xcdTAwNzNcXHUyNEUyXFx1RkY1M1xcdTAwREZcXHUwMTVCXFx1MUU2NVxcdTAxNURcXHUxRTYxXFx1MDE2MVxcdTFFNjdcXHUxRTYzXFx1MUU2OVxcdTAyMTlcXHUwMTVGXFx1MDIzRlxcdUE3QTlcXHVBNzg1XFx1MUU5Ql0vZyB9LCB7ICdiYXNlJzogJ3QnLCAnbGV0dGVycyc6IC9bXFx1MDA3NFxcdTI0RTNcXHVGRjU0XFx1MUU2QlxcdTFFOTdcXHUwMTY1XFx1MUU2RFxcdTAyMUJcXHUwMTYzXFx1MUU3MVxcdTFFNkZcXHUwMTY3XFx1MDFBRFxcdTAyODhcXHUyQzY2XFx1QTc4N10vZyB9LCB7ICdiYXNlJzogJ3R6JywgJ2xldHRlcnMnOiAvW1xcdUE3MjldL2cgfSwgeyAnYmFzZSc6ICd1JywgJ2xldHRlcnMnOiAvW1xcdTAwNzVcXHUyNEU0XFx1RkY1NVxcdTAwRjlcXHUwMEZBXFx1MDBGQlxcdTAxNjlcXHUxRTc5XFx1MDE2QlxcdTFFN0JcXHUwMTZEXFx1MDBGQ1xcdTAxRENcXHUwMUQ4XFx1MDFENlxcdTAxREFcXHUxRUU3XFx1MDE2RlxcdTAxNzFcXHUwMUQ0XFx1MDIxNVxcdTAyMTdcXHUwMUIwXFx1MUVFQlxcdTFFRTlcXHUxRUVGXFx1MUVFRFxcdTFFRjFcXHUxRUU1XFx1MUU3M1xcdTAxNzNcXHUxRTc3XFx1MUU3NVxcdTAyODldL2cgfSwgeyAnYmFzZSc6ICd2JywgJ2xldHRlcnMnOiAvW1xcdTAwNzZcXHUyNEU1XFx1RkY1NlxcdTFFN0RcXHUxRTdGXFx1MDI4QlxcdUE3NUZcXHUwMjhDXS9nIH0sIHsgJ2Jhc2UnOiAndnknLCAnbGV0dGVycyc6IC9bXFx1QTc2MV0vZyB9LCB7ICdiYXNlJzogJ3cnLCAnbGV0dGVycyc6IC9bXFx1MDA3N1xcdTI0RTZcXHVGRjU3XFx1MUU4MVxcdTFFODNcXHUwMTc1XFx1MUU4N1xcdTFFODVcXHUxRTk4XFx1MUU4OVxcdTJDNzNdL2cgfSwgeyAnYmFzZSc6ICd4JywgJ2xldHRlcnMnOiAvW1xcdTAwNzhcXHUyNEU3XFx1RkY1OFxcdTFFOEJcXHUxRThEXS9nIH0sIHsgJ2Jhc2UnOiAneScsICdsZXR0ZXJzJzogL1tcXHUwMDc5XFx1MjRFOFxcdUZGNTlcXHUxRUYzXFx1MDBGRFxcdTAxNzdcXHUxRUY5XFx1MDIzM1xcdTFFOEZcXHUwMEZGXFx1MUVGN1xcdTFFOTlcXHUxRUY1XFx1MDFCNFxcdTAyNEZcXHUxRUZGXS9nIH0sIHsgJ2Jhc2UnOiAneicsICdsZXR0ZXJzJzogL1tcXHUwMDdBXFx1MjRFOVxcdUZGNUFcXHUwMTdBXFx1MUU5MVxcdTAxN0NcXHUwMTdFXFx1MUU5M1xcdTFFOTVcXHUwMUI2XFx1MDIyNVxcdTAyNDBcXHUyQzZDXFx1QTc2M10vZyB9XTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdHJpcERpYWNyaXRpY3Moc3RyKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmxlbmd0aDsgaSsrKSB7XG5cdFx0c3RyID0gc3RyLnJlcGxhY2UobWFwW2ldLmxldHRlcnMsIG1hcFtpXS5iYXNlKTtcblx0fVxuXHRyZXR1cm4gc3RyO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9zdHJpcERpYWNyaXRpY3MgPSByZXF1aXJlKCcuL3N0cmlwRGlhY3JpdGljcycpO1xuXG52YXIgX3N0cmlwRGlhY3JpdGljczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHJpcERpYWNyaXRpY3MpO1xuXG5mdW5jdGlvbiBmaWx0ZXJPcHRpb25zKG9wdGlvbnMsIGZpbHRlclZhbHVlLCBleGNsdWRlT3B0aW9ucywgcHJvcHMpIHtcblx0dmFyIF90aGlzID0gdGhpcztcblxuXHRpZiAocHJvcHMuaWdub3JlQWNjZW50cykge1xuXHRcdGZpbHRlclZhbHVlID0gKDAsIF9zdHJpcERpYWNyaXRpY3MyWydkZWZhdWx0J10pKGZpbHRlclZhbHVlKTtcblx0fVxuXG5cdGlmIChwcm9wcy5pZ25vcmVDYXNlKSB7XG5cdFx0ZmlsdGVyVmFsdWUgPSBmaWx0ZXJWYWx1ZS50b0xvd2VyQ2FzZSgpO1xuXHR9XG5cblx0aWYgKGV4Y2x1ZGVPcHRpb25zKSBleGNsdWRlT3B0aW9ucyA9IGV4Y2x1ZGVPcHRpb25zLm1hcChmdW5jdGlvbiAoaSkge1xuXHRcdHJldHVybiBpW3Byb3BzLnZhbHVlS2V5XTtcblx0fSk7XG5cblx0cmV0dXJuIG9wdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChvcHRpb24pIHtcblx0XHRpZiAoZXhjbHVkZU9wdGlvbnMgJiYgZXhjbHVkZU9wdGlvbnMuaW5kZXhPZihvcHRpb25bcHJvcHMudmFsdWVLZXldKSA+IC0xKSByZXR1cm4gZmFsc2U7XG5cdFx0aWYgKHByb3BzLmZpbHRlck9wdGlvbikgcmV0dXJuIHByb3BzLmZpbHRlck9wdGlvbi5jYWxsKF90aGlzLCBvcHRpb24sIGZpbHRlclZhbHVlKTtcblx0XHRpZiAoIWZpbHRlclZhbHVlKSByZXR1cm4gdHJ1ZTtcblx0XHR2YXIgdmFsdWVUZXN0ID0gU3RyaW5nKG9wdGlvbltwcm9wcy52YWx1ZUtleV0pO1xuXHRcdHZhciBsYWJlbFRlc3QgPSBTdHJpbmcob3B0aW9uW3Byb3BzLmxhYmVsS2V5XSk7XG5cdFx0aWYgKHByb3BzLmlnbm9yZUFjY2VudHMpIHtcblx0XHRcdGlmIChwcm9wcy5tYXRjaFByb3AgIT09ICdsYWJlbCcpIHZhbHVlVGVzdCA9ICgwLCBfc3RyaXBEaWFjcml0aWNzMlsnZGVmYXVsdCddKSh2YWx1ZVRlc3QpO1xuXHRcdFx0aWYgKHByb3BzLm1hdGNoUHJvcCAhPT0gJ3ZhbHVlJykgbGFiZWxUZXN0ID0gKDAsIF9zdHJpcERpYWNyaXRpY3MyWydkZWZhdWx0J10pKGxhYmVsVGVzdCk7XG5cdFx0fVxuXHRcdGlmIChwcm9wcy5pZ25vcmVDYXNlKSB7XG5cdFx0XHRpZiAocHJvcHMubWF0Y2hQcm9wICE9PSAnbGFiZWwnKSB2YWx1ZVRlc3QgPSB2YWx1ZVRlc3QudG9Mb3dlckNhc2UoKTtcblx0XHRcdGlmIChwcm9wcy5tYXRjaFByb3AgIT09ICd2YWx1ZScpIGxhYmVsVGVzdCA9IGxhYmVsVGVzdC50b0xvd2VyQ2FzZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcHJvcHMubWF0Y2hQb3MgPT09ICdzdGFydCcgPyBwcm9wcy5tYXRjaFByb3AgIT09ICdsYWJlbCcgJiYgdmFsdWVUZXN0LnN1YnN0cigwLCBmaWx0ZXJWYWx1ZS5sZW5ndGgpID09PSBmaWx0ZXJWYWx1ZSB8fCBwcm9wcy5tYXRjaFByb3AgIT09ICd2YWx1ZScgJiYgbGFiZWxUZXN0LnN1YnN0cigwLCBmaWx0ZXJWYWx1ZS5sZW5ndGgpID09PSBmaWx0ZXJWYWx1ZSA6IHByb3BzLm1hdGNoUHJvcCAhPT0gJ2xhYmVsJyAmJiB2YWx1ZVRlc3QuaW5kZXhPZihmaWx0ZXJWYWx1ZSkgPj0gMCB8fCBwcm9wcy5tYXRjaFByb3AgIT09ICd2YWx1ZScgJiYgbGFiZWxUZXN0LmluZGV4T2YoZmlsdGVyVmFsdWUpID49IDA7XG5cdH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbHRlck9wdGlvbnM7IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxudmFyIF9jbGFzc25hbWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbmFtZXMpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbmZ1bmN0aW9uIG1lbnVSZW5kZXJlcihfcmVmKSB7XG5cdHZhciBmb2N1c2VkT3B0aW9uID0gX3JlZi5mb2N1c2VkT3B0aW9uO1xuXHR2YXIgaW5zdGFuY2VQcmVmaXggPSBfcmVmLmluc3RhbmNlUHJlZml4O1xuXHR2YXIgbGFiZWxLZXkgPSBfcmVmLmxhYmVsS2V5O1xuXHR2YXIgb25Gb2N1cyA9IF9yZWYub25Gb2N1cztcblx0dmFyIG9uU2VsZWN0ID0gX3JlZi5vblNlbGVjdDtcblx0dmFyIG9wdGlvbkNsYXNzTmFtZSA9IF9yZWYub3B0aW9uQ2xhc3NOYW1lO1xuXHR2YXIgb3B0aW9uQ29tcG9uZW50ID0gX3JlZi5vcHRpb25Db21wb25lbnQ7XG5cdHZhciBvcHRpb25SZW5kZXJlciA9IF9yZWYub3B0aW9uUmVuZGVyZXI7XG5cdHZhciBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuXHR2YXIgdmFsdWVBcnJheSA9IF9yZWYudmFsdWVBcnJheTtcblx0dmFyIHZhbHVlS2V5ID0gX3JlZi52YWx1ZUtleTtcblx0dmFyIG9uT3B0aW9uUmVmID0gX3JlZi5vbk9wdGlvblJlZjtcblxuXHR2YXIgT3B0aW9uID0gb3B0aW9uQ29tcG9uZW50O1xuXG5cdHJldHVybiBvcHRpb25zLm1hcChmdW5jdGlvbiAob3B0aW9uLCBpKSB7XG5cdFx0dmFyIGlzU2VsZWN0ZWQgPSB2YWx1ZUFycmF5ICYmIHZhbHVlQXJyYXkuaW5kZXhPZihvcHRpb24pID4gLTE7XG5cdFx0dmFyIGlzRm9jdXNlZCA9IG9wdGlvbiA9PT0gZm9jdXNlZE9wdGlvbjtcblx0XHR2YXIgb3B0aW9uQ2xhc3MgPSAoMCwgX2NsYXNzbmFtZXMyWydkZWZhdWx0J10pKG9wdGlvbkNsYXNzTmFtZSwge1xuXHRcdFx0J1NlbGVjdC1vcHRpb24nOiB0cnVlLFxuXHRcdFx0J2lzLXNlbGVjdGVkJzogaXNTZWxlY3RlZCxcblx0XHRcdCdpcy1mb2N1c2VkJzogaXNGb2N1c2VkLFxuXHRcdFx0J2lzLWRpc2FibGVkJzogb3B0aW9uLmRpc2FibGVkXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRPcHRpb24sXG5cdFx0XHR7XG5cdFx0XHRcdGNsYXNzTmFtZTogb3B0aW9uQ2xhc3MsXG5cdFx0XHRcdGluc3RhbmNlUHJlZml4OiBpbnN0YW5jZVByZWZpeCxcblx0XHRcdFx0aXNEaXNhYmxlZDogb3B0aW9uLmRpc2FibGVkLFxuXHRcdFx0XHRpc0ZvY3VzZWQ6IGlzRm9jdXNlZCxcblx0XHRcdFx0aXNTZWxlY3RlZDogaXNTZWxlY3RlZCxcblx0XHRcdFx0a2V5OiAnb3B0aW9uLScgKyBpICsgJy0nICsgb3B0aW9uW3ZhbHVlS2V5XSxcblx0XHRcdFx0b25Gb2N1czogb25Gb2N1cyxcblx0XHRcdFx0b25TZWxlY3Q6IG9uU2VsZWN0LFxuXHRcdFx0XHRvcHRpb246IG9wdGlvbixcblx0XHRcdFx0b3B0aW9uSW5kZXg6IGksXG5cdFx0XHRcdHJlZjogZnVuY3Rpb24gKHJlZikge1xuXHRcdFx0XHRcdG9uT3B0aW9uUmVmKHJlZiwgaXNGb2N1c2VkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdG9wdGlvblJlbmRlcmVyKG9wdGlvbiwgaSlcblx0XHQpO1xuXHR9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW51UmVuZGVyZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfU2VsZWN0ID0gcmVxdWlyZSgnLi9TZWxlY3QnKTtcblxudmFyIF9TZWxlY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU2VsZWN0KTtcblxudmFyIF91dGlsc1N0cmlwRGlhY3JpdGljcyA9IHJlcXVpcmUoJy4vdXRpbHMvc3RyaXBEaWFjcml0aWNzJyk7XG5cbnZhciBfdXRpbHNTdHJpcERpYWNyaXRpY3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHNTdHJpcERpYWNyaXRpY3MpO1xuXG52YXIgcHJvcFR5cGVzID0ge1xuXHRhdXRvbG9hZDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLmlzUmVxdWlyZWQsIC8vIGF1dG9tYXRpY2FsbHkgY2FsbCB0aGUgYGxvYWRPcHRpb25zYCBwcm9wIG9uLW1vdW50OyBkZWZhdWx0cyB0byB0cnVlXG5cdGNhY2hlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmFueSwgLy8gb2JqZWN0IHRvIHVzZSB0byBjYWNoZSByZXN1bHRzOyBzZXQgdG8gbnVsbC9mYWxzZSB0byBkaXNhYmxlIGNhY2hpbmdcblx0Y2hpbGRyZW46IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLCAvLyBDaGlsZCBmdW5jdGlvbiByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhlIGlubmVyIFNlbGVjdCBjb21wb25lbnQ7IChwcm9wczogT2JqZWN0KTogUHJvcFR5cGVzLmVsZW1lbnRcblx0aWdub3JlQWNjZW50czogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLCAvLyBzdHJpcCBkaWFjcml0aWNzIHdoZW4gZmlsdGVyaW5nOyBkZWZhdWx0cyB0byB0cnVlXG5cdGlnbm9yZUNhc2U6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCwgLy8gcGVyZm9ybSBjYXNlLWluc2Vuc2l0aXZlIGZpbHRlcmluZzsgZGVmYXVsdHMgdG8gdHJ1ZVxuXHRsb2FkaW5nUGxhY2Vob2xkZXI6IF9yZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsIC8vIHJlcGxhY2VzIHRoZSBwbGFjZWhvbGRlciB3aGlsZSBvcHRpb25zIGFyZSBsb2FkaW5nXG5cdGxvYWRPcHRpb25zOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCwgLy8gY2FsbGJhY2sgdG8gbG9hZCBvcHRpb25zIGFzeW5jaHJvbm91c2x5OyAoaW5wdXRWYWx1ZTogc3RyaW5nLCBjYWxsYmFjazogRnVuY3Rpb24pOiA/UHJvbWlzZVxuXHRvcHRpb25zOiBfcmVhY3QuUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWQsIC8vIGFycmF5IG9mIG9wdGlvbnNcblx0cGxhY2Vob2xkZXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub25lT2ZUeXBlKFsvLyBmaWVsZCBwbGFjZWhvbGRlciwgZGlzcGxheWVkIHdoZW4gdGhlcmUncyBubyB2YWx1ZSAoc2hhcmVkIHdpdGggU2VsZWN0KVxuXHRfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZywgX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ub2RlXSksXG5cdHNlYXJjaFByb21wdFRleHQ6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub25lT2ZUeXBlKFsvLyBsYWJlbCB0byBwcm9tcHQgZm9yIHNlYXJjaCBpbnB1dFxuXHRfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZywgX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ub2RlXSlcbn07XG5cbnZhciBkZWZhdWx0UHJvcHMgPSB7XG5cdGF1dG9sb2FkOiB0cnVlLFxuXHRjYWNoZToge30sXG5cdGNoaWxkcmVuOiBkZWZhdWx0Q2hpbGRyZW4sXG5cdGlnbm9yZUFjY2VudHM6IHRydWUsXG5cdGlnbm9yZUNhc2U6IHRydWUsXG5cdGxvYWRpbmdQbGFjZWhvbGRlcjogJ0xvYWRpbmcuLi4nLFxuXHRvcHRpb25zOiBbXSxcblx0c2VhcmNoUHJvbXB0VGV4dDogJ1R5cGUgdG8gc2VhcmNoJ1xufTtcblxudmFyIEFzeW5jID0gKGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG5cdF9pbmhlcml0cyhBc3luYywgX0NvbXBvbmVudCk7XG5cblx0ZnVuY3Rpb24gQXN5bmMocHJvcHMsIGNvbnRleHQpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXN5bmMpO1xuXG5cdFx0X2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoQXN5bmMucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCk7XG5cblx0XHR0aGlzLnN0YXRlID0ge1xuXHRcdFx0aXNMb2FkaW5nOiBmYWxzZSxcblx0XHRcdG9wdGlvbnM6IHByb3BzLm9wdGlvbnNcblx0XHR9O1xuXG5cdFx0dGhpcy5fb25JbnB1dENoYW5nZSA9IHRoaXMuX29uSW5wdXRDaGFuZ2UuYmluZCh0aGlzKTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhBc3luYywgW3tcblx0XHRrZXk6ICdjb21wb25lbnREaWRNb3VudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdFx0dmFyIGF1dG9sb2FkID0gdGhpcy5wcm9wcy5hdXRvbG9hZDtcblxuXHRcdFx0aWYgKGF1dG9sb2FkKSB7XG5cdFx0XHRcdHRoaXMubG9hZE9wdGlvbnMoJycpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2NvbXBvbmVudFdpbGxVcGRhdGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdFx0XHR2YXIgcHJvcGVydGllc1RvU3luYyA9IFsnb3B0aW9ucyddO1xuXHRcdFx0cHJvcGVydGllc1RvU3luYy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG5cdFx0XHRcdGlmIChfdGhpcy5wcm9wc1twcm9wXSAhPT0gbmV4dFByb3BzW3Byb3BdKSB7XG5cdFx0XHRcdFx0X3RoaXMuc2V0U3RhdGUoX2RlZmluZVByb3BlcnR5KHt9LCBwcm9wLCBuZXh0UHJvcHNbcHJvcF0pKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnbG9hZE9wdGlvbnMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBsb2FkT3B0aW9ucyhpbnB1dFZhbHVlKSB7XG5cdFx0XHR2YXIgX3RoaXMyID0gdGhpcztcblxuXHRcdFx0dmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG5cdFx0XHR2YXIgY2FjaGUgPSBfcHJvcHMuY2FjaGU7XG5cdFx0XHR2YXIgbG9hZE9wdGlvbnMgPSBfcHJvcHMubG9hZE9wdGlvbnM7XG5cblx0XHRcdGlmIChjYWNoZSAmJiBjYWNoZS5oYXNPd25Qcm9wZXJ0eShpbnB1dFZhbHVlKSkge1xuXHRcdFx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdFx0XHRvcHRpb25zOiBjYWNoZVtpbnB1dFZhbHVlXVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKGVycm9yLCBkYXRhKSB7XG5cdFx0XHRcdGlmIChjYWxsYmFjayA9PT0gX3RoaXMyLl9jYWxsYmFjaykge1xuXHRcdFx0XHRcdF90aGlzMi5fY2FsbGJhY2sgPSBudWxsO1xuXG5cdFx0XHRcdFx0dmFyIG9wdGlvbnMgPSBkYXRhICYmIGRhdGEub3B0aW9ucyB8fCBbXTtcblxuXHRcdFx0XHRcdGlmIChjYWNoZSkge1xuXHRcdFx0XHRcdFx0Y2FjaGVbaW5wdXRWYWx1ZV0gPSBvcHRpb25zO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF90aGlzMi5zZXRTdGF0ZSh7XG5cdFx0XHRcdFx0XHRpc0xvYWRpbmc6IGZhbHNlLFxuXHRcdFx0XHRcdFx0b3B0aW9uczogb3B0aW9uc1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBJZ25vcmUgYWxsIGJ1dCB0aGUgbW9zdCByZWNlbnQgcmVxdWVzdFxuXHRcdFx0dGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdFx0dmFyIHByb21pc2UgPSBsb2FkT3B0aW9ucyhpbnB1dFZhbHVlLCBjYWxsYmFjayk7XG5cdFx0XHRpZiAocHJvbWlzZSkge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdFx0XHRyZXR1cm4gY2FsbGJhY2sobnVsbCwgZGF0YSk7XG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdHJldHVybiBjYWxsYmFjayhlcnJvcik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fY2FsbGJhY2sgJiYgIXRoaXMuc3RhdGUuaXNMb2FkaW5nKSB7XG5cdFx0XHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0XHRcdGlzTG9hZGluZzogdHJ1ZVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGlucHV0VmFsdWU7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnX29uSW5wdXRDaGFuZ2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBfb25JbnB1dENoYW5nZShpbnB1dFZhbHVlKSB7XG5cdFx0XHR2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHM7XG5cdFx0XHR2YXIgaWdub3JlQWNjZW50cyA9IF9wcm9wczIuaWdub3JlQWNjZW50cztcblx0XHRcdHZhciBpZ25vcmVDYXNlID0gX3Byb3BzMi5pZ25vcmVDYXNlO1xuXG5cdFx0XHRpZiAoaWdub3JlQWNjZW50cykge1xuXHRcdFx0XHRpbnB1dFZhbHVlID0gKDAsIF91dGlsc1N0cmlwRGlhY3JpdGljczJbJ2RlZmF1bHQnXSkoaW5wdXRWYWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpZ25vcmVDYXNlKSB7XG5cdFx0XHRcdGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmxvYWRPcHRpb25zKGlucHV0VmFsdWUpO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3JlbmRlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0XHRcdHZhciBfcHJvcHMzID0gdGhpcy5wcm9wcztcblx0XHRcdHZhciBjaGlsZHJlbiA9IF9wcm9wczMuY2hpbGRyZW47XG5cdFx0XHR2YXIgbG9hZGluZ1BsYWNlaG9sZGVyID0gX3Byb3BzMy5sb2FkaW5nUGxhY2Vob2xkZXI7XG5cdFx0XHR2YXIgcGxhY2Vob2xkZXIgPSBfcHJvcHMzLnBsYWNlaG9sZGVyO1xuXHRcdFx0dmFyIHNlYXJjaFByb21wdFRleHQgPSBfcHJvcHMzLnNlYXJjaFByb21wdFRleHQ7XG5cdFx0XHR2YXIgX3N0YXRlID0gdGhpcy5zdGF0ZTtcblx0XHRcdHZhciBpc0xvYWRpbmcgPSBfc3RhdGUuaXNMb2FkaW5nO1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBfc3RhdGUub3B0aW9ucztcblxuXHRcdFx0dmFyIHByb3BzID0ge1xuXHRcdFx0XHRub1Jlc3VsdHNUZXh0OiBpc0xvYWRpbmcgPyBsb2FkaW5nUGxhY2Vob2xkZXIgOiBzZWFyY2hQcm9tcHRUZXh0LFxuXHRcdFx0XHRwbGFjZWhvbGRlcjogaXNMb2FkaW5nID8gbG9hZGluZ1BsYWNlaG9sZGVyIDogcGxhY2Vob2xkZXIsXG5cdFx0XHRcdG9wdGlvbnM6IGlzTG9hZGluZyA/IFtdIDogb3B0aW9uc1xuXHRcdFx0fTtcblxuXHRcdFx0cmV0dXJuIGNoaWxkcmVuKF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLCBwcm9wcywge1xuXHRcdFx0XHRpc0xvYWRpbmc6IGlzTG9hZGluZyxcblx0XHRcdFx0b25JbnB1dENoYW5nZTogdGhpcy5fb25JbnB1dENoYW5nZVxuXHRcdFx0fSkpO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBBc3luYztcbn0pKF9yZWFjdC5Db21wb25lbnQpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBBc3luYztcblxuQXN5bmMucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuQXN5bmMuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG5mdW5jdGlvbiBkZWZhdWx0Q2hpbGRyZW4ocHJvcHMpIHtcblx0cmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9TZWxlY3QyWydkZWZhdWx0J10sIHByb3BzKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX1NlbGVjdCA9IHJlcXVpcmUoJy4vU2VsZWN0Jyk7XG5cbnZhciBfU2VsZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbGVjdCk7XG5cbnZhciBBc3luY0NyZWF0YWJsZSA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG5cdGRpc3BsYXlOYW1lOiAnQXN5bmNDcmVhdGFibGVTZWxlY3QnLFxuXG5cdHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHRyZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRfU2VsZWN0MlsnZGVmYXVsdCddLkFzeW5jLFxuXHRcdFx0dGhpcy5wcm9wcyxcblx0XHRcdGZ1bmN0aW9uIChhc3luY1Byb3BzKSB7XG5cdFx0XHRcdHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcblx0XHRcdFx0XHRfU2VsZWN0MlsnZGVmYXVsdCddLkNyZWF0YWJsZSxcblx0XHRcdFx0XHRfdGhpcy5wcm9wcyxcblx0XHRcdFx0XHRmdW5jdGlvbiAoY3JlYXRhYmxlUHJvcHMpIHtcblx0XHRcdFx0XHRcdHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChfU2VsZWN0MlsnZGVmYXVsdCddLCBfZXh0ZW5kcyh7fSwgYXN5bmNQcm9wcywgY3JlYXRhYmxlUHJvcHMsIHtcblx0XHRcdFx0XHRcdFx0b25JbnB1dENoYW5nZTogZnVuY3Rpb24gKGlucHV0KSB7XG5cdFx0XHRcdFx0XHRcdFx0Y3JlYXRhYmxlUHJvcHMub25JbnB1dENoYW5nZShpbnB1dCk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGFzeW5jUHJvcHMub25JbnB1dENoYW5nZShpbnB1dCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0KTtcblx0fVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXN5bmNDcmVhdGFibGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX1NlbGVjdCA9IHJlcXVpcmUoJy4vU2VsZWN0Jyk7XG5cbnZhciBfU2VsZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NlbGVjdCk7XG5cbnZhciBfdXRpbHNEZWZhdWx0RmlsdGVyT3B0aW9ucyA9IHJlcXVpcmUoJy4vdXRpbHMvZGVmYXVsdEZpbHRlck9wdGlvbnMnKTtcblxudmFyIF91dGlsc0RlZmF1bHRGaWx0ZXJPcHRpb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzRGVmYXVsdEZpbHRlck9wdGlvbnMpO1xuXG52YXIgX3V0aWxzRGVmYXVsdE1lbnVSZW5kZXJlciA9IHJlcXVpcmUoJy4vdXRpbHMvZGVmYXVsdE1lbnVSZW5kZXJlcicpO1xuXG52YXIgX3V0aWxzRGVmYXVsdE1lbnVSZW5kZXJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsc0RlZmF1bHRNZW51UmVuZGVyZXIpO1xuXG52YXIgQ3JlYXRhYmxlID0gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUNsYXNzKHtcblx0ZGlzcGxheU5hbWU6ICdDcmVhdGFibGVTZWxlY3QnLFxuXG5cdHByb3BUeXBlczoge1xuXHRcdC8vIENoaWxkIGZ1bmN0aW9uIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGUgaW5uZXIgU2VsZWN0IGNvbXBvbmVudFxuXHRcdC8vIFRoaXMgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGNvbXBvc2UgSE9DcyAoZWcgQ3JlYXRhYmxlIGFuZCBBc3luYylcblx0XHQvLyAocHJvcHM6IE9iamVjdCk6IFByb3BUeXBlcy5lbGVtZW50XG5cdFx0Y2hpbGRyZW46IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcblxuXHRcdC8vIFNlZSBTZWxlY3QucHJvcFR5cGVzLmZpbHRlck9wdGlvbnNcblx0XHRmaWx0ZXJPcHRpb25zOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmFueSxcblxuXHRcdC8vIFNlYXJjaGVzIGZvciBhbnkgbWF0Y2hpbmcgb3B0aW9uIHdpdGhpbiB0aGUgc2V0IG9mIG9wdGlvbnMuXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBwcmV2ZW50cyBkdXBsaWNhdGUgb3B0aW9ucyBmcm9tIGJlaW5nIGNyZWF0ZWQuXG5cdFx0Ly8gKHsgb3B0aW9uOiBPYmplY3QsIG9wdGlvbnM6IEFycmF5LCBsYWJlbEtleTogc3RyaW5nLCB2YWx1ZUtleTogc3RyaW5nIH0pOiBib29sZWFuXG5cdFx0aXNPcHRpb25VbmlxdWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYyxcblxuXHRcdC8vIERldGVybWluZXMgaWYgdGhlIGN1cnJlbnQgaW5wdXQgdGV4dCByZXByZXNlbnRzIGEgdmFsaWQgb3B0aW9uLlxuXHRcdC8vICh7IGxhYmVsOiBzdHJpbmcgfSk6IGJvb2xlYW5cblx0XHRpc1ZhbGlkTmV3T3B0aW9uOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG5cblx0XHQvLyBTZWUgU2VsZWN0LnByb3BUeXBlcy5tZW51UmVuZGVyZXJcblx0XHRtZW51UmVuZGVyZXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYW55LFxuXG5cdFx0Ly8gRmFjdG9yeSB0byBjcmVhdGUgbmV3IG9wdGlvbi5cblx0XHQvLyAoeyBsYWJlbDogc3RyaW5nLCBsYWJlbEtleTogc3RyaW5nLCB2YWx1ZUtleTogc3RyaW5nIH0pOiBPYmplY3Rcblx0XHRuZXdPcHRpb25DcmVhdG9yOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsXG5cblx0XHQvLyBTZWUgU2VsZWN0LnByb3BUeXBlcy5vcHRpb25zXG5cdFx0b3B0aW9uczogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5hcnJheSxcblxuXHRcdC8vIENyZWF0ZXMgcHJvbXB0L3BsYWNlaG9sZGVyIG9wdGlvbiB0ZXh0LlxuXHRcdC8vIChmaWx0ZXJUZXh0OiBzdHJpbmcpOiBzdHJpbmdcblx0XHRwcm9tcHRUZXh0Q3JlYXRvcjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLFxuXG5cdFx0Ly8gRGVjaWRlcyBpZiBhIGtleURvd24gZXZlbnQgKGVnIGl0cyBga2V5Q29kZWApIHNob3VsZCByZXN1bHQgaW4gdGhlIGNyZWF0aW9uIG9mIGEgbmV3IG9wdGlvbi5cblx0XHRzaG91bGRLZXlEb3duRXZlbnRDcmVhdGVOZXdPcHRpb246IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuY1xuXHR9LFxuXG5cdC8vIERlZmF1bHQgcHJvcCBtZXRob2RzXG5cdHN0YXRpY3M6IHtcblx0XHRpc09wdGlvblVuaXF1ZTogaXNPcHRpb25VbmlxdWUsXG5cdFx0aXNWYWxpZE5ld09wdGlvbjogaXNWYWxpZE5ld09wdGlvbixcblx0XHRuZXdPcHRpb25DcmVhdG9yOiBuZXdPcHRpb25DcmVhdG9yLFxuXHRcdHByb21wdFRleHRDcmVhdG9yOiBwcm9tcHRUZXh0Q3JlYXRvcixcblx0XHRzaG91bGRLZXlEb3duRXZlbnRDcmVhdGVOZXdPcHRpb246IHNob3VsZEtleURvd25FdmVudENyZWF0ZU5ld09wdGlvblxuXHR9LFxuXG5cdGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRmaWx0ZXJPcHRpb25zOiBfdXRpbHNEZWZhdWx0RmlsdGVyT3B0aW9uczJbJ2RlZmF1bHQnXSxcblx0XHRcdGlzT3B0aW9uVW5pcXVlOiBpc09wdGlvblVuaXF1ZSxcblx0XHRcdGlzVmFsaWROZXdPcHRpb246IGlzVmFsaWROZXdPcHRpb24sXG5cdFx0XHRtZW51UmVuZGVyZXI6IF91dGlsc0RlZmF1bHRNZW51UmVuZGVyZXIyWydkZWZhdWx0J10sXG5cdFx0XHRuZXdPcHRpb25DcmVhdG9yOiBuZXdPcHRpb25DcmVhdG9yLFxuXHRcdFx0cHJvbXB0VGV4dENyZWF0b3I6IHByb21wdFRleHRDcmVhdG9yLFxuXHRcdFx0c2hvdWxkS2V5RG93bkV2ZW50Q3JlYXRlTmV3T3B0aW9uOiBzaG91bGRLZXlEb3duRXZlbnRDcmVhdGVOZXdPcHRpb25cblx0XHR9O1xuXHR9LFxuXG5cdGNyZWF0ZU5ld09wdGlvbjogZnVuY3Rpb24gY3JlYXRlTmV3T3B0aW9uKCkge1xuXHRcdHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuXHRcdHZhciBpc1ZhbGlkTmV3T3B0aW9uID0gX3Byb3BzLmlzVmFsaWROZXdPcHRpb247XG5cdFx0dmFyIG5ld09wdGlvbkNyZWF0b3IgPSBfcHJvcHMubmV3T3B0aW9uQ3JlYXRvcjtcblx0XHR2YXIgX3Byb3BzJG9wdGlvbnMgPSBfcHJvcHMub3B0aW9ucztcblx0XHR2YXIgb3B0aW9ucyA9IF9wcm9wcyRvcHRpb25zID09PSB1bmRlZmluZWQgPyBbXSA6IF9wcm9wcyRvcHRpb25zO1xuXHRcdHZhciBzaG91bGRLZXlEb3duRXZlbnRDcmVhdGVOZXdPcHRpb24gPSBfcHJvcHMuc2hvdWxkS2V5RG93bkV2ZW50Q3JlYXRlTmV3T3B0aW9uO1xuXG5cdFx0aWYgKGlzVmFsaWROZXdPcHRpb24oeyBsYWJlbDogdGhpcy5pbnB1dFZhbHVlIH0pKSB7XG5cdFx0XHR2YXIgb3B0aW9uID0gbmV3T3B0aW9uQ3JlYXRvcih7IGxhYmVsOiB0aGlzLmlucHV0VmFsdWUsIGxhYmVsS2V5OiB0aGlzLmxhYmVsS2V5LCB2YWx1ZUtleTogdGhpcy52YWx1ZUtleSB9KTtcblx0XHRcdHZhciBfaXNPcHRpb25VbmlxdWUgPSB0aGlzLmlzT3B0aW9uVW5pcXVlKHsgb3B0aW9uOiBvcHRpb24gfSk7XG5cblx0XHRcdC8vIERvbid0IGFkZCB0aGUgc2FtZSBvcHRpb24gdHdpY2UuXG5cdFx0XHRpZiAoX2lzT3B0aW9uVW5pcXVlKSB7XG5cdFx0XHRcdG9wdGlvbnMudW5zaGlmdChvcHRpb24pO1xuXG5cdFx0XHRcdHRoaXMuc2VsZWN0LnNlbGVjdFZhbHVlKG9wdGlvbik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlck9wdGlvbnM6IGZ1bmN0aW9uIGZpbHRlck9wdGlvbnMoKSB7XG5cdFx0dmFyIF9wcm9wczIgPSB0aGlzLnByb3BzO1xuXHRcdHZhciBmaWx0ZXJPcHRpb25zID0gX3Byb3BzMi5maWx0ZXJPcHRpb25zO1xuXHRcdHZhciBpc1ZhbGlkTmV3T3B0aW9uID0gX3Byb3BzMi5pc1ZhbGlkTmV3T3B0aW9uO1xuXHRcdHZhciBvcHRpb25zID0gX3Byb3BzMi5vcHRpb25zO1xuXHRcdHZhciBwcm9tcHRUZXh0Q3JlYXRvciA9IF9wcm9wczIucHJvbXB0VGV4dENyZWF0b3I7XG5cblx0XHQvLyBUUklDS1kgQ2hlY2sgY3VycmVudGx5IHNlbGVjdGVkIG9wdGlvbnMgYXMgd2VsbC5cblx0XHQvLyBEb24ndCBkaXNwbGF5IGEgY3JlYXRlLXByb21wdCBmb3IgYSB2YWx1ZSB0aGF0J3Mgc2VsZWN0ZWQuXG5cdFx0Ly8gVGhpcyBjb3ZlcnMgYXN5bmMgZWRnZS1jYXNlcyB3aGVyZSBhIG5ld2x5LWNyZWF0ZWQgT3B0aW9uIGlzbid0IHlldCBpbiB0aGUgYXN5bmMtbG9hZGVkIGFycmF5LlxuXHRcdHZhciBleGNsdWRlT3B0aW9ucyA9IGFyZ3VtZW50c1syXSB8fCBbXTtcblxuXHRcdHZhciBmaWx0ZXJlZE9wdGlvbnMgPSBmaWx0ZXJPcHRpb25zLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSB8fCBbXTtcblxuXHRcdGlmIChpc1ZhbGlkTmV3T3B0aW9uKHsgbGFiZWw6IHRoaXMuaW5wdXRWYWx1ZSB9KSkge1xuXHRcdFx0dmFyIF9uZXdPcHRpb25DcmVhdG9yID0gdGhpcy5wcm9wcy5uZXdPcHRpb25DcmVhdG9yO1xuXG5cdFx0XHR2YXIgb3B0aW9uID0gX25ld09wdGlvbkNyZWF0b3Ioe1xuXHRcdFx0XHRsYWJlbDogdGhpcy5pbnB1dFZhbHVlLFxuXHRcdFx0XHRsYWJlbEtleTogdGhpcy5sYWJlbEtleSxcblx0XHRcdFx0dmFsdWVLZXk6IHRoaXMudmFsdWVLZXlcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBUUklDS1kgQ29tcGFyZSB0byBhbGwgb3B0aW9ucyAobm90IGp1c3QgZmlsdGVyZWQgb3B0aW9ucykgaW4gY2FzZSBvcHRpb24gaGFzIGFscmVhZHkgYmVlbiBzZWxlY3RlZCkuXG5cdFx0XHQvLyBGb3IgbXVsdGktc2VsZWN0cywgdGhpcyB3b3VsZCByZW1vdmUgaXQgZnJvbSB0aGUgZmlsdGVyZWQgbGlzdC5cblx0XHRcdHZhciBfaXNPcHRpb25VbmlxdWUyID0gdGhpcy5pc09wdGlvblVuaXF1ZSh7XG5cdFx0XHRcdG9wdGlvbjogb3B0aW9uLFxuXHRcdFx0XHRvcHRpb25zOiBleGNsdWRlT3B0aW9ucy5jb25jYXQoZmlsdGVyZWRPcHRpb25zKVxuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChfaXNPcHRpb25VbmlxdWUyKSB7XG5cdFx0XHRcdHZhciBfcHJvbXB0ID0gcHJvbXB0VGV4dENyZWF0b3IodGhpcy5pbnB1dFZhbHVlKTtcblxuXHRcdFx0XHR0aGlzLl9jcmVhdGVQbGFjZWhvbGRlck9wdGlvbiA9IF9uZXdPcHRpb25DcmVhdG9yKHtcblx0XHRcdFx0XHRsYWJlbDogX3Byb21wdCxcblx0XHRcdFx0XHRsYWJlbEtleTogdGhpcy5sYWJlbEtleSxcblx0XHRcdFx0XHR2YWx1ZUtleTogdGhpcy52YWx1ZUtleVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRmaWx0ZXJlZE9wdGlvbnMudW5zaGlmdCh0aGlzLl9jcmVhdGVQbGFjZWhvbGRlck9wdGlvbik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZpbHRlcmVkT3B0aW9ucztcblx0fSxcblxuXHRpc09wdGlvblVuaXF1ZTogZnVuY3Rpb24gaXNPcHRpb25VbmlxdWUoX3JlZjIpIHtcblx0XHR2YXIgb3B0aW9uID0gX3JlZjIub3B0aW9uO1xuXHRcdHZhciBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcblx0XHR2YXIgaXNPcHRpb25VbmlxdWUgPSB0aGlzLnByb3BzLmlzT3B0aW9uVW5pcXVlO1xuXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5zZWxlY3QuZmlsdGVyT3B0aW9ucygpO1xuXG5cdFx0cmV0dXJuIGlzT3B0aW9uVW5pcXVlKHtcblx0XHRcdGxhYmVsS2V5OiB0aGlzLmxhYmVsS2V5LFxuXHRcdFx0b3B0aW9uOiBvcHRpb24sXG5cdFx0XHRvcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0dmFsdWVLZXk6IHRoaXMudmFsdWVLZXlcblx0XHR9KTtcblx0fSxcblxuXHRtZW51UmVuZGVyZXI6IGZ1bmN0aW9uIG1lbnVSZW5kZXJlcihwYXJhbXMpIHtcblx0XHR2YXIgbWVudVJlbmRlcmVyID0gdGhpcy5wcm9wcy5tZW51UmVuZGVyZXI7XG5cblx0XHRyZXR1cm4gbWVudVJlbmRlcmVyKF9leHRlbmRzKHt9LCBwYXJhbXMsIHtcblx0XHRcdG9uU2VsZWN0OiB0aGlzLm9uT3B0aW9uU2VsZWN0XG5cdFx0fSkpO1xuXHR9LFxuXG5cdG9uSW5wdXRDaGFuZ2U6IGZ1bmN0aW9uIG9uSW5wdXRDaGFuZ2UoaW5wdXQpIHtcblx0XHQvLyBUaGlzIHZhbHVlIG1heSBiZSBuZWVkZWQgaW4gYmV0d2VlbiBTZWxlY3QgbW91bnRzICh3aGVuIHRoaXMuc2VsZWN0IGlzIG51bGwpXG5cdFx0dGhpcy5pbnB1dFZhbHVlID0gaW5wdXQ7XG5cdH0sXG5cblx0b25JbnB1dEtleURvd246IGZ1bmN0aW9uIG9uSW5wdXRLZXlEb3duKGV2ZW50KSB7XG5cdFx0dmFyIHNob3VsZEtleURvd25FdmVudENyZWF0ZU5ld09wdGlvbiA9IHRoaXMucHJvcHMuc2hvdWxkS2V5RG93bkV2ZW50Q3JlYXRlTmV3T3B0aW9uO1xuXG5cdFx0dmFyIGZvY3VzZWRPcHRpb24gPSB0aGlzLnNlbGVjdC5nZXRGb2N1c2VkT3B0aW9uKCk7XG5cblx0XHRpZiAoZm9jdXNlZE9wdGlvbiAmJiBmb2N1c2VkT3B0aW9uID09PSB0aGlzLl9jcmVhdGVQbGFjZWhvbGRlck9wdGlvbiAmJiBzaG91bGRLZXlEb3duRXZlbnRDcmVhdGVOZXdPcHRpb24oeyBrZXlDb2RlOiBldmVudC5rZXlDb2RlIH0pKSB7XG5cdFx0XHR0aGlzLmNyZWF0ZU5ld09wdGlvbigpO1xuXG5cdFx0XHQvLyBQcmV2ZW50IGRlY29yYXRlZCBTZWxlY3QgZnJvbSBkb2luZyBhbnl0aGluZyBhZGRpdGlvbmFsIHdpdGggdGhpcyBrZXlEb3duIGV2ZW50XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblxuXHRvbk9wdGlvblNlbGVjdDogZnVuY3Rpb24gb25PcHRpb25TZWxlY3Qob3B0aW9uLCBldmVudCkge1xuXHRcdGlmIChvcHRpb24gPT09IHRoaXMuX2NyZWF0ZVBsYWNlaG9sZGVyT3B0aW9uKSB7XG5cdFx0XHR0aGlzLmNyZWF0ZU5ld09wdGlvbigpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnNlbGVjdC5zZWxlY3RWYWx1ZShvcHRpb24pO1xuXHRcdH1cblx0fSxcblxuXHRyZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdFx0dmFyIF9wcm9wczMgPSB0aGlzLnByb3BzO1xuXHRcdHZhciBfcHJvcHMzJGNoaWxkcmVuID0gX3Byb3BzMy5jaGlsZHJlbjtcblx0XHR2YXIgY2hpbGRyZW4gPSBfcHJvcHMzJGNoaWxkcmVuID09PSB1bmRlZmluZWQgPyBkZWZhdWx0Q2hpbGRyZW4gOiBfcHJvcHMzJGNoaWxkcmVuO1xuXHRcdHZhciBuZXdPcHRpb25DcmVhdG9yID0gX3Byb3BzMy5uZXdPcHRpb25DcmVhdG9yO1xuXHRcdHZhciBzaG91bGRLZXlEb3duRXZlbnRDcmVhdGVOZXdPcHRpb24gPSBfcHJvcHMzLnNob3VsZEtleURvd25FdmVudENyZWF0ZU5ld09wdGlvbjtcblxuXHRcdHZhciByZXN0UHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzMywgWydjaGlsZHJlbicsICduZXdPcHRpb25DcmVhdG9yJywgJ3Nob3VsZEtleURvd25FdmVudENyZWF0ZU5ld09wdGlvbiddKTtcblxuXHRcdHZhciBwcm9wcyA9IF9leHRlbmRzKHt9LCByZXN0UHJvcHMsIHtcblx0XHRcdGFsbG93Q3JlYXRlOiB0cnVlLFxuXHRcdFx0ZmlsdGVyT3B0aW9uczogdGhpcy5maWx0ZXJPcHRpb25zLFxuXHRcdFx0bWVudVJlbmRlcmVyOiB0aGlzLm1lbnVSZW5kZXJlcixcblx0XHRcdG9uSW5wdXRDaGFuZ2U6IHRoaXMub25JbnB1dENoYW5nZSxcblx0XHRcdG9uSW5wdXRLZXlEb3duOiB0aGlzLm9uSW5wdXRLZXlEb3duLFxuXHRcdFx0cmVmOiBmdW5jdGlvbiByZWYoX3JlZikge1xuXHRcdFx0XHRfdGhpcy5zZWxlY3QgPSBfcmVmO1xuXG5cdFx0XHRcdC8vIFRoZXNlIHZhbHVlcyBtYXkgYmUgbmVlZGVkIGluIGJldHdlZW4gU2VsZWN0IG1vdW50cyAod2hlbiB0aGlzLnNlbGVjdCBpcyBudWxsKVxuXHRcdFx0XHRpZiAoX3JlZikge1xuXHRcdFx0XHRcdF90aGlzLmxhYmVsS2V5ID0gX3JlZi5wcm9wcy5sYWJlbEtleTtcblx0XHRcdFx0XHRfdGhpcy52YWx1ZUtleSA9IF9yZWYucHJvcHMudmFsdWVLZXk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBjaGlsZHJlbihwcm9wcyk7XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBkZWZhdWx0Q2hpbGRyZW4ocHJvcHMpIHtcblx0cmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KF9TZWxlY3QyWydkZWZhdWx0J10sIHByb3BzKTtcbn07XG5cbmZ1bmN0aW9uIGlzT3B0aW9uVW5pcXVlKF9yZWYzKSB7XG5cdHZhciBvcHRpb24gPSBfcmVmMy5vcHRpb247XG5cdHZhciBvcHRpb25zID0gX3JlZjMub3B0aW9ucztcblx0dmFyIGxhYmVsS2V5ID0gX3JlZjMubGFiZWxLZXk7XG5cdHZhciB2YWx1ZUtleSA9IF9yZWYzLnZhbHVlS2V5O1xuXG5cdHJldHVybiBvcHRpb25zLmZpbHRlcihmdW5jdGlvbiAoZXhpc3RpbmdPcHRpb24pIHtcblx0XHRyZXR1cm4gZXhpc3RpbmdPcHRpb25bbGFiZWxLZXldID09PSBvcHRpb25bbGFiZWxLZXldIHx8IGV4aXN0aW5nT3B0aW9uW3ZhbHVlS2V5XSA9PT0gb3B0aW9uW3ZhbHVlS2V5XTtcblx0fSkubGVuZ3RoID09PSAwO1xufTtcblxuZnVuY3Rpb24gaXNWYWxpZE5ld09wdGlvbihfcmVmNCkge1xuXHR2YXIgbGFiZWwgPSBfcmVmNC5sYWJlbDtcblxuXHRyZXR1cm4gISFsYWJlbDtcbn07XG5cbmZ1bmN0aW9uIG5ld09wdGlvbkNyZWF0b3IoX3JlZjUpIHtcblx0dmFyIGxhYmVsID0gX3JlZjUubGFiZWw7XG5cdHZhciBsYWJlbEtleSA9IF9yZWY1LmxhYmVsS2V5O1xuXHR2YXIgdmFsdWVLZXkgPSBfcmVmNS52YWx1ZUtleTtcblxuXHR2YXIgb3B0aW9uID0ge307XG5cdG9wdGlvblt2YWx1ZUtleV0gPSBsYWJlbDtcblx0b3B0aW9uW2xhYmVsS2V5XSA9IGxhYmVsO1xuXHRvcHRpb24uY2xhc3NOYW1lID0gJ1NlbGVjdC1jcmVhdGUtb3B0aW9uLXBsYWNlaG9sZGVyJztcblx0cmV0dXJuIG9wdGlvbjtcbn07XG5cbmZ1bmN0aW9uIHByb21wdFRleHRDcmVhdG9yKGxhYmVsKSB7XG5cdHJldHVybiAnQ3JlYXRlIG9wdGlvbiBcIicgKyBsYWJlbCArICdcIic7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEtleURvd25FdmVudENyZWF0ZU5ld09wdGlvbihfcmVmNikge1xuXHR2YXIga2V5Q29kZSA9IF9yZWY2LmtleUNvZGU7XG5cblx0c3dpdGNoIChrZXlDb2RlKSB7XG5cdFx0Y2FzZSA5OiAvLyBUQUJcblx0XHRjYXNlIDEzOiAvLyBFTlRFUlxuXHRcdGNhc2UgMTg4OlxuXHRcdFx0Ly8gQ09NTUFcblx0XHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDcmVhdGFibGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9jbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG52YXIgX2NsYXNzbmFtZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NuYW1lcyk7XG5cbnZhciBPcHRpb24gPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlQ2xhc3Moe1xuXHRkaXNwbGF5TmFtZTogJ09wdGlvbicsXG5cblx0cHJvcFR5cGVzOiB7XG5cdFx0Y2hpbGRyZW46IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMubm9kZSxcblx0XHRjbGFzc05hbWU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLCAvLyBjbGFzc05hbWUgKGJhc2VkIG9uIG1vdXNlIHBvc2l0aW9uKVxuXHRcdGluc3RhbmNlUHJlZml4OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLCAvLyB1bmlxdWUgcHJlZml4IGZvciB0aGUgaWRzICh1c2VkIGZvciBhcmlhKVxuXHRcdGlzRGlzYWJsZWQ6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCwgLy8gdGhlIG9wdGlvbiBpcyBkaXNhYmxlZFxuXHRcdGlzRm9jdXNlZDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLCAvLyB0aGUgb3B0aW9uIGlzIGZvY3VzZWRcblx0XHRpc1NlbGVjdGVkOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsIC8vIHRoZSBvcHRpb24gaXMgc2VsZWN0ZWRcblx0XHRvbkZvY3VzOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsIC8vIG1ldGhvZCB0byBoYW5kbGUgbW91c2VFbnRlciBvbiBvcHRpb24gZWxlbWVudFxuXHRcdG9uU2VsZWN0OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsIC8vIG1ldGhvZCB0byBoYW5kbGUgY2xpY2sgb24gb3B0aW9uIGVsZW1lbnRcblx0XHRvblVuZm9jdXM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYywgLy8gbWV0aG9kIHRvIGhhbmRsZSBtb3VzZUxlYXZlIG9uIG9wdGlvbiBlbGVtZW50XG5cdFx0b3B0aW9uOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLCAvLyBvYmplY3QgdGhhdCBpcyBiYXNlIGZvciB0aGF0IG9wdGlvblxuXHRcdG9wdGlvbkluZGV4OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm51bWJlciB9LFxuXHQvLyBpbmRleCBvZiB0aGUgb3B0aW9uLCB1c2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBpZHMgZm9yIGFyaWFcblx0YmxvY2tFdmVudDogZnVuY3Rpb24gYmxvY2tFdmVudChldmVudCkge1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0aWYgKGV2ZW50LnRhcmdldC50YWdOYW1lICE9PSAnQScgfHwgISgnaHJlZicgaW4gZXZlbnQudGFyZ2V0KSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoZXZlbnQudGFyZ2V0LnRhcmdldCkge1xuXHRcdFx0d2luZG93Lm9wZW4oZXZlbnQudGFyZ2V0LmhyZWYsIGV2ZW50LnRhcmdldC50YXJnZXQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cubG9jYXRpb24uaHJlZiA9IGV2ZW50LnRhcmdldC5ocmVmO1xuXHRcdH1cblx0fSxcblxuXHRoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0dGhpcy5wcm9wcy5vblNlbGVjdCh0aGlzLnByb3BzLm9wdGlvbiwgZXZlbnQpO1xuXHR9LFxuXG5cdGhhbmRsZU1vdXNlRW50ZXI6IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRW50ZXIoZXZlbnQpIHtcblx0XHR0aGlzLm9uRm9jdXMoZXZlbnQpO1xuXHR9LFxuXG5cdGhhbmRsZU1vdXNlTW92ZTogZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGV2ZW50KSB7XG5cdFx0dGhpcy5vbkZvY3VzKGV2ZW50KTtcblx0fSxcblxuXHRoYW5kbGVUb3VjaEVuZDogZnVuY3Rpb24gaGFuZGxlVG91Y2hFbmQoZXZlbnQpIHtcblx0XHQvLyBDaGVjayBpZiB0aGUgdmlldyBpcyBiZWluZyBkcmFnZ2VkLCBJbiB0aGlzIGNhc2Vcblx0XHQvLyB3ZSBkb24ndCB3YW50IHRvIGZpcmUgdGhlIGNsaWNrIGV2ZW50IChiZWNhdXNlIHRoZSB1c2VyIG9ubHkgd2FudHMgdG8gc2Nyb2xsKVxuXHRcdGlmICh0aGlzLmRyYWdnaW5nKSByZXR1cm47XG5cblx0XHR0aGlzLmhhbmRsZU1vdXNlRG93bihldmVudCk7XG5cdH0sXG5cblx0aGFuZGxlVG91Y2hNb3ZlOiBmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmUoZXZlbnQpIHtcblx0XHQvLyBTZXQgYSBmbGFnIHRoYXQgdGhlIHZpZXcgaXMgYmVpbmcgZHJhZ2dlZFxuXHRcdHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuXHR9LFxuXG5cdGhhbmRsZVRvdWNoU3RhcnQ6IGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnQoZXZlbnQpIHtcblx0XHQvLyBTZXQgYSBmbGFnIHRoYXQgdGhlIHZpZXcgaXMgbm90IGJlaW5nIGRyYWdnZWRcblx0XHR0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG5cdH0sXG5cblx0b25Gb2N1czogZnVuY3Rpb24gb25Gb2N1cyhldmVudCkge1xuXHRcdGlmICghdGhpcy5wcm9wcy5pc0ZvY3VzZWQpIHtcblx0XHRcdHRoaXMucHJvcHMub25Gb2N1cyh0aGlzLnByb3BzLm9wdGlvbiwgZXZlbnQpO1xuXHRcdH1cblx0fSxcblx0cmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG5cdFx0dmFyIF9wcm9wcyA9IHRoaXMucHJvcHM7XG5cdFx0dmFyIG9wdGlvbiA9IF9wcm9wcy5vcHRpb247XG5cdFx0dmFyIGluc3RhbmNlUHJlZml4ID0gX3Byb3BzLmluc3RhbmNlUHJlZml4O1xuXHRcdHZhciBvcHRpb25JbmRleCA9IF9wcm9wcy5vcHRpb25JbmRleDtcblxuXHRcdHZhciBjbGFzc05hbWUgPSAoMCwgX2NsYXNzbmFtZXMyWydkZWZhdWx0J10pKHRoaXMucHJvcHMuY2xhc3NOYW1lLCBvcHRpb24uY2xhc3NOYW1lKTtcblxuXHRcdHJldHVybiBvcHRpb24uZGlzYWJsZWQgPyBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcblx0XHRcdCdkaXYnLFxuXHRcdFx0eyBjbGFzc05hbWU6IGNsYXNzTmFtZSxcblx0XHRcdFx0b25Nb3VzZURvd246IHRoaXMuYmxvY2tFdmVudCxcblx0XHRcdFx0b25DbGljazogdGhpcy5ibG9ja0V2ZW50IH0sXG5cdFx0XHR0aGlzLnByb3BzLmNoaWxkcmVuXG5cdFx0KSA6IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuXHRcdFx0J2RpdicsXG5cdFx0XHR7IGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuXHRcdFx0XHRzdHlsZTogb3B0aW9uLnN0eWxlLFxuXHRcdFx0XHRyb2xlOiAnb3B0aW9uJyxcblx0XHRcdFx0b25Nb3VzZURvd246IHRoaXMuaGFuZGxlTW91c2VEb3duLFxuXHRcdFx0XHRvbk1vdXNlRW50ZXI6IHRoaXMuaGFuZGxlTW91c2VFbnRlcixcblx0XHRcdFx0b25Nb3VzZU1vdmU6IHRoaXMuaGFuZGxlTW91c2VNb3ZlLFxuXHRcdFx0XHRvblRvdWNoU3RhcnQ6IHRoaXMuaGFuZGxlVG91Y2hTdGFydCxcblx0XHRcdFx0b25Ub3VjaE1vdmU6IHRoaXMuaGFuZGxlVG91Y2hNb3ZlLFxuXHRcdFx0XHRvblRvdWNoRW5kOiB0aGlzLmhhbmRsZVRvdWNoRW5kLFxuXHRcdFx0XHRpZDogaW5zdGFuY2VQcmVmaXggKyAnLW9wdGlvbi0nICsgb3B0aW9uSW5kZXgsXG5cdFx0XHRcdHRpdGxlOiBvcHRpb24udGl0bGUgfSxcblx0XHRcdHRoaXMucHJvcHMuY2hpbGRyZW5cblx0XHQpO1xuXHR9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcHRpb247IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9jbGFzc25hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG52YXIgX2NsYXNzbmFtZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NuYW1lcyk7XG5cbnZhciBWYWx1ZSA9IF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVDbGFzcyh7XG5cblx0ZGlzcGxheU5hbWU6ICdWYWx1ZScsXG5cblx0cHJvcFR5cGVzOiB7XG5cdFx0Y2hpbGRyZW46IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMubm9kZSxcblx0XHRkaXNhYmxlZDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLCAvLyBkaXNhYmxlZCBwcm9wIHBhc3NlZCB0byBSZWFjdFNlbGVjdFxuXHRcdGlkOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZywgLy8gVW5pcXVlIGlkIGZvciB0aGUgdmFsdWUgLSB1c2VkIGZvciBhcmlhXG5cdFx0b25DbGljazogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLCAvLyBtZXRob2QgdG8gaGFuZGxlIGNsaWNrIG9uIHZhbHVlIGxhYmVsXG5cdFx0b25SZW1vdmU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYywgLy8gbWV0aG9kIHRvIGhhbmRsZSByZW1vdmFsIG9mIHRoZSB2YWx1ZVxuXHRcdHZhbHVlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkIH0sXG5cblx0Ly8gdGhlIG9wdGlvbiBvYmplY3QgZm9yIHRoaXMgdmFsdWVcblx0aGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcblx0XHRpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgJiYgZXZlbnQuYnV0dG9uICE9PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICh0aGlzLnByb3BzLm9uQ2xpY2spIHtcblx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0dGhpcy5wcm9wcy5vbkNsaWNrKHRoaXMucHJvcHMudmFsdWUsIGV2ZW50KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKHRoaXMucHJvcHMudmFsdWUuaHJlZikge1xuXHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiBvblJlbW92ZShldmVudCkge1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0dGhpcy5wcm9wcy5vblJlbW92ZSh0aGlzLnByb3BzLnZhbHVlKTtcblx0fSxcblxuXHRoYW5kbGVUb3VjaEVuZFJlbW92ZTogZnVuY3Rpb24gaGFuZGxlVG91Y2hFbmRSZW1vdmUoZXZlbnQpIHtcblx0XHQvLyBDaGVjayBpZiB0aGUgdmlldyBpcyBiZWluZyBkcmFnZ2VkLCBJbiB0aGlzIGNhc2Vcblx0XHQvLyB3ZSBkb24ndCB3YW50IHRvIGZpcmUgdGhlIGNsaWNrIGV2ZW50IChiZWNhdXNlIHRoZSB1c2VyIG9ubHkgd2FudHMgdG8gc2Nyb2xsKVxuXHRcdGlmICh0aGlzLmRyYWdnaW5nKSByZXR1cm47XG5cblx0XHQvLyBGaXJlIHRoZSBtb3VzZSBldmVudHNcblx0XHR0aGlzLm9uUmVtb3ZlKGV2ZW50KTtcblx0fSxcblxuXHRoYW5kbGVUb3VjaE1vdmU6IGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZShldmVudCkge1xuXHRcdC8vIFNldCBhIGZsYWcgdGhhdCB0aGUgdmlldyBpcyBiZWluZyBkcmFnZ2VkXG5cdFx0dGhpcy5kcmFnZ2luZyA9IHRydWU7XG5cdH0sXG5cblx0aGFuZGxlVG91Y2hTdGFydDogZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydChldmVudCkge1xuXHRcdC8vIFNldCBhIGZsYWcgdGhhdCB0aGUgdmlldyBpcyBub3QgYmVpbmcgZHJhZ2dlZFxuXHRcdHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcblx0fSxcblxuXHRyZW5kZXJSZW1vdmVJY29uOiBmdW5jdGlvbiByZW5kZXJSZW1vdmVJY29uKCkge1xuXHRcdGlmICh0aGlzLnByb3BzLmRpc2FibGVkIHx8ICF0aGlzLnByb3BzLm9uUmVtb3ZlKSByZXR1cm47XG5cdFx0cmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuXHRcdFx0J3NwYW4nLFxuXHRcdFx0eyBjbGFzc05hbWU6ICdTZWxlY3QtdmFsdWUtaWNvbicsXG5cdFx0XHRcdCdhcmlhLWhpZGRlbic6ICd0cnVlJyxcblx0XHRcdFx0b25Nb3VzZURvd246IHRoaXMub25SZW1vdmUsXG5cdFx0XHRcdG9uVG91Y2hFbmQ6IHRoaXMuaGFuZGxlVG91Y2hFbmRSZW1vdmUsXG5cdFx0XHRcdG9uVG91Y2hTdGFydDogdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LFxuXHRcdFx0XHRvblRvdWNoTW92ZTogdGhpcy5oYW5kbGVUb3VjaE1vdmUgfSxcblx0XHRcdCfDlydcblx0XHQpO1xuXHR9LFxuXG5cdHJlbmRlckxhYmVsOiBmdW5jdGlvbiByZW5kZXJMYWJlbCgpIHtcblx0XHR2YXIgY2xhc3NOYW1lID0gJ1NlbGVjdC12YWx1ZS1sYWJlbCc7XG5cdFx0cmV0dXJuIHRoaXMucHJvcHMub25DbGljayB8fCB0aGlzLnByb3BzLnZhbHVlLmhyZWYgPyBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcblx0XHRcdCdhJyxcblx0XHRcdHsgY2xhc3NOYW1lOiBjbGFzc05hbWUsIGhyZWY6IHRoaXMucHJvcHMudmFsdWUuaHJlZiwgdGFyZ2V0OiB0aGlzLnByb3BzLnZhbHVlLnRhcmdldCwgb25Nb3VzZURvd246IHRoaXMuaGFuZGxlTW91c2VEb3duLCBvblRvdWNoRW5kOiB0aGlzLmhhbmRsZU1vdXNlRG93biB9LFxuXHRcdFx0dGhpcy5wcm9wcy5jaGlsZHJlblxuXHRcdCkgOiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcblx0XHRcdCdzcGFuJyxcblx0XHRcdHsgY2xhc3NOYW1lOiBjbGFzc05hbWUsIHJvbGU6ICdvcHRpb24nLCAnYXJpYS1zZWxlY3RlZCc6ICd0cnVlJywgaWQ6IHRoaXMucHJvcHMuaWQgfSxcblx0XHRcdHRoaXMucHJvcHMuY2hpbGRyZW5cblx0XHQpO1xuXHR9LFxuXG5cdHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuXHRcdHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcblx0XHRcdCdkaXYnLFxuXHRcdFx0eyBjbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lczJbJ2RlZmF1bHQnXSkoJ1NlbGVjdC12YWx1ZScsIHRoaXMucHJvcHMudmFsdWUuY2xhc3NOYW1lKSxcblx0XHRcdFx0c3R5bGU6IHRoaXMucHJvcHMudmFsdWUuc3R5bGUsXG5cdFx0XHRcdHRpdGxlOiB0aGlzLnByb3BzLnZhbHVlLnRpdGxlXG5cdFx0XHR9LFxuXHRcdFx0dGhpcy5yZW5kZXJSZW1vdmVJY29uKCksXG5cdFx0XHR0aGlzLnJlbmRlckxhYmVsKClcblx0XHQpO1xuXHR9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZhbHVlOyIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTYgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vcmVhY3Qtc2VsZWN0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX3JlYWN0SW5wdXRBdXRvc2l6ZSA9IHJlcXVpcmUoJ3JlYWN0LWlucHV0LWF1dG9zaXplJyk7XG5cbnZhciBfcmVhY3RJbnB1dEF1dG9zaXplMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0SW5wdXRBdXRvc2l6ZSk7XG5cbnZhciBfY2xhc3NuYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxudmFyIF9jbGFzc25hbWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzbmFtZXMpO1xuXG52YXIgX3V0aWxzRGVmYXVsdEFycm93UmVuZGVyZXIgPSByZXF1aXJlKCcuL3V0aWxzL2RlZmF1bHRBcnJvd1JlbmRlcmVyJyk7XG5cbnZhciBfdXRpbHNEZWZhdWx0QXJyb3dSZW5kZXJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlsc0RlZmF1bHRBcnJvd1JlbmRlcmVyKTtcblxudmFyIF91dGlsc0RlZmF1bHRGaWx0ZXJPcHRpb25zID0gcmVxdWlyZSgnLi91dGlscy9kZWZhdWx0RmlsdGVyT3B0aW9ucycpO1xuXG52YXIgX3V0aWxzRGVmYXVsdEZpbHRlck9wdGlvbnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXRpbHNEZWZhdWx0RmlsdGVyT3B0aW9ucyk7XG5cbnZhciBfdXRpbHNEZWZhdWx0TWVudVJlbmRlcmVyID0gcmVxdWlyZSgnLi91dGlscy9kZWZhdWx0TWVudVJlbmRlcmVyJyk7XG5cbnZhciBfdXRpbHNEZWZhdWx0TWVudVJlbmRlcmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzRGVmYXVsdE1lbnVSZW5kZXJlcik7XG5cbnZhciBfQXN5bmMgPSByZXF1aXJlKCcuL0FzeW5jJyk7XG5cbnZhciBfQXN5bmMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQXN5bmMpO1xuXG52YXIgX0FzeW5jQ3JlYXRhYmxlID0gcmVxdWlyZSgnLi9Bc3luY0NyZWF0YWJsZScpO1xuXG52YXIgX0FzeW5jQ3JlYXRhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0FzeW5jQ3JlYXRhYmxlKTtcblxudmFyIF9DcmVhdGFibGUgPSByZXF1aXJlKCcuL0NyZWF0YWJsZScpO1xuXG52YXIgX0NyZWF0YWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9DcmVhdGFibGUpO1xuXG52YXIgX09wdGlvbiA9IHJlcXVpcmUoJy4vT3B0aW9uJyk7XG5cbnZhciBfT3B0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX09wdGlvbik7XG5cbnZhciBfVmFsdWUgPSByZXF1aXJlKCcuL1ZhbHVlJyk7XG5cbnZhciBfVmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVmFsdWUpO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlWYWx1ZSh2YWx1ZSkge1xuXHR2YXIgdmFsdWVUeXBlID0gdHlwZW9mIHZhbHVlO1xuXHRpZiAodmFsdWVUeXBlID09PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblx0fSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdudW1iZXInIHx8IHZhbHVlVHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0cmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG59XG5cbnZhciBzdHJpbmdPck5vZGUgPSBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9uZU9mVHlwZShbX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsIF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMubm9kZV0pO1xuXG52YXIgaW5zdGFuY2VJZCA9IDE7XG5cbnZhciBTZWxlY3QgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlQ2xhc3Moe1xuXG5cdGRpc3BsYXlOYW1lOiAnU2VsZWN0JyxcblxuXHRwcm9wVHlwZXM6IHtcblx0XHRhZGRMYWJlbFRleHQ6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLCAvLyBwbGFjZWhvbGRlciBkaXNwbGF5ZWQgd2hlbiB5b3Ugd2FudCB0byBhZGQgYSBsYWJlbCBvbiBhIG11bHRpLXZhbHVlIGlucHV0XG5cdFx0J2FyaWEtbGFiZWwnOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZywgLy8gQXJpYSBsYWJlbCAoZm9yIGFzc2lzdGl2ZSB0ZWNoKVxuXHRcdCdhcmlhLWxhYmVsbGVkYnknOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZywgLy8gSFRNTCBJRCBvZiBhbiBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgdGhlIGxhYmVsIChmb3IgYXNzaXN0aXZlIHRlY2gpXG5cdFx0YXJyb3dSZW5kZXJlcjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLCAvLyBDcmVhdGUgZHJvcC1kb3duIGNhcmV0IGVsZW1lbnRcblx0XHRhdXRvQmx1cjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLCAvLyBhdXRvbWF0aWNhbGx5IGJsdXIgdGhlIGNvbXBvbmVudCB3aGVuIGFuIG9wdGlvbiBpcyBzZWxlY3RlZFxuXHRcdGF1dG9mb2N1czogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLCAvLyBhdXRvZm9jdXMgdGhlIGNvbXBvbmVudCBvbiBtb3VudFxuXHRcdGF1dG9zaXplOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsIC8vIHdoZXRoZXIgdG8gZW5hYmxlIGF1dG9zaXppbmcgb3Igbm90XG5cdFx0YmFja3NwYWNlUmVtb3ZlczogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLCAvLyB3aGV0aGVyIGJhY2tzcGFjZSByZW1vdmVzIGFuIGl0ZW0gaWYgdGhlcmUgaXMgbm8gdGV4dCBpbnB1dFxuXHRcdGJhY2tzcGFjZVRvUmVtb3ZlTWVzc2FnZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsIC8vIE1lc3NhZ2UgdG8gdXNlIGZvciBzY3JlZW5yZWFkZXJzIHRvIHByZXNzIGJhY2tzcGFjZSB0byByZW1vdmUgdGhlIGN1cnJlbnQgaXRlbSAtIHtsYWJlbH0gaXMgcmVwbGFjZWQgd2l0aCB0aGUgaXRlbSBsYWJlbFxuXHRcdGNsYXNzTmFtZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsIC8vIGNsYXNzTmFtZSBmb3IgdGhlIG91dGVyIGVsZW1lbnRcblx0XHRjbGVhckFsbFRleHQ6IHN0cmluZ09yTm9kZSwgLy8gdGl0bGUgZm9yIHRoZSBcImNsZWFyXCIgY29udHJvbCB3aGVuIG11bHRpOiB0cnVlXG5cdFx0Y2xlYXJWYWx1ZVRleHQ6IHN0cmluZ09yTm9kZSwgLy8gdGl0bGUgZm9yIHRoZSBcImNsZWFyXCIgY29udHJvbFxuXHRcdGNsZWFyYWJsZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLCAvLyBzaG91bGQgaXQgYmUgcG9zc2libGUgdG8gcmVzZXQgdmFsdWVcblx0XHRkZWxpbWl0ZXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLCAvLyBkZWxpbWl0ZXIgdG8gdXNlIHRvIGpvaW4gbXVsdGlwbGUgdmFsdWVzIGZvciB0aGUgaGlkZGVuIGZpZWxkIHZhbHVlXG5cdFx0ZGlzYWJsZWQ6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCwgLy8gd2hldGhlciB0aGUgU2VsZWN0IGlzIGRpc2FibGVkIG9yIG5vdFxuXHRcdGVzY2FwZUNsZWFyc1ZhbHVlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsIC8vIHdoZXRoZXIgZXNjYXBlIGNsZWFycyB0aGUgdmFsdWUgd2hlbiB0aGUgbWVudSBpcyBjbG9zZWRcblx0XHRmaWx0ZXJPcHRpb246IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYywgLy8gbWV0aG9kIHRvIGZpbHRlciBhIHNpbmdsZSBvcHRpb24gKG9wdGlvbiwgZmlsdGVyU3RyaW5nKVxuXHRcdGZpbHRlck9wdGlvbnM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYW55LCAvLyBib29sZWFuIHRvIGVuYWJsZSBkZWZhdWx0IGZpbHRlcmluZyBvciBmdW5jdGlvbiB0byBmaWx0ZXIgdGhlIG9wdGlvbnMgYXJyYXkgKFtvcHRpb25zXSwgZmlsdGVyU3RyaW5nLCBbdmFsdWVzXSlcblx0XHRpZ25vcmVBY2NlbnRzOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsIC8vIHdoZXRoZXIgdG8gc3RyaXAgZGlhY3JpdGljcyB3aGVuIGZpbHRlcmluZ1xuXHRcdGlnbm9yZUNhc2U6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCwgLy8gd2hldGhlciB0byBwZXJmb3JtIGNhc2UtaW5zZW5zaXRpdmUgZmlsdGVyaW5nXG5cdFx0aW5wdXRQcm9wczogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5vYmplY3QsIC8vIGN1c3RvbSBhdHRyaWJ1dGVzIGZvciB0aGUgSW5wdXRcblx0XHRpbnB1dFJlbmRlcmVyOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsIC8vIHJldHVybnMgYSBjdXN0b20gaW5wdXQgY29tcG9uZW50XG5cdFx0aW5zdGFuY2VJZDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsIC8vIHNldCB0aGUgY29tcG9uZW50cyBpbnN0YW5jZUlkXG5cdFx0aXNMb2FkaW5nOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsIC8vIHdoZXRoZXIgdGhlIFNlbGVjdCBpcyBsb2FkaW5nIGV4dGVybmFsbHkgb3Igbm90IChzdWNoIGFzIG9wdGlvbnMgYmVpbmcgbG9hZGVkKVxuXHRcdGpvaW5WYWx1ZXM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCwgLy8gam9pbnMgbXVsdGlwbGUgdmFsdWVzIGludG8gYSBzaW5nbGUgZm9ybSBmaWVsZCB3aXRoIHRoZSBkZWxpbWl0ZXIgKGxlZ2FjeSBtb2RlKVxuXHRcdGxhYmVsS2V5OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZywgLy8gcGF0aCBvZiB0aGUgbGFiZWwgdmFsdWUgaW4gb3B0aW9uIG9iamVjdHNcblx0XHRtYXRjaFBvczogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsIC8vIChhbnl8c3RhcnQpIG1hdGNoIHRoZSBzdGFydCBvciBlbnRpcmUgc3RyaW5nIHdoZW4gZmlsdGVyaW5nXG5cdFx0bWF0Y2hQcm9wOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZywgLy8gKGFueXxsYWJlbHx2YWx1ZSkgd2hpY2ggb3B0aW9uIHByb3BlcnR5IHRvIGZpbHRlciBvblxuXHRcdG1lbnVCdWZmZXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMubnVtYmVyLCAvLyBvcHRpb25hbCBidWZmZXIgKGluIHB4KSBiZXR3ZWVuIHRoZSBib3R0b20gb2YgdGhlIHZpZXdwb3J0IGFuZCB0aGUgYm90dG9tIG9mIHRoZSBtZW51XG5cdFx0bWVudUNvbnRhaW5lclN0eWxlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLm9iamVjdCwgLy8gb3B0aW9uYWwgc3R5bGUgdG8gYXBwbHkgdG8gdGhlIG1lbnUgY29udGFpbmVyXG5cdFx0bWVudVJlbmRlcmVyOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsIC8vIHJlbmRlcnMgYSBjdXN0b20gbWVudSB3aXRoIG9wdGlvbnNcblx0XHRtZW51U3R5bGU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub2JqZWN0LCAvLyBvcHRpb25hbCBzdHlsZSB0byBhcHBseSB0byB0aGUgbWVudVxuXHRcdG11bHRpOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsIC8vIG11bHRpLXZhbHVlIGlucHV0XG5cdFx0bmFtZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5zdHJpbmcsIC8vIGdlbmVyYXRlcyBhIGhpZGRlbiA8aW5wdXQgLz4gdGFnIHdpdGggdGhpcyBmaWVsZCBuYW1lIGZvciBodG1sIGZvcm1zXG5cdFx0bm9SZXN1bHRzVGV4dDogc3RyaW5nT3JOb2RlLCAvLyBwbGFjZWhvbGRlciBkaXNwbGF5ZWQgd2hlbiB0aGVyZSBhcmUgbm8gbWF0Y2hpbmcgc2VhcmNoIHJlc3VsdHNcblx0XHRvbkJsdXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYywgLy8gb25CbHVyIGhhbmRsZXI6IGZ1bmN0aW9uIChldmVudCkge31cblx0XHRvbkJsdXJSZXNldHNJbnB1dDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLCAvLyB3aGV0aGVyIGlucHV0IGlzIGNsZWFyZWQgb24gYmx1clxuXHRcdG9uQ2hhbmdlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsIC8vIG9uQ2hhbmdlIGhhbmRsZXI6IGZ1bmN0aW9uIChuZXdWYWx1ZSkge31cblx0XHRvbkNsb3NlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsIC8vIGZpcmVzIHdoZW4gdGhlIG1lbnUgaXMgY2xvc2VkXG5cdFx0b25DbG9zZVJlc2V0c0lucHV0OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsIC8vIHdoZXRoZXIgaW5wdXQgaXMgY2xlYXJlZCB3aGVuIG1lbnUgaXMgY2xvc2VkIHRocm91Z2ggdGhlIGFycm93XG5cdFx0b25Gb2N1czogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLCAvLyBvbkZvY3VzIGhhbmRsZXI6IGZ1bmN0aW9uIChldmVudCkge31cblx0XHRvbklucHV0Q2hhbmdlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsIC8vIG9uSW5wdXRDaGFuZ2UgaGFuZGxlcjogZnVuY3Rpb24gKGlucHV0VmFsdWUpIHt9XG5cdFx0b25JbnB1dEtleURvd246IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYywgLy8gaW5wdXQga2V5RG93biBoYW5kbGVyOiBmdW5jdGlvbiAoZXZlbnQpIHt9XG5cdFx0b25NZW51U2Nyb2xsVG9Cb3R0b206IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYywgLy8gZmlyZXMgd2hlbiB0aGUgbWVudSBpcyBzY3JvbGxlZCB0byB0aGUgYm90dG9tOyBjYW4gYmUgdXNlZCB0byBwYWdpbmF0ZSBvcHRpb25zXG5cdFx0b25PcGVuOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsIC8vIGZpcmVzIHdoZW4gdGhlIG1lbnUgaXMgb3BlbmVkXG5cdFx0b25WYWx1ZUNsaWNrOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmZ1bmMsIC8vIG9uQ2xpY2sgaGFuZGxlciBmb3IgdmFsdWUgbGFiZWxzOiBmdW5jdGlvbiAodmFsdWUsIGV2ZW50KSB7fVxuXHRcdG9wZW5BZnRlckZvY3VzOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsIC8vIGJvb2xlYW4gdG8gZW5hYmxlIG9wZW5pbmcgZHJvcGRvd24gd2hlbiBmb2N1c2VkXG5cdFx0b3Blbk9uRm9jdXM6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuYm9vbCwgLy8gYWx3YXlzIG9wZW4gb3B0aW9ucyBtZW51IG9uIGZvY3VzXG5cdFx0b3B0aW9uQ2xhc3NOYW1lOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZywgLy8gYWRkaXRpb25hbCBjbGFzcyhlcykgdG8gYXBwbHkgdG8gdGhlIDxPcHRpb24gLz4gZWxlbWVudHNcblx0XHRvcHRpb25Db21wb25lbnQ6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYywgLy8gb3B0aW9uIGNvbXBvbmVudCB0byByZW5kZXIgaW4gZHJvcGRvd25cblx0XHRvcHRpb25SZW5kZXJlcjogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLCAvLyBvcHRpb25SZW5kZXJlcjogZnVuY3Rpb24gKG9wdGlvbikge31cblx0XHRvcHRpb25zOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmFycmF5LCAvLyBhcnJheSBvZiBvcHRpb25zXG5cdFx0cGFnZVNpemU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMubnVtYmVyLCAvLyBudW1iZXIgb2YgZW50cmllcyB0byBwYWdlIHdoZW4gdXNpbmcgcGFnZSB1cC9kb3duIGtleXNcblx0XHRwbGFjZWhvbGRlcjogc3RyaW5nT3JOb2RlLCAvLyBmaWVsZCBwbGFjZWhvbGRlciwgZGlzcGxheWVkIHdoZW4gdGhlcmUncyBubyB2YWx1ZVxuXHRcdHJlcXVpcmVkOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsIC8vIGFwcGxpZXMgSFRNTDUgcmVxdWlyZWQgYXR0cmlidXRlIHdoZW4gbmVlZGVkXG5cdFx0cmVzZXRWYWx1ZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5hbnksIC8vIHZhbHVlIHRvIHVzZSB3aGVuIHlvdSBjbGVhciB0aGUgY29udHJvbFxuXHRcdHNjcm9sbE1lbnVJbnRvVmlldzogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLCAvLyBib29sZWFuIHRvIGVuYWJsZSB0aGUgdmlld3BvcnQgdG8gc2hpZnQgc28gdGhhdCB0aGUgZnVsbCBtZW51IGZ1bGx5IHZpc2libGUgd2hlbiBlbmdhZ2VkXG5cdFx0c2VhcmNoYWJsZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLCAvLyB3aGV0aGVyIHRvIGVuYWJsZSBzZWFyY2hpbmcgZmVhdHVyZSBvciBub3Rcblx0XHRzaW1wbGVWYWx1ZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5ib29sLCAvLyBwYXNzIHRoZSB2YWx1ZSB0byBvbkNoYW5nZSBhcyBhIHNpbXBsZSB2YWx1ZSAobGVnYWN5IHByZSAxLjAgbW9kZSksIGRlZmF1bHRzIHRvIGZhbHNlXG5cdFx0c3R5bGU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub2JqZWN0LCAvLyBvcHRpb25hbCBzdHlsZSB0byBhcHBseSB0byB0aGUgY29udHJvbFxuXHRcdHRhYkluZGV4OiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLnN0cmluZywgLy8gb3B0aW9uYWwgdGFiIGluZGV4IG9mIHRoZSBjb250cm9sXG5cdFx0dGFiU2VsZWN0c1ZhbHVlOiBfcmVhY3QyWydkZWZhdWx0J10uUHJvcFR5cGVzLmJvb2wsIC8vIHdoZXRoZXIgdG8gdHJlYXQgdGFiYmluZyBvdXQgd2hpbGUgZm9jdXNlZCB0byBiZSB2YWx1ZSBzZWxlY3Rpb25cblx0XHR2YWx1ZTogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5hbnksIC8vIGluaXRpYWwgZmllbGQgdmFsdWVcblx0XHR2YWx1ZUNvbXBvbmVudDogX3JlYWN0MlsnZGVmYXVsdCddLlByb3BUeXBlcy5mdW5jLCAvLyB2YWx1ZSBjb21wb25lbnQgdG8gcmVuZGVyXG5cdFx0dmFsdWVLZXk6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuc3RyaW5nLCAvLyBwYXRoIG9mIHRoZSBsYWJlbCB2YWx1ZSBpbiBvcHRpb24gb2JqZWN0c1xuXHRcdHZhbHVlUmVuZGVyZXI6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMuZnVuYywgLy8gdmFsdWVSZW5kZXJlcjogZnVuY3Rpb24gKG9wdGlvbikge31cblx0XHR3cmFwcGVyU3R5bGU6IF9yZWFjdDJbJ2RlZmF1bHQnXS5Qcm9wVHlwZXMub2JqZWN0IH0sXG5cblx0Ly8gb3B0aW9uYWwgc3R5bGUgdG8gYXBwbHkgdG8gdGhlIGNvbXBvbmVudCB3cmFwcGVyXG5cdHN0YXRpY3M6IHsgQXN5bmM6IF9Bc3luYzJbJ2RlZmF1bHQnXSwgQXN5bmNDcmVhdGFibGU6IF9Bc3luY0NyZWF0YWJsZTJbJ2RlZmF1bHQnXSwgQ3JlYXRhYmxlOiBfQ3JlYXRhYmxlMlsnZGVmYXVsdCddIH0sXG5cblx0Z2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGFkZExhYmVsVGV4dDogJ0FkZCBcIntsYWJlbH1cIj8nLFxuXHRcdFx0YXJyb3dSZW5kZXJlcjogX3V0aWxzRGVmYXVsdEFycm93UmVuZGVyZXIyWydkZWZhdWx0J10sXG5cdFx0XHRhdXRvc2l6ZTogdHJ1ZSxcblx0XHRcdGJhY2tzcGFjZVJlbW92ZXM6IHRydWUsXG5cdFx0XHRiYWNrc3BhY2VUb1JlbW92ZU1lc3NhZ2U6ICdQcmVzcyBiYWNrc3BhY2UgdG8gcmVtb3ZlIHtsYWJlbH0nLFxuXHRcdFx0Y2xlYXJhYmxlOiB0cnVlLFxuXHRcdFx0Y2xlYXJBbGxUZXh0OiAnQ2xlYXIgYWxsJyxcblx0XHRcdGNsZWFyVmFsdWVUZXh0OiAnQ2xlYXIgdmFsdWUnLFxuXHRcdFx0ZGVsaW1pdGVyOiAnLCcsXG5cdFx0XHRkaXNhYmxlZDogZmFsc2UsXG5cdFx0XHRlc2NhcGVDbGVhcnNWYWx1ZTogdHJ1ZSxcblx0XHRcdGZpbHRlck9wdGlvbnM6IF91dGlsc0RlZmF1bHRGaWx0ZXJPcHRpb25zMlsnZGVmYXVsdCddLFxuXHRcdFx0aWdub3JlQWNjZW50czogdHJ1ZSxcblx0XHRcdGlnbm9yZUNhc2U6IHRydWUsXG5cdFx0XHRpbnB1dFByb3BzOiB7fSxcblx0XHRcdGlzTG9hZGluZzogZmFsc2UsXG5cdFx0XHRqb2luVmFsdWVzOiBmYWxzZSxcblx0XHRcdGxhYmVsS2V5OiAnbGFiZWwnLFxuXHRcdFx0bWF0Y2hQb3M6ICdhbnknLFxuXHRcdFx0bWF0Y2hQcm9wOiAnYW55Jyxcblx0XHRcdG1lbnVCdWZmZXI6IDAsXG5cdFx0XHRtZW51UmVuZGVyZXI6IF91dGlsc0RlZmF1bHRNZW51UmVuZGVyZXIyWydkZWZhdWx0J10sXG5cdFx0XHRtdWx0aTogZmFsc2UsXG5cdFx0XHRub1Jlc3VsdHNUZXh0OiAnTm8gcmVzdWx0cyBmb3VuZCcsXG5cdFx0XHRvbkJsdXJSZXNldHNJbnB1dDogdHJ1ZSxcblx0XHRcdG9uQ2xvc2VSZXNldHNJbnB1dDogdHJ1ZSxcblx0XHRcdG9wZW5BZnRlckZvY3VzOiBmYWxzZSxcblx0XHRcdG9wdGlvbkNvbXBvbmVudDogX09wdGlvbjJbJ2RlZmF1bHQnXSxcblx0XHRcdHBhZ2VTaXplOiA1LFxuXHRcdFx0cGxhY2Vob2xkZXI6ICdTZWxlY3QuLi4nLFxuXHRcdFx0cmVxdWlyZWQ6IGZhbHNlLFxuXHRcdFx0c2Nyb2xsTWVudUludG9WaWV3OiB0cnVlLFxuXHRcdFx0c2VhcmNoYWJsZTogdHJ1ZSxcblx0XHRcdHNpbXBsZVZhbHVlOiBmYWxzZSxcblx0XHRcdHRhYlNlbGVjdHNWYWx1ZTogdHJ1ZSxcblx0XHRcdHZhbHVlQ29tcG9uZW50OiBfVmFsdWUyWydkZWZhdWx0J10sXG5cdFx0XHR2YWx1ZUtleTogJ3ZhbHVlJ1xuXHRcdH07XG5cdH0sXG5cblx0Z2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGlucHV0VmFsdWU6ICcnLFxuXHRcdFx0aXNGb2N1c2VkOiBmYWxzZSxcblx0XHRcdGlzT3BlbjogZmFsc2UsXG5cdFx0XHRpc1BzZXVkb0ZvY3VzZWQ6IGZhbHNlLFxuXHRcdFx0cmVxdWlyZWQ6IGZhbHNlXG5cdFx0fTtcblx0fSxcblxuXHRjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcblx0XHR0aGlzLl9pbnN0YW5jZVByZWZpeCA9ICdyZWFjdC1zZWxlY3QtJyArICh0aGlzLnByb3BzLmluc3RhbmNlSWQgfHwgKytpbnN0YW5jZUlkKSArICctJztcblx0XHR2YXIgdmFsdWVBcnJheSA9IHRoaXMuZ2V0VmFsdWVBcnJheSh0aGlzLnByb3BzLnZhbHVlKTtcblxuXHRcdGlmICh0aGlzLnByb3BzLnJlcXVpcmVkKSB7XG5cdFx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdFx0cmVxdWlyZWQ6IHRoaXMuaGFuZGxlUmVxdWlyZWQodmFsdWVBcnJheVswXSwgdGhpcy5wcm9wcy5tdWx0aSlcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0aWYgKHRoaXMucHJvcHMuYXV0b2ZvY3VzKSB7XG5cdFx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0fVxuXHR9LFxuXG5cdGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG5cdFx0dmFyIHZhbHVlQXJyYXkgPSB0aGlzLmdldFZhbHVlQXJyYXkobmV4dFByb3BzLnZhbHVlLCBuZXh0UHJvcHMpO1xuXG5cdFx0aWYgKG5leHRQcm9wcy5yZXF1aXJlZCkge1xuXHRcdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRcdHJlcXVpcmVkOiB0aGlzLmhhbmRsZVJlcXVpcmVkKHZhbHVlQXJyYXlbMF0sIG5leHRQcm9wcy5tdWx0aSlcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRjb21wb25lbnRXaWxsVXBkYXRlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG5cdFx0aWYgKG5leHRTdGF0ZS5pc09wZW4gIT09IHRoaXMuc3RhdGUuaXNPcGVuKSB7XG5cdFx0XHR0aGlzLnRvZ2dsZVRvdWNoT3V0c2lkZUV2ZW50KG5leHRTdGF0ZS5pc09wZW4pO1xuXHRcdFx0dmFyIGhhbmRsZXIgPSBuZXh0U3RhdGUuaXNPcGVuID8gbmV4dFByb3BzLm9uT3BlbiA6IG5leHRQcm9wcy5vbkNsb3NlO1xuXHRcdFx0aGFuZGxlciAmJiBoYW5kbGVyKCk7XG5cdFx0fVxuXHR9LFxuXG5cdGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG5cdFx0Ly8gZm9jdXMgdG8gdGhlIHNlbGVjdGVkIG9wdGlvblxuXHRcdGlmICh0aGlzLm1lbnUgJiYgdGhpcy5mb2N1c2VkICYmIHRoaXMuc3RhdGUuaXNPcGVuICYmICF0aGlzLmhhc1Njcm9sbGVkVG9PcHRpb24pIHtcblx0XHRcdHZhciBmb2N1c2VkT3B0aW9uTm9kZSA9IF9yZWFjdERvbTJbJ2RlZmF1bHQnXS5maW5kRE9NTm9kZSh0aGlzLmZvY3VzZWQpO1xuXHRcdFx0dmFyIG1lbnVOb2RlID0gX3JlYWN0RG9tMlsnZGVmYXVsdCddLmZpbmRET01Ob2RlKHRoaXMubWVudSk7XG5cdFx0XHRtZW51Tm9kZS5zY3JvbGxUb3AgPSBmb2N1c2VkT3B0aW9uTm9kZS5vZmZzZXRUb3A7XG5cdFx0XHR0aGlzLmhhc1Njcm9sbGVkVG9PcHRpb24gPSB0cnVlO1xuXHRcdH0gZWxzZSBpZiAoIXRoaXMuc3RhdGUuaXNPcGVuKSB7XG5cdFx0XHR0aGlzLmhhc1Njcm9sbGVkVG9PcHRpb24gPSBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fc2Nyb2xsVG9Gb2N1c2VkT3B0aW9uT25VcGRhdGUgJiYgdGhpcy5mb2N1c2VkICYmIHRoaXMubWVudSkge1xuXHRcdFx0dGhpcy5fc2Nyb2xsVG9Gb2N1c2VkT3B0aW9uT25VcGRhdGUgPSBmYWxzZTtcblx0XHRcdHZhciBmb2N1c2VkRE9NID0gX3JlYWN0RG9tMlsnZGVmYXVsdCddLmZpbmRET01Ob2RlKHRoaXMuZm9jdXNlZCk7XG5cdFx0XHR2YXIgbWVudURPTSA9IF9yZWFjdERvbTJbJ2RlZmF1bHQnXS5maW5kRE9NTm9kZSh0aGlzLm1lbnUpO1xuXHRcdFx0dmFyIGZvY3VzZWRSZWN0ID0gZm9jdXNlZERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdHZhciBtZW51UmVjdCA9IG1lbnVET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRpZiAoZm9jdXNlZFJlY3QuYm90dG9tID4gbWVudVJlY3QuYm90dG9tIHx8IGZvY3VzZWRSZWN0LnRvcCA8IG1lbnVSZWN0LnRvcCkge1xuXHRcdFx0XHRtZW51RE9NLnNjcm9sbFRvcCA9IGZvY3VzZWRET00ub2Zmc2V0VG9wICsgZm9jdXNlZERPTS5jbGllbnRIZWlnaHQgLSBtZW51RE9NLm9mZnNldEhlaWdodDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHRoaXMucHJvcHMuc2Nyb2xsTWVudUludG9WaWV3ICYmIHRoaXMubWVudUNvbnRhaW5lcikge1xuXHRcdFx0dmFyIG1lbnVDb250YWluZXJSZWN0ID0gdGhpcy5tZW51Q29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0aWYgKHdpbmRvdy5pbm5lckhlaWdodCA8IG1lbnVDb250YWluZXJSZWN0LmJvdHRvbSArIHRoaXMucHJvcHMubWVudUJ1ZmZlcikge1xuXHRcdFx0XHR3aW5kb3cuc2Nyb2xsQnkoMCwgbWVudUNvbnRhaW5lclJlY3QuYm90dG9tICsgdGhpcy5wcm9wcy5tZW51QnVmZmVyIC0gd2luZG93LmlubmVySGVpZ2h0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHByZXZQcm9wcy5kaXNhYmxlZCAhPT0gdGhpcy5wcm9wcy5kaXNhYmxlZCkge1xuXHRcdFx0dGhpcy5zZXRTdGF0ZSh7IGlzRm9jdXNlZDogZmFsc2UgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVhY3Qvbm8tZGlkLXVwZGF0ZS1zZXQtc3RhdGVcblx0XHRcdHRoaXMuY2xvc2VNZW51KCk7XG5cdFx0fVxuXHR9LFxuXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUb3VjaE91dHNpZGUpO1xuXHR9LFxuXG5cdHRvZ2dsZVRvdWNoT3V0c2lkZUV2ZW50OiBmdW5jdGlvbiB0b2dnbGVUb3VjaE91dHNpZGVFdmVudChlbmFibGVkKSB7XG5cdFx0aWYgKGVuYWJsZWQpIHtcblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRvdWNoT3V0c2lkZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRvdWNoT3V0c2lkZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGhhbmRsZVRvdWNoT3V0c2lkZTogZnVuY3Rpb24gaGFuZGxlVG91Y2hPdXRzaWRlKGV2ZW50KSB7XG5cdFx0Ly8gaGFuZGxlIHRvdWNoIG91dHNpZGUgb24gaW9zIHRvIGRpc21pc3MgbWVudVxuXHRcdGlmICh0aGlzLndyYXBwZXIgJiYgIXRoaXMud3JhcHBlci5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG5cdFx0XHR0aGlzLmNsb3NlTWVudSgpO1xuXHRcdH1cblx0fSxcblxuXHRmb2N1czogZnVuY3Rpb24gZm9jdXMoKSB7XG5cdFx0aWYgKCF0aGlzLmlucHV0KSByZXR1cm47XG5cdFx0dGhpcy5pbnB1dC5mb2N1cygpO1xuXG5cdFx0aWYgKHRoaXMucHJvcHMub3BlbkFmdGVyRm9jdXMpIHtcblx0XHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0XHRpc09wZW46IHRydWVcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRibHVySW5wdXQ6IGZ1bmN0aW9uIGJsdXJJbnB1dCgpIHtcblx0XHRpZiAoIXRoaXMuaW5wdXQpIHJldHVybjtcblx0XHR0aGlzLmlucHV0LmJsdXIoKTtcblx0fSxcblxuXHRoYW5kbGVUb3VjaE1vdmU6IGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZShldmVudCkge1xuXHRcdC8vIFNldCBhIGZsYWcgdGhhdCB0aGUgdmlldyBpcyBiZWluZyBkcmFnZ2VkXG5cdFx0dGhpcy5kcmFnZ2luZyA9IHRydWU7XG5cdH0sXG5cblx0aGFuZGxlVG91Y2hTdGFydDogZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydChldmVudCkge1xuXHRcdC8vIFNldCBhIGZsYWcgdGhhdCB0aGUgdmlldyBpcyBub3QgYmVpbmcgZHJhZ2dlZFxuXHRcdHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcblx0fSxcblxuXHRoYW5kbGVUb3VjaEVuZDogZnVuY3Rpb24gaGFuZGxlVG91Y2hFbmQoZXZlbnQpIHtcblx0XHQvLyBDaGVjayBpZiB0aGUgdmlldyBpcyBiZWluZyBkcmFnZ2VkLCBJbiB0aGlzIGNhc2Vcblx0XHQvLyB3ZSBkb24ndCB3YW50IHRvIGZpcmUgdGhlIGNsaWNrIGV2ZW50IChiZWNhdXNlIHRoZSB1c2VyIG9ubHkgd2FudHMgdG8gc2Nyb2xsKVxuXHRcdGlmICh0aGlzLmRyYWdnaW5nKSByZXR1cm47XG5cblx0XHQvLyBGaXJlIHRoZSBtb3VzZSBldmVudHNcblx0XHR0aGlzLmhhbmRsZU1vdXNlRG93bihldmVudCk7XG5cdH0sXG5cblx0aGFuZGxlVG91Y2hFbmRDbGVhclZhbHVlOiBmdW5jdGlvbiBoYW5kbGVUb3VjaEVuZENsZWFyVmFsdWUoZXZlbnQpIHtcblx0XHQvLyBDaGVjayBpZiB0aGUgdmlldyBpcyBiZWluZyBkcmFnZ2VkLCBJbiB0aGlzIGNhc2Vcblx0XHQvLyB3ZSBkb24ndCB3YW50IHRvIGZpcmUgdGhlIGNsaWNrIGV2ZW50IChiZWNhdXNlIHRoZSB1c2VyIG9ubHkgd2FudHMgdG8gc2Nyb2xsKVxuXHRcdGlmICh0aGlzLmRyYWdnaW5nKSByZXR1cm47XG5cblx0XHQvLyBDbGVhciB0aGUgdmFsdWVcblx0XHR0aGlzLmNsZWFyVmFsdWUoZXZlbnQpO1xuXHR9LFxuXG5cdGhhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XG5cdFx0Ly8gaWYgdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQgYnkgYSBtb3VzZWRvd24gYW5kIG5vdCB0aGUgcHJpbWFyeVxuXHRcdC8vIGJ1dHRvbiwgb3IgaWYgdGhlIGNvbXBvbmVudCBpcyBkaXNhYmxlZCwgaWdub3JlIGl0LlxuXHRcdGlmICh0aGlzLnByb3BzLmRpc2FibGVkIHx8IGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nICYmIGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChldmVudC50YXJnZXQudGFnTmFtZSA9PT0gJ0lOUFVUJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIHByZXZlbnQgZGVmYXVsdCBldmVudCBoYW5kbGVyc1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHQvLyBmb3IgdGhlIG5vbi1zZWFyY2hhYmxlIHNlbGVjdCwgdG9nZ2xlIHRoZSBtZW51XG5cdFx0aWYgKCF0aGlzLnByb3BzLnNlYXJjaGFibGUpIHtcblx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdHJldHVybiB0aGlzLnNldFN0YXRlKHtcblx0XHRcdFx0aXNPcGVuOiAhdGhpcy5zdGF0ZS5pc09wZW5cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnN0YXRlLmlzRm9jdXNlZCkge1xuXHRcdFx0Ly8gT24gaU9TLCB3ZSBjYW4gZ2V0IGludG8gYSBzdGF0ZSB3aGVyZSB3ZSB0aGluayB0aGUgaW5wdXQgaXMgZm9jdXNlZCBidXQgaXQgaXNuJ3QgcmVhbGx5LFxuXHRcdFx0Ly8gc2luY2UgaU9TIGlnbm9yZXMgcHJvZ3JhbW1hdGljIGNhbGxzIHRvIGlucHV0LmZvY3VzKCkgdGhhdCB3ZXJlbid0IHRyaWdnZXJlZCBieSBhIGNsaWNrIGV2ZW50LlxuXHRcdFx0Ly8gQ2FsbCBmb2N1cygpIGFnYWluIGhlcmUgdG8gYmUgc2FmZS5cblx0XHRcdHRoaXMuZm9jdXMoKTtcblxuXHRcdFx0dmFyIGlucHV0ID0gdGhpcy5pbnB1dDtcblx0XHRcdGlmICh0eXBlb2YgaW5wdXQuZ2V0SW5wdXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Ly8gR2V0IHRoZSBhY3R1YWwgRE9NIGlucHV0IGlmIHRoZSByZWYgaXMgYW4gPEF1dG9zaXplSW5wdXQgLz4gY29tcG9uZW50XG5cdFx0XHRcdGlucHV0ID0gaW5wdXQuZ2V0SW5wdXQoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY2xlYXJzIHRoZSB2YWx1ZSBzbyB0aGF0IHRoZSBjdXJzb3Igd2lsbCBiZSBhdCB0aGUgZW5kIG9mIGlucHV0IHdoZW4gdGhlIGNvbXBvbmVudCByZS1yZW5kZXJzXG5cdFx0XHRpbnB1dC52YWx1ZSA9ICcnO1xuXG5cdFx0XHQvLyBpZiB0aGUgaW5wdXQgaXMgZm9jdXNlZCwgZW5zdXJlIHRoZSBtZW51IGlzIG9wZW5cblx0XHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0XHRpc09wZW46IHRydWUsXG5cdFx0XHRcdGlzUHNldWRvRm9jdXNlZDogZmFsc2Vcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBvdGhlcndpc2UsIGZvY3VzIHRoZSBpbnB1dCBhbmQgb3BlbiB0aGUgbWVudVxuXHRcdFx0dGhpcy5fb3BlbkFmdGVyRm9jdXMgPSB0cnVlO1xuXHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdH1cblx0fSxcblxuXHRoYW5kbGVNb3VzZURvd25PbkFycm93OiBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd25PbkFycm93KGV2ZW50KSB7XG5cdFx0Ly8gaWYgdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQgYnkgYSBtb3VzZWRvd24gYW5kIG5vdCB0aGUgcHJpbWFyeVxuXHRcdC8vIGJ1dHRvbiwgb3IgaWYgdGhlIGNvbXBvbmVudCBpcyBkaXNhYmxlZCwgaWdub3JlIGl0LlxuXHRcdGlmICh0aGlzLnByb3BzLmRpc2FibGVkIHx8IGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nICYmIGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHQvLyBJZiB0aGUgbWVudSBpc24ndCBvcGVuLCBsZXQgdGhlIGV2ZW50IGJ1YmJsZSB0byB0aGUgbWFpbiBoYW5kbGVNb3VzZURvd25cblx0XHRpZiAoIXRoaXMuc3RhdGUuaXNPcGVuKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdC8vIHByZXZlbnQgZGVmYXVsdCBldmVudCBoYW5kbGVyc1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0Ly8gY2xvc2UgdGhlIG1lbnVcblx0XHR0aGlzLmNsb3NlTWVudSgpO1xuXHR9LFxuXG5cdGhhbmRsZU1vdXNlRG93bk9uTWVudTogZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duT25NZW51KGV2ZW50KSB7XG5cdFx0Ly8gaWYgdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQgYnkgYSBtb3VzZWRvd24gYW5kIG5vdCB0aGUgcHJpbWFyeVxuXHRcdC8vIGJ1dHRvbiwgb3IgaWYgdGhlIGNvbXBvbmVudCBpcyBkaXNhYmxlZCwgaWdub3JlIGl0LlxuXHRcdGlmICh0aGlzLnByb3BzLmRpc2FibGVkIHx8IGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nICYmIGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0dGhpcy5fb3BlbkFmdGVyRm9jdXMgPSB0cnVlO1xuXHRcdHRoaXMuZm9jdXMoKTtcblx0fSxcblxuXHRjbG9zZU1lbnU6IGZ1bmN0aW9uIGNsb3NlTWVudSgpIHtcblx0XHRpZiAodGhpcy5wcm9wcy5vbkNsb3NlUmVzZXRzSW5wdXQpIHtcblx0XHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0XHRpc09wZW46IGZhbHNlLFxuXHRcdFx0XHRpc1BzZXVkb0ZvY3VzZWQ6IHRoaXMuc3RhdGUuaXNGb2N1c2VkICYmICF0aGlzLnByb3BzLm11bHRpLFxuXHRcdFx0XHRpbnB1dFZhbHVlOiAnJ1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0XHRpc09wZW46IGZhbHNlLFxuXHRcdFx0XHRpc1BzZXVkb0ZvY3VzZWQ6IHRoaXMuc3RhdGUuaXNGb2N1c2VkICYmICF0aGlzLnByb3BzLm11bHRpLFxuXHRcdFx0XHRpbnB1dFZhbHVlOiB0aGlzLnN0YXRlLmlucHV0VmFsdWVcblx0XHRcdH0pO1xuXHRcdH1cblx0XHR0aGlzLmhhc1Njcm9sbGVkVG9PcHRpb24gPSBmYWxzZTtcblx0fSxcblxuXHRoYW5kbGVJbnB1dEZvY3VzOiBmdW5jdGlvbiBoYW5kbGVJbnB1dEZvY3VzKGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMucHJvcHMuZGlzYWJsZWQpIHJldHVybjtcblx0XHR2YXIgaXNPcGVuID0gdGhpcy5zdGF0ZS5pc09wZW4gfHwgdGhpcy5fb3BlbkFmdGVyRm9jdXMgfHwgdGhpcy5wcm9wcy5vcGVuT25Gb2N1cztcblx0XHRpZiAodGhpcy5wcm9wcy5vbkZvY3VzKSB7XG5cdFx0XHR0aGlzLnByb3BzLm9uRm9jdXMoZXZlbnQpO1xuXHRcdH1cblx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdGlzRm9jdXNlZDogdHJ1ZSxcblx0XHRcdGlzT3BlbjogaXNPcGVuXG5cdFx0fSk7XG5cdFx0dGhpcy5fb3BlbkFmdGVyRm9jdXMgPSBmYWxzZTtcblx0fSxcblxuXHRoYW5kbGVJbnB1dEJsdXI6IGZ1bmN0aW9uIGhhbmRsZUlucHV0Qmx1cihldmVudCkge1xuXHRcdC8vIFRoZSBjaGVjayBmb3IgbWVudS5jb250YWlucyhhY3RpdmVFbGVtZW50KSBpcyBuZWNlc3NhcnkgdG8gcHJldmVudCBJRTExJ3Mgc2Nyb2xsYmFyIGZyb20gY2xvc2luZyB0aGUgbWVudSBpbiBjZXJ0YWluIGNvbnRleHRzLlxuXHRcdGlmICh0aGlzLm1lbnUgJiYgKHRoaXMubWVudSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fCB0aGlzLm1lbnUuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpKSB7XG5cdFx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMucHJvcHMub25CbHVyKSB7XG5cdFx0XHR0aGlzLnByb3BzLm9uQmx1cihldmVudCk7XG5cdFx0fVxuXHRcdHZhciBvbkJsdXJyZWRTdGF0ZSA9IHtcblx0XHRcdGlzRm9jdXNlZDogZmFsc2UsXG5cdFx0XHRpc09wZW46IGZhbHNlLFxuXHRcdFx0aXNQc2V1ZG9Gb2N1c2VkOiBmYWxzZVxuXHRcdH07XG5cdFx0aWYgKHRoaXMucHJvcHMub25CbHVyUmVzZXRzSW5wdXQpIHtcblx0XHRcdG9uQmx1cnJlZFN0YXRlLmlucHV0VmFsdWUgPSAnJztcblx0XHR9XG5cdFx0dGhpcy5zZXRTdGF0ZShvbkJsdXJyZWRTdGF0ZSk7XG5cdH0sXG5cblx0aGFuZGxlSW5wdXRDaGFuZ2U6IGZ1bmN0aW9uIGhhbmRsZUlucHV0Q2hhbmdlKGV2ZW50KSB7XG5cdFx0dmFyIG5ld0lucHV0VmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XG5cblx0XHRpZiAodGhpcy5zdGF0ZS5pbnB1dFZhbHVlICE9PSBldmVudC50YXJnZXQudmFsdWUgJiYgdGhpcy5wcm9wcy5vbklucHV0Q2hhbmdlKSB7XG5cdFx0XHR2YXIgbmV4dFN0YXRlID0gdGhpcy5wcm9wcy5vbklucHV0Q2hhbmdlKG5ld0lucHV0VmFsdWUpO1xuXHRcdFx0Ly8gTm90ZTogIT0gdXNlZCBkZWxpYmVyYXRlbHkgaGVyZSB0byBjYXRjaCB1bmRlZmluZWQgYW5kIG51bGxcblx0XHRcdGlmIChuZXh0U3RhdGUgIT0gbnVsbCAmJiB0eXBlb2YgbmV4dFN0YXRlICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRuZXdJbnB1dFZhbHVlID0gJycgKyBuZXh0U3RhdGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRpc09wZW46IHRydWUsXG5cdFx0XHRpc1BzZXVkb0ZvY3VzZWQ6IGZhbHNlLFxuXHRcdFx0aW5wdXRWYWx1ZTogbmV3SW5wdXRWYWx1ZVxuXHRcdH0pO1xuXHR9LFxuXG5cdGhhbmRsZUtleURvd246IGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcblx0XHRpZiAodGhpcy5wcm9wcy5kaXNhYmxlZCkgcmV0dXJuO1xuXG5cdFx0aWYgKHR5cGVvZiB0aGlzLnByb3BzLm9uSW5wdXRLZXlEb3duID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLnByb3BzLm9uSW5wdXRLZXlEb3duKGV2ZW50KTtcblx0XHRcdGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcblx0XHRcdGNhc2UgODpcblx0XHRcdFx0Ly8gYmFja3NwYWNlXG5cdFx0XHRcdGlmICghdGhpcy5zdGF0ZS5pbnB1dFZhbHVlICYmIHRoaXMucHJvcHMuYmFja3NwYWNlUmVtb3Zlcykge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0dGhpcy5wb3BWYWx1ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGNhc2UgOTpcblx0XHRcdFx0Ly8gdGFiXG5cdFx0XHRcdGlmIChldmVudC5zaGlmdEtleSB8fCAhdGhpcy5zdGF0ZS5pc09wZW4gfHwgIXRoaXMucHJvcHMudGFiU2VsZWN0c1ZhbHVlKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc2VsZWN0Rm9jdXNlZE9wdGlvbigpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRjYXNlIDEzOlxuXHRcdFx0XHQvLyBlbnRlclxuXHRcdFx0XHRpZiAoIXRoaXMuc3RhdGUuaXNPcGVuKSByZXR1cm47XG5cdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR0aGlzLnNlbGVjdEZvY3VzZWRPcHRpb24oKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDI3OlxuXHRcdFx0XHQvLyBlc2NhcGVcblx0XHRcdFx0aWYgKHRoaXMuc3RhdGUuaXNPcGVuKSB7XG5cdFx0XHRcdFx0dGhpcy5jbG9zZU1lbnUoKTtcblx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLnByb3BzLmNsZWFyYWJsZSAmJiB0aGlzLnByb3BzLmVzY2FwZUNsZWFyc1ZhbHVlKSB7XG5cdFx0XHRcdFx0dGhpcy5jbGVhclZhbHVlKGV2ZW50KTtcblx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgMzg6XG5cdFx0XHRcdC8vIHVwXG5cdFx0XHRcdHRoaXMuZm9jdXNQcmV2aW91c09wdGlvbigpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgNDA6XG5cdFx0XHRcdC8vIGRvd25cblx0XHRcdFx0dGhpcy5mb2N1c05leHRPcHRpb24oKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDMzOlxuXHRcdFx0XHQvLyBwYWdlIHVwXG5cdFx0XHRcdHRoaXMuZm9jdXNQYWdlVXBPcHRpb24oKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDM0OlxuXHRcdFx0XHQvLyBwYWdlIGRvd25cblx0XHRcdFx0dGhpcy5mb2N1c1BhZ2VEb3duT3B0aW9uKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAzNTpcblx0XHRcdFx0Ly8gZW5kIGtleVxuXHRcdFx0XHRpZiAoZXZlbnQuc2hpZnRLZXkpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5mb2N1c0VuZE9wdGlvbigpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgMzY6XG5cdFx0XHRcdC8vIGhvbWUga2V5XG5cdFx0XHRcdGlmIChldmVudC5zaGlmdEtleSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmZvY3VzU3RhcnRPcHRpb24oKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdH0sXG5cblx0aGFuZGxlVmFsdWVDbGljazogZnVuY3Rpb24gaGFuZGxlVmFsdWVDbGljayhvcHRpb24sIGV2ZW50KSB7XG5cdFx0aWYgKCF0aGlzLnByb3BzLm9uVmFsdWVDbGljaykgcmV0dXJuO1xuXHRcdHRoaXMucHJvcHMub25WYWx1ZUNsaWNrKG9wdGlvbiwgZXZlbnQpO1xuXHR9LFxuXG5cdGhhbmRsZU1lbnVTY3JvbGw6IGZ1bmN0aW9uIGhhbmRsZU1lbnVTY3JvbGwoZXZlbnQpIHtcblx0XHRpZiAoIXRoaXMucHJvcHMub25NZW51U2Nyb2xsVG9Cb3R0b20pIHJldHVybjtcblx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0aWYgKHRhcmdldC5zY3JvbGxIZWlnaHQgPiB0YXJnZXQub2Zmc2V0SGVpZ2h0ICYmICEodGFyZ2V0LnNjcm9sbEhlaWdodCAtIHRhcmdldC5vZmZzZXRIZWlnaHQgLSB0YXJnZXQuc2Nyb2xsVG9wKSkge1xuXHRcdFx0dGhpcy5wcm9wcy5vbk1lbnVTY3JvbGxUb0JvdHRvbSgpO1xuXHRcdH1cblx0fSxcblxuXHRoYW5kbGVSZXF1aXJlZDogZnVuY3Rpb24gaGFuZGxlUmVxdWlyZWQodmFsdWUsIG11bHRpKSB7XG5cdFx0aWYgKCF2YWx1ZSkgcmV0dXJuIHRydWU7XG5cdFx0cmV0dXJuIG11bHRpID8gdmFsdWUubGVuZ3RoID09PSAwIDogT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMDtcblx0fSxcblxuXHRnZXRPcHRpb25MYWJlbDogZnVuY3Rpb24gZ2V0T3B0aW9uTGFiZWwob3ApIHtcblx0XHRyZXR1cm4gb3BbdGhpcy5wcm9wcy5sYWJlbEtleV07XG5cdH0sXG5cblx0LyoqXG4gICogVHVybnMgYSB2YWx1ZSBpbnRvIGFuIGFycmF5IGZyb20gdGhlIGdpdmVuIG9wdGlvbnNcbiAgKiBAcGFyYW1cdHtTdHJpbmd8TnVtYmVyfEFycmF5fVx0dmFsdWVcdFx0LSB0aGUgdmFsdWUgb2YgdGhlIHNlbGVjdCBpbnB1dFxuICAqIEBwYXJhbVx0e09iamVjdH1cdFx0bmV4dFByb3BzXHQtIG9wdGlvbmFsbHkgc3BlY2lmeSB0aGUgbmV4dFByb3BzIHNvIHRoZSByZXR1cm5lZCBhcnJheSB1c2VzIHRoZSBsYXRlc3QgY29uZmlndXJhdGlvblxuICAqIEByZXR1cm5zXHR7QXJyYXl9XHR0aGUgdmFsdWUgb2YgdGhlIHNlbGVjdCByZXByZXNlbnRlZCBpbiBhbiBhcnJheVxuICAqL1xuXHRnZXRWYWx1ZUFycmF5OiBmdW5jdGlvbiBnZXRWYWx1ZUFycmF5KHZhbHVlLCBuZXh0UHJvcHMpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdFx0LyoqIHN1cHBvcnQgb3B0aW9uYWxseSBwYXNzaW5nIGluIHRoZSBgbmV4dFByb3BzYCBzbyBgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc2AgdXBkYXRlcyB3aWxsIGZ1bmN0aW9uIGFzIGV4cGVjdGVkICovXG5cdFx0dmFyIHByb3BzID0gdHlwZW9mIG5leHRQcm9wcyA9PT0gJ29iamVjdCcgPyBuZXh0UHJvcHMgOiB0aGlzLnByb3BzO1xuXHRcdGlmIChwcm9wcy5tdWx0aSkge1xuXHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHZhbHVlID0gdmFsdWUuc3BsaXQocHJvcHMuZGVsaW1pdGVyKTtcblx0XHRcdGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0aWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBbXTtcblx0XHRcdFx0dmFsdWUgPSBbdmFsdWVdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuIF90aGlzLmV4cGFuZFZhbHVlKHZhbHVlLCBwcm9wcyk7XG5cdFx0XHR9KS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0dmFyIGV4cGFuZGVkVmFsdWUgPSB0aGlzLmV4cGFuZFZhbHVlKHZhbHVlLCBwcm9wcyk7XG5cdFx0cmV0dXJuIGV4cGFuZGVkVmFsdWUgPyBbZXhwYW5kZWRWYWx1ZV0gOiBbXTtcblx0fSxcblxuXHQvKipcbiAgKiBSZXRyaWV2ZSBhIHZhbHVlIGZyb20gdGhlIGdpdmVuIG9wdGlvbnMgYW5kIHZhbHVlS2V5XG4gICogQHBhcmFtXHR7U3RyaW5nfE51bWJlcnxBcnJheX1cdHZhbHVlXHQtIHRoZSBzZWxlY3RlZCB2YWx1ZShzKVxuICAqIEBwYXJhbVx0e09iamVjdH1cdFx0cHJvcHNcdC0gdGhlIFNlbGVjdCBjb21wb25lbnQncyBwcm9wcyAob3IgbmV4dFByb3BzKVxuICAqL1xuXHRleHBhbmRWYWx1ZTogZnVuY3Rpb24gZXhwYW5kVmFsdWUodmFsdWUsIHByb3BzKSB7XG5cdFx0dmFyIHZhbHVlVHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0XHRpZiAodmFsdWVUeXBlICE9PSAnc3RyaW5nJyAmJiB2YWx1ZVR5cGUgIT09ICdudW1iZXInICYmIHZhbHVlVHlwZSAhPT0gJ2Jvb2xlYW4nKSByZXR1cm4gdmFsdWU7XG5cdFx0dmFyIG9wdGlvbnMgPSBwcm9wcy5vcHRpb25zO1xuXHRcdHZhciB2YWx1ZUtleSA9IHByb3BzLnZhbHVlS2V5O1xuXG5cdFx0aWYgKCFvcHRpb25zKSByZXR1cm47XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAob3B0aW9uc1tpXVt2YWx1ZUtleV0gPT09IHZhbHVlKSByZXR1cm4gb3B0aW9uc1tpXTtcblx0XHR9XG5cdH0sXG5cblx0c2V0VmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKHZhbHVlKSB7XG5cdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cblx0XHRpZiAodGhpcy5wcm9wcy5hdXRvQmx1cikge1xuXHRcdFx0dGhpcy5ibHVySW5wdXQoKTtcblx0XHR9XG5cdFx0aWYgKCF0aGlzLnByb3BzLm9uQ2hhbmdlKSByZXR1cm47XG5cdFx0aWYgKHRoaXMucHJvcHMucmVxdWlyZWQpIHtcblx0XHRcdHZhciByZXF1aXJlZCA9IHRoaXMuaGFuZGxlUmVxdWlyZWQodmFsdWUsIHRoaXMucHJvcHMubXVsdGkpO1xuXHRcdFx0dGhpcy5zZXRTdGF0ZSh7IHJlcXVpcmVkOiByZXF1aXJlZCB9KTtcblx0XHR9XG5cdFx0aWYgKHRoaXMucHJvcHMuc2ltcGxlVmFsdWUgJiYgdmFsdWUpIHtcblx0XHRcdHZhbHVlID0gdGhpcy5wcm9wcy5tdWx0aSA/IHZhbHVlLm1hcChmdW5jdGlvbiAoaSkge1xuXHRcdFx0XHRyZXR1cm4gaVtfdGhpczIucHJvcHMudmFsdWVLZXldO1xuXHRcdFx0fSkuam9pbih0aGlzLnByb3BzLmRlbGltaXRlcikgOiB2YWx1ZVt0aGlzLnByb3BzLnZhbHVlS2V5XTtcblx0XHR9XG5cdFx0dGhpcy5wcm9wcy5vbkNoYW5nZSh2YWx1ZSk7XG5cdH0sXG5cblx0c2VsZWN0VmFsdWU6IGZ1bmN0aW9uIHNlbGVjdFZhbHVlKHZhbHVlKSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cblx0XHQvL05PVEU6IHVwZGF0ZSB2YWx1ZSBpbiB0aGUgY2FsbGJhY2sgdG8gbWFrZSBzdXJlIHRoZSBpbnB1dCB2YWx1ZSBpcyBlbXB0eSBzbyB0aGF0IHRoZXJlIGFyZSBubyBzdHlsaW5nIGlzc3VlcyAoQ2hyb21lIGhhZCBpc3N1ZSBvdGhlcndpc2UpXG5cdFx0dGhpcy5oYXNTY3JvbGxlZFRvT3B0aW9uID0gZmFsc2U7XG5cdFx0aWYgKHRoaXMucHJvcHMubXVsdGkpIHtcblx0XHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0XHRpbnB1dFZhbHVlOiAnJyxcblx0XHRcdFx0Zm9jdXNlZEluZGV4OiBudWxsXG5cdFx0XHR9LCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF90aGlzMy5hZGRWYWx1ZSh2YWx1ZSk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRcdGlzT3BlbjogZmFsc2UsXG5cdFx0XHRcdGlucHV0VmFsdWU6ICcnLFxuXHRcdFx0XHRpc1BzZXVkb0ZvY3VzZWQ6IHRoaXMuc3RhdGUuaXNGb2N1c2VkXG5cdFx0XHR9LCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF90aGlzMy5zZXRWYWx1ZSh2YWx1ZSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0YWRkVmFsdWU6IGZ1bmN0aW9uIGFkZFZhbHVlKHZhbHVlKSB7XG5cdFx0dmFyIHZhbHVlQXJyYXkgPSB0aGlzLmdldFZhbHVlQXJyYXkodGhpcy5wcm9wcy52YWx1ZSk7XG5cdFx0dGhpcy5zZXRWYWx1ZSh2YWx1ZUFycmF5LmNvbmNhdCh2YWx1ZSkpO1xuXHR9LFxuXG5cdHBvcFZhbHVlOiBmdW5jdGlvbiBwb3BWYWx1ZSgpIHtcblx0XHR2YXIgdmFsdWVBcnJheSA9IHRoaXMuZ2V0VmFsdWVBcnJheSh0aGlzLnByb3BzLnZhbHVlKTtcblx0XHRpZiAoIXZhbHVlQXJyYXkubGVuZ3RoKSByZXR1cm47XG5cdFx0aWYgKHZhbHVlQXJyYXlbdmFsdWVBcnJheS5sZW5ndGggLSAxXS5jbGVhcmFibGVWYWx1ZSA9PT0gZmFsc2UpIHJldHVybjtcblx0XHR0aGlzLnNldFZhbHVlKHZhbHVlQXJyYXkuc2xpY2UoMCwgdmFsdWVBcnJheS5sZW5ndGggLSAxKSk7XG5cdH0sXG5cblx0cmVtb3ZlVmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVZhbHVlKHZhbHVlKSB7XG5cdFx0dmFyIHZhbHVlQXJyYXkgPSB0aGlzLmdldFZhbHVlQXJyYXkodGhpcy5wcm9wcy52YWx1ZSk7XG5cdFx0dGhpcy5zZXRWYWx1ZSh2YWx1ZUFycmF5LmZpbHRlcihmdW5jdGlvbiAoaSkge1xuXHRcdFx0cmV0dXJuIGkgIT09IHZhbHVlO1xuXHRcdH0pKTtcblx0XHR0aGlzLmZvY3VzKCk7XG5cdH0sXG5cblx0Y2xlYXJWYWx1ZTogZnVuY3Rpb24gY2xlYXJWYWx1ZShldmVudCkge1xuXHRcdC8vIGlmIHRoZSBldmVudCB3YXMgdHJpZ2dlcmVkIGJ5IGEgbW91c2Vkb3duIGFuZCBub3QgdGhlIHByaW1hcnlcblx0XHQvLyBidXR0b24sIGlnbm9yZSBpdC5cblx0XHRpZiAoZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgJiYgZXZlbnQuYnV0dG9uICE9PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0dGhpcy5zZXRWYWx1ZSh0aGlzLmdldFJlc2V0VmFsdWUoKSk7XG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRpc09wZW46IGZhbHNlLFxuXHRcdFx0aW5wdXRWYWx1ZTogJydcblx0XHR9LCB0aGlzLmZvY3VzKTtcblx0fSxcblxuXHRnZXRSZXNldFZhbHVlOiBmdW5jdGlvbiBnZXRSZXNldFZhbHVlKCkge1xuXHRcdGlmICh0aGlzLnByb3BzLnJlc2V0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHJvcHMucmVzZXRWYWx1ZTtcblx0XHR9IGVsc2UgaWYgKHRoaXMucHJvcHMubXVsdGkpIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdGZvY3VzT3B0aW9uOiBmdW5jdGlvbiBmb2N1c09wdGlvbihvcHRpb24pIHtcblx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdGZvY3VzZWRPcHRpb246IG9wdGlvblxuXHRcdH0pO1xuXHR9LFxuXG5cdGZvY3VzTmV4dE9wdGlvbjogZnVuY3Rpb24gZm9jdXNOZXh0T3B0aW9uKCkge1xuXHRcdHRoaXMuZm9jdXNBZGphY2VudE9wdGlvbignbmV4dCcpO1xuXHR9LFxuXG5cdGZvY3VzUHJldmlvdXNPcHRpb246IGZ1bmN0aW9uIGZvY3VzUHJldmlvdXNPcHRpb24oKSB7XG5cdFx0dGhpcy5mb2N1c0FkamFjZW50T3B0aW9uKCdwcmV2aW91cycpO1xuXHR9LFxuXG5cdGZvY3VzUGFnZVVwT3B0aW9uOiBmdW5jdGlvbiBmb2N1c1BhZ2VVcE9wdGlvbigpIHtcblx0XHR0aGlzLmZvY3VzQWRqYWNlbnRPcHRpb24oJ3BhZ2VfdXAnKTtcblx0fSxcblxuXHRmb2N1c1BhZ2VEb3duT3B0aW9uOiBmdW5jdGlvbiBmb2N1c1BhZ2VEb3duT3B0aW9uKCkge1xuXHRcdHRoaXMuZm9jdXNBZGphY2VudE9wdGlvbigncGFnZV9kb3duJyk7XG5cdH0sXG5cblx0Zm9jdXNTdGFydE9wdGlvbjogZnVuY3Rpb24gZm9jdXNTdGFydE9wdGlvbigpIHtcblx0XHR0aGlzLmZvY3VzQWRqYWNlbnRPcHRpb24oJ3N0YXJ0Jyk7XG5cdH0sXG5cblx0Zm9jdXNFbmRPcHRpb246IGZ1bmN0aW9uIGZvY3VzRW5kT3B0aW9uKCkge1xuXHRcdHRoaXMuZm9jdXNBZGphY2VudE9wdGlvbignZW5kJyk7XG5cdH0sXG5cblx0Zm9jdXNBZGphY2VudE9wdGlvbjogZnVuY3Rpb24gZm9jdXNBZGphY2VudE9wdGlvbihkaXIpIHtcblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuX3Zpc2libGVPcHRpb25zLm1hcChmdW5jdGlvbiAob3B0aW9uLCBpbmRleCkge1xuXHRcdFx0cmV0dXJuIHsgb3B0aW9uOiBvcHRpb24sIGluZGV4OiBpbmRleCB9O1xuXHRcdH0pLmZpbHRlcihmdW5jdGlvbiAob3B0aW9uKSB7XG5cdFx0XHRyZXR1cm4gIW9wdGlvbi5vcHRpb24uZGlzYWJsZWQ7XG5cdFx0fSk7XG5cdFx0dGhpcy5fc2Nyb2xsVG9Gb2N1c2VkT3B0aW9uT25VcGRhdGUgPSB0cnVlO1xuXHRcdGlmICghdGhpcy5zdGF0ZS5pc09wZW4pIHtcblx0XHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0XHRpc09wZW46IHRydWUsXG5cdFx0XHRcdGlucHV0VmFsdWU6ICcnLFxuXHRcdFx0XHRmb2N1c2VkT3B0aW9uOiB0aGlzLl9mb2N1c2VkT3B0aW9uIHx8IG9wdGlvbnNbZGlyID09PSAnbmV4dCcgPyAwIDogb3B0aW9ucy5sZW5ndGggLSAxXS5vcHRpb25cblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIW9wdGlvbnMubGVuZ3RoKSByZXR1cm47XG5cdFx0dmFyIGZvY3VzZWRJbmRleCA9IC0xO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuX2ZvY3VzZWRPcHRpb24gPT09IG9wdGlvbnNbaV0ub3B0aW9uKSB7XG5cdFx0XHRcdGZvY3VzZWRJbmRleCA9IGk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoZGlyID09PSAnbmV4dCcgJiYgZm9jdXNlZEluZGV4ICE9PSAtMSkge1xuXHRcdFx0Zm9jdXNlZEluZGV4ID0gKGZvY3VzZWRJbmRleCArIDEpICUgb3B0aW9ucy5sZW5ndGg7XG5cdFx0fSBlbHNlIGlmIChkaXIgPT09ICdwcmV2aW91cycpIHtcblx0XHRcdGlmIChmb2N1c2VkSW5kZXggPiAwKSB7XG5cdFx0XHRcdGZvY3VzZWRJbmRleCA9IGZvY3VzZWRJbmRleCAtIDE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb2N1c2VkSW5kZXggPSBvcHRpb25zLmxlbmd0aCAtIDE7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChkaXIgPT09ICdzdGFydCcpIHtcblx0XHRcdGZvY3VzZWRJbmRleCA9IDA7XG5cdFx0fSBlbHNlIGlmIChkaXIgPT09ICdlbmQnKSB7XG5cdFx0XHRmb2N1c2VkSW5kZXggPSBvcHRpb25zLmxlbmd0aCAtIDE7XG5cdFx0fSBlbHNlIGlmIChkaXIgPT09ICdwYWdlX3VwJykge1xuXHRcdFx0dmFyIHBvdGVudGlhbEluZGV4ID0gZm9jdXNlZEluZGV4IC0gdGhpcy5wcm9wcy5wYWdlU2l6ZTtcblx0XHRcdGlmIChwb3RlbnRpYWxJbmRleCA8IDApIHtcblx0XHRcdFx0Zm9jdXNlZEluZGV4ID0gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvY3VzZWRJbmRleCA9IHBvdGVudGlhbEluZGV4O1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoZGlyID09PSAncGFnZV9kb3duJykge1xuXHRcdFx0dmFyIHBvdGVudGlhbEluZGV4ID0gZm9jdXNlZEluZGV4ICsgdGhpcy5wcm9wcy5wYWdlU2l6ZTtcblx0XHRcdGlmIChwb3RlbnRpYWxJbmRleCA+IG9wdGlvbnMubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRmb2N1c2VkSW5kZXggPSBvcHRpb25zLmxlbmd0aCAtIDE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb2N1c2VkSW5kZXggPSBwb3RlbnRpYWxJbmRleDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZm9jdXNlZEluZGV4ID09PSAtMSkge1xuXHRcdFx0Zm9jdXNlZEluZGV4ID0gMDtcblx0XHR9XG5cblx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdGZvY3VzZWRJbmRleDogb3B0aW9uc1tmb2N1c2VkSW5kZXhdLmluZGV4LFxuXHRcdFx0Zm9jdXNlZE9wdGlvbjogb3B0aW9uc1tmb2N1c2VkSW5kZXhdLm9wdGlvblxuXHRcdH0pO1xuXHR9LFxuXG5cdGdldEZvY3VzZWRPcHRpb246IGZ1bmN0aW9uIGdldEZvY3VzZWRPcHRpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ZvY3VzZWRPcHRpb247XG5cdH0sXG5cblx0Z2V0SW5wdXRWYWx1ZTogZnVuY3Rpb24gZ2V0SW5wdXRWYWx1ZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5pbnB1dFZhbHVlO1xuXHR9LFxuXG5cdHNlbGVjdEZvY3VzZWRPcHRpb246IGZ1bmN0aW9uIHNlbGVjdEZvY3VzZWRPcHRpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2ZvY3VzZWRPcHRpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLnNlbGVjdFZhbHVlKHRoaXMuX2ZvY3VzZWRPcHRpb24pO1xuXHRcdH1cblx0fSxcblxuXHRyZW5kZXJMb2FkaW5nOiBmdW5jdGlvbiByZW5kZXJMb2FkaW5nKCkge1xuXHRcdGlmICghdGhpcy5wcm9wcy5pc0xvYWRpbmcpIHJldHVybjtcblx0XHRyZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG5cdFx0XHQnc3BhbicsXG5cdFx0XHR7IGNsYXNzTmFtZTogJ1NlbGVjdC1sb2FkaW5nLXpvbmUnLCAnYXJpYS1oaWRkZW4nOiAndHJ1ZScgfSxcblx0XHRcdF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdzcGFuJywgeyBjbGFzc05hbWU6ICdTZWxlY3QtbG9hZGluZycgfSlcblx0XHQpO1xuXHR9LFxuXG5cdHJlbmRlclZhbHVlOiBmdW5jdGlvbiByZW5kZXJWYWx1ZSh2YWx1ZUFycmF5LCBpc09wZW4pIHtcblx0XHR2YXIgX3RoaXM0ID0gdGhpcztcblxuXHRcdHZhciByZW5kZXJMYWJlbCA9IHRoaXMucHJvcHMudmFsdWVSZW5kZXJlciB8fCB0aGlzLmdldE9wdGlvbkxhYmVsO1xuXHRcdHZhciBWYWx1ZUNvbXBvbmVudCA9IHRoaXMucHJvcHMudmFsdWVDb21wb25lbnQ7XG5cdFx0aWYgKCF2YWx1ZUFycmF5Lmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuICF0aGlzLnN0YXRlLmlucHV0VmFsdWUgPyBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcblx0XHRcdFx0J2RpdicsXG5cdFx0XHRcdHsgY2xhc3NOYW1lOiAnU2VsZWN0LXBsYWNlaG9sZGVyJyB9LFxuXHRcdFx0XHR0aGlzLnByb3BzLnBsYWNlaG9sZGVyXG5cdFx0XHQpIDogbnVsbDtcblx0XHR9XG5cdFx0dmFyIG9uQ2xpY2sgPSB0aGlzLnByb3BzLm9uVmFsdWVDbGljayA/IHRoaXMuaGFuZGxlVmFsdWVDbGljayA6IG51bGw7XG5cdFx0aWYgKHRoaXMucHJvcHMubXVsdGkpIHtcblx0XHRcdHJldHVybiB2YWx1ZUFycmF5Lm1hcChmdW5jdGlvbiAodmFsdWUsIGkpIHtcblx0XHRcdFx0cmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuXHRcdFx0XHRcdFZhbHVlQ29tcG9uZW50LFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlkOiBfdGhpczQuX2luc3RhbmNlUHJlZml4ICsgJy12YWx1ZS0nICsgaSxcblx0XHRcdFx0XHRcdGluc3RhbmNlUHJlZml4OiBfdGhpczQuX2luc3RhbmNlUHJlZml4LFxuXHRcdFx0XHRcdFx0ZGlzYWJsZWQ6IF90aGlzNC5wcm9wcy5kaXNhYmxlZCB8fCB2YWx1ZS5jbGVhcmFibGVWYWx1ZSA9PT0gZmFsc2UsXG5cdFx0XHRcdFx0XHRrZXk6ICd2YWx1ZS0nICsgaSArICctJyArIHZhbHVlW190aGlzNC5wcm9wcy52YWx1ZUtleV0sXG5cdFx0XHRcdFx0XHRvbkNsaWNrOiBvbkNsaWNrLFxuXHRcdFx0XHRcdFx0b25SZW1vdmU6IF90aGlzNC5yZW1vdmVWYWx1ZSxcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0cmVuZGVyTGFiZWwodmFsdWUsIGkpLFxuXHRcdFx0XHRcdF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuXHRcdFx0XHRcdFx0J3NwYW4nLFxuXHRcdFx0XHRcdFx0eyBjbGFzc05hbWU6ICdTZWxlY3QtYXJpYS1vbmx5JyB9LFxuXHRcdFx0XHRcdFx0J8KgJ1xuXHRcdFx0XHRcdClcblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoIXRoaXMuc3RhdGUuaW5wdXRWYWx1ZSkge1xuXHRcdFx0aWYgKGlzT3Blbikgb25DbGljayA9IG51bGw7XG5cdFx0XHRyZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRcdFZhbHVlQ29tcG9uZW50LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWQ6IHRoaXMuX2luc3RhbmNlUHJlZml4ICsgJy12YWx1ZS1pdGVtJyxcblx0XHRcdFx0XHRkaXNhYmxlZDogdGhpcy5wcm9wcy5kaXNhYmxlZCxcblx0XHRcdFx0XHRpbnN0YW5jZVByZWZpeDogdGhpcy5faW5zdGFuY2VQcmVmaXgsXG5cdFx0XHRcdFx0b25DbGljazogb25DbGljayxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVBcnJheVswXVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZW5kZXJMYWJlbCh2YWx1ZUFycmF5WzBdKVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblx0cmVuZGVySW5wdXQ6IGZ1bmN0aW9uIHJlbmRlcklucHV0KHZhbHVlQXJyYXksIGZvY3VzZWRPcHRpb25JbmRleCkge1xuXHRcdHZhciBfdGhpczUgPSB0aGlzO1xuXG5cdFx0aWYgKHRoaXMucHJvcHMuaW5wdXRSZW5kZXJlcikge1xuXHRcdFx0cmV0dXJuIHRoaXMucHJvcHMuaW5wdXRSZW5kZXJlcigpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgX2NsYXNzTmFtZXM7XG5cblx0XHRcdHZhciBjbGFzc05hbWUgPSAoMCwgX2NsYXNzbmFtZXMyWydkZWZhdWx0J10pKCdTZWxlY3QtaW5wdXQnLCB0aGlzLnByb3BzLmlucHV0UHJvcHMuY2xhc3NOYW1lKTtcblx0XHRcdHZhciBpc09wZW4gPSAhIXRoaXMuc3RhdGUuaXNPcGVuO1xuXG5cdFx0XHR2YXIgYXJpYU93bnMgPSAoMCwgX2NsYXNzbmFtZXMyWydkZWZhdWx0J10pKChfY2xhc3NOYW1lcyA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX2NsYXNzTmFtZXMsIHRoaXMuX2luc3RhbmNlUHJlZml4ICsgJy1saXN0JywgaXNPcGVuKSwgX2RlZmluZVByb3BlcnR5KF9jbGFzc05hbWVzLCB0aGlzLl9pbnN0YW5jZVByZWZpeCArICctYmFja3NwYWNlLXJlbW92ZS1tZXNzYWdlJywgdGhpcy5wcm9wcy5tdWx0aSAmJiAhdGhpcy5wcm9wcy5kaXNhYmxlZCAmJiB0aGlzLnN0YXRlLmlzRm9jdXNlZCAmJiAhdGhpcy5zdGF0ZS5pbnB1dFZhbHVlKSwgX2NsYXNzTmFtZXMpKTtcblxuXHRcdFx0Ly8gVE9ETzogQ2hlY2sgaG93IHRoaXMgcHJvamVjdCBpbmNsdWRlcyBPYmplY3QuYXNzaWduKClcblx0XHRcdHZhciBpbnB1dFByb3BzID0gX2V4dGVuZHMoe30sIHRoaXMucHJvcHMuaW5wdXRQcm9wcywge1xuXHRcdFx0XHRyb2xlOiAnY29tYm9ib3gnLFxuXHRcdFx0XHQnYXJpYS1leHBhbmRlZCc6ICcnICsgaXNPcGVuLFxuXHRcdFx0XHQnYXJpYS1vd25zJzogYXJpYU93bnMsXG5cdFx0XHRcdCdhcmlhLWhhc3BvcHVwJzogJycgKyBpc09wZW4sXG5cdFx0XHRcdCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiBpc09wZW4gPyB0aGlzLl9pbnN0YW5jZVByZWZpeCArICctb3B0aW9uLScgKyBmb2N1c2VkT3B0aW9uSW5kZXggOiB0aGlzLl9pbnN0YW5jZVByZWZpeCArICctdmFsdWUnLFxuXHRcdFx0XHQnYXJpYS1sYWJlbGxlZGJ5JzogdGhpcy5wcm9wc1snYXJpYS1sYWJlbGxlZGJ5J10sXG5cdFx0XHRcdCdhcmlhLWxhYmVsJzogdGhpcy5wcm9wc1snYXJpYS1sYWJlbCddLFxuXHRcdFx0XHRjbGFzc05hbWU6IGNsYXNzTmFtZSxcblx0XHRcdFx0dGFiSW5kZXg6IHRoaXMucHJvcHMudGFiSW5kZXgsXG5cdFx0XHRcdG9uQmx1cjogdGhpcy5oYW5kbGVJbnB1dEJsdXIsXG5cdFx0XHRcdG9uQ2hhbmdlOiB0aGlzLmhhbmRsZUlucHV0Q2hhbmdlLFxuXHRcdFx0XHRvbkZvY3VzOiB0aGlzLmhhbmRsZUlucHV0Rm9jdXMsXG5cdFx0XHRcdHJlZjogZnVuY3Rpb24gcmVmKF9yZWYpIHtcblx0XHRcdFx0XHRyZXR1cm4gX3RoaXM1LmlucHV0ID0gX3JlZjtcblx0XHRcdFx0fSxcblx0XHRcdFx0cmVxdWlyZWQ6IHRoaXMuc3RhdGUucmVxdWlyZWQsXG5cdFx0XHRcdHZhbHVlOiB0aGlzLnN0YXRlLmlucHV0VmFsdWVcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAodGhpcy5wcm9wcy5kaXNhYmxlZCB8fCAhdGhpcy5wcm9wcy5zZWFyY2hhYmxlKSB7XG5cdFx0XHRcdHZhciBfcHJvcHMkaW5wdXRQcm9wcyA9IHRoaXMucHJvcHMuaW5wdXRQcm9wcztcblx0XHRcdFx0dmFyIGlucHV0Q2xhc3NOYW1lID0gX3Byb3BzJGlucHV0UHJvcHMuaW5wdXRDbGFzc05hbWU7XG5cblx0XHRcdFx0dmFyIGRpdlByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcyRpbnB1dFByb3BzLCBbJ2lucHV0Q2xhc3NOYW1lJ10pO1xuXG5cdFx0XHRcdHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnZGl2JywgX2V4dGVuZHMoe30sIGRpdlByb3BzLCB7XG5cdFx0XHRcdFx0cm9sZTogJ2NvbWJvYm94Jyxcblx0XHRcdFx0XHQnYXJpYS1leHBhbmRlZCc6IGlzT3Blbixcblx0XHRcdFx0XHQnYXJpYS1vd25zJzogaXNPcGVuID8gdGhpcy5faW5zdGFuY2VQcmVmaXggKyAnLWxpc3QnIDogdGhpcy5faW5zdGFuY2VQcmVmaXggKyAnLXZhbHVlJyxcblx0XHRcdFx0XHQnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogaXNPcGVuID8gdGhpcy5faW5zdGFuY2VQcmVmaXggKyAnLW9wdGlvbi0nICsgZm9jdXNlZE9wdGlvbkluZGV4IDogdGhpcy5faW5zdGFuY2VQcmVmaXggKyAnLXZhbHVlJyxcblx0XHRcdFx0XHRjbGFzc05hbWU6IGNsYXNzTmFtZSxcblx0XHRcdFx0XHR0YWJJbmRleDogdGhpcy5wcm9wcy50YWJJbmRleCB8fCAwLFxuXHRcdFx0XHRcdG9uQmx1cjogdGhpcy5oYW5kbGVJbnB1dEJsdXIsXG5cdFx0XHRcdFx0b25Gb2N1czogdGhpcy5oYW5kbGVJbnB1dEZvY3VzLFxuXHRcdFx0XHRcdHJlZjogZnVuY3Rpb24gKHJlZikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIF90aGlzNS5pbnB1dCA9IHJlZjtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdCdhcmlhLXJlYWRvbmx5JzogJycgKyAhIXRoaXMucHJvcHMuZGlzYWJsZWQsXG5cdFx0XHRcdFx0c3R5bGU6IHsgYm9yZGVyOiAwLCB3aWR0aDogMSwgZGlzcGxheTogJ2lubGluZS1ibG9jaycgfSB9KSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLnByb3BzLmF1dG9zaXplKSB7XG5cdFx0XHRcdHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChfcmVhY3RJbnB1dEF1dG9zaXplMlsnZGVmYXVsdCddLCBfZXh0ZW5kcyh7fSwgaW5wdXRQcm9wcywgeyBtaW5XaWR0aDogJzVweCcgfSkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuXHRcdFx0XHQnZGl2Jyxcblx0XHRcdFx0eyBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LFxuXHRcdFx0XHRfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudCgnaW5wdXQnLCBpbnB1dFByb3BzKVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblx0cmVuZGVyQ2xlYXI6IGZ1bmN0aW9uIHJlbmRlckNsZWFyKCkge1xuXHRcdGlmICghdGhpcy5wcm9wcy5jbGVhcmFibGUgfHwgIXRoaXMucHJvcHMudmFsdWUgfHwgdGhpcy5wcm9wcy52YWx1ZSA9PT0gMCB8fCB0aGlzLnByb3BzLm11bHRpICYmICF0aGlzLnByb3BzLnZhbHVlLmxlbmd0aCB8fCB0aGlzLnByb3BzLmRpc2FibGVkIHx8IHRoaXMucHJvcHMuaXNMb2FkaW5nKSByZXR1cm47XG5cdFx0cmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuXHRcdFx0J3NwYW4nLFxuXHRcdFx0eyBjbGFzc05hbWU6ICdTZWxlY3QtY2xlYXItem9uZScsIHRpdGxlOiB0aGlzLnByb3BzLm11bHRpID8gdGhpcy5wcm9wcy5jbGVhckFsbFRleHQgOiB0aGlzLnByb3BzLmNsZWFyVmFsdWVUZXh0LFxuXHRcdFx0XHQnYXJpYS1sYWJlbCc6IHRoaXMucHJvcHMubXVsdGkgPyB0aGlzLnByb3BzLmNsZWFyQWxsVGV4dCA6IHRoaXMucHJvcHMuY2xlYXJWYWx1ZVRleHQsXG5cdFx0XHRcdG9uTW91c2VEb3duOiB0aGlzLmNsZWFyVmFsdWUsXG5cdFx0XHRcdG9uVG91Y2hTdGFydDogdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LFxuXHRcdFx0XHRvblRvdWNoTW92ZTogdGhpcy5oYW5kbGVUb3VjaE1vdmUsXG5cdFx0XHRcdG9uVG91Y2hFbmQ6IHRoaXMuaGFuZGxlVG91Y2hFbmRDbGVhclZhbHVlXG5cdFx0XHR9LFxuXHRcdFx0X3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7IGNsYXNzTmFtZTogJ1NlbGVjdC1jbGVhcicsIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDogJyZ0aW1lczsnIH0gfSlcblx0XHQpO1xuXHR9LFxuXG5cdHJlbmRlckFycm93OiBmdW5jdGlvbiByZW5kZXJBcnJvdygpIHtcblx0XHR2YXIgb25Nb3VzZURvd24gPSB0aGlzLmhhbmRsZU1vdXNlRG93bk9uQXJyb3c7XG5cdFx0dmFyIGFycm93ID0gdGhpcy5wcm9wcy5hcnJvd1JlbmRlcmVyKHsgb25Nb3VzZURvd246IG9uTW91c2VEb3duIH0pO1xuXG5cdFx0cmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuXHRcdFx0J3NwYW4nLFxuXHRcdFx0e1xuXHRcdFx0XHRjbGFzc05hbWU6ICdTZWxlY3QtYXJyb3ctem9uZScsXG5cdFx0XHRcdG9uTW91c2VEb3duOiBvbk1vdXNlRG93blxuXHRcdFx0fSxcblx0XHRcdGFycm93XG5cdFx0KTtcblx0fSxcblxuXHRmaWx0ZXJPcHRpb25zOiBmdW5jdGlvbiBmaWx0ZXJPcHRpb25zKGV4Y2x1ZGVPcHRpb25zKSB7XG5cdFx0dmFyIGZpbHRlclZhbHVlID0gdGhpcy5zdGF0ZS5pbnB1dFZhbHVlO1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5wcm9wcy5vcHRpb25zIHx8IFtdO1xuXHRcdGlmICh0aGlzLnByb3BzLmZpbHRlck9wdGlvbnMpIHtcblx0XHRcdC8vIE1haW50YWluIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggYm9vbGVhbiBhdHRyaWJ1dGVcblx0XHRcdHZhciBmaWx0ZXJPcHRpb25zID0gdHlwZW9mIHRoaXMucHJvcHMuZmlsdGVyT3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMucHJvcHMuZmlsdGVyT3B0aW9ucyA6IF91dGlsc0RlZmF1bHRGaWx0ZXJPcHRpb25zMlsnZGVmYXVsdCddO1xuXG5cdFx0XHRyZXR1cm4gZmlsdGVyT3B0aW9ucyhvcHRpb25zLCBmaWx0ZXJWYWx1ZSwgZXhjbHVkZU9wdGlvbnMsIHtcblx0XHRcdFx0ZmlsdGVyT3B0aW9uOiB0aGlzLnByb3BzLmZpbHRlck9wdGlvbixcblx0XHRcdFx0aWdub3JlQWNjZW50czogdGhpcy5wcm9wcy5pZ25vcmVBY2NlbnRzLFxuXHRcdFx0XHRpZ25vcmVDYXNlOiB0aGlzLnByb3BzLmlnbm9yZUNhc2UsXG5cdFx0XHRcdGxhYmVsS2V5OiB0aGlzLnByb3BzLmxhYmVsS2V5LFxuXHRcdFx0XHRtYXRjaFBvczogdGhpcy5wcm9wcy5tYXRjaFBvcyxcblx0XHRcdFx0bWF0Y2hQcm9wOiB0aGlzLnByb3BzLm1hdGNoUHJvcCxcblx0XHRcdFx0dmFsdWVLZXk6IHRoaXMucHJvcHMudmFsdWVLZXlcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucztcblx0XHR9XG5cdH0sXG5cblx0b25PcHRpb25SZWY6IGZ1bmN0aW9uIG9uT3B0aW9uUmVmKHJlZiwgaXNGb2N1c2VkKSB7XG5cdFx0aWYgKGlzRm9jdXNlZCkge1xuXHRcdFx0dGhpcy5mb2N1c2VkID0gcmVmO1xuXHRcdH1cblx0fSxcblxuXHRyZW5kZXJNZW51OiBmdW5jdGlvbiByZW5kZXJNZW51KG9wdGlvbnMsIHZhbHVlQXJyYXksIGZvY3VzZWRPcHRpb24pIHtcblx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHJvcHMubWVudVJlbmRlcmVyKHtcblx0XHRcdFx0Zm9jdXNlZE9wdGlvbjogZm9jdXNlZE9wdGlvbixcblx0XHRcdFx0Zm9jdXNPcHRpb246IHRoaXMuZm9jdXNPcHRpb24sXG5cdFx0XHRcdGluc3RhbmNlUHJlZml4OiB0aGlzLl9pbnN0YW5jZVByZWZpeCxcblx0XHRcdFx0bGFiZWxLZXk6IHRoaXMucHJvcHMubGFiZWxLZXksXG5cdFx0XHRcdG9uRm9jdXM6IHRoaXMuZm9jdXNPcHRpb24sXG5cdFx0XHRcdG9uU2VsZWN0OiB0aGlzLnNlbGVjdFZhbHVlLFxuXHRcdFx0XHRvcHRpb25DbGFzc05hbWU6IHRoaXMucHJvcHMub3B0aW9uQ2xhc3NOYW1lLFxuXHRcdFx0XHRvcHRpb25Db21wb25lbnQ6IHRoaXMucHJvcHMub3B0aW9uQ29tcG9uZW50LFxuXHRcdFx0XHRvcHRpb25SZW5kZXJlcjogdGhpcy5wcm9wcy5vcHRpb25SZW5kZXJlciB8fCB0aGlzLmdldE9wdGlvbkxhYmVsLFxuXHRcdFx0XHRvcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0XHRzZWxlY3RWYWx1ZTogdGhpcy5zZWxlY3RWYWx1ZSxcblx0XHRcdFx0dmFsdWVBcnJheTogdmFsdWVBcnJheSxcblx0XHRcdFx0dmFsdWVLZXk6IHRoaXMucHJvcHMudmFsdWVLZXksXG5cdFx0XHRcdG9uT3B0aW9uUmVmOiB0aGlzLm9uT3B0aW9uUmVmXG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKHRoaXMucHJvcHMubm9SZXN1bHRzVGV4dCkge1xuXHRcdFx0cmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFxuXHRcdFx0XHQnZGl2Jyxcblx0XHRcdFx0eyBjbGFzc05hbWU6ICdTZWxlY3Qtbm9yZXN1bHRzJyB9LFxuXHRcdFx0XHR0aGlzLnByb3BzLm5vUmVzdWx0c1RleHRcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fSxcblxuXHRyZW5kZXJIaWRkZW5GaWVsZDogZnVuY3Rpb24gcmVuZGVySGlkZGVuRmllbGQodmFsdWVBcnJheSkge1xuXHRcdHZhciBfdGhpczYgPSB0aGlzO1xuXG5cdFx0aWYgKCF0aGlzLnByb3BzLm5hbWUpIHJldHVybjtcblx0XHRpZiAodGhpcy5wcm9wcy5qb2luVmFsdWVzKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZUFycmF5Lm1hcChmdW5jdGlvbiAoaSkge1xuXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5VmFsdWUoaVtfdGhpczYucHJvcHMudmFsdWVLZXldKTtcblx0XHRcdH0pLmpvaW4odGhpcy5wcm9wcy5kZWxpbWl0ZXIpO1xuXHRcdFx0cmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIHtcblx0XHRcdFx0dHlwZTogJ2hpZGRlbicsXG5cdFx0XHRcdHJlZjogZnVuY3Rpb24gKHJlZikge1xuXHRcdFx0XHRcdHJldHVybiBfdGhpczYudmFsdWUgPSByZWY7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5hbWU6IHRoaXMucHJvcHMubmFtZSxcblx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRkaXNhYmxlZDogdGhpcy5wcm9wcy5kaXNhYmxlZCB9KTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlQXJyYXkubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuXHRcdFx0cmV0dXJuIF9yZWFjdDJbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIHsga2V5OiAnaGlkZGVuLicgKyBpbmRleCxcblx0XHRcdFx0dHlwZTogJ2hpZGRlbicsXG5cdFx0XHRcdHJlZjogJ3ZhbHVlJyArIGluZGV4LFxuXHRcdFx0XHRuYW1lOiBfdGhpczYucHJvcHMubmFtZSxcblx0XHRcdFx0dmFsdWU6IHN0cmluZ2lmeVZhbHVlKGl0ZW1bX3RoaXM2LnByb3BzLnZhbHVlS2V5XSksXG5cdFx0XHRcdGRpc2FibGVkOiBfdGhpczYucHJvcHMuZGlzYWJsZWQgfSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0Z2V0Rm9jdXNhYmxlT3B0aW9uSW5kZXg6IGZ1bmN0aW9uIGdldEZvY3VzYWJsZU9wdGlvbkluZGV4KHNlbGVjdGVkT3B0aW9uKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLl92aXNpYmxlT3B0aW9ucztcblx0XHRpZiAoIW9wdGlvbnMubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuXHRcdHZhciBmb2N1c2VkT3B0aW9uID0gdGhpcy5zdGF0ZS5mb2N1c2VkT3B0aW9uIHx8IHNlbGVjdGVkT3B0aW9uO1xuXHRcdGlmIChmb2N1c2VkT3B0aW9uICYmICFmb2N1c2VkT3B0aW9uLmRpc2FibGVkKSB7XG5cdFx0XHR2YXIgZm9jdXNlZE9wdGlvbkluZGV4ID0gb3B0aW9ucy5pbmRleE9mKGZvY3VzZWRPcHRpb24pO1xuXHRcdFx0aWYgKGZvY3VzZWRPcHRpb25JbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0cmV0dXJuIGZvY3VzZWRPcHRpb25JbmRleDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICghb3B0aW9uc1tpXS5kaXNhYmxlZCkgcmV0dXJuIGk7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdHJlbmRlck91dGVyOiBmdW5jdGlvbiByZW5kZXJPdXRlcihvcHRpb25zLCB2YWx1ZUFycmF5LCBmb2N1c2VkT3B0aW9uKSB7XG5cdFx0dmFyIF90aGlzNyA9IHRoaXM7XG5cblx0XHR2YXIgbWVudSA9IHRoaXMucmVuZGVyTWVudShvcHRpb25zLCB2YWx1ZUFycmF5LCBmb2N1c2VkT3B0aW9uKTtcblx0XHRpZiAoIW1lbnUpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcblx0XHRcdCdkaXYnLFxuXHRcdFx0eyByZWY6IGZ1bmN0aW9uIChyZWYpIHtcblx0XHRcdFx0XHRyZXR1cm4gX3RoaXM3Lm1lbnVDb250YWluZXIgPSByZWY7XG5cdFx0XHRcdH0sIGNsYXNzTmFtZTogJ1NlbGVjdC1tZW51LW91dGVyJywgc3R5bGU6IHRoaXMucHJvcHMubWVudUNvbnRhaW5lclN0eWxlIH0sXG5cdFx0XHRfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcblx0XHRcdFx0J2RpdicsXG5cdFx0XHRcdHsgcmVmOiBmdW5jdGlvbiAocmVmKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gX3RoaXM3Lm1lbnUgPSByZWY7XG5cdFx0XHRcdFx0fSwgcm9sZTogJ2xpc3Rib3gnLCBjbGFzc05hbWU6ICdTZWxlY3QtbWVudScsIGlkOiB0aGlzLl9pbnN0YW5jZVByZWZpeCArICctbGlzdCcsXG5cdFx0XHRcdFx0c3R5bGU6IHRoaXMucHJvcHMubWVudVN0eWxlLFxuXHRcdFx0XHRcdG9uU2Nyb2xsOiB0aGlzLmhhbmRsZU1lbnVTY3JvbGwsXG5cdFx0XHRcdFx0b25Nb3VzZURvd246IHRoaXMuaGFuZGxlTW91c2VEb3duT25NZW51IH0sXG5cdFx0XHRcdG1lbnVcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuXHRcdHZhciBfdGhpczggPSB0aGlzO1xuXG5cdFx0dmFyIHZhbHVlQXJyYXkgPSB0aGlzLmdldFZhbHVlQXJyYXkodGhpcy5wcm9wcy52YWx1ZSk7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLl92aXNpYmxlT3B0aW9ucyA9IHRoaXMuZmlsdGVyT3B0aW9ucyh0aGlzLnByb3BzLm11bHRpID8gdGhpcy5nZXRWYWx1ZUFycmF5KHRoaXMucHJvcHMudmFsdWUpIDogbnVsbCk7XG5cdFx0dmFyIGlzT3BlbiA9IHRoaXMuc3RhdGUuaXNPcGVuO1xuXHRcdGlmICh0aGlzLnByb3BzLm11bHRpICYmICFvcHRpb25zLmxlbmd0aCAmJiB2YWx1ZUFycmF5Lmxlbmd0aCAmJiAhdGhpcy5zdGF0ZS5pbnB1dFZhbHVlKSBpc09wZW4gPSBmYWxzZTtcblx0XHR2YXIgZm9jdXNlZE9wdGlvbkluZGV4ID0gdGhpcy5nZXRGb2N1c2FibGVPcHRpb25JbmRleCh2YWx1ZUFycmF5WzBdKTtcblxuXHRcdHZhciBmb2N1c2VkT3B0aW9uID0gbnVsbDtcblx0XHRpZiAoZm9jdXNlZE9wdGlvbkluZGV4ICE9PSBudWxsKSB7XG5cdFx0XHRmb2N1c2VkT3B0aW9uID0gdGhpcy5fZm9jdXNlZE9wdGlvbiA9IG9wdGlvbnNbZm9jdXNlZE9wdGlvbkluZGV4XTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9jdXNlZE9wdGlvbiA9IHRoaXMuX2ZvY3VzZWRPcHRpb24gPSBudWxsO1xuXHRcdH1cblx0XHR2YXIgY2xhc3NOYW1lID0gKDAsIF9jbGFzc25hbWVzMlsnZGVmYXVsdCddKSgnU2VsZWN0JywgdGhpcy5wcm9wcy5jbGFzc05hbWUsIHtcblx0XHRcdCdTZWxlY3QtLW11bHRpJzogdGhpcy5wcm9wcy5tdWx0aSxcblx0XHRcdCdTZWxlY3QtLXNpbmdsZSc6ICF0aGlzLnByb3BzLm11bHRpLFxuXHRcdFx0J2lzLWRpc2FibGVkJzogdGhpcy5wcm9wcy5kaXNhYmxlZCxcblx0XHRcdCdpcy1mb2N1c2VkJzogdGhpcy5zdGF0ZS5pc0ZvY3VzZWQsXG5cdFx0XHQnaXMtbG9hZGluZyc6IHRoaXMucHJvcHMuaXNMb2FkaW5nLFxuXHRcdFx0J2lzLW9wZW4nOiBpc09wZW4sXG5cdFx0XHQnaXMtcHNldWRvLWZvY3VzZWQnOiB0aGlzLnN0YXRlLmlzUHNldWRvRm9jdXNlZCxcblx0XHRcdCdpcy1zZWFyY2hhYmxlJzogdGhpcy5wcm9wcy5zZWFyY2hhYmxlLFxuXHRcdFx0J2hhcy12YWx1ZSc6IHZhbHVlQXJyYXkubGVuZ3RoXG5cdFx0fSk7XG5cblx0XHR2YXIgcmVtb3ZlTWVzc2FnZSA9IG51bGw7XG5cdFx0aWYgKHRoaXMucHJvcHMubXVsdGkgJiYgIXRoaXMucHJvcHMuZGlzYWJsZWQgJiYgdmFsdWVBcnJheS5sZW5ndGggJiYgIXRoaXMuc3RhdGUuaW5wdXRWYWx1ZSAmJiB0aGlzLnN0YXRlLmlzRm9jdXNlZCAmJiB0aGlzLnByb3BzLmJhY2tzcGFjZVJlbW92ZXMpIHtcblx0XHRcdHJlbW92ZU1lc3NhZ2UgPSBfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcblx0XHRcdFx0J3NwYW4nLFxuXHRcdFx0XHR7IGlkOiB0aGlzLl9pbnN0YW5jZVByZWZpeCArICctYmFja3NwYWNlLXJlbW92ZS1tZXNzYWdlJywgY2xhc3NOYW1lOiAnU2VsZWN0LWFyaWEtb25seScsICdhcmlhLWxpdmUnOiAnYXNzZXJ0aXZlJyB9LFxuXHRcdFx0XHR0aGlzLnByb3BzLmJhY2tzcGFjZVRvUmVtb3ZlTWVzc2FnZS5yZXBsYWNlKCd7bGFiZWx9JywgdmFsdWVBcnJheVt2YWx1ZUFycmF5Lmxlbmd0aCAtIDFdW3RoaXMucHJvcHMubGFiZWxLZXldKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gX3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG5cdFx0XHQnZGl2Jyxcblx0XHRcdHsgcmVmOiBmdW5jdGlvbiAocmVmKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF90aGlzOC53cmFwcGVyID0gcmVmO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRjbGFzc05hbWU6IGNsYXNzTmFtZSxcblx0XHRcdFx0c3R5bGU6IHRoaXMucHJvcHMud3JhcHBlclN0eWxlIH0sXG5cdFx0XHR0aGlzLnJlbmRlckhpZGRlbkZpZWxkKHZhbHVlQXJyYXkpLFxuXHRcdFx0X3JlYWN0MlsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRcdCdkaXYnLFxuXHRcdFx0XHR7IHJlZjogZnVuY3Rpb24gKHJlZikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIF90aGlzOC5jb250cm9sID0gcmVmO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Y2xhc3NOYW1lOiAnU2VsZWN0LWNvbnRyb2wnLFxuXHRcdFx0XHRcdHN0eWxlOiB0aGlzLnByb3BzLnN0eWxlLFxuXHRcdFx0XHRcdG9uS2V5RG93bjogdGhpcy5oYW5kbGVLZXlEb3duLFxuXHRcdFx0XHRcdG9uTW91c2VEb3duOiB0aGlzLmhhbmRsZU1vdXNlRG93bixcblx0XHRcdFx0XHRvblRvdWNoRW5kOiB0aGlzLmhhbmRsZVRvdWNoRW5kLFxuXHRcdFx0XHRcdG9uVG91Y2hTdGFydDogdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LFxuXHRcdFx0XHRcdG9uVG91Y2hNb3ZlOiB0aGlzLmhhbmRsZVRvdWNoTW92ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfcmVhY3QyWydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChcblx0XHRcdFx0XHQnc3BhbicsXG5cdFx0XHRcdFx0eyBjbGFzc05hbWU6ICdTZWxlY3QtbXVsdGktdmFsdWUtd3JhcHBlcicsIGlkOiB0aGlzLl9pbnN0YW5jZVByZWZpeCArICctdmFsdWUnIH0sXG5cdFx0XHRcdFx0dGhpcy5yZW5kZXJWYWx1ZSh2YWx1ZUFycmF5LCBpc09wZW4pLFxuXHRcdFx0XHRcdHRoaXMucmVuZGVySW5wdXQodmFsdWVBcnJheSwgZm9jdXNlZE9wdGlvbkluZGV4KVxuXHRcdFx0XHQpLFxuXHRcdFx0XHRyZW1vdmVNZXNzYWdlLFxuXHRcdFx0XHR0aGlzLnJlbmRlckxvYWRpbmcoKSxcblx0XHRcdFx0dGhpcy5yZW5kZXJDbGVhcigpLFxuXHRcdFx0XHR0aGlzLnJlbmRlckFycm93KClcblx0XHRcdCksXG5cdFx0XHRpc09wZW4gPyB0aGlzLnJlbmRlck91dGVyKG9wdGlvbnMsICF0aGlzLnByb3BzLm11bHRpID8gdmFsdWVBcnJheSA6IG51bGwsIGZvY3VzZWRPcHRpb24pIDogbnVsbFxuXHRcdCk7XG5cdH1cblxufSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFNlbGVjdDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgY3VycnlOID0gcmVxdWlyZSgnLi9jdXJyeU4nKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBjdXJyaWVkIGVxdWl2YWxlbnQgb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLiBUaGUgY3VycmllZCBmdW5jdGlvblxuICogaGFzIHR3byB1bnVzdWFsIGNhcGFiaWxpdGllcy4gRmlyc3QsIGl0cyBhcmd1bWVudHMgbmVlZG4ndCBiZSBwcm92aWRlZCBvbmVcbiAqIGF0IGEgdGltZS4gSWYgYGZgIGlzIGEgdGVybmFyeSBmdW5jdGlvbiBhbmQgYGdgIGlzIGBSLmN1cnJ5KGYpYCwgdGhlXG4gKiBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAtIGBnKDEpKDIpKDMpYFxuICogICAtIGBnKDEpKDIsIDMpYFxuICogICAtIGBnKDEsIDIpKDMpYFxuICogICAtIGBnKDEsIDIsIDMpYFxuICpcbiAqIFNlY29uZGx5LCB0aGUgc3BlY2lhbCBwbGFjZWhvbGRlciB2YWx1ZSBgUi5fX2AgbWF5IGJlIHVzZWQgdG8gc3BlY2lmeVxuICogXCJnYXBzXCIsIGFsbG93aW5nIHBhcnRpYWwgYXBwbGljYXRpb24gb2YgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyxcbiAqIHJlZ2FyZGxlc3Mgb2YgdGhlaXIgcG9zaXRpb25zLiBJZiBgZ2AgaXMgYXMgYWJvdmUgYW5kIGBfYCBpcyBgUi5fX2AsIHRoZVxuICogZm9sbG93aW5nIGFyZSBlcXVpdmFsZW50OlxuICpcbiAqICAgLSBgZygxLCAyLCAzKWBcbiAqICAgLSBgZyhfLCAyLCAzKSgxKWBcbiAqICAgLSBgZyhfLCBfLCAzKSgxKSgyKWBcbiAqICAgLSBgZyhfLCBfLCAzKSgxLCAyKWBcbiAqICAgLSBgZyhfLCAyKSgxKSgzKWBcbiAqICAgLSBgZyhfLCAyKSgxLCAzKWBcbiAqICAgLSBgZyhfLCAyKShfLCAzKSgxKWBcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKiAtPiBhKSAtPiAoKiAtPiBhKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3LCBjdXJyaWVkIGZ1bmN0aW9uLlxuICogQHNlZSBSLmN1cnJ5TlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBhZGRGb3VyTnVtYmVycyA9IChhLCBiLCBjLCBkKSA9PiBhICsgYiArIGMgKyBkO1xuICpcbiAqICAgICAgdmFyIGN1cnJpZWRBZGRGb3VyTnVtYmVycyA9IFIuY3VycnkoYWRkRm91ck51bWJlcnMpO1xuICogICAgICB2YXIgZiA9IGN1cnJpZWRBZGRGb3VyTnVtYmVycygxLCAyKTtcbiAqICAgICAgdmFyIGcgPSBmKDMpO1xuICogICAgICBnKDQpOyAvLz0+IDEwXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBjdXJyeShmbikge1xuICByZXR1cm4gY3VycnlOKGZuLmxlbmd0aCwgZm4pO1xufSk7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXG5pbXBvcnQgeyBjdXJyeSwgcGlwZSB9IGZyb20gJ3JhbWRhJztcblxuLyoqXG4gIHR5cGUgVmFsaWRhdGlvblxuICAgID0gU3VjY2VzcyBhXG4gICAgfCBGYWlsdXJlIGJcbiAqL1xuXG5jb25zdCB0eXBlcyA9IHtcbiAgSnVzdDogTWF0aC5yYW5kb20oKSxcbiAgTm90aGluZzogTWF0aC5yYW5kb20oKSxcbn07XG5cblxuZnVuY3Rpb24gTWF5YmUodmFsdWUsIHR5cGUpIHtcbiAgLy8gQ2hlY2sgdGhhdCBhIHZhbGlkIHR5cGUgaXMgYmVpbmcgdXNlZFxuICBjb25zdCBpc0p1c3QgPSB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUgPT09IHR5cGVzLkp1c3Q7XG4gIHRoaXMuaXNKdXN0ID0gaXNKdXN0O1xuICB0aGlzLmlzTm90aGluZyA9ICFpc0p1c3Q7XG4gIHRoaXMud2l0aERlZmF1bHQgPSBkZWZhdWx0VmFsID0+IChpc0p1c3QgPyB2YWx1ZSA6IGRlZmF1bHRWYWwpO1xuICB0aGlzLm1hcCA9IGYgPT4gKGlzSnVzdFxuICAgID8gTWF5YmUub2YoZih2YWx1ZSkpXG4gICAgOiBNYXliZS5Ob3RoaW5nKClcbiAgKTtcbiAgdGhpcy5jaGFpbiA9IGYgPT4gdGhpcy5tYXAoZikud2l0aERlZmF1bHQoTWF5YmUuTm90aGluZygpKTtcbn1cblxuLy8gU3RhdGljIGZ1bmN0aW9uc1xuTWF5YmUuSnVzdCA9IHYgPT4gbmV3IE1heWJlKHYsIHR5cGVzLkp1c3QpO1xuTWF5YmUuTm90aGluZyA9IF8gPT4gbmV3IE1heWJlKG51bGwsIHR5cGVzLk5vdGhpbmcpO1xuTWF5YmUub2YgPSBNYXliZS5KdXN0OyAvLyB0aGUgZnVuY3Rpb24gaXRzZWxmIHdpbGwgdGFrZSBjYXJlIG9mIG51bGxzIGFuZCB1bmRlZmluZWRzXG5cbk1heWJlLmlzSnVzdCA9IHYgPT4gdi5pc0p1c3Q7XG5NYXliZS5pc05vdGhpbmcgPSB2ID0+IHYuaXNOb3RoaW5nO1xuTWF5YmUud2l0aERlZmF1bHQgPSBjdXJyeSgoZGVmYXVsdFZhbCwgdikgPT4gdi53aXRoRGVmYXVsdChkZWZhdWx0VmFsKSk7XG5NYXliZS5tYXAgPSBjdXJyeSgoZiwgdikgPT4gdi5tYXAoZikpO1xuTWF5YmUubWFwMiA9IGN1cnJ5KChmLCB2MSwgdjIpID0+IChcbiAgTWF5YmUuaXNKdXN0KHYxKSAmJiBNYXliZS5pc0p1c3QodjIpXG4gID8gTWF5YmUub2YoZihcbiAgICAgIE1heWJlLndpdGhEZWZhdWx0KG51bGwsIHYxKSxcbiAgICAgIE1heWJlLndpdGhEZWZhdWx0KG51bGwsIHYyKVxuICAgICkpXG4gIDogTWF5YmUuTm90aGluZygpXG4pKTtcbk1heWJlLmNoYWluID0gY3VycnkoKHYsIGYpID0+IHYuY2hhaW4oZikpO1xuXG5leHBvcnQgZGVmYXVsdCBNYXliZTtcbiIsIi8qKlxuXG4gIFRoaXMgdHlwZSB0YWtlcyBjYXJlIG9mIGRhdGEgdGhhdCBpcyBmZXRjaGVkIGZyb20gdGhlIHNlcnZlci5cbiAgdHlwZSBSZW1vdGVEYXRhXG4gICAgPSBOb3RBc2tlZCBudWxsXG4gICAgfCBMb2FkaW5nIFJlcXVlc3RcbiAgICB8IEZhaWx1cmUgUmVzcG9uc2VcbiAgICB8IFN1Y2Nlc3MgUmVzcG9uc2VcblxuICovXG5pbXBvcnQgeyBjdXJyeSB9IGZyb20gJ3JhbWRhJztcbmltcG9ydCBNYXliZSBmcm9tICcuL01heWJlJztcblxuY29uc3QgdHlwZXMgPSB7XG4gIE5vdEFza2VkOiBNYXRoLnJhbmRvbSgpLFxuICBMb2FkaW5nOiBNYXRoLnJhbmRvbSgpLFxuICBGYWlsdXJlOiBNYXRoLnJhbmRvbSgpLFxuICBTdWNjZXNzOiBNYXRoLnJhbmRvbSgpLFxufTtcblxuY29uc3QgbWFwSWYgPSBjdXJyeSgoY29uZGl0aW9uLCB2YWx1ZSwgZikgPT4gKGNvbmRpdGlvbiA/IGYodmFsdWUpIDogdmFsdWUpKTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIElOU1RBTkNFIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbmZ1bmN0aW9uIFJlbW90ZURhdGEodmFsdWUsIHR5cGUpIHtcbiAgY29uc3QgaXNTdWNjZXNzID0gdHlwZSA9PT0gdHlwZXMuU3VjY2VzcztcbiAgY29uc3QgaXNGYWlsdXJlID0gdHlwZSA9PT0gdHlwZXMuRmFpbHVyZTtcbiAgY29uc3QgaXNMb2FkaW5nID0gdHlwZSA9PT0gdHlwZXMuTG9hZGluZztcbiAgaWYgKGlzRmFpbHVyZSkge1xuICAgIGNvbnNvbGUubG9nKCdGYWlsaW5nIHdpdGggcmVhc29uOicsIHZhbHVlKTtcbiAgfVxuXG4gIHRoaXMuaXNTdWNjZXNzID0gaXNTdWNjZXNzO1xuICB0aGlzLmlzRmFpbHVyZSA9IGlzRmFpbHVyZTtcbiAgdGhpcy5pc0xvYWRpbmcgPSBpc0xvYWRpbmc7XG4gIHRoaXMuaXNOb3RBc2tlZCA9IHR5cGUgPT09IHR5cGVzLk5vdEFza2VkO1xuICB0aGlzLndpdGhEZWZhdWx0ID0gZWxzZVZhbCA9PiAoaXNTdWNjZXNzID8gdmFsdWUgOiBlbHNlVmFsKTtcbiAgdGhpcy5tYXAgPSBmID0+IG5ldyBSZW1vdGVEYXRhKG1hcElmKGlzU3VjY2VzcywgdmFsdWUsIGYpLCB0eXBlKTtcbiAgdGhpcy5tYXBTdWNjZXNzID0gZiA9PiBuZXcgUmVtb3RlRGF0YShtYXBJZihpc1N1Y2Nlc3MsIHZhbHVlLCBmKSwgdHlwZSk7XG4gIHRoaXMubWFwTG9hZGluZyA9IGYgPT4gbmV3IFJlbW90ZURhdGEobWFwSWYoaXNMb2FkaW5nLCB2YWx1ZSwgZiksIHR5cGUpO1xuICB0aGlzLm1hcEZhaWx1cmUgPSBmID0+IG5ldyBSZW1vdGVEYXRhKG1hcElmKGlzRmFpbHVyZSwgdmFsdWUsIGYpLCB0eXBlKTtcbiAgdGhpcy50b01heWJlID0gXyA9PiAoaXNTdWNjZXNzID8gTWF5YmUuSnVzdCh2YWx1ZSkgOiBNYXliZS5Ob3RoaW5nKCkpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW4sIG5ldy1jYXBcbiAgdGhpcy5fdmFsdWUgPSB2YWx1ZTsgLy8gSlVTVCBGT1IgREVCVUdHSU5HIFBVUlBPU0VTLiBETyBOT1QgVVNFXG59XG5cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFNUQVRJQyBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5SZW1vdGVEYXRhLk5vdEFza2VkID0gXyA9PiBuZXcgUmVtb3RlRGF0YShudWxsLCB0eXBlcy5Ob3RBc2tlZCk7XG5SZW1vdGVEYXRhLkxvYWRpbmcgPSB2ID0+IG5ldyBSZW1vdGVEYXRhKHYsIHR5cGVzLkxvYWRpbmcpO1xuUmVtb3RlRGF0YS5GYWlsdXJlID0gdiA9PiBuZXcgUmVtb3RlRGF0YSh2LCB0eXBlcy5GYWlsdXJlKTtcblJlbW90ZURhdGEuU3VjY2VzcyA9IHYgPT4gbmV3IFJlbW90ZURhdGEodiwgdHlwZXMuU3VjY2Vzcyk7XG5cblJlbW90ZURhdGEuaXNOb3RBc2tlZCA9IHYgPT4gdi5pc05vdEFza2VkO1xuUmVtb3RlRGF0YS5pc0xvYWRpbmcgPSB2ID0+IHYuaXNMb2FkaW5nO1xuUmVtb3RlRGF0YS5pc0ZhaWx1cmUgPSB2ID0+IHYuaXNGYWlsdXJlO1xuUmVtb3RlRGF0YS5pc1N1Y2Nlc3MgPSB2ID0+IHYuaXNTdWNjZXNzO1xuUmVtb3RlRGF0YS53aXRoRGVmYXVsdCA9IGN1cnJ5KChlbHNlVmFsLCB2KSA9PiB2LndpdGhEZWZhdWx0KGVsc2VWYWwpKTtcblJlbW90ZURhdGEubWFwID0gY3VycnkoKGYsIHYpID0+IHYubWFwKGYpKTtcblJlbW90ZURhdGEubWFwU3VjY2VzcyA9IGN1cnJ5KChmLCB2KSA9PiB2Lm1hcFN1Y2Nlc3MoZikpO1xuUmVtb3RlRGF0YS5tYXBMb2FkaW5nID0gY3VycnkoKGYsIHYpID0+IHYubWFwTG9hZGluZyhmKSk7XG5SZW1vdGVEYXRhLm1hcEZhaWx1cmUgPSBjdXJyeSgoZiwgdikgPT4gdi5tYXBGYWlsdXJlKGYpKTtcblJlbW90ZURhdGEudG9NYXliZSA9IHYgPT4gdi50b01heWJlKCk7XG5cbmV4cG9ydCBkZWZhdWx0IFJlbW90ZURhdGE7XG4iLCIvLyBCdWcgY2hlY2tpbmcgZnVuY3Rpb24gdGhhdCB3aWxsIHRocm93IGFuIGVycm9yIHdoZW5ldmVyXG4vLyB0aGUgY29uZGl0aW9uIHNlbnQgdG8gaXQgaXMgZXZhbHVhdGVkIHRvIGZhbHNlXG4vKipcbiAqIFByb2Nlc3NlcyB0aGUgbWVzc2FnZSBhbmQgb3V0cHV0cyB0aGUgY29ycmVjdCBtZXNzYWdlIGlmIHRoZSBjb25kaXRpb25cbiAqIGlzIGZhbHNlLiBPdGhlcndpc2UgaXQgb3V0cHV0cyBudWxsLlxuICogQGFwaSBwcml2YXRlXG4gKiBAbWV0aG9kIHByb2Nlc3NDb25kaXRpb25cbiAqIEBwYXJhbSAge0Jvb2xlYW59IGNvbmRpdGlvbiAtIFJlc3VsdCBvZiB0aGUgZXZhbHVhdGVkIGNvbmRpdGlvblxuICogQHBhcmFtICB7U3RyaW5nfSBlcnJvck1lc3NhZ2UgLSBNZXNzYWdlIGV4cGxhaW5pZyB0aGUgZXJyb3IgaW4gY2FzZSBpdCBpcyB0aHJvd25cbiAqIEByZXR1cm4ge1N0cmluZyB8IG51bGx9ICAtIEVycm9yIG1lc3NhZ2UgaWYgdGhlcmUgaXMgYW4gZXJyb3IsIG51bCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NDb25kaXRpb24oY29uZGl0aW9uLCBlcnJvck1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgY29tcGxldGVFcnJvck1lc3NhZ2UgPSAnJztcbiAgICB2YXIgcmUgPSAvYXQgKFteXFxzXSspXFxzXFwoL2c7XG4gICAgdmFyIHN0YWNrVHJhY2UgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICB2YXIgc3RhY2tGdW5jdGlvbnMgPSBbXTtcblxuICAgIHZhciBmdW5jTmFtZSA9IHJlLmV4ZWMoc3RhY2tUcmFjZSk7XG4gICAgd2hpbGUgKGZ1bmNOYW1lICYmIGZ1bmNOYW1lWzFdKSB7XG4gICAgICBzdGFja0Z1bmN0aW9ucy5wdXNoKGZ1bmNOYW1lWzFdKTtcbiAgICAgIGZ1bmNOYW1lID0gcmUuZXhlYyhzdGFja1RyYWNlKTtcbiAgICB9XG5cbiAgICAvLyBOdW1iZXIgMCBpcyBwcm9jZXNzQ29uZGl0aW9uIGl0c2VsZixcbiAgICAvLyBOdW1iZXIgMSBpcyBhc3NlcnQsXG4gICAgLy8gTnVtYmVyIDIgaXMgdGhlIGNhbGxlciBmdW5jdGlvbi5cbiAgICBpZiAoc3RhY2tGdW5jdGlvbnNbMl0pIHtcbiAgICAgIGNvbXBsZXRlRXJyb3JNZXNzYWdlID0gc3RhY2tGdW5jdGlvbnNbMl0gKyAnOiAnICsgY29tcGxldGVFcnJvck1lc3NhZ2U7XG4gICAgfVxuXG4gICAgY29tcGxldGVFcnJvck1lc3NhZ2UgKz0gZXJyb3JNZXNzYWdlO1xuICAgIHJldHVybiBjb21wbGV0ZUVycm9yTWVzc2FnZTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgYm9vbGVhbiBwYXNzZWQgdG8gaXQgZXZhbHVhdGVzIHRvIGZhbHNlLlxuICogVG8gYmUgdXNlZCBsaWtlIHRoaXM6XG4gKiBcdFx0YXNzZXJ0KG15RGF0ZSAhPT0gdW5kZWZpbmVkLCBcIkRhdGUgY2Fubm90IGJlIHVuZGVmaW5lZC5cIik7XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBhc3NlcnRcbiAqIEBwYXJhbSAge0Jvb2xlYW59IGNvbmRpdGlvbiAtIFJlc3VsdCBvZiB0aGUgZXZhbHVhdGVkIGNvbmRpdGlvblxuICogQHBhcmFtICB7U3RyaW5nfSBlcnJvck1lc3NhZ2UgLSBNZXNzYWdlIGV4cGxhaW5pZyB0aGUgZXJyb3IgaW4gY2FzZSBpdCBpcyB0aHJvd25cbiAqIEByZXR1cm4gdm9pZFxuICovXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBlcnJvck1lc3NhZ2UpIHtcbiAgdmFyIGVycm9yID0gcHJvY2Vzc0NvbmRpdGlvbihjb25kaXRpb24sIGVycm9yTWVzc2FnZSk7XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgfVxufVxuXG4vKipcbiAqIExvZ3MgYSB3YXJuaW5nIGlmIHRoZSBib29sZWFuIHBhc3NlZCB0byBpdCBldmFsdWF0ZXMgdG8gZmFsc2UuXG4gKiBUbyBiZSB1c2VkIGxpa2UgdGhpczpcbiAqIFx0XHRhc3NlcnQud2FybihteURhdGUgIT09IHVuZGVmaW5lZCwgXCJObyBkYXRlIHByb3ZpZGVkLlwiKTtcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIHdhcm5cbiAqIEBwYXJhbSAge0Jvb2xlYW59IGNvbmRpdGlvbiAtIFJlc3VsdCBvZiB0aGUgZXZhbHVhdGVkIGNvbmRpdGlvblxuICogQHBhcmFtICB7U3RyaW5nfSBlcnJvck1lc3NhZ2UgLSBNZXNzYWdlIGV4cGxhaW5pZyB0aGUgZXJyb3IgaW4gY2FzZSBpdCBpcyB0aHJvd25cbiAqIEByZXR1cm4gdm9pZFxuICovXG5hc3NlcnQud2FybiA9IGZ1bmN0aW9uIHdhcm4oY29uZGl0aW9uLCBlcnJvck1lc3NhZ2UpIHtcbiAgdmFyIGVycm9yID0gcHJvY2Vzc0NvbmRpdGlvbihjb25kaXRpb24sIGVycm9yTWVzc2FnZSk7XG4gIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc29sZS53YXJuKGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgYXNzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lJaXdpYzI5MWNtTmxjeUk2V3lKaGMzTmxjblF1YW5NaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lMeThnUW5WbklHTm9aV05yYVc1bklHWjFibU4wYVc5dUlIUm9ZWFFnZDJsc2JDQjBhSEp2ZHlCaGJpQmxjbkp2Y2lCM2FHVnVaWFpsY2x4dUx5OGdkR2hsSUdOdmJtUnBkR2x2YmlCelpXNTBJSFJ2SUdsMElHbHpJR1YyWVd4MVlYUmxaQ0IwYnlCbVlXeHpaVnh1THlvcVhHNGdLaUJRY205alpYTnpaWE1nZEdobElHMWxjM05oWjJVZ1lXNWtJRzkxZEhCMWRITWdkR2hsSUdOdmNuSmxZM1FnYldWemMyRm5aU0JwWmlCMGFHVWdZMjl1WkdsMGFXOXVYRzRnS2lCcGN5Qm1ZV3h6WlM0Z1QzUm9aWEozYVhObElHbDBJRzkxZEhCMWRITWdiblZzYkM1Y2JpQXFJRUJoY0drZ2NISnBkbUYwWlZ4dUlDb2dRRzFsZEdodlpDQndjbTlqWlhOelEyOXVaR2wwYVc5dVhHNGdLaUJBY0dGeVlXMGdJSHRDYjI5c1pXRnVmU0JqYjI1a2FYUnBiMjRnTFNCU1pYTjFiSFFnYjJZZ2RHaGxJR1YyWVd4MVlYUmxaQ0JqYjI1a2FYUnBiMjVjYmlBcUlFQndZWEpoYlNBZ2UxTjBjbWx1WjMwZ1pYSnliM0pOWlhOellXZGxJQzBnVFdWemMyRm5aU0JsZUhCc1lXbHVhV2NnZEdobElHVnljbTl5SUdsdUlHTmhjMlVnYVhRZ2FYTWdkR2h5YjNkdVhHNGdLaUJBY21WMGRYSnVJSHRUZEhKcGJtY2dmQ0J1ZFd4c2ZTQWdMU0JGY25KdmNpQnRaWE56WVdkbElHbG1JSFJvWlhKbElHbHpJR0Z1SUdWeWNtOXlMQ0J1ZFd3Z2IzUm9aWEozYVhObExseHVJQ292WEc1bWRXNWpkR2x2YmlCd2NtOWpaWE56UTI5dVpHbDBhVzl1S0dOdmJtUnBkR2x2Yml3Z1pYSnliM0pOWlhOellXZGxLU0I3WEc0Z0lHbG1JQ2doWTI5dVpHbDBhVzl1S1NCN1hHNGdJQ0FnYkdWMElHTnZiWEJzWlhSbFJYSnliM0pOWlhOellXZGxJRDBnSnljN1hHNGdJQ0FnWTI5dWMzUWdjbVVnUFNBdllYUWdLRnRlWEZ4elhTc3BYRnh6WEZ3b0wyYzdYRzRnSUNBZ1kyOXVjM1FnYzNSaFkydFVjbUZqWlNBOUlHNWxkeUJGY25KdmNpZ3BMbk4wWVdOck8xeHVJQ0FnSUdOdmJuTjBJSE4wWVdOclJuVnVZM1JwYjI1eklEMGdXMTA3WEc1Y2JpQWdJQ0JzWlhRZ1puVnVZMDVoYldVZ1BTQnlaUzVsZUdWaktITjBZV05yVkhKaFkyVXBPMXh1SUNBZ0lIZG9hV3hsSUNobWRXNWpUbUZ0WlNBbUppQm1kVzVqVG1GdFpWc3hYU2tnZTF4dUlDQWdJQ0FnYzNSaFkydEdkVzVqZEdsdmJuTXVjSFZ6YUNobWRXNWpUbUZ0WlZzeFhTazdYRzRnSUNBZ0lDQm1kVzVqVG1GdFpTQTlJSEpsTG1WNFpXTW9jM1JoWTJ0VWNtRmpaU2s3WEc0Z0lDQWdmVnh1WEc0Z0lDQWdMeThnVG5WdFltVnlJREFnYVhNZ2NISnZZMlZ6YzBOdmJtUnBkR2x2YmlCcGRITmxiR1lzWEc0Z0lDQWdMeThnVG5WdFltVnlJREVnYVhNZ1lYTnpaWEowTEZ4dUlDQWdJQzh2SUU1MWJXSmxjaUF5SUdseklIUm9aU0JqWVd4c1pYSWdablZ1WTNScGIyNHVYRzRnSUNBZ2FXWWdLSE4wWVdOclJuVnVZM1JwYjI1eld6SmRLU0I3WEc0Z0lDQWdJQ0JqYjIxd2JHVjBaVVZ5Y205eVRXVnpjMkZuWlNBOUlHQWtlM04wWVdOclJuVnVZM1JwYjI1eld6SmRmVG9nSkh0amIyMXdiR1YwWlVWeWNtOXlUV1Z6YzJGblpYMWdPMXh1SUNBZ0lIMWNibHh1SUNBZ0lHTnZiWEJzWlhSbFJYSnliM0pOWlhOellXZGxJQ3M5SUdWeWNtOXlUV1Z6YzJGblpUdGNiaUFnSUNCeVpYUjFjbTRnWTI5dGNHeGxkR1ZGY25KdmNrMWxjM05oWjJVN1hHNGdJSDFjYmx4dUlDQnlaWFIxY200Z2JuVnNiRHRjYm4xY2JseHVMeW9xWEc0Z0tpQlVhSEp2ZDNNZ1lXNGdaWEp5YjNJZ2FXWWdkR2hsSUdKdmIyeGxZVzRnY0dGemMyVmtJSFJ2SUdsMElHVjJZV3gxWVhSbGN5QjBieUJtWVd4elpTNWNiaUFxSUZSdklHSmxJSFZ6WldRZ2JHbHJaU0IwYUdsek9seHVJQ29nWEhSY2RHRnpjMlZ5ZENodGVVUmhkR1VnSVQwOUlIVnVaR1ZtYVc1bFpDd2dYQ0pFWVhSbElHTmhibTV2ZENCaVpTQjFibVJsWm1sdVpXUXVYQ0lwTzF4dUlDb2dRR0Z3YVNCd2RXSnNhV05jYmlBcUlFQnRaWFJvYjJRZ1lYTnpaWEowWEc0Z0tpQkFjR0Z5WVcwZ0lIdENiMjlzWldGdWZTQmpiMjVrYVhScGIyNGdMU0JTWlhOMWJIUWdiMllnZEdobElHVjJZV3gxWVhSbFpDQmpiMjVrYVhScGIyNWNiaUFxSUVCd1lYSmhiU0FnZTFOMGNtbHVaMzBnWlhKeWIzSk5aWE56WVdkbElDMGdUV1Z6YzJGblpTQmxlSEJzWVdsdWFXY2dkR2hsSUdWeWNtOXlJR2x1SUdOaGMyVWdhWFFnYVhNZ2RHaHliM2R1WEc0Z0tpQkFjbVYwZFhKdUlIWnZhV1JjYmlBcUwxeHVablZ1WTNScGIyNGdZWE56WlhKMEtHTnZibVJwZEdsdmJpd2daWEp5YjNKTlpYTnpZV2RsS1NCN1hHNGdJR052Ym5OMElHVnljbTl5SUQwZ2NISnZZMlZ6YzBOdmJtUnBkR2x2YmloamIyNWthWFJwYjI0c0lHVnljbTl5VFdWemMyRm5aU2s3WEc0Z0lHbG1JQ2gwZVhCbGIyWWdaWEp5YjNJZ1BUMDlJQ2R6ZEhKcGJtY25LU0I3WEc0Z0lDQWdkR2h5YjNjZ2JtVjNJRVZ5Y205eUtHVnljbTl5S1R0Y2JpQWdmVnh1ZlZ4dVhHNHZLaXBjYmlBcUlFeHZaM01nWVNCM1lYSnVhVzVuSUdsbUlIUm9aU0JpYjI5c1pXRnVJSEJoYzNObFpDQjBieUJwZENCbGRtRnNkV0YwWlhNZ2RHOGdabUZzYzJVdVhHNGdLaUJVYnlCaVpTQjFjMlZrSUd4cGEyVWdkR2hwY3pwY2JpQXFJRngwWEhSaGMzTmxjblF1ZDJGeWJpaHRlVVJoZEdVZ0lUMDlJSFZ1WkdWbWFXNWxaQ3dnWENKT2J5QmtZWFJsSUhCeWIzWnBaR1ZrTGx3aUtUdGNiaUFxSUVCaGNHa2djSFZpYkdsalhHNGdLaUJBYldWMGFHOWtJSGRoY201Y2JpQXFJRUJ3WVhKaGJTQWdlMEp2YjJ4bFlXNTlJR052Ym1ScGRHbHZiaUF0SUZKbGMzVnNkQ0J2WmlCMGFHVWdaWFpoYkhWaGRHVmtJR052Ym1ScGRHbHZibHh1SUNvZ1FIQmhjbUZ0SUNCN1UzUnlhVzVuZlNCbGNuSnZjazFsYzNOaFoyVWdMU0JOWlhOellXZGxJR1Y0Y0d4aGFXNXBaeUIwYUdVZ1pYSnliM0lnYVc0Z1kyRnpaU0JwZENCcGN5QjBhSEp2ZDI1Y2JpQXFJRUJ5WlhSMWNtNGdkbTlwWkZ4dUlDb3ZYRzVoYzNObGNuUXVkMkZ5YmlBOUlHWjFibU4wYVc5dUlIZGhjbTRvWTI5dVpHbDBhVzl1TENCbGNuSnZjazFsYzNOaFoyVXBJSHRjYmlBZ1kyOXVjM1FnWlhKeWIzSWdQU0J3Y205alpYTnpRMjl1WkdsMGFXOXVLR052Ym1ScGRHbHZiaXdnWlhKeWIzSk5aWE56WVdkbEtUdGNiaUFnYVdZZ0tIUjVjR1Z2WmlCbGNuSnZjaUE5UFQwZ0ozTjBjbWx1WnljcElIdGNiaUFnSUNCamIyNXpiMnhsTG5kaGNtNG9aWEp5YjNJcE8xeHVJQ0I5WEc1OU8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmhjM05sY25RN1hHNGlYU3dpWm1sc1pTSTZJbUZ6YzJWeWRDNXFjeUlzSW5OdmRYSmpaVkp2YjNRaU9pSXZjMjkxY21ObEx5SjlcbiIsImltcG9ydCB7IGN1cnJ5IH0gZnJvbSAncmFtZGEnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdmbC1hc3NlcnQnO1xuXG4vKipcbiAgdHlwZSBWYWxpZGF0aW9uXG4gICAgPSBTdWNjZXNzIGFcbiAgICB8IEZhaWx1cmUgYlxuICovXG5cbmNvbnN0IHR5cGVzID0ge1xuICBTdWNjZXNzOiBNYXRoLnJhbmRvbSgpLFxuICBGYWlsdXJlOiBNYXRoLnJhbmRvbSgpLFxufTtcblxuY29uc3QgbWFwSWYgPSBjdXJyeSgoY29uZGl0aW9uLCB2YWx1ZSwgZikgPT4gKGNvbmRpdGlvbiA/IGYodmFsdWUpIDogdmFsdWUpKTtcblxuLy8gVGhpcyBmdW5jdGlvbiBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkIGJ5IGFueW9uZSBvdGhlciB0aGFuIHRoaXMgZmlsZS5cbmZ1bmN0aW9uIFZhbGlkYXRpb24odmFsdWUsIHR5cGUpIHtcbiAgLy8gQ2hlY2sgdGhhdCBhIHZhbGlkIHR5cGUgaXMgYmVpbmcgdXNlZFxuICBjb25zdCBpc1N1Y2Nlc3MgPSB0eXBlID09PSB0eXBlcy5TdWNjZXNzO1xuXG4gIHRoaXMuaXNTdWNjZXNzID0gaXNTdWNjZXNzO1xuICB0aGlzLmlzRmFpbHVyZSA9ICFpc1N1Y2Nlc3M7XG4gIHRoaXMud2l0aERlZmF1bHQgPSBkZWZhdWx0VmFsID0+IChpc1N1Y2Nlc3MgPyB2YWx1ZSA6IGRlZmF1bHRWYWwpO1xuICB0aGlzLm1hcCA9IGYgPT4gbmV3IFZhbGlkYXRpb24obWFwSWYoaXNTdWNjZXNzLCB2YWx1ZSwgZiksIHR5cGUpO1xuICB0aGlzLm1hcFN1Y2Nlc3MgPSBmID0+IG5ldyBWYWxpZGF0aW9uKG1hcElmKGlzU3VjY2VzcywgdmFsdWUsIGYpLCB0eXBlKTtcbiAgdGhpcy5tYXBGYWlsdXJlID0gZiA9PiBuZXcgVmFsaWRhdGlvbihtYXBJZighaXNTdWNjZXNzLCB2YWx1ZSwgZiksIHR5cGUpO1xuICB0aGlzLnRocm93RmFpbHVyZSA9IF8gPT4gKCFpc1N1Y2Nlc3NcbiAgICA/IGFzc2VydChmYWxzZSwgdmFsdWUpXG4gICAgOiB0aGlzXG4gICk7XG4gIHRoaXMuYW5kVGhlbiA9IGYgPT4ge1xuICAgIGlmICghaXNTdWNjZXNzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCB2YWwgPSBmKHZhbHVlKTtcbiAgICBhc3NlcnQoXG4gICAgICB2YWwgaW5zdGFuY2VvZiBWYWxpZGF0aW9uLFxuICAgICAgJ1ZhbHVlIHJldHVybmVkIGJ5IFZhbGlkYXRpb24uYW5kVGhlbiBpcyBub3Qgb2YgdHlwZSBWYWxpZGF0aW9uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcbiAgLy8gVmFsaWRhdGlvbiAtPiBWYWxpZGF0aW9uXG4gIHRoaXMuY2hhaW4gPSB2ID0+IHtcbiAgICBpZiAoIWlzU3VjY2VzcykgeyByZXR1cm4gdGhpczsgfVxuXG4gICAgYXNzZXJ0KFxuICAgICAgdiBpbnN0YW5jZW9mIFZhbGlkYXRpb24sXG4gICAgICAnVmFsdWUgcGFzc2VkIHRvIFZhbGlkYXRpb24uY2hhaW4gaXMgbm90IG9mIHR5cGUgVmFsaWRhdGlvbidcbiAgICApO1xuXG4gICAgcmV0dXJuIHY7XG4gIH07XG4gIC8vIEpVU1QgRk9SIERFQlVHR0lORyBQVVJQT1NFUy4gRE8gTk9UIFVTRVxuICB0aGlzLl92YWx1ZSA9IHZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlXG59XG5cbi8vIFN0YXRpYyBmdW5jdGlvbnNcblZhbGlkYXRpb24uU3VjY2VzcyA9IHYgPT4gbmV3IFZhbGlkYXRpb24odiwgdHlwZXMuU3VjY2Vzcyk7XG5WYWxpZGF0aW9uLkZhaWx1cmUgPSB2ID0+IG5ldyBWYWxpZGF0aW9uKHYsIHR5cGVzLkZhaWx1cmUpO1xuXG5WYWxpZGF0aW9uLmlzU3VjY2VzcyA9IHYgPT4gdi5pc1N1Y2Nlc3M7XG5WYWxpZGF0aW9uLmlzRmFpbHVyZSA9IHYgPT4gdi5pc0ZhaWx1cmU7XG5WYWxpZGF0aW9uLndpdGhEZWZhdWx0ID0gY3VycnkoKGRlZmF1bHRWYWwsIHYpID0+IHYud2l0aERlZmF1bHQoZGVmYXVsdFZhbCkpO1xuVmFsaWRhdGlvbi5tYXAgPSBjdXJyeSgoZiwgdikgPT4gdi5tYXAoZikpO1xuVmFsaWRhdGlvbi5tYXBTdWNjZXNzID0gY3VycnkoKGYsIHYpID0+IHYubWFwU3VjY2VzcyhmKSk7XG5WYWxpZGF0aW9uLm1hcEZhaWx1cmUgPSBjdXJyeSgoZiwgdikgPT4gdi5tYXBGYWlsdXJlKGYpKTtcblZhbGlkYXRpb24udGhyb3dGYWlsdXJlID0gdiA9PiB2LnRocm93RmFpbHVyZSgpO1xuVmFsaWRhdGlvbi5hbmRUaGVuID0gY3VycnkoKGYsIHYpID0+IHYuYW5kVGhlbihmKSk7XG5WYWxpZGF0aW9uLmNoYWluID0gY3VycnkoKHYxLCB2MikgPT4gdjEuY2hhaW4odjIpKTtcblxuZXhwb3J0IGRlZmF1bHQgVmFsaWRhdGlvbjtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGlucHV0IHZhbHVlIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBUeXBlXG4gKiBAc2lnICogLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfSB4IFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB4YCBpcyBgdW5kZWZpbmVkYCBvciBgbnVsbGAsIG90aGVyd2lzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaXNOaWwobnVsbCk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzTmlsKHVuZGVmaW5lZCk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzTmlsKDApOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaXNOaWwoW10pOyAvLz0+IGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiBpc05pbCh4KSB7IHJldHVybiB4ID09IG51bGw7IH0pO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xuaW1wb3J0IFZhbGlkYXRpb24gZnJvbSAnLi9WYWxpZGF0aW9uJztcbmltcG9ydCBNYXliZSBmcm9tICcuL01heWJlJztcbmltcG9ydCB7IGN1cnJ5LCBwaXBlLCBpc05pbCB9IGZyb20gJ3JhbWRhJztcblxuZXhwb3J0IGNvbnN0IGVyck1zZyA9IGN1cnJ5KChwcm9wLCBlcnJvck1lc3NhZ2UpID0+XG4gIGBJbnZhbGlkIHByb3BlcnR5IHZhbHVlIGZvciAke3Byb3B9LiAke2Vycm9yTWVzc2FnZX1gXG4pO1xuXG4vLyBBbGwgdHlwZSBjaGVja3MgcmV0dXJuIGEgVmFsaWRhdGlvbiBvYmplY3QuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyAgR2VuZXJhbCBUeXBlIGNoZWNrZXJzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBjb25zdCBpbnQgPSB2ID0+IChcbiAgdHlwZW9mIHYgPT09ICdudW1iZXInICYmICh2ICUgMSkgPT09IDBcbiAgICA/IFZhbGlkYXRpb24uU3VjY2Vzcyh2KVxuICAgIDogVmFsaWRhdGlvbi5GYWlsdXJlKGAke3Z9IGlzIG5vdCBhbiBpbnRlZ2VyYClcbik7XG5cbmV4cG9ydCBjb25zdCBmbG9hdCA9IHYgPT4gKFxuICB0eXBlb2YgdiA9PT0gJ251bWJlcidcbiAgICA/IFZhbGlkYXRpb24uU3VjY2Vzcyh2KVxuICAgIDogVmFsaWRhdGlvbi5GYWlsdXJlKGAke3Z9IGlzIG5vdCBhIGZsb2F0YClcbik7XG5cbmV4cG9ydCBjb25zdCBzdHJpbmcgPSB2ID0+IChcbiAgdHlwZW9mIHYgPT09ICdzdHJpbmcnXG4gICAgPyBWYWxpZGF0aW9uLlN1Y2Nlc3ModilcbiAgICA6IFZhbGlkYXRpb24uRmFpbHVyZShgJHt2fSBpcyBub3QgYSBzdHJpbmdgKVxuKTtcblxuZXhwb3J0IGNvbnN0IGJvb2wgPSB2ID0+IChcbiAgdHlwZW9mIHYgPT09ICdib29sZWFuJ1xuICAgID8gVmFsaWRhdGlvbi5TdWNjZXNzKHYpXG4gICAgOiBWYWxpZGF0aW9uLkZhaWx1cmUoYCR7dn0gaXMgbm90IGEgYm9vbGVhbmApXG4pO1xuXG5leHBvcnQgY29uc3QgbnVsbFR5cGUgPSB2ID0+IChcbiAgdHlwZW9mIHYgPT09ICdvYmplY3QnICYmIHYgPT09IG51bGxcbiAgICA/IFZhbGlkYXRpb24uU3VjY2Vzcyh2KVxuICAgIDogVmFsaWRhdGlvbi5GYWlsdXJlKGAke3Z9IGlzIG5vdCBudWxsYClcbik7XG5cbmV4cG9ydCBjb25zdCBhcnJheSA9IGN1cnJ5KChzdWJUeXBlLCB2KSA9PiB7XG4gIGlmICh2IGluc3RhbmNlb2YgVmFsaWRhdGlvbikge1xuICAgIHJldHVybiBWYWxpZGF0aW9uLmFuZFRoZW4oYXJyYXksIHYpO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgcmV0dXJuIFZhbGlkYXRpb24uRmFpbHVyZShgJHt2fSBpcyBub3QgYW4gYXJyYXlgKTtcbiAgfVxuXG4gIGNvbnN0IHN1YlR5cGVzVmFsaWRhdGlvbiA9IHZcbiAgICAubWFwKHN1YlR5cGUpXG4gICAgLnJlZHVjZShWYWxpZGF0aW9uLmNoYWluLCBWYWxpZGF0aW9uLlN1Y2Nlc3ModikpO1xuXG4gIGlmIChWYWxpZGF0aW9uLmlzU3VjY2VzcyhzdWJUeXBlc1ZhbGlkYXRpb24pKSB7XG4gICAgcmV0dXJuIFZhbGlkYXRpb24uU3VjY2Vzcyh2KTtcbiAgfVxuICByZXR1cm4gVmFsaWRhdGlvbi5tYXBGYWlsdXJlKGVyck1zZygnYXJyYXknKSwgc3ViVHlwZXNWYWxpZGF0aW9uKTtcbn0pO1xuXG5leHBvcnQgY29uc3QgZGF0ZSA9IHYgPT4gKFxuICB2ICE9PSB1bmRlZmluZWQgJiYgdiBpbnN0YW5jZW9mIERhdGVcbiAgICA/IFZhbGlkYXRpb24uU3VjY2Vzcyh2KVxuICAgIDogVmFsaWRhdGlvbi5GYWlsdXJlKGAke3Z9IGlzIG5vdCBhIERhdGVgKVxuKTtcblxuZXhwb3J0IGNvbnN0IG51bGxhYmxlID0gY3VycnkoKHN1YlR5cGUsIHYpID0+IChcbiAgIHYgPT09IG51bGxcbiAgID8gVmFsaWRhdGlvbi5TdWNjZXNzKHYpXG4gICA6IHN1YlR5cGUodilcbikpO1xuXG5leHBvcnQgY29uc3QgbWF5YmUgPSBjdXJyeSgoc3ViVHlwZSwgdikgPT4gKFxuICB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgVmFsaWRhdGlvbi5pc1N1Y2Nlc3MoYm9vbCh2LmlzTm90aGluZykpXG4gICAgPyBwaXBlKFxuICAgICAgICBNYXliZS5tYXAoc3ViVHlwZSksXG4gICAgICAgIE1heWJlLm1hcChWYWxpZGF0aW9uLm1hcChfID0+IFZhbGlkYXRpb24uU3VjY2Vzcyh2KSkpLFxuICAgICAgICBNYXliZS53aXRoRGVmYXVsdChWYWxpZGF0aW9uLlN1Y2Nlc3ModikpLFxuICAgICAgKSh2KVxuICAgIDogVmFsaWRhdGlvbi5GYWlsdXJlKGAke3Z9IGlzIG5vdCBvZiB0eXBlIE1heWJlYClcbikpO1xuXG5leHBvcnQgY29uc3QgcmVtb3RlRGF0YSA9IHYgPT4gKFxuICB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgVmFsaWRhdGlvbi5pc1N1Y2Nlc3MoYm9vbCh2LmlzTm90QXNrZWQpKVxuICAgID8gVmFsaWRhdGlvbi5TdWNjZXNzKHYpXG4gICAgOiBWYWxpZGF0aW9uLkZhaWx1cmUoYCR7dn0gaXMgbm90IG9mIHR5cGUgUmVtb3RlRGF0YS5gKVxuKTtcblxuZXhwb3J0IGNvbnN0IHJlcXVlc3QgPSB2ID0+IChcbiAgdHlwZW9mIHYgPT09ICdvYmplY3QnICYmIHYgaW5zdGFuY2VvZiBSZXF1ZXN0XG4gICAgPyBWYWxpZGF0aW9uLlN1Y2Nlc3ModilcbiAgICA6IFZhbGlkYXRpb24uRmFpbHVyZShgJHt2fSBpcyBub3Qgb2YgdHlwZSBSZXF1ZXN0LmApXG4pO1xuXG5leHBvcnQgY29uc3QgcmVzcG9uc2UgPSB2ID0+IChcbiAgdHlwZW9mIHYgPT09ICdvYmplY3QnICYmIHYgaW5zdGFuY2VvZiBSZXNwb25zZVxuICAgID8gVmFsaWRhdGlvbi5TdWNjZXNzKHYpXG4gICAgOiBWYWxpZGF0aW9uLkZhaWx1cmUoYCR7dn0gaXMgbm90IG9mIHR5cGUgUmVzcG9uc2UuYClcbik7XG5cbmNvbnN0IGhhdmVTYW1lS2V5cyA9IChvMSwgbzIpID0+IHtcbiAgY29uc3QgazEgPSBPYmplY3Qua2V5cyhvMSk7XG4gIGNvbnN0IGsyID0gT2JqZWN0LmtleXMobzIpO1xuICByZXR1cm4gazEucmVkdWNlKChvdXQsIGtleSkgPT4gb3V0ICYmIGsyLmluY2x1ZGVzKGtleSksIHRydWUpO1xufTtcblxuZXhwb3J0IGNvbnN0IG9iamVjdCA9IGN1cnJ5KCh0eXBlU2lnbmF0dXJlLCB2KSA9PiB7XG4gIGlmIChpc05pbCh2KSkge1xuICAgIHJldHVybiBWYWxpZGF0aW9uLkZhaWx1cmUoYCR7dn0gaXMgbm90IG9mIHR5cGUgb2JqZWN0LmApO1xuICB9XG4gIGlmICghaGF2ZVNhbWVLZXlzKHR5cGVTaWduYXR1cmUsIHYpKSB7XG4gICAgcmV0dXJuIFZhbGlkYXRpb24uRmFpbHVyZShcbiAgICAgIGBPYmplY3QgZG9lcyBub3QgaGF2ZSBzYW1lIGtleXMgYXMgaXRzIHR5cGUgc2lnbmF0dXJlOlxuICAgICAgS2V5cyBwcmVzZW50OiAke09iamVjdC5rZXlzKHYpfVxuICAgICAgS2V5cyBleHBlY3RlZDogJHtPYmplY3Qua2V5cyh0eXBlU2lnbmF0dXJlKX1cbiAgICAgICR7dn1gXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyh0eXBlU2lnbmF0dXJlKVxuICAucmVkdWNlKFxuICAgIChvdXRjb21lLCBrZXkpID0+XG4gICAgICBWYWxpZGF0aW9uLmNoYWluKFxuICAgICAgICBvdXRjb21lLFxuICAgICAgICBwaXBlKFxuICAgICAgICAgICAgdHlwZVNpZ25hdHVyZVtrZXldLFxuICAgICAgICAgICAgVmFsaWRhdGlvbi5tYXBGYWlsdXJlKGVyck1zZyhrZXkpKSxcbiAgICAgICAgICAgIFZhbGlkYXRpb24ubWFwU3VjY2VzcyhfID0+IHYpXG4gICAgICAgICAgKSh2W2tleV0pXG4gICAgICApLFxuICAgICAgVmFsaWRhdGlvbi5TdWNjZXNzKHYpXG4gICk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbnQsXG4gIGZsb2F0LFxuICBzdHJpbmcsXG4gIGJvb2wsXG4gIG51bGxUeXBlLFxuICBudWxsYWJsZSxcbiAgYXJyYXksXG4gIGRhdGUsXG4gIG1heWJlLFxuICByZW1vdGVEYXRhLFxuICByZXF1ZXN0LFxuICByZXNwb25zZSxcbiAgb2JqZWN0LFxufTtcbiIsIihmdW5jdGlvbigpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvdjE1LjAuMS9zcmMvaXNvbW9ycGhpYy9jbGFzc2ljL2VsZW1lbnQvUmVhY3RFbGVtZW50LmpzI0wyMVxuICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yICYmIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRV9GQUxMQkFDSyA9IDB4ZWFjNztcblxuICBmdW5jdGlvbiBhZGRQcm9wZXJ0eVRvKHRhcmdldCwgbWV0aG9kTmFtZSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBtZXRob2ROYW1lLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJhblByb3BlcnR5KHRhcmdldCwgbWV0aG9kTmFtZSkge1xuICAgIGFkZFByb3BlcnR5VG8odGFyZ2V0LCBtZXRob2ROYW1lLCBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBJbW11dGFibGVFcnJvcihcIlRoZSBcIiArIG1ldGhvZE5hbWUgK1xuICAgICAgICBcIiBtZXRob2QgY2Fubm90IGJlIGludm9rZWQgb24gYW4gSW1tdXRhYmxlIGRhdGEgc3RydWN0dXJlLlwiKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBpbW11dGFiaWxpdHlUYWcgPSBcIl9faW1tdXRhYmxlX2ludmFyaWFudHNfaG9sZFwiO1xuXG4gIGZ1bmN0aW9uIGFkZEltbXV0YWJpbGl0eVRhZyh0YXJnZXQpIHtcbiAgICBhZGRQcm9wZXJ0eVRvKHRhcmdldCwgaW1tdXRhYmlsaXR5VGFnLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW1tdXRhYmxlKHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0ID09PSBudWxsIHx8IEJvb2xlYW4oXG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBpbW11dGFiaWxpdHlUYWcpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbiBKYXZhU2NyaXB0LCBvbmx5IG9iamVjdHMgYXJlIGV2ZW4gcG90ZW50aWFsbHkgbXV0YWJsZS5cbiAgICAgIC8vIHN0cmluZ3MsIG51bWJlcnMsIG51bGwsIGFuZCB1bmRlZmluZWQgYXJlIGFsbCBuYXR1cmFsbHkgaW1tdXRhYmxlLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gICAgLy8gQXZvaWQgZmFsc2UgcG9zaXRpdmVzIGR1ZSB0byAoTmFOICE9PSBOYU4pIGV2YWx1YXRpbmcgdG8gdHJ1ZVxuICAgIHJldHVybiAoYSA9PT0gYiB8fCAoYSAhPT0gYSAmJiBiICE9PSBiKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc01lcmdhYmxlT2JqZWN0KHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQgIT09IG51bGwgJiYgdHlwZW9mIHRhcmdldCA9PT0gXCJvYmplY3RcIiAmJiAhKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBEYXRlKTtcbiAgfVxuXG4gIHZhciBtdXRhdGluZ09iamVjdE1ldGhvZHMgPSBbXG4gICAgXCJzZXRQcm90b3R5cGVPZlwiXG4gIF07XG5cbiAgdmFyIG5vbk11dGF0aW5nT2JqZWN0TWV0aG9kcyA9IFtcbiAgICBcImtleXNcIlxuICBdO1xuXG4gIHZhciBtdXRhdGluZ0FycmF5TWV0aG9kcyA9IG11dGF0aW5nT2JqZWN0TWV0aG9kcy5jb25jYXQoW1xuICAgIFwicHVzaFwiLCBcInBvcFwiLCBcInNvcnRcIiwgXCJzcGxpY2VcIiwgXCJzaGlmdFwiLCBcInVuc2hpZnRcIiwgXCJyZXZlcnNlXCJcbiAgXSk7XG5cbiAgdmFyIG5vbk11dGF0aW5nQXJyYXlNZXRob2RzID0gbm9uTXV0YXRpbmdPYmplY3RNZXRob2RzLmNvbmNhdChbXG4gICAgXCJtYXBcIiwgXCJmaWx0ZXJcIiwgXCJzbGljZVwiLCBcImNvbmNhdFwiLCBcInJlZHVjZVwiLCBcInJlZHVjZVJpZ2h0XCJcbiAgXSk7XG5cbiAgdmFyIG11dGF0aW5nRGF0ZU1ldGhvZHMgPSBtdXRhdGluZ09iamVjdE1ldGhvZHMuY29uY2F0KFtcbiAgICBcInNldERhdGVcIiwgXCJzZXRGdWxsWWVhclwiLCBcInNldEhvdXJzXCIsIFwic2V0TWlsbGlzZWNvbmRzXCIsIFwic2V0TWludXRlc1wiLCBcInNldE1vbnRoXCIsIFwic2V0U2Vjb25kc1wiLFxuICAgIFwic2V0VGltZVwiLCBcInNldFVUQ0RhdGVcIiwgXCJzZXRVVENGdWxsWWVhclwiLCBcInNldFVUQ0hvdXJzXCIsIFwic2V0VVRDTWlsbGlzZWNvbmRzXCIsIFwic2V0VVRDTWludXRlc1wiLFxuICAgIFwic2V0VVRDTW9udGhcIiwgXCJzZXRVVENTZWNvbmRzXCIsIFwic2V0WWVhclwiXG4gIF0pO1xuXG4gIGZ1bmN0aW9uIEltbXV0YWJsZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB2YXIgZXJyICAgICAgID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIC8vIFRPRE86IENvbnNpZGVyIGBPYmplY3Quc2V0UHJvdG90eXBlT2YoZXJyLCBJbW11dGFibGVFcnJvcik7YFxuICAgIGVyci5fX3Byb3RvX18gPSBJbW11dGFibGVFcnJvcjtcblxuICAgIHJldHVybiBlcnI7XG4gIH1cbiAgSW1tdXRhYmxlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIG1ha2VJbW11dGFibGUob2JqLCBiYW5uZWRNZXRob2RzKSB7XG4gICAgLy8gVGFnIGl0IHNvIHdlIGNhbiBxdWlja2x5IHRlbGwgaXQncyBpbW11dGFibGUgbGF0ZXIuXG4gICAgYWRkSW1tdXRhYmlsaXR5VGFnKG9iaik7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAvLyBNYWtlIGFsbCBtdXRhdGluZyBtZXRob2RzIHRocm93IGV4Y2VwdGlvbnMuXG4gICAgICBmb3IgKHZhciBpbmRleCBpbiBiYW5uZWRNZXRob2RzKSB7XG4gICAgICAgIGlmIChiYW5uZWRNZXRob2RzLmhhc093blByb3BlcnR5KGluZGV4KSkge1xuICAgICAgICAgIGJhblByb3BlcnR5KG9iaiwgYmFubmVkTWV0aG9kc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZyZWV6ZSBpdCBhbmQgcmV0dXJuIGl0LlxuICAgICAgT2JqZWN0LmZyZWV6ZShvYmopO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlTWV0aG9kUmV0dXJuSW1tdXRhYmxlKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgIHZhciBjdXJyZW50TWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuXG4gICAgYWRkUHJvcGVydHlUbyhvYmosIG1ldGhvZE5hbWUsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEltbXV0YWJsZShjdXJyZW50TWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhcnJheVNldChpZHgsIHZhbHVlLCBjb25maWcpIHtcbiAgICB2YXIgZGVlcCAgICAgICAgICA9IGNvbmZpZyAmJiBjb25maWcuZGVlcDtcblxuICAgIGlmIChpZHggaW4gdGhpcykge1xuICAgICAgaWYgKGRlZXAgJiYgdGhpc1tpZHhdICE9PSB2YWx1ZSAmJiBpc01lcmdhYmxlT2JqZWN0KHZhbHVlKSAmJiBpc01lcmdhYmxlT2JqZWN0KHRoaXNbaWR4XSkpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzW2lkeF0ubWVyZ2UodmFsdWUsIHtkZWVwOiB0cnVlLCBtb2RlOiAncmVwbGFjZSd9KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0VxdWFsKHRoaXNbaWR4XSwgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtdXRhYmxlID0gYXNNdXRhYmxlQXJyYXkuY2FsbCh0aGlzKTtcbiAgICBtdXRhYmxlW2lkeF0gPSBJbW11dGFibGUodmFsdWUpO1xuICAgIHJldHVybiBtYWtlSW1tdXRhYmxlQXJyYXkobXV0YWJsZSk7XG4gIH1cblxuICB2YXIgaW1tdXRhYmxlRW1wdHlBcnJheSA9IEltbXV0YWJsZShbXSk7XG5cbiAgZnVuY3Rpb24gYXJyYXlTZXRJbihwdGgsIHZhbHVlLCBjb25maWcpIHtcbiAgICB2YXIgaGVhZCA9IHB0aFswXTtcblxuICAgIGlmIChwdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gYXJyYXlTZXQuY2FsbCh0aGlzLCBoZWFkLCB2YWx1ZSwgY29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhaWwgPSBwdGguc2xpY2UoMSk7XG4gICAgICB2YXIgdGhpc0hlYWQgPSB0aGlzW2hlYWRdO1xuICAgICAgdmFyIG5ld1ZhbHVlO1xuXG4gICAgICBpZiAodHlwZW9mKHRoaXNIZWFkKSA9PT0gXCJvYmplY3RcIiAmJiB0aGlzSGVhZCAhPT0gbnVsbCAmJiB0eXBlb2YodGhpc0hlYWQuc2V0SW4pID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gTWlnaHQgKHZhbGlkbHkpIGJlIG9iamVjdCBvciBhcnJheVxuICAgICAgICBuZXdWYWx1ZSA9IHRoaXNIZWFkLnNldEluKHRhaWwsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXh0SGVhZCA9IHRhaWxbMF07XG4gICAgICAgIC8vIElmIHRoZSBuZXh0IHBhdGggcGFydCBpcyBhIG51bWJlciwgdGhlbiB3ZSBhcmUgc2V0dGluZyBpbnRvIGFuIGFycmF5LCBlbHNlIGFuIG9iamVjdC5cbiAgICAgICAgaWYgKG5leHRIZWFkICE9PSAnJyAmJiBpc0Zpbml0ZShuZXh0SGVhZCkpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IGFycmF5U2V0SW4uY2FsbChpbW11dGFibGVFbXB0eUFycmF5LCB0YWlsLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBvYmplY3RTZXRJbi5jYWxsKGltbXV0YWJsZUVtcHR5T2JqZWN0LCB0YWlsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhlYWQgaW4gdGhpcyAmJiB0aGlzSGVhZCA9PT0gbmV3VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBtdXRhYmxlID0gYXNNdXRhYmxlQXJyYXkuY2FsbCh0aGlzKTtcbiAgICAgIG11dGFibGVbaGVhZF0gPSBuZXdWYWx1ZTtcbiAgICAgIHJldHVybiBtYWtlSW1tdXRhYmxlQXJyYXkobXV0YWJsZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFrZUltbXV0YWJsZUFycmF5KGFycmF5KSB7XG4gICAgLy8gRG9uJ3QgY2hhbmdlIHRoZWlyIGltcGxlbWVudGF0aW9ucywgYnV0IHdyYXAgdGhlc2UgZnVuY3Rpb25zIHRvIG1ha2Ugc3VyZVxuICAgIC8vIHRoZXkgYWx3YXlzIHJldHVybiBhbiBpbW11dGFibGUgdmFsdWUuXG4gICAgZm9yICh2YXIgaW5kZXggaW4gbm9uTXV0YXRpbmdBcnJheU1ldGhvZHMpIHtcbiAgICAgIGlmIChub25NdXRhdGluZ0FycmF5TWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShpbmRleCkpIHtcbiAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBub25NdXRhdGluZ0FycmF5TWV0aG9kc1tpbmRleF07XG4gICAgICAgIG1ha2VNZXRob2RSZXR1cm5JbW11dGFibGUoYXJyYXksIG1ldGhvZE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFkZFByb3BlcnR5VG8oYXJyYXksIFwiZmxhdE1hcFwiLCAgZmxhdE1hcCk7XG4gICAgYWRkUHJvcGVydHlUbyhhcnJheSwgXCJhc09iamVjdFwiLCBhc09iamVjdCk7XG4gICAgYWRkUHJvcGVydHlUbyhhcnJheSwgXCJhc011dGFibGVcIiwgYXNNdXRhYmxlQXJyYXkpO1xuICAgIGFkZFByb3BlcnR5VG8oYXJyYXksIFwic2V0XCIsIGFycmF5U2V0KTtcbiAgICBhZGRQcm9wZXJ0eVRvKGFycmF5LCBcInNldEluXCIsIGFycmF5U2V0SW4pO1xuICAgIGFkZFByb3BlcnR5VG8oYXJyYXksIFwidXBkYXRlXCIsIHVwZGF0ZSk7XG4gICAgYWRkUHJvcGVydHlUbyhhcnJheSwgXCJ1cGRhdGVJblwiLCB1cGRhdGVJbik7XG5cbiAgICBmb3IodmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYXJyYXlbaV0gPSBJbW11dGFibGUoYXJyYXlbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYWtlSW1tdXRhYmxlKGFycmF5LCBtdXRhdGluZ0FycmF5TWV0aG9kcyk7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlSW1tdXRhYmxlRGF0ZShkYXRlKSB7XG4gICAgYWRkUHJvcGVydHlUbyhkYXRlLCBcImFzTXV0YWJsZVwiLCBhc011dGFibGVEYXRlKTtcblxuICAgIHJldHVybiBtYWtlSW1tdXRhYmxlKGRhdGUsIG11dGF0aW5nRGF0ZU1ldGhvZHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNNdXRhYmxlRGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGhpcy5nZXRUaW1lKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVmZmVjdGl2ZWx5IHBlcmZvcm1zIGEgbWFwKCkgb3ZlciB0aGUgZWxlbWVudHMgaW4gdGhlIGFycmF5LCB1c2luZyB0aGVcbiAgICogcHJvdmlkZWQgaXRlcmF0b3IsIGV4Y2VwdCB0aGF0IHdoZW5ldmVyIHRoZSBpdGVyYXRvciByZXR1cm5zIGFuIGFycmF5LCB0aGF0XG4gICAqIGFycmF5J3MgZWxlbWVudHMgYXJlIGFkZGVkIHRvIHRoZSBmaW5hbCByZXN1bHQgaW5zdGVhZCBvZiB0aGUgYXJyYXkgaXRzZWxmLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRvciAtIFRoZSBpdGVyYXRvciBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCBvbiBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5LiBJdCB3aWxsIHJlY2VpdmUgdGhyZWUgYXJndW1lbnRzOiB0aGUgY3VycmVudCB2YWx1ZSwgdGhlIGN1cnJlbnQgaW5kZXgsIGFuZCB0aGUgY3VycmVudCBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBmbGF0TWFwKGl0ZXJhdG9yKSB7XG4gICAgLy8gQ2FsbGluZyAuZmxhdE1hcCgpIHdpdGggbm8gYXJndW1lbnRzIGlzIGEgbm8tb3AuIERvbid0IGJvdGhlciBjbG9uaW5nLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoLFxuICAgICAgICBpbmRleDtcblxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGl0ZXJhdG9yUmVzdWx0ID0gaXRlcmF0b3IodGhpc1tpbmRleF0sIGluZGV4LCB0aGlzKTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlcmF0b3JSZXN1bHQpKSB7XG4gICAgICAgIC8vIENvbmNhdGVuYXRlIEFycmF5IHJlc3VsdHMgaW50byB0aGUgcmV0dXJuIHZhbHVlIHdlJ3JlIGJ1aWxkaW5nIHVwLlxuICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIGl0ZXJhdG9yUmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhhbmRsZSBub24tQXJyYXkgcmVzdWx0cyB0aGUgc2FtZSB3YXkgbWFwKCkgZG9lcy5cbiAgICAgICAgcmVzdWx0LnB1c2goaXRlcmF0b3JSZXN1bHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYWtlSW1tdXRhYmxlQXJyYXkocmVzdWx0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIEltbXV0YWJsZSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgZ2l2ZW4ga2V5cyBpbmNsdWRlZC5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheX0ga2V5c1RvUmVtb3ZlIC0gQSBsaXN0IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBrZXlzIHRvIGV4Y2x1ZGUgaW4gdGhlIHJldHVybiB2YWx1ZS4gSW5zdGVhZCBvZiBwcm92aWRpbmcgYSBzaW5nbGUgYXJyYXksIHRoaXMgbWV0aG9kIGNhbiBhbHNvIGJlIGNhbGxlZCBieSBwYXNzaW5nIG11bHRpcGxlIHN0cmluZ3MgYXMgc2VwYXJhdGUgYXJndW1lbnRzLlxuICAgKi9cbiAgZnVuY3Rpb24gd2l0aG91dChyZW1vdmUpIHtcbiAgICAvLyBDYWxsaW5nIC53aXRob3V0KCkgd2l0aCBubyBhcmd1bWVudHMgaXMgYSBuby1vcC4gRG9uJ3QgYm90aGVyIGNsb25pbmcuXG4gICAgaWYgKHR5cGVvZiByZW1vdmUgPT09IFwidW5kZWZpbmVkXCIgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZW1vdmUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgLy8gSWYgd2Ugd2VyZW4ndCBnaXZlbiBhbiBhcnJheSwgdXNlIHRoZSBhcmd1bWVudHMgbGlzdC5cbiAgICAgIHZhciBrZXlzVG9SZW1vdmVBcnJheSA9IChBcnJheS5pc0FycmF5KHJlbW92ZSkpID9cbiAgICAgICAgIHJlbW92ZS5zbGljZSgpIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgICAgLy8gQ29udmVydCBudW1lcmljIGtleXMgdG8gc3RyaW5ncyBzaW5jZSB0aGF0J3MgaG93IHRoZXknbGxcbiAgICAgIC8vIGNvbWUgZnJvbSB0aGUgZW51bWVyYXRpb24gb2YgdGhlIG9iamVjdC5cbiAgICAgIGtleXNUb1JlbW92ZUFycmF5LmZvckVhY2goZnVuY3Rpb24oZWwsIGlkeCwgYXJyKSB7XG4gICAgICAgIGlmKHR5cGVvZihlbCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBhcnJbaWR4XSA9IGVsLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZW1vdmUgPSBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgICByZXR1cm4ga2V5c1RvUmVtb3ZlQXJyYXkuaW5kZXhPZihrZXkpICE9PSAtMTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuaW5zdGFudGlhdGVFbXB0eU9iamVjdCgpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMpIHtcbiAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KGtleSkgJiYgcmVtb3ZlKHRoaXNba2V5XSwga2V5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB0aGlzW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ha2VJbW11dGFibGVPYmplY3QocmVzdWx0LFxuICAgICAge2luc3RhbnRpYXRlRW1wdHlPYmplY3Q6IHRoaXMuaW5zdGFudGlhdGVFbXB0eU9iamVjdH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYXNNdXRhYmxlQXJyYXkob3B0cykge1xuICAgIHZhciByZXN1bHQgPSBbXSwgaSwgbGVuZ3RoO1xuXG4gICAgaWYob3B0cyAmJiBvcHRzLmRlZXApIHtcbiAgICAgIGZvcihpID0gMCwgbGVuZ3RoID0gdGhpcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChhc0RlZXBNdXRhYmxlKHRoaXNbaV0pKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yKGkgPSAwLCBsZW5ndGggPSB0aGlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRWZmZWN0aXZlbHkgcGVyZm9ybXMgYSBbbWFwXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9tYXApIG92ZXIgdGhlIGVsZW1lbnRzIGluIHRoZSBhcnJheSwgZXhwZWN0aW5nIHRoYXQgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uXG4gICAqIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIHR3byBlbGVtZW50cyAtIHRoZSBmaXJzdCByZXByZXNlbnRpbmcgYSBrZXksIHRoZSBvdGhlclxuICAgKiBhIHZhbHVlLiBUaGVuIHJldHVybnMgYW4gSW1tdXRhYmxlIE9iamVjdCBjb25zdHJ1Y3RlZCBvZiB0aG9zZSBrZXlzIGFuZCB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdG9yIC0gQSBmdW5jdGlvbiB3aGljaCBzaG91bGQgcmV0dXJuIGFuIGFycmF5IG9mIHR3byBlbGVtZW50cyAtIHRoZSBmaXJzdCByZXByZXNlbnRpbmcgdGhlIGRlc2lyZWQga2V5LCB0aGUgb3RoZXIgdGhlIGRlc2lyZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBhc09iamVjdChpdGVyYXRvcikge1xuICAgIC8vIElmIG5vIGl0ZXJhdG9yIHdhcyBwcm92aWRlZCwgYXNzdW1lIHRoZSBpZGVudGl0eSBmdW5jdGlvblxuICAgIC8vIChzdWdnZXN0aW5nIHRoaXMgYXJyYXkgaXMgYWxyZWFkeSBhIGxpc3Qgb2Yga2V5L3ZhbHVlIHBhaXJzLilcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGl0ZXJhdG9yID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB7fSxcbiAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGgsXG4gICAgICAgIGluZGV4O1xuXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgcGFpciAgPSBpdGVyYXRvcih0aGlzW2luZGV4XSwgaW5kZXgsIHRoaXMpLFxuICAgICAgICAgIGtleSAgID0gcGFpclswXSxcbiAgICAgICAgICB2YWx1ZSA9IHBhaXJbMV07XG5cbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ha2VJbW11dGFibGVPYmplY3QocmVzdWx0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzRGVlcE11dGFibGUob2JqKSB7XG4gICAgaWYgKFxuICAgICAgKCFvYmopIHx8XG4gICAgICAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHx8XG4gICAgICAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBpbW11dGFiaWxpdHlUYWcpKSB8fFxuICAgICAgKG9iaiBpbnN0YW5jZW9mIERhdGUpXG4gICAgKSB7IHJldHVybiBvYmo7IH1cbiAgICByZXR1cm4gb2JqLmFzTXV0YWJsZSh7ZGVlcDogdHJ1ZX0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcXVpY2tDb3B5KHNyYywgZGVzdCkge1xuICAgIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNyYywga2V5KSkge1xuICAgICAgICBkZXN0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIEltbXV0YWJsZSBPYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBhbmQgdmFsdWVzIG9mIGJvdGhcbiAgICogdGhpcyBvYmplY3QgYW5kIHRoZSBwcm92aWRlZCBvYmplY3QsIHByaW9yaXRpemluZyB0aGUgcHJvdmlkZWQgb2JqZWN0J3NcbiAgICogdmFsdWVzIHdoZW5ldmVyIHRoZSBzYW1lIGtleSBpcyBwcmVzZW50IGluIGJvdGggb2JqZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG90aGVyIC0gVGhlIG90aGVyIG9iamVjdCB0byBtZXJnZS4gTXVsdGlwbGUgb2JqZWN0cyBjYW4gYmUgcGFzc2VkIGFzIGFuIGFycmF5LiBJbiBzdWNoIGEgY2FzZSwgdGhlIGxhdGVyIGFuIG9iamVjdCBhcHBlYXJzIGluIHRoYXQgbGlzdCwgdGhlIGhpZ2hlciBpdHMgcHJpb3JpdHkuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgLSBPcHRpb25hbCBjb25maWcgb2JqZWN0IHRoYXQgY29udGFpbnMgc2V0dGluZ3MuIFN1cHBvcnRlZCBzZXR0aW5ncyBhcmU6IHtkZWVwOiB0cnVlfSBmb3IgZGVlcCBtZXJnZSBhbmQge21lcmdlcjogbWVyZ2VyRnVuY30gd2hlcmUgbWVyZ2VyRnVuYyBpcyBhIGZ1bmN0aW9uXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0IHRha2VzIGEgcHJvcGVydHkgZnJvbSBib3RoIG9iamVjdHMuIElmIGFueXRoaW5nIGlzIHJldHVybmVkIGl0IG92ZXJyaWRlcyB0aGUgbm9ybWFsIG1lcmdlIGJlaGF2aW91ci5cbiAgICovXG4gIGZ1bmN0aW9uIG1lcmdlKG90aGVyLCBjb25maWcpIHtcbiAgICAvLyBDYWxsaW5nIC5tZXJnZSgpIHdpdGggbm8gYXJndW1lbnRzIGlzIGEgbm8tb3AuIERvbid0IGJvdGhlciBjbG9uaW5nLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAob3RoZXIgPT09IG51bGwgfHwgKHR5cGVvZiBvdGhlciAhPT0gXCJvYmplY3RcIikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbW11dGFibGUjbWVyZ2UgY2FuIG9ubHkgYmUgaW52b2tlZCB3aXRoIG9iamVjdHMgb3IgYXJyYXlzLCBub3QgXCIgKyBKU09OLnN0cmluZ2lmeShvdGhlcikpO1xuICAgIH1cblxuICAgIHZhciByZWNlaXZlZEFycmF5ID0gKEFycmF5LmlzQXJyYXkob3RoZXIpKSxcbiAgICAgICAgZGVlcCAgICAgICAgICA9IGNvbmZpZyAmJiBjb25maWcuZGVlcCxcbiAgICAgICAgbW9kZSAgICAgICAgICA9IGNvbmZpZyAmJiBjb25maWcubW9kZSB8fCAnbWVyZ2UnLFxuICAgICAgICBtZXJnZXIgICAgICAgID0gY29uZmlnICYmIGNvbmZpZy5tZXJnZXIsXG4gICAgICAgIHJlc3VsdDtcblxuICAgIC8vIFVzZSB0aGUgZ2l2ZW4ga2V5IHRvIGV4dHJhY3QgYSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBvYmplY3QsIHRoZW4gcGxhY2VcbiAgICAvLyB0aGF0IHZhbHVlIGluIHRoZSByZXN1bHQgb2JqZWN0IHVuZGVyIHRoZSBzYW1lIGtleS4gSWYgdGhhdCByZXN1bHRlZFxuICAgIC8vIGluIGEgY2hhbmdlIGZyb20gdGhpcyBvYmplY3QncyB2YWx1ZSBhdCB0aGF0IGtleSwgc2V0IGFueUNoYW5nZXMgPSB0cnVlLlxuICAgIGZ1bmN0aW9uIGFkZFRvUmVzdWx0KGN1cnJlbnRPYmosIG90aGVyT2JqLCBrZXkpIHtcbiAgICAgIHZhciBpbW11dGFibGVWYWx1ZSA9IEltbXV0YWJsZShvdGhlck9ialtrZXldKTtcbiAgICAgIHZhciBtZXJnZXJSZXN1bHQgPSBtZXJnZXIgJiYgbWVyZ2VyKGN1cnJlbnRPYmpba2V5XSwgaW1tdXRhYmxlVmFsdWUsIGNvbmZpZyk7XG4gICAgICB2YXIgY3VycmVudFZhbHVlID0gY3VycmVudE9ialtrZXldO1xuXG4gICAgICBpZiAoKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB8fFxuICAgICAgICAobWVyZ2VyUmVzdWx0ICE9PSB1bmRlZmluZWQpIHx8XG4gICAgICAgICghY3VycmVudE9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB8fFxuICAgICAgICAhaXNFcXVhbChpbW11dGFibGVWYWx1ZSwgY3VycmVudFZhbHVlKSkge1xuXG4gICAgICAgIHZhciBuZXdWYWx1ZTtcblxuICAgICAgICBpZiAobWVyZ2VyUmVzdWx0KSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBtZXJnZXJSZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVlcCAmJiBpc01lcmdhYmxlT2JqZWN0KGN1cnJlbnRWYWx1ZSkgJiYgaXNNZXJnYWJsZU9iamVjdChpbW11dGFibGVWYWx1ZSkpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IGN1cnJlbnRWYWx1ZS5tZXJnZShpbW11dGFibGVWYWx1ZSwgY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IGltbXV0YWJsZVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0VxdWFsKGN1cnJlbnRWYWx1ZSwgbmV3VmFsdWUpIHx8ICFjdXJyZW50T2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIE1ha2UgYSBzaGFsbG93IGNsb25lIG9mIHRoZSBjdXJyZW50IG9iamVjdC5cbiAgICAgICAgICAgIHJlc3VsdCA9IHF1aWNrQ29weShjdXJyZW50T2JqLCBjdXJyZW50T2JqLmluc3RhbnRpYXRlRW1wdHlPYmplY3QoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFyRHJvcHBlZEtleXMoY3VycmVudE9iaiwgb3RoZXJPYmopIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBjdXJyZW50T2JqKSB7XG4gICAgICAgIGlmICghb3RoZXJPYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gTWFrZSBhIHNoYWxsb3cgY2xvbmUgb2YgdGhlIGN1cnJlbnQgb2JqZWN0LlxuICAgICAgICAgICAgcmVzdWx0ID0gcXVpY2tDb3B5KGN1cnJlbnRPYmosIGN1cnJlbnRPYmouaW5zdGFudGlhdGVFbXB0eU9iamVjdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIHJlc3VsdFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleTtcblxuICAgIC8vIEFjaGlldmUgcHJpb3JpdGl6YXRpb24gYnkgb3ZlcnJpZGluZyBwcmV2aW91cyB2YWx1ZXMgdGhhdCBnZXQgaW4gdGhlIHdheS5cbiAgICBpZiAoIXJlY2VpdmVkQXJyYXkpIHtcbiAgICAgIC8vIFRoZSBtb3N0IGNvbW1vbiB1c2UgY2FzZToganVzdCBtZXJnZSBvbmUgb2JqZWN0IGludG8gdGhlIGV4aXN0aW5nIG9uZS5cbiAgICAgIGZvciAoa2V5IGluIG90aGVyKSB7XG4gICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG90aGVyLCBrZXkpKSB7XG4gICAgICAgICAgYWRkVG9SZXN1bHQodGhpcywgb3RoZXIsIGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtb2RlID09PSAncmVwbGFjZScpIHtcbiAgICAgICAgY2xlYXJEcm9wcGVkS2V5cyh0aGlzLCBvdGhlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIGFsc28gYWNjZXB0IGFuIEFycmF5XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIG90aGVyRnJvbUFycmF5ID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgICAgIGZvciAoa2V5IGluIG90aGVyRnJvbUFycmF5KSB7XG4gICAgICAgICAgaWYgKG90aGVyRnJvbUFycmF5Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGFkZFRvUmVzdWx0KHJlc3VsdCAhPT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdGhpcywgb3RoZXJGcm9tQXJyYXksIGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1ha2VJbW11dGFibGVPYmplY3QocmVzdWx0LFxuICAgICAgICB7aW5zdGFudGlhdGVFbXB0eU9iamVjdDogdGhpcy5pbnN0YW50aWF0ZUVtcHR5T2JqZWN0fSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb2JqZWN0UmVwbGFjZSh2YWx1ZSwgY29uZmlnKSB7XG4gICAgdmFyIGRlZXAgICAgICAgICAgPSBjb25maWcgJiYgY29uZmlnLmRlZXA7XG5cbiAgICAvLyBDYWxsaW5nIC5yZXBsYWNlKCkgd2l0aCBubyBhcmd1bWVudHMgaXMgYSBuby1vcC4gRG9uJ3QgYm90aGVyIGNsb25pbmcuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbW11dGFibGUjcmVwbGFjZSBjYW4gb25seSBiZSBpbnZva2VkIHdpdGggb2JqZWN0cyBvciBhcnJheXMsIG5vdCBcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubWVyZ2UodmFsdWUsIHtkZWVwOiBkZWVwLCBtb2RlOiAncmVwbGFjZSd9KTtcbiAgfVxuXG4gIHZhciBpbW11dGFibGVFbXB0eU9iamVjdCA9IEltbXV0YWJsZSh7fSk7XG5cbiAgZnVuY3Rpb24gb2JqZWN0U2V0SW4ocGF0aCwgdmFsdWUsIGNvbmZpZykge1xuICAgIHZhciBoZWFkID0gcGF0aFswXTtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBvYmplY3RTZXQuY2FsbCh0aGlzLCBoZWFkLCB2YWx1ZSwgY29uZmlnKTtcbiAgICB9XG5cbiAgICB2YXIgdGFpbCA9IHBhdGguc2xpY2UoMSk7XG4gICAgdmFyIG5ld1ZhbHVlO1xuICAgIHZhciB0aGlzSGVhZCA9IHRoaXNbaGVhZF07XG5cbiAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShoZWFkKSAmJiB0eXBlb2YodGhpc0hlYWQpID09PSBcIm9iamVjdFwiICYmIHRoaXNIZWFkICE9PSBudWxsICYmIHR5cGVvZih0aGlzSGVhZC5zZXRJbikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgLy8gTWlnaHQgKHZhbGlkbHkpIGJlIG9iamVjdCBvciBhcnJheVxuICAgICAgbmV3VmFsdWUgPSB0aGlzSGVhZC5zZXRJbih0YWlsLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqZWN0U2V0SW4uY2FsbChpbW11dGFibGVFbXB0eU9iamVjdCwgdGFpbCwgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KGhlYWQpICYmIHRoaXNIZWFkID09PSBuZXdWYWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIG11dGFibGUgPSBxdWlja0NvcHkodGhpcywgdGhpcy5pbnN0YW50aWF0ZUVtcHR5T2JqZWN0KCkpO1xuICAgIG11dGFibGVbaGVhZF0gPSBuZXdWYWx1ZTtcbiAgICByZXR1cm4gbWFrZUltbXV0YWJsZU9iamVjdChtdXRhYmxlLCB0aGlzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9iamVjdFNldChwcm9wZXJ0eSwgdmFsdWUsIGNvbmZpZykge1xuICAgIHZhciBkZWVwICAgICAgICAgID0gY29uZmlnICYmIGNvbmZpZy5kZWVwO1xuXG4gICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICBpZiAoZGVlcCAmJiB0aGlzW3Byb3BlcnR5XSAhPT0gdmFsdWUgJiYgaXNNZXJnYWJsZU9iamVjdCh2YWx1ZSkgJiYgaXNNZXJnYWJsZU9iamVjdCh0aGlzW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzW3Byb3BlcnR5XS5tZXJnZSh2YWx1ZSwge2RlZXA6IHRydWUsIG1vZGU6ICdyZXBsYWNlJ30pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRXF1YWwodGhpc1twcm9wZXJ0eV0sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbXV0YWJsZSA9IHF1aWNrQ29weSh0aGlzLCB0aGlzLmluc3RhbnRpYXRlRW1wdHlPYmplY3QoKSk7XG4gICAgbXV0YWJsZVtwcm9wZXJ0eV0gPSBJbW11dGFibGUodmFsdWUpO1xuICAgIHJldHVybiBtYWtlSW1tdXRhYmxlT2JqZWN0KG11dGFibGUsIHRoaXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlKHByb3BlcnR5LCB1cGRhdGVyKSB7XG4gICAgdmFyIHJlc3RBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgaW5pdGlhbFZhbCA9IHRoaXNbcHJvcGVydHldO1xuICAgIHJldHVybiB0aGlzLnNldChwcm9wZXJ0eSwgdXBkYXRlci5hcHBseShpbml0aWFsVmFsLCBbaW5pdGlhbFZhbF0uY29uY2F0KHJlc3RBcmdzKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW5QYXRoKG9iaiwgcGF0aCkge1xuICAgIC8qanNoaW50IGVxbnVsbDp0cnVlICovXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoLmxlbmd0aDsgb2JqICE9IG51bGwgJiYgaSA8IGw7IGkrKykge1xuICAgICAgb2JqID0gb2JqW3BhdGhbaV1dO1xuICAgIH1cblxuICAgIHJldHVybiAoaSAmJiBpID09IGwpID8gb2JqIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSW4ocGF0aCwgdXBkYXRlcikge1xuICAgIHZhciByZXN0QXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGluaXRpYWxWYWwgPSBnZXRJblBhdGgodGhpcywgcGF0aCk7XG5cbiAgICByZXR1cm4gdGhpcy5zZXRJbihwYXRoLCB1cGRhdGVyLmFwcGx5KGluaXRpYWxWYWwsIFtpbml0aWFsVmFsXS5jb25jYXQocmVzdEFyZ3MpKSk7XG4gIH1cblxuICBmdW5jdGlvbiBhc011dGFibGVPYmplY3Qob3B0cykge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmluc3RhbnRpYXRlRW1wdHlPYmplY3QoKSwga2V5O1xuXG4gICAgaWYob3B0cyAmJiBvcHRzLmRlZXApIHtcbiAgICAgIGZvciAoa2V5IGluIHRoaXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gYXNEZWVwTXV0YWJsZSh0aGlzW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoa2V5IGluIHRoaXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdGhpc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIENyZWF0ZXMgcGxhaW4gb2JqZWN0IHRvIGJlIHVzZWQgZm9yIGNsb25pbmdcbiAgZnVuY3Rpb24gaW5zdGFudGlhdGVQbGFpbk9iamVjdCgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvLyBGaW5hbGl6ZXMgYW4gb2JqZWN0IHdpdGggaW1tdXRhYmxlIG1ldGhvZHMsIGZyZWV6ZXMgaXQsIGFuZCByZXR1cm5zIGl0LlxuICBmdW5jdGlvbiBtYWtlSW1tdXRhYmxlT2JqZWN0KG9iaiwgb3B0aW9ucykge1xuICAgIHZhciBpbnN0YW50aWF0ZUVtcHR5T2JqZWN0ID1cbiAgICAgIChvcHRpb25zICYmIG9wdGlvbnMuaW5zdGFudGlhdGVFbXB0eU9iamVjdCkgP1xuICAgICAgICBvcHRpb25zLmluc3RhbnRpYXRlRW1wdHlPYmplY3QgOiBpbnN0YW50aWF0ZVBsYWluT2JqZWN0O1xuXG4gICAgYWRkUHJvcGVydHlUbyhvYmosIFwibWVyZ2VcIiwgbWVyZ2UpO1xuICAgIGFkZFByb3BlcnR5VG8ob2JqLCBcInJlcGxhY2VcIiwgb2JqZWN0UmVwbGFjZSk7XG4gICAgYWRkUHJvcGVydHlUbyhvYmosIFwid2l0aG91dFwiLCB3aXRob3V0KTtcbiAgICBhZGRQcm9wZXJ0eVRvKG9iaiwgXCJhc011dGFibGVcIiwgYXNNdXRhYmxlT2JqZWN0KTtcbiAgICBhZGRQcm9wZXJ0eVRvKG9iaiwgXCJpbnN0YW50aWF0ZUVtcHR5T2JqZWN0XCIsIGluc3RhbnRpYXRlRW1wdHlPYmplY3QpO1xuICAgIGFkZFByb3BlcnR5VG8ob2JqLCBcInNldFwiLCBvYmplY3RTZXQpO1xuICAgIGFkZFByb3BlcnR5VG8ob2JqLCBcInNldEluXCIsIG9iamVjdFNldEluKTtcbiAgICBhZGRQcm9wZXJ0eVRvKG9iaiwgXCJ1cGRhdGVcIiwgdXBkYXRlKTtcbiAgICBhZGRQcm9wZXJ0eVRvKG9iaiwgXCJ1cGRhdGVJblwiLCB1cGRhdGVJbik7XG5cbiAgICByZXR1cm4gbWFrZUltbXV0YWJsZShvYmosIG11dGF0aW5nT2JqZWN0TWV0aG9kcyk7XG4gIH1cblxuICAvLyBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIGEgdmFsaWQgcmVhY3QgZWxlbWVudFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi92MTUuMC4xL3NyYy9pc29tb3JwaGljL2NsYXNzaWMvZWxlbWVudC9SZWFjdEVsZW1lbnQuanMjTDMyNlxuICBmdW5jdGlvbiBpc1JlYWN0RWxlbWVudChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgb2JqICE9PSBudWxsICYmXG4gICAgICAgICAgIChvYmouJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRV9GQUxMQkFDSyB8fCBvYmouJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSk7XG4gIH1cblxuICBmdW5jdGlvbiBJbW11dGFibGUob2JqLCBvcHRpb25zLCBzdGFja1JlbWFpbmluZykge1xuICAgIGlmIChpc0ltbXV0YWJsZShvYmopIHx8IGlzUmVhY3RFbGVtZW50KG9iaikpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHJldHVybiBtYWtlSW1tdXRhYmxlQXJyYXkob2JqLnNsaWNlKCkpO1xuICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIG1ha2VJbW11dGFibGVEYXRlKG5ldyBEYXRlKG9iai5nZXRUaW1lKCkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRG9uJ3QgZnJlZXplIHRoZSBvYmplY3Qgd2Ugd2VyZSBnaXZlbjsgbWFrZSBhIGNsb25lIGFuZCB1c2UgdGhhdC5cbiAgICAgIHZhciBwcm90b3R5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMucHJvdG90eXBlO1xuICAgICAgdmFyIGluc3RhbnRpYXRlRW1wdHlPYmplY3QgPVxuICAgICAgICAoIXByb3RvdHlwZSB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGUpID9cbiAgICAgICAgICBpbnN0YW50aWF0ZVBsYWluT2JqZWN0IDogKGZ1bmN0aW9uKCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpOyB9KTtcbiAgICAgIHZhciBjbG9uZSA9IGluc3RhbnRpYXRlRW1wdHlPYmplY3QoKTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAvKmpzaGludCBlcW51bGw6dHJ1ZSAqL1xuICAgICAgICBpZiAoc3RhY2tSZW1haW5pbmcgPT0gbnVsbCkge1xuICAgICAgICAgIHN0YWNrUmVtYWluaW5nID0gNjQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWNrUmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW1tdXRhYmxlRXJyb3IoXCJBdHRlbXB0IHRvIGNvbnN0cnVjdCBJbW11dGFibGUgZnJvbSBhIGRlZXBseSBuZXN0ZWQgb2JqZWN0IHdhcyBkZXRlY3RlZC5cIiArXG4gICAgICAgICAgICBcIiBIYXZlIHlvdSB0cmllZCB0byB3cmFwIGFuIG9iamVjdCB3aXRoIGNpcmN1bGFyIHJlZmVyZW5jZXMgKGUuZy4gUmVhY3QgZWxlbWVudCk/XCIgK1xuICAgICAgICAgICAgXCIgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ydGZlbGRtYW4vc2VhbWxlc3MtaW1tdXRhYmxlL3dpa2kvRGVlcGx5LW5lc3RlZC1vYmplY3Qtd2FzLWRldGVjdGVkIGZvciBkZXRhaWxzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdGFja1JlbWFpbmluZyAtPSAxO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSkge1xuICAgICAgICAgIGNsb25lW2tleV0gPSBJbW11dGFibGUob2JqW2tleV0sIHVuZGVmaW5lZCwgc3RhY2tSZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYWtlSW1tdXRhYmxlT2JqZWN0KGNsb25lLFxuICAgICAgICB7aW5zdGFudGlhdGVFbXB0eU9iamVjdDogaW5zdGFudGlhdGVFbXB0eU9iamVjdH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdyYXBwZXIgdG8gYWxsb3cgdGhlIHVzZSBvZiBvYmplY3QgbWV0aG9kcyBhcyBzdGF0aWMgbWV0aG9kcyBvZiBJbW11dGFibGUuXG4gIGZ1bmN0aW9uIHRvU3RhdGljKGZuKSB7XG4gICAgZnVuY3Rpb24gc3RhdGljV3JhcHBlcigpIHtcbiAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgdmFyIHNlbGYgPSBhcmdzLnNoaWZ0KCk7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRpY1dyYXBwZXI7XG4gIH1cblxuICAvLyBXcmFwcGVyIHRvIGFsbG93IHRoZSB1c2Ugb2Ygb2JqZWN0IG1ldGhvZHMgYXMgc3RhdGljIG1ldGhvZHMgb2YgSW1tdXRhYmxlLlxuICAvLyB3aXRoIHRoZSBhZGRpdGlvbmFsIGNvbmRpdGlvbiBvZiBjaG9vc2luZyB3aGljaCBmdW5jdGlvbiB0byBjYWxsIGRlcGVuZGluZ1xuICAvLyBpZiBhcmd1bWVudCBpcyBhbiBhcnJheSBvciBhbiBvYmplY3QuXG4gIGZ1bmN0aW9uIHRvU3RhdGljT2JqZWN0T3JBcnJheShmbk9iamVjdCwgZm5BcnJheSkge1xuICAgIGZ1bmN0aW9uIHN0YXRpY1dyYXBwZXIoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIHZhciBzZWxmID0gYXJncy5zaGlmdCgpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZikpIHtcbiAgICAgICAgICByZXR1cm4gZm5BcnJheS5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZuT2JqZWN0LmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdGF0aWNXcmFwcGVyO1xuICB9XG5cbiAgLy8gRXhwb3J0IHRoZSBsaWJyYXJ5XG4gIEltbXV0YWJsZS5mcm9tICAgICAgICAgICA9IEltbXV0YWJsZTtcbiAgSW1tdXRhYmxlLmlzSW1tdXRhYmxlICAgID0gaXNJbW11dGFibGU7XG4gIEltbXV0YWJsZS5JbW11dGFibGVFcnJvciA9IEltbXV0YWJsZUVycm9yO1xuICBJbW11dGFibGUubWVyZ2UgICAgICAgICAgPSB0b1N0YXRpYyhtZXJnZSk7XG4gIEltbXV0YWJsZS5yZXBsYWNlICAgICAgICA9IHRvU3RhdGljKG9iamVjdFJlcGxhY2UpO1xuICBJbW11dGFibGUud2l0aG91dCAgICAgICAgPSB0b1N0YXRpYyh3aXRob3V0KTtcbiAgSW1tdXRhYmxlLmFzTXV0YWJsZSAgICAgID0gdG9TdGF0aWNPYmplY3RPckFycmF5KGFzTXV0YWJsZU9iamVjdCwgYXNNdXRhYmxlQXJyYXkpO1xuICBJbW11dGFibGUuc2V0ICAgICAgICAgICAgPSB0b1N0YXRpY09iamVjdE9yQXJyYXkob2JqZWN0U2V0LCBhcnJheVNldCk7XG4gIEltbXV0YWJsZS5zZXRJbiAgICAgICAgICA9IHRvU3RhdGljT2JqZWN0T3JBcnJheShvYmplY3RTZXRJbiwgYXJyYXlTZXRJbik7XG4gIEltbXV0YWJsZS51cGRhdGUgICAgICAgICA9IHRvU3RhdGljKHVwZGF0ZSk7XG4gIEltbXV0YWJsZS51cGRhdGVJbiAgICAgICA9IHRvU3RhdGljKHVwZGF0ZUluKTtcbiAgSW1tdXRhYmxlLmZsYXRNYXAgICAgICAgID0gdG9TdGF0aWMoZmxhdE1hcCk7XG4gIEltbXV0YWJsZS5hc09iamVjdCAgICAgICA9IHRvU3RhdGljKGFzT2JqZWN0KTtcblxuICBPYmplY3QuZnJlZXplKEltbXV0YWJsZSk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBJbW11dGFibGU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBleHBvcnRzLkltbXV0YWJsZSA9IEltbXV0YWJsZTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSB7XG4gICAgd2luZG93LkltbXV0YWJsZSA9IEltbXV0YWJsZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiKSB7XG4gICAgZ2xvYmFsLkltbXV0YWJsZSA9IEltbXV0YWJsZTtcbiAgfVxufSkoKTtcbiIsImltcG9ydCBJbW11dGFibGUgZnJvbSAnc2VhbWxlc3MtaW1tdXRhYmxlJztcbmltcG9ydCBWYWxpZGF0aW9uIGZyb20gJy4vVmFsaWRhdGlvbic7XG5pbXBvcnQgeyBwaXBlIH0gZnJvbSAncmFtZGEnO1xuXG5leHBvcnQgY29uc3QgY2hlY2tUeXBlID0gKHR5cGVDaGVja2VyLCBjdXN0b21DaGVjaykgPT5cbiAgcGlwZShcbiAgICB0eXBlQ2hlY2tlcixcbiAgICBWYWxpZGF0aW9uLnRocm93RmFpbHVyZSxcbiAgICBWYWxpZGF0aW9uLndpdGhEZWZhdWx0KG51bGwpLFxuICAgIGN1c3RvbUNoZWNrXG4gICk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbW11dGFibGVDb25zdHJ1Y3Rvcih0eXBlQ2hlY2tlciwgY3VzdG9tQ2hlY2sgPSB2ID0+IHYpIHtcbiAgcmV0dXJuIHtcbiAgICBvZjogcGlwZShcbiAgICAgIGN1c3RvbUNoZWNrLFxuICAgICAgSW1tdXRhYmxlLFxuICAgICksXG4gIH07XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXN0ZWQtdGVybmFyeSAqL1xuaW1wb3J0IHsgaW1tdXRhYmxlQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGRhdGUsIG9iamVjdCB9IGZyb20gJy4vdHlwZS1jaGVja2Vycyc7XG5pbXBvcnQgTWF5YmUgZnJvbSAnLi9NYXliZSc7XG5pbXBvcnQgeyBwaXBlIH0gZnJvbSAncmFtZGEnO1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gICAgIEFMTCBHRVRURVJTIEFORCBTRVRURVJTIChQVUJMSUMgT1IgTk9UKSBNVVNUIEJFIElOIFRISVMgRklMRVxuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgY29uc3QgdHlwZUNoZWNrID0gb2JqZWN0KHtcbiAgc3RhcnQ6IGRhdGUsXG4gIGVuZDogZGF0ZSxcbn0pO1xuXG4vLyBDT05TVFJVQ1RPUlxuY29uc3QgVGltZUludGVydmFsID0gaW1tdXRhYmxlQ29uc3RydWN0b3IodHlwZUNoZWNrKTtcblxuLy8gUFJJVkFURSBHRVRURVJTXG5leHBvcnQgY29uc3QgZ2V0U3RhcnQgPSBtb2RlbCA9PiAoXG4gICFtb2RlbCA/IG51bGxcbiAgICA6IG1vZGVsLnN0YXJ0IGluc3RhbmNlb2YgRGF0ZSA/IG1vZGVsLnN0YXJ0XG4gICAgOiBudWxsXG4pO1xuXG5leHBvcnQgY29uc3QgZ2V0RW5kID0gbW9kZWwgPT4gKFxuICAhbW9kZWwgPyBudWxsXG4gICAgOiBtb2RlbC5lbmQgaW5zdGFuY2VvZiBEYXRlID8gbW9kZWwuZW5kXG4gICAgOiBudWxsXG4pO1xuLy8gR0VUVEVSU1xuLy8gUmV0dXJucyB0aGUgdGltZSBkaWZmZXJlbmNlIGJldHdlZXQgc3RhcnQgYW5kIGVuZCBpbiBtaWxsaXNlY29uZHNcbmV4cG9ydCBjb25zdCBnZXRWYWx1ZSA9IChtb2RlbCkgPT4ge1xuICBjb25zdCBtYXliZVN0YXJ0ID0gcGlwZShcbiAgICBNYXliZS5vZixcbiAgICBNYXliZS5tYXAoZ2V0U3RhcnQpLFxuICAgIE1heWJlLm1hcCh2ID0+IHYudmFsdWVPZigpKVxuICApKG1vZGVsKTtcblxuICBjb25zdCBtYXliZUVuZCA9IHBpcGUoXG4gICAgTWF5YmUub2YsXG4gICAgTWF5YmUubWFwKGdldEVuZCksXG4gICAgTWF5YmUubWFwKHYgPT4gdi52YWx1ZU9mKCkpXG4gICkobW9kZWwpO1xuICByZXR1cm4gcGlwZShcbiAgICBNYXliZS5tYXAyKChzLCBlKSA9PiBlIC0gcyksXG4gICAgTWF5YmUud2l0aERlZmF1bHQobnVsbClcbiAgKShtYXliZVN0YXJ0LCBtYXliZUVuZCk7XG59O1xuXG5PYmplY3QuYXNzaWduKFRpbWVJbnRlcnZhbCwge1xuICB0eXBlQ2hlY2ssXG4gIGdldFN0YXJ0LFxuICBnZXRFbmQsXG4gIGdldFZhbHVlLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVJbnRlcnZhbDtcbiIsImltcG9ydCB7IGN1cnJ5IH0gZnJvbSAncmFtZGEnO1xuaW1wb3J0IFRpbWVJbnRlcnZhbCBmcm9tICcuLi9UaW1lSW50ZXJ2YWwnO1xuaW1wb3J0IHtcbiAgaXNSZWNvcmRpbmcsXG4gIGdldFN0YXJ0VGltZSxcbiAgZ2V0SW50ZXJ2YWxzLFxuICBzZXRTdGFydFRpbWUsXG4gIHNldEludGVydmFscyxcbn0gZnJvbSAnLi9pbmRleCc7XG5cbi8qKlxuICogVG9nZ2xlcyBhIHJlY29yZGluZyB0byBvbiBvciBvZmZcbiAqIEBwYXJhbXMge1Byb2plY3R9IG1vZGVsXG4gKiBAcGFyYW1zIHtEYXRlfSB0aW1lXG4gKiBAcGFyYW1zIHtCb29sZWFufSBvblxuICovXG5leHBvcnQgZGVmYXVsdCBjdXJyeSgobW9kZWwpID0+IHtcbiAgaWYgKCFpc1JlY29yZGluZyhtb2RlbCkpIHtcbiAgICByZXR1cm4gc2V0U3RhcnRUaW1lKG1vZGVsLCBuZXcgRGF0ZSgpKTtcbiAgfVxuXG4gIGNvbnN0IG5ld0ludGVydmFsID0gVGltZUludGVydmFsLm9mKHtcbiAgICBzdGFydDogZ2V0U3RhcnRUaW1lKG1vZGVsKSxcbiAgICBlbmQ6IG5ldyBEYXRlKCksXG4gIH0pO1xuXG4gIGNvbnN0IHdpdGhTdGFydFRpbWUgPSBzZXRTdGFydFRpbWUobW9kZWwsIG51bGwpO1xuICByZXR1cm4gc2V0SW50ZXJ2YWxzKHdpdGhTdGFydFRpbWUsIFtuZXdJbnRlcnZhbCwgLi4uZ2V0SW50ZXJ2YWxzKG1vZGVsKV0pO1xufSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xuXG5cbi8qKlxuICogQWRkcyB0d28gdmFsdWVzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhXG4gKiBAcGFyYW0ge051bWJlcn0gYlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQHNlZSBSLnN1YnRyYWN0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5hZGQoMiwgMyk7ICAgICAgIC8vPT4gIDVcbiAqICAgICAgUi5hZGQoNykoMTApOyAgICAgIC8vPT4gMTdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gIHJldHVybiBOdW1iZXIoYSkgKyBOdW1iZXIoYik7XG59KTtcbiIsImltcG9ydCB7IGFkZCwgcGlwZSB9IGZyb20gJ3JhbWRhJztcbmltcG9ydCB7IGdldEludGVydmFscywgZ2V0U3RhcnRUaW1lIH0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgVGltZUludGVydmFsIGZyb20gJy4uL1RpbWVJbnRlcnZhbCc7XG5cbi8qKlxuICogQG1ldGhvZCBjYWxjdWxhdGVSdW5uaW5nVGltZVxuICogQHBhcmFtICB7RGF0ZX0gc3RhcnRUaW1lXG4gKiBAcGFyYW0gIHtBcnJheTxUaW1lSW50ZXJ2YWw+fSBpbnRlcnZhbHMgLSBUaW1lIGludGVydmFscyBvZiB0eXBlIHsgc3RhcnQ6IE9iamVjdCwgZW5kOiBPYmplY3R9XG4gKiBAcmV0dXJuIHtJbnRlZ2VyfVxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVSdW5uaW5nVGltZShzdGFydFRpbWUsIGludGVydmFscykge1xuICBjb25zdCBpbnRlcnZhbHNTdW0gPSBpbnRlcnZhbHNcbiAgICAubWFwKFRpbWVJbnRlcnZhbC5nZXRWYWx1ZSlcbiAgICAucmVkdWNlKGFkZCwgMCk7XG5cbiAgY29uc3Qgc3VtU2luY2VTdGFydFRpbWUgPSAhc3RhcnRUaW1lXG4gICAgPyAwXG4gICAgOiBwaXBlKFxuICAgICAgICBkID0+ICh7IHN0YXJ0OiBkLCBlbmQ6IG5ldyBEYXRlKCkgfSksXG4gICAgICAgIFRpbWVJbnRlcnZhbC5vZixcbiAgICAgICAgVGltZUludGVydmFsLmdldFZhbHVlXG4gICAgICApKHN0YXJ0VGltZSk7XG5cbiAgcmV0dXJuIGludGVydmFsc1N1bSArIHN1bVNpbmNlU3RhcnRUaW1lO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gIHtSZWNvcmRpbmd9IHJlY29yZGluZ1xuICogQHJldHVybiB7SW50ZWdlcn0gLSBUaW1lIGluIG1pbGxpc2Vjb25kc1xuICovXG5leHBvcnQgZGVmYXVsdCAobW9kZWwpID0+IHtcbiAgY29uc3Qgc3RhcnRUaW1lID0gZ2V0U3RhcnRUaW1lKG1vZGVsKTtcbiAgY29uc3QgaW50ZXJ2YWxzID0gZ2V0SW50ZXJ2YWxzKG1vZGVsKTtcblxuICByZXR1cm4gY2FsY3VsYXRlUnVubmluZ1RpbWUoc3RhcnRUaW1lLCBpbnRlcnZhbHMpO1xufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAsIG5vLW5lc3RlZC10ZXJuYXJ5ICovXG5pbXBvcnQgeyBpbW11dGFibGVDb25zdHJ1Y3RvciB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCBUaW1lSW50ZXJ2YWwgZnJvbSAnLi4vVGltZUludGVydmFsJztcbmltcG9ydCB7IG51bGxhYmxlLCBhcnJheSwgZGF0ZSwgb2JqZWN0IH0gZnJvbSAnLi4vdHlwZS1jaGVja2Vycyc7XG5pbXBvcnQgeyBpc05pbCwgcHJvcE9yLCBwaXBlLCBjdXJyeSB9IGZyb20gJ3JhbWRhJztcbmltcG9ydCBfdG9nZ2xlUmVjb3JkaW5nIGZyb20gJy4vdG9nZ2xlUmVjb3JkaW5nJztcbmltcG9ydCBfdG90YWxUaW1lIGZyb20gJy4vdG90YWxUaW1lJztcbmltcG9ydCBJbW11dGFibGUgZnJvbSAnc2VhbWxlc3MtaW1tdXRhYmxlJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gICAgIEFMTCBHRVRURVJTIEFORCBTRVRURVJTIChQVUJMSUMgT1IgTk9UKSBNVVNUIEJFIElOIFRISVMgRklMRVxuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgY29uc3QgdHlwZUNoZWNrID0gb2JqZWN0KHtcbiAgc3RhcnRUaW1lOiBudWxsYWJsZShkYXRlKSxcbiAgaW50ZXJ2YWxzOiBhcnJheShUaW1lSW50ZXJ2YWwudHlwZUNoZWNrKSxcbn0pO1xuXG4vLyBDT05TVFJVQ1RPUlxuY29uc3QgUmVjb3JkaW5nID0gaW1tdXRhYmxlQ29uc3RydWN0b3IoXG4gIHR5cGVDaGVjayxcbiAgciA9PiAoe1xuICAgIHN0YXJ0VGltZTogciAmJiByLnN0YXJ0VGltZSA/IHIuc3RhcnRUaW1lIDogbnVsbCxcbiAgICBpbnRlcnZhbHM6IHIgJiYgci5pbnRlcnZhbHMgPyByLmludGVydmFscyA6IFtdLFxuICB9KVxuKTtcblxuLy8gUFJJVkFURSBHRVRURVJTXG5leHBvcnQgY29uc3QgZ2V0U3RhcnRUaW1lID0gcHJvcE9yKG51bGwsICdzdGFydFRpbWUnKTtcbmV4cG9ydCBjb25zdCBnZXRJbnRlcnZhbHMgPSBtb2RlbCA9PiAoXG4gIGlzTmlsKG1vZGVsKSA/IFtdXG4gIDogaXNOaWwobW9kZWwuaW50ZXJ2YWxzKSA/IFtdXG4gIDogbW9kZWwuaW50ZXJ2YWxzXG4pO1xuXG4vLyBQUklWQVRFIFNFVFRFUlNcbmV4cG9ydCBjb25zdCBzZXRTdGFydFRpbWUgPSBjdXJyeSgobW9kZWwsIHYpID0+IHtcbiAgY29uc3QgaW11dGFibGVNb2RlbCA9IEltbXV0YWJsZShtb2RlbCk7XG4gIHJldHVybiAhIWltdXRhYmxlTW9kZWwgJiYgISFpbXV0YWJsZU1vZGVsLm1lcmdlXG4gICAgPyBpbXV0YWJsZU1vZGVsLm1lcmdlKHsgc3RhcnRUaW1lOiB2IH0sIHsgZGVlcDogdHJ1ZSB9KVxuICAgIDogbnVsbDtcbn0pO1xuXG5leHBvcnQgY29uc3Qgc2V0SW50ZXJ2YWxzID0gY3VycnkoKG1vZGVsLCB2KSA9PiB7XG4gIGNvbnN0IGltdXRhYmxlTW9kZWwgPSBJbW11dGFibGUobW9kZWwpO1xuICByZXR1cm4gISFpbXV0YWJsZU1vZGVsICYmICEhaW11dGFibGVNb2RlbC5tZXJnZVxuICAgID8gaW11dGFibGVNb2RlbC5tZXJnZSh7IGludGVydmFsczogdiB9LCB7IGRlZXA6IHRydWUgfSlcbiAgICA6IG51bGw7XG59KTtcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gUFVCTElDIElOVEVSRkFDRVxuLy8gQk9PTEVBTiBcImdldHR0ZXJzXCJcbmV4cG9ydCBjb25zdCBpc1JlY29yZGluZyA9IHBpcGUoZ2V0U3RhcnRUaW1lLCB2ID0+ICEhdik7XG5leHBvcnQgY29uc3QgdG9nZ2xlUmVjb3JkaW5nID0gX3RvZ2dsZVJlY29yZGluZztcbmV4cG9ydCBjb25zdCB0b3RhbFRpbWUgPSBfdG90YWxUaW1lO1xuXG5PYmplY3QuYXNzaWduKFJlY29yZGluZywge1xuICB0eXBlQ2hlY2ssXG4gIGdldFN0YXJ0VGltZSxcbiAgZ2V0SW50ZXJ2YWxzLFxuICBzZXRTdGFydFRpbWUsXG4gIHNldEludGVydmFscyxcbiAgaXNSZWNvcmRpbmcsXG4gIHRvZ2dsZVJlY29yZGluZyxcbiAgdG90YWxUaW1lLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFJlY29yZGluZztcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi9cbmltcG9ydCB7IHByb3BPciwgY3VycnksIGlzTmlsIH0gZnJvbSAncmFtZGEnO1xuaW1wb3J0IHsgb2JqZWN0LCBzdHJpbmcsIG51bGxhYmxlIH0gZnJvbSAnLi90eXBlLWNoZWNrZXJzJztcbmltcG9ydCB7IGltbXV0YWJsZUNvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgUmVjb3JkaW5nIGZyb20gJy4vUmVjb3JkaW5nJztcbmltcG9ydCBJbW11dGFibGUgZnJvbSAnc2VhbWxlc3MtaW1tdXRhYmxlJztcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gICAgIEFMTCBHRVRURVJTIEFORCBTRVRURVJTIChQVUJMSUMgT1IgTk9UKSBNVVNUIEJFIElOIFRISVMgRklMRVxuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5leHBvcnQgY29uc3QgdHlwZUNoZWNrID0gb2JqZWN0KHtcbiAgbmFtZTogc3RyaW5nLFxuICB1cmw6IHN0cmluZyxcbiAgcmVjb3JkaW5nOiBudWxsYWJsZShSZWNvcmRpbmcudHlwZUNoZWNrKSxcbn0pO1xuXG5jb25zdCBEZWxpdmVyYWJsZSA9IGltbXV0YWJsZUNvbnN0cnVjdG9yKHR5cGVDaGVjayk7XG5cbmV4cG9ydCBjb25zdCBnZXRSZWNvcmRpbmcgPSBkZWxpdmVyYWJsZSA9PiAoXG4gIGRlbGl2ZXJhYmxlXG4gICAgPyBkZWxpdmVyYWJsZS5yZWNvcmRpbmcgfHwgUmVjb3JkaW5nLm9mKHt9KVxuICAgIDogbnVsbFxuKTtcblxuZXhwb3J0IGNvbnN0IGdldE5hbWUgPSBwcm9wT3IobnVsbCwgJ25hbWUnKTtcbmV4cG9ydCBjb25zdCBnZXRVcmwgPSBwcm9wT3IobnVsbCwgJ3VybCcpO1xuXG4vLyBEZWxpdmVyYWJsZSAtPiBSZWNvcmRpbmcgLT4gRGVsaXZlcmFibGVcbmV4cG9ydCBjb25zdCBzZXRSZWNvcmRpbmcgPSBjdXJyeSgobW9kZWwsIG5ld1JlY29yZGluZykgPT4gKFxuICBpc05pbChtb2RlbClcbiAgICA/IG51bGxcbiAgICA6IEltbXV0YWJsZShtb2RlbCkubWVyZ2UoeyByZWNvcmRpbmc6IG5ld1JlY29yZGluZyB9LCB7IGRlZXA6IHRydWUgfSlcbikpO1xuXG5leHBvcnQgY29uc3QgaXNTYW1lID0gY3VycnkoKGQxLCBkMikgPT4gZ2V0TmFtZShkMSkgPT09IGdldE5hbWUoZDIpKTtcblxuT2JqZWN0LmFzc2lnbihEZWxpdmVyYWJsZSwge1xuICB0eXBlQ2hlY2ssXG4gIGdldFJlY29yZGluZyxcbiAgZ2V0TmFtZSxcbiAgZ2V0VXJsLFxuICBzZXRSZWNvcmRpbmcsXG4gIGlzU2FtZSxcbn0pO1xuZXhwb3J0IGRlZmF1bHQgRGVsaXZlcmFibGU7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXG5pbXBvcnQgeyBzdHJpbmcsIG9iamVjdCwgYXJyYXksIG51bGxhYmxlIH0gZnJvbSAnLi90eXBlLWNoZWNrZXJzJztcbmltcG9ydCBEZWxpdmVyYWJsZSBmcm9tICcuL0RlbGl2ZXJhYmxlJztcbmltcG9ydCB7IGltbXV0YWJsZUNvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBwcm9wT3IsIGN1cnJ5LCBwcm9wRXEgfSBmcm9tICdyYW1kYSc7XG5pbXBvcnQgSW1tdXRhYmxlIGZyb20gJ3NlYW1sZXNzLWltbXV0YWJsZSc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2ZsLWFzc2VydCc7XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyAgICAgQUxMIEdFVFRFUlMgQU5EIFNFVFRFUlMgKFBVQkxJQyBPUiBOT1QpIE1VU1QgQkUgSU4gVEhJUyBGSUxFXG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBjb25zdCB0eXBlQ2hlY2sgPSBvYmplY3Qoe1xuICBuYW1lOiBzdHJpbmcsXG4gIHVybDogc3RyaW5nLFxuICB1bnNlbGVjdGVkRGVsaXZlcmFibGVzOiBhcnJheShEZWxpdmVyYWJsZS50eXBlQ2hlY2spLFxuICBzZWxlY3RlZERlbGl2ZXJhYmxlOiBudWxsYWJsZShEZWxpdmVyYWJsZS50eXBlQ2hlY2spLFxufSk7XG5cbi8vIHVuc2VsZWN0ZWREZWxpdmVyYWJsZXMgYW5kIHNlbGVjdGVkRGVsaXZlcmFibGVzIHRvZ2V0aGVyIGZvcm0gYSB6aXBsaXN0LlxuY29uc3QgUHJvamVjdCA9IGltbXV0YWJsZUNvbnN0cnVjdG9yKHR5cGVDaGVjayk7XG5cbi8vIEdFVFRFUlNcbmV4cG9ydCBjb25zdCBnZXROYW1lID0gcHJvcE9yKG51bGwsICduYW1lJyk7XG5leHBvcnQgY29uc3QgZ2V0VXJsID0gcHJvcE9yKG51bGwsICd1cmwnKTtcbmV4cG9ydCBjb25zdCBnZXRTZWxlY3RlZERlbGl2ZXJhYmxlID0gcHJvcE9yKG51bGwsICdzZWxlY3RlZERlbGl2ZXJhYmxlJyk7XG5leHBvcnQgY29uc3QgZ2V0RGVsaXZlcmFibGVzID0gbW9kZWwgPT4gKFxuICBnZXRTZWxlY3RlZERlbGl2ZXJhYmxlKG1vZGVsKVxuICAgID8gW2dldFNlbGVjdGVkRGVsaXZlcmFibGUobW9kZWwpLCAuLi5wcm9wT3IoW10sICd1bnNlbGVjdGVkRGVsaXZlcmFibGVzJywgbW9kZWwpXVxuICAgIDogcHJvcE9yKFtdLCAndW5zZWxlY3RlZERlbGl2ZXJhYmxlcycsIG1vZGVsKVxuICApO1xuXG5leHBvcnQgY29uc3Qgc2V0U2VsZWN0ZWREZWxpdmVyYWJsZSA9IGN1cnJ5KChtb2RlbCwgbmV3U2VsZWN0ZWQpID0+IHtcbiAgY29uc3QgYWxsID0gZ2V0RGVsaXZlcmFibGVzKG1vZGVsKTtcbiAgY29uc3QgbmV3RGVsaXZlcmFibGVzID0gYWxsLmZpbHRlcihcbiAgICBkID0+IERlbGl2ZXJhYmxlLmdldE5hbWUoZCkgIT09IERlbGl2ZXJhYmxlLmdldE5hbWUobmV3U2VsZWN0ZWQpXG4gICk7XG5cbiAgcmV0dXJuIEltbXV0YWJsZS5tZXJnZSh7XG4gICAgdW5zZWxlY3RlZERlbGl2ZXJhYmxlczogbmV3RGVsaXZlcmFibGVzLFxuICAgIHNlbGVjdGVkRGVsaXZlcmFibGU6IG5ld1NlbGVjdGVkIHx8IG51bGwsXG4gIH0pO1xufSk7XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVEZWxpdmVyYWJsZSA9IGN1cnJ5KChtb2RlbCwgbmV3RGVsaXZlcmFibGUpID0+IHsgLy8gZXNsaW50LWRpc2FibGUgY29tcGxleGl0eVxuICBpZiAoIW1vZGVsIHx8ICFuZXdEZWxpdmVyYWJsZSkge1xuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuXG4gIGNvbnN0IHNhbWVOYW1lID0gZGVsaXYgPT4gKFxuICAgICAgZGVsaXZcbiAgICAgID8gcHJvcEVxKCduYW1lJywgbmV3RGVsaXZlcmFibGUubmFtZSwgZGVsaXYpXG4gICAgICA6IGZhbHNlXG4gICAgKTtcblxuICBpZiAoc2FtZU5hbWUoUHJvamVjdC5nZXRTZWxlY3RlZERlbGl2ZXJhYmxlKG1vZGVsKSkpIHtcbiAgICByZXR1cm4gSW1tdXRhYmxlKG1vZGVsKS5tZXJnZSh7XG4gICAgICBzZWxlY3RlZERlbGl2ZXJhYmxlOiBuZXdEZWxpdmVyYWJsZSxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChtb2RlbC51bnNlbGVjdGVkRGVsaXZlcmFibGVzLmZpbmQoc2FtZU5hbWUpKSB7XG4gICAgY29uc3QgbmV3VW5zZWxlY3RlZCA9IG1vZGVsLnVuc2VsZWN0ZWREZWxpdmVyYWJsZXMubWFwKFxuICAgICAgZCA9PiAoc2FtZU5hbWUoZCkgPyBuZXdEZWxpdmVyYWJsZSA6IGQpXG4gICAgKTtcblxuICAgIHJldHVybiBJbW11dGFibGUobW9kZWwpLm1lcmdlKHtcbiAgICAgIHVuc2VsZWN0ZWREZWxpdmVyYWJsZXM6IG5ld1Vuc2VsZWN0ZWQsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG1vZGVsO1xufSk7XG5cbmV4cG9ydCBjb25zdCBpc1NhbWUgPSBjdXJyeSgocDEsIHAyKSA9PiBnZXROYW1lKHAxKSA9PT0gZ2V0TmFtZShwMikpO1xuXG5cbi8vIE5PIFNFVFRFUlNcbk9iamVjdC5hc3NpZ24oUHJvamVjdCwge1xuICB0eXBlQ2hlY2ssXG4gIGdldE5hbWUsXG4gIGdldFVybCxcbiAgZ2V0RGVsaXZlcmFibGVzLFxuICBnZXRTZWxlY3RlZERlbGl2ZXJhYmxlLFxuICBzZXRTZWxlY3RlZERlbGl2ZXJhYmxlLFxuICB1cGRhdGVEZWxpdmVyYWJsZSxcbiAgaXNTYW1lLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IFByb2plY3Q7XG4iLCJpbXBvcnQgX01heWJlIGZyb20gJy4vTWF5YmUnO1xuaW1wb3J0IF9SZW1vdGVEYXRhIGZyb20gJy4vUmVtb3RlRGF0YSc7XG5pbXBvcnQgX1ZhbGlkYXRpb24gZnJvbSAnLi9WYWxpZGF0aW9uJztcbmltcG9ydCBfdHlwZUNoZWNrZXJzIGZyb20gJy4vdHlwZS1jaGVja2Vycyc7XG5pbXBvcnQgX1JlY29yZGluZyBmcm9tICcuL1JlY29yZGluZyc7XG5pbXBvcnQgX1RpbWVJbnRlcnZhbCBmcm9tICcuL1RpbWVJbnRlcnZhbCc7XG5pbXBvcnQgX0RlbGl2ZXJhYmxlIGZyb20gJy4vRGVsaXZlcmFibGUnO1xuaW1wb3J0IF9Qcm9qZWN0IGZyb20gJy4vUHJvamVjdCc7XG5cbmV4cG9ydCBjb25zdCBNYXliZSA9IF9NYXliZTtcbmV4cG9ydCBjb25zdCBSZW1vdGVEYXRhID0gX1JlbW90ZURhdGE7XG5leHBvcnQgY29uc3QgVmFsaWRhdGlvbiA9IF9WYWxpZGF0aW9uO1xuZXhwb3J0IGNvbnN0IHR5cGVDaGVja2VycyA9IF90eXBlQ2hlY2tlcnM7XG5leHBvcnQgY29uc3QgUmVjb3JkaW5nID0gX1JlY29yZGluZztcbmV4cG9ydCBjb25zdCBUaW1lSW50ZXJ2YWwgPSBfVGltZUludGVydmFsO1xuZXhwb3J0IGNvbnN0IERlbGl2ZXJhYmxlID0gX0RlbGl2ZXJhYmxlO1xuZXhwb3J0IGNvbnN0IFByb2plY3QgPSBfUHJvamVjdDtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBwaXBlIH0gZnJvbSAncmFtZGEnO1xuaW1wb3J0IHsgUmVjb3JkaW5nIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuXG5jb25zdCBwYWQyID0gbnVtID0+IChgMDAke251bX1gKS5zbGljZSgtMik7XG5cbmZ1bmN0aW9uIG1pbGxpc2Vjb25kc1RvVGltZVN0cmluZyhtcykge1xuICBjb25zdCBzZWNvbmRzID0gTWF0aC5mbG9vcihtcyAvIDEwMDApICUgNjA7XG4gIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKG1zIC8gKDEwMDAgKiA2MCkpICUgNjA7XG4gIGNvbnN0IGhvdXJzID0gTWF0aC5mbG9vcihtcyAvICgxMDAwICogNjAgKiA2MCkpICUgMjQ7XG5cbiAgcmV0dXJuIGhvdXJzID4gMFxuICAgID8gYCR7cGFkMihob3Vycyl9OiR7cGFkMihtaW51dGVzKX1gXG4gICAgOiBgJHtwYWQyKG1pbnV0ZXMpfToke3BhZDIoc2Vjb25kcyl9YDtcbn1cblxuLy8gV2UgdXNlIGEgY2xhc3MgaW5zdGVhZCBvZiBhIHN0YXRlbGVzcyBjb21wb25lbnQgYmVjYXVzZSB3ZVxuLy8gbmVlZCB0aGUgYHRoaXNgIGtleXdvcmQgdG8gdHJpZ2dlciB0aGUgZm9yY2UtdXBkYXRlXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgcmVjb3JkaW5nIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGlzUmVjb3JkaW5nID0gUmVjb3JkaW5nLmlzUmVjb3JkaW5nKHJlY29yZGluZyk7XG4gICAgaWYgKGlzUmVjb3JkaW5nKSB7XG4gICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KF8gPT4gdGhpcy5mb3JjZVVwZGF0ZSgpLCA1MDApO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVTdHJpbmcgPSBwaXBlKFJlY29yZGluZy50b3RhbFRpbWUsIG1pbGxpc2Vjb25kc1RvVGltZVN0cmluZykocmVjb3JkaW5nKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT1cIlRpbWVUcmFja2VyLXRpbWVyLXRpbWVcIlxuICAgICAgICBzdHlsZT17eyBtaW5XaWR0aDogYCR7dGltZVN0cmluZy5sZW5ndGggKiAwLjU2fWVtYCB9fVxuICAgICAgPlxuICAgICAge3RpbWVTdHJpbmd9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cblRpbWVyLnByb3BUeXBlcyA9IHtcbiAgcmVjb3JkaW5nOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LFxufTtcbiIsIi8vXG4vLyAgICBBQ1RJT04gQ1JFQVRPUlNcbi8vXG5pbXBvcnQgeyBjdXJyeSB9IGZyb20gJ3JhbWRhJztcblxuZXhwb3J0IGNvbnN0IHRvZ2dsZVJlY29yZGluZyA9IGN1cnJ5KChwcm9qZWN0LCBkZWxpdmVyYWJsZSkgPT4gKHtcbiAgdHlwZTogJ1dJREdFVF90b2dnbGVSZWNvcmRpbmcnLFxuICBwcm9qZWN0LFxuICBkZWxpdmVyYWJsZSxcbn0pKTtcbmV4cG9ydCBjb25zdCBzZWxlY3REZWxpdmVyYWJsZSA9IGN1cnJ5KChwcm9qZWN0LCBkZWxpdmVyYWJsZSkgPT4gKHtcbiAgdHlwZTogJ1dJREdFVF9zZWxlY3REZWxpdmVyYWJsZScsXG4gIHByb2plY3QsXG4gIGRlbGl2ZXJhYmxlLFxufSkpO1xuZXhwb3J0IGNvbnN0IHNlbGVjdFByb2plY3QgPSAocHJvamVjdCkgPT4gKHtcbiAgdHlwZTogJ1dJREdFVF9zZWxlY3RQcm9qZWN0JyxcbiAgcHJvamVjdCxcbn0pO1xuZXhwb3J0IGNvbnN0IHNldFByb2plY3RzID0gKHJhd1Byb2plY3RzKSA9PiAoe1xuICB0eXBlOiAnV0lER0VUX3NldFByb2plY3RzJyxcbiAgcmF3UHJvamVjdHMsXG59KTtcbmV4cG9ydCBjb25zdCB0b2dnbGVNaW5pbWlzZWQgPSAobWluaW1pc2UpID0+ICh7XG4gIHR5cGU6ICdXSURHRVRfdG9nZ2xlTWluaW1pc2VkJyxcbiAgbWluaW1pc2UsXG59KTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3Byb3AtdHlwZXMgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBQcm9qZWN0LCBEZWxpdmVyYWJsZSwgUmVjb3JkaW5nIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgdG9nZ2xlUmVjb3JkaW5nIH0gZnJvbSAnLi4vYWN0aW9ucyc7XG5pbXBvcnQgVGltZXIgZnJvbSAnLi9UaW1lcic7XG5cbmNvbnN0IFJlY29yZGluZ1JvdyA9ICh7IHN0b3JlLCBwcm9qZWN0LCBkZWxpdmVyYWJsZSwgcmVjb3JkaW5nIH0pID0+IChcbiAgPGRpdiBjbGFzc05hbWU9XCJUaW1lVHJhY2tlci1SZWNvcmRpbmdSb3dcIj5cbiAgICA8ZGl2IGNsYXNzTmFtZT1cIlRpbWVUcmFja2VyLVJlY29yZGluZ1Jvdy1uYW1lc1wiPlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiVGltZVRyYWNrZXItUmVjb3JkaW5nUm93LWRlbGl2ZXJhYmxlTmFtZVwiPlxuICAgICAgICB7RGVsaXZlcmFibGUuZ2V0TmFtZShkZWxpdmVyYWJsZSl9XG4gICAgICA8L3NwYW4+XG5cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT1cIlRpbWVUcmFja2VyLVJlY29yZGluZ1Jvdy1wcm9qZWN0TmFtZVwiPlxuICAgICAgICB7UHJvamVjdC5nZXROYW1lKHByb2plY3QpfVxuICAgICAgPC9zcGFuPlxuICAgIDwvZGl2PlxuXG4gICAgPGJ1dHRvblxuICAgICAgY2xhc3NOYW1lPXtcbiAgICAgICAgYFRpbWVUcmFja2VyLVJlY29yZGluZ1Jvdy1zdGFydC1zdG9wIGJ0biBmYSAke1xuICAgICAgICAgIFJlY29yZGluZy5pc1JlY29yZGluZyhyZWNvcmRpbmcpID8gJ2J0bi1kYW5nZXIgZmEtcGF1c2UnIDogJ2J0bi1pbmZvIGZhLXBsYXknXG4gICAgICAgIH1gfVxuICAgICAgb25DbGljaz17XG4gICAgICAgIF8gPT4gc3RvcmUuZGlzcGF0Y2godG9nZ2xlUmVjb3JkaW5nKHByb2plY3QsIGRlbGl2ZXJhYmxlKSlcbiAgICAgIH1cbiAgICAvPlxuXG4gICAgPFRpbWVyIHJlY29yZGluZz17cmVjb3JkaW5nfSAvPlxuICA8L2Rpdj5cbik7XG5cblxuZXhwb3J0IGRlZmF1bHQgUmVjb3JkaW5nUm93O1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tbmVzdGVkLXRlcm5hcnksIHJlYWN0L3Byb3AtdHlwZXMgKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgU2VsZWN0IGZyb20gJ3JlYWN0LXNlbGVjdCc7XG5pbXBvcnQgeyBwaXBlLCBtYXAsIHByb3BPciwgc29ydEJ5LCBwcm9wRXEsIGZpbmQsIHByb3AsIGZpbHRlciB9IGZyb20gJ3JhbWRhJztcbmltcG9ydCBUaW1lciBmcm9tICcuL1RpbWVyJztcbmltcG9ydCBSZWNvcmRpbmdSb3cgZnJvbSAnLi9SZWNvcmRpbmdSb3cnO1xuaW1wb3J0IHsgUmVjb3JkaW5nLCBQcm9qZWN0LCBEZWxpdmVyYWJsZSwgTWF5YmUgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIHRvZ2dsZVJlY29yZGluZyxcbiAgc2VsZWN0RGVsaXZlcmFibGUsXG4gIHNlbGVjdFByb2plY3QsXG4gIHRvZ2dsZU1pbmltaXNlZCxcbn0gZnJvbSAnLi4vYWN0aW9ucyc7XG5cbmNvbnN0IHRvT3B0aW9uID0gZWwgPT4gKGVsXG4gID8gcGlwZShwcm9wT3IobnVsbCwgJ25hbWUnKSwgbmFtZSA9PiAoeyBsYWJlbDogbmFtZSwgdmFsdWU6IG5hbWUgfSkpKGVsKVxuICA6IG51bGxcbik7XG5cbi8vIE9wdGlvbiAtPiBbUHJvamVjdF0gLT4gUHJvamVjdFxuY29uc3Qgc2FtZU5hbWVBc09wdGlvblZhbHVlID0gcGlwZShcbiAgcHJvcE9yKG51bGwsICd2YWx1ZScpLFxuICBwcm9wRXEoJ25hbWUnKSxcbiAgZmluZCxcbik7XG5cbi8vIE9iamVjdCAtPiBTdHJpbmcgOiBUaGlzIGNyZWF0ZXMgYSBzdHJpbmcgdXNlZnVsIGluIHNvcnRpbmcgYW5kIGlkZW50aWZ5aW5nXG4vLyAgICAgICAgICAgICAgICAgICAgdGhlIHByb2plY3QgZGVsaXZlcmFibGUgcmVjb3JkaW5nXG5jb25zdCBzdHJpbmdJZGVudGlmaWVyID0gKHsgcHJvamVjdCwgZGVsaXZlcmFibGUgfSkgPT4ge1xuICByZXR1cm4gUHJvamVjdC5nZXROYW1lKHByb2plY3QpICtcbiAgICBEZWxpdmVyYWJsZS5nZXROYW1lKGRlbGl2ZXJhYmxlKTtcbn07XG5cbmNvbnN0IHJ1bm5pbmdUaW1lciA9IHJlY29yZGluZ3NJbmZvID0+XG4gIE1heWJlLm9mKHJlY29yZGluZ3NJbmZvKVxuICAgIC5tYXAobWFwKHByb3AoJ3JlY29yZGluZycpKSlcbiAgICAubWFwKGZpbHRlcihSZWNvcmRpbmcuaXNSZWNvcmRpbmcpKVxuICAgIC5tYXAocHJvcCgwKSlcbiAgICAud2l0aERlZmF1bHQodW5kZWZpbmVkKTtcblxuY29uc3QgV2lkZ2V0ID0gKHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb21wbGV4aXR5XG4gIHN0b3JlLFxuICAvLyBwcm9wc1xuICBzZWxlY3RlZFByb2plY3QsXG4gIGFsbFByb2plY3RzLFxuICByZWNvcmRpbmdzSW5mbyxcbiAgaXNNaW5pbWlzZWQsXG59KSA9PiB7XG4gIGNvbnN0IHNlbGVjdGVkRGVsaXZlcmFibGUgPSBQcm9qZWN0LmdldFNlbGVjdGVkRGVsaXZlcmFibGUoc2VsZWN0ZWRQcm9qZWN0KTtcbiAgY29uc3QgYWN0aXZlUmVjb3JkaW5nID0gaXNNaW5pbWlzZWRcbiAgICA/IHJ1bm5pbmdUaW1lcihyZWNvcmRpbmdzSW5mbylcbiAgICA6IERlbGl2ZXJhYmxlLmdldFJlY29yZGluZyhzZWxlY3RlZERlbGl2ZXJhYmxlKTtcbiAgY29uc3QgaXNSZWNvcmRpbmcgPSBSZWNvcmRpbmcuaXNSZWNvcmRpbmcoYWN0aXZlUmVjb3JkaW5nKTtcbiAgY29uc3QgcHJvamVjdE9wdGlvbnMgPSBhbGxQcm9qZWN0cy5tYXAodG9PcHRpb24pO1xuICBjb25zdCBkZWxpdmVyYWJsZU9wdGlvbnMgPSBQcm9qZWN0LmdldERlbGl2ZXJhYmxlcyhzZWxlY3RlZFByb2plY3QpLm1hcCh0b09wdGlvbik7XG5cbiAgY29uc3QgdGltZVRyYWNrZXJDbGljayA9IF8gPT5cbiAgICBzdG9yZS5kaXNwYXRjaCh0b2dnbGVSZWNvcmRpbmcoc2VsZWN0ZWRQcm9qZWN0LCBzZWxlY3RlZERlbGl2ZXJhYmxlKSk7XG5cbiAgLy8geyBsYWJlbDxTdHJpbmc+LCB2YWx1ZTxTdHJpbmc+fSAtPiBBY3Rpb25cbiAgY29uc3QgY2hhbmdlUHJvamVjdCA9IChvcHRpb24pID0+IHBpcGUoXG4gICAgc2FtZU5hbWVBc09wdGlvblZhbHVlKG9wdGlvbiksXG4gICAgc2VsZWN0UHJvamVjdCxcbiAgICBhY3Rpb24gPT4gc3RvcmUuZGlzcGF0Y2goYWN0aW9uKSxcbiAgKShhbGxQcm9qZWN0cyk7XG5cbiAgLy8geyBsYWJlbDxTdHJpbmc+LCB2YWx1ZTxTdHJpbmc+fSAtPiBBY3Rpb25cbiAgY29uc3QgY2hhbmdlRGVsaXZlcmFibGUgPSAob3B0aW9uKSA9PiBwaXBlKFxuICAgIFByb2plY3QuZ2V0RGVsaXZlcmFibGVzLFxuICAgIHNhbWVOYW1lQXNPcHRpb25WYWx1ZShvcHRpb24pLFxuICAgIHNlbGVjdERlbGl2ZXJhYmxlKHNlbGVjdGVkUHJvamVjdCksXG4gICAgYWN0aW9uID0+IHN0b3JlLmRpc3BhdGNoKGFjdGlvbiksXG4gICkoc2VsZWN0ZWRQcm9qZWN0KTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtgVGltZVRyYWNrZXIgJHtpc01pbmltaXNlZCA/ICdUaW1lVHJhY2tlci0tbWluaW1pc2VkJyA6ICcnfWB9PlxuICAgICAgPGRpdlxuICAgICAgICBjbGFzc05hbWU9e1xuICAgICAgICAgIGBUaW1lVHJhY2tlci10aW1lciAke2lzUmVjb3JkaW5nXG4gICAgICAgICAgICAgID8gJ1RpbWVUcmFja2VyLXRpbWVyLS1yZWNvcmRpbmcnXG4gICAgICAgICAgICAgIDogJyd9YFxuICAgICAgICAgIH1cbiAgICAgICAgb25DbGljaz17XyA9PiBzdG9yZS5kaXNwYXRjaCh0b2dnbGVNaW5pbWlzZWQoIWlzTWluaW1pc2VkKSl9XG4gICAgICA+XG4gICAgICAgIDxUaW1lciByZWNvcmRpbmc9e2FjdGl2ZVJlY29yZGluZ30gLz5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJUaW1lVHJhY2tlci1maWVsZHNcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJUaW1lVHJhY2tlci1wcm9qZWN0c1wiPlxuICAgICAgICAgIDxTZWxlY3RcbiAgICAgICAgICAgIG5hbWU9XCJmb3JtLWZpZWxkLW5hbWVcIlxuICAgICAgICAgICAgdmFsdWU9e3RvT3B0aW9uKHNlbGVjdGVkUHJvamVjdCl9XG4gICAgICAgICAgICBvcHRpb25zPXtzb3J0QnkocHJvcE9yKCcnLCAnbGFiZWwnKSwgcHJvamVjdE9wdGlvbnMpfVxuICAgICAgICAgICAgb25DaGFuZ2U9e2NoYW5nZVByb2plY3R9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIlRpbWVUcmFja2VyLXNpZGVCdXR0b25zXCI+XG4gICAgICAgICAgICA8YVxuICAgICAgICAgICAgICBocmVmPXtQcm9qZWN0LmdldFVybChzZWxlY3RlZFByb2plY3QpfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9e2BidG4gYnRuLSR7c2VsZWN0ZWRQcm9qZWN0ID8gJ2RhbmdlcicgOiAnZGlzYWJsZWQnfSBmYSBmYS1saW5rYH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8YSBjbGFzc05hbWU9XCJidG4gYnRuLXNlY29uZGFyeSBmYSBmYS1wbHVzXCIgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJUaW1lVHJhY2tlci1kZWxpdmVyYWJsZXNcIj5cbiAgICAgICAgICA8U2VsZWN0XG4gICAgICAgICAgICBuYW1lPVwiZm9ybS1maWVsZC1uYW1lXCJcbiAgICAgICAgICAgIHZhbHVlPXt0b09wdGlvbihzZWxlY3RlZERlbGl2ZXJhYmxlKX1cbiAgICAgICAgICAgIG9wdGlvbnM9e3NvcnRCeShwcm9wT3IoJycsICdsYWJlbCcpLCBkZWxpdmVyYWJsZU9wdGlvbnMpfVxuICAgICAgICAgICAgb25DaGFuZ2U9e2NoYW5nZURlbGl2ZXJhYmxlfVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJUaW1lVHJhY2tlci1zaWRlQnV0dG9uc1wiPlxuICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgaHJlZj17RGVsaXZlcmFibGUuZ2V0VXJsKHNlbGVjdGVkRGVsaXZlcmFibGUpfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidG4gYnRuLWRhbmdlciBmYSBmYS1saW5rXCJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgYnRuIGJ0bi0ke3NlbGVjdGVkRGVsaXZlcmFibGUgPyAnZGFuZ2VyJyA6ICdkaXNhYmxlZCd9IGZhIGZhLWxpbmtgfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxhXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJ0biBidG4tc2Vjb25kYXJ5IGZhIGZhLXBsdXNcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIGNsYXNzTmFtZT17YFRpbWVUcmFja2VyLXN0YXJ0LXN0b3AgYnRuICR7aXNSZWNvcmRpbmcgPyAnYnRuLWRhbmdlcicgOiAnYnRuLWRlZmF1bHQnfWB9XG4gICAgICAgICAgb25DbGljaz17dGltZVRyYWNrZXJDbGlja31cbiAgICAgICAgICBkaXNhYmxlZD17IXNlbGVjdGVkRGVsaXZlcmFibGV9XG4gICAgICAgID5cbiAgICAgICAgICB7aXNSZWNvcmRpbmcgPyAnUGF1c2UnIDogJ1N0YXJ0J31cbiAgICAgICAgPC9idXR0b24+XG5cbiAgICAgICAge3JlY29yZGluZ3NJbmZvXG4gICAgICAgICAgLnNvcnQoKGluZm8xLCBpbmZvMikgPT4gc3RyaW5nSWRlbnRpZmllcihpbmZvMSkgPCBzdHJpbmdJZGVudGlmaWVyKGluZm8yKSlcbiAgICAgICAgICAubWFwKChpbmZvKSA9PlxuICAgICAgICAgICg8UmVjb3JkaW5nUm93XG4gICAgICAgICAgICBrZXk9e3N0cmluZ0lkZW50aWZpZXIoaW5mbyl9XG4gICAgICAgICAgICBzdG9yZT17c3RvcmV9XG4gICAgICAgICAgICB7Li4uaW5mb31cbiAgICAgICAgICAvPikpXG4gICAgICAgIH1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfcmVhY3QuUHJvcFR5cGVzLnNoYXBlKHtcbiAgc3Vic2NyaWJlOiBfcmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgZGlzcGF0Y2g6IF9yZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBnZXRTdGF0ZTogX3JlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbn0pOyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gd2FybmluZztcbi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IGlmIHlvdSBlbmFibGVcbiAgICAvLyBcImJyZWFrIG9uIGFsbCBleGNlcHRpb25zXCIgaW4geW91ciBjb25zb2xlLFxuICAgIC8vIGl0IHdvdWxkIHBhdXNlIHRoZSBleGVjdXRpb24gYXQgdGhpcyBsaW5lLlxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuICB9IGNhdGNoIChlKSB7fVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG59IiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB1bmRlZmluZWQ7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3N0b3JlU2hhcGUgPSByZXF1aXJlKCcuLi91dGlscy9zdG9yZVNoYXBlJyk7XG5cbnZhciBfc3RvcmVTaGFwZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdG9yZVNoYXBlKTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnLi4vdXRpbHMvd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBkaWRXYXJuQWJvdXRSZWNlaXZpbmdTdG9yZSA9IGZhbHNlO1xuZnVuY3Rpb24gd2FybkFib3V0UmVjZWl2aW5nU3RvcmUoKSB7XG4gIGlmIChkaWRXYXJuQWJvdXRSZWNlaXZpbmdTdG9yZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBkaWRXYXJuQWJvdXRSZWNlaXZpbmdTdG9yZSA9IHRydWU7XG5cbiAgKDAsIF93YXJuaW5nMltcImRlZmF1bHRcIl0pKCc8UHJvdmlkZXI+IGRvZXMgbm90IHN1cHBvcnQgY2hhbmdpbmcgYHN0b3JlYCBvbiB0aGUgZmx5LiAnICsgJ0l0IGlzIG1vc3QgbGlrZWx5IHRoYXQgeW91IHNlZSB0aGlzIGVycm9yIGJlY2F1c2UgeW91IHVwZGF0ZWQgdG8gJyArICdSZWR1eCAyLnggYW5kIFJlYWN0IFJlZHV4IDIueCB3aGljaCBubyBsb25nZXIgaG90IHJlbG9hZCByZWR1Y2VycyAnICsgJ2F1dG9tYXRpY2FsbHkuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yZWR1eC9yZWxlYXNlcy8nICsgJ3RhZy92Mi4wLjAgZm9yIHRoZSBtaWdyYXRpb24gaW5zdHJ1Y3Rpb25zLicpO1xufVxuXG52YXIgUHJvdmlkZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUHJvdmlkZXIsIF9Db21wb25lbnQpO1xuXG4gIFByb3ZpZGVyLnByb3RvdHlwZS5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHsgc3RvcmU6IHRoaXMuc3RvcmUgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBQcm92aWRlcihwcm9wcywgY29udGV4dCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm92aWRlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpKTtcblxuICAgIF90aGlzLnN0b3JlID0gcHJvcHMuc3RvcmU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgUHJvdmlkZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gX3JlYWN0LkNoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gIH07XG5cbiAgcmV0dXJuIFByb3ZpZGVyO1xufShfcmVhY3QuQ29tcG9uZW50KTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBQcm92aWRlcjtcblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBQcm92aWRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIChuZXh0UHJvcHMpIHtcbiAgICB2YXIgc3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgIHZhciBuZXh0U3RvcmUgPSBuZXh0UHJvcHMuc3RvcmU7XG5cblxuICAgIGlmIChzdG9yZSAhPT0gbmV4dFN0b3JlKSB7XG4gICAgICB3YXJuQWJvdXRSZWNlaXZpbmdTdG9yZSgpO1xuICAgIH1cbiAgfTtcbn1cblxuUHJvdmlkZXIucHJvcFR5cGVzID0ge1xuICBzdG9yZTogX3N0b3JlU2hhcGUyW1wiZGVmYXVsdFwiXS5pc1JlcXVpcmVkLFxuICBjaGlsZHJlbjogX3JlYWN0LlByb3BUeXBlcy5lbGVtZW50LmlzUmVxdWlyZWRcbn07XG5Qcm92aWRlci5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgc3RvcmU6IF9zdG9yZVNoYXBlMltcImRlZmF1bHRcIl0uaXNSZXF1aXJlZFxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gc2hhbGxvd0VxdWFsO1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKG9iakEgPT09IG9iakIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duLmNhbGwob2JqQiwga2V5c0FbaV0pIHx8IG9iakFba2V5c0FbaV1dICE9PSBvYmpCW2tleXNBW2ldXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufSIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5leHBvcnQgZGVmYXVsdCByb290O1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0UmF3VGFnO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGdldFJhd1RhZyBmcm9tICcuL19nZXRSYXdUYWcuanMnO1xuaW1wb3J0IG9iamVjdFRvU3RyaW5nIGZyb20gJy4vX29iamVjdFRvU3RyaW5nLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICB2YWx1ZSA9IE9iamVjdCh2YWx1ZSk7XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gdmFsdWUpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRUYWc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlckFyZztcbiIsImltcG9ydCBvdmVyQXJnIGZyb20gJy4vX292ZXJBcmcuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0UHJvdG90eXBlO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0TGlrZTtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGdldFByb3RvdHlwZSBmcm9tICcuL19nZXRQcm90b3R5cGUuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQbGFpbk9iamVjdDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN5bWJvbE9ic2VydmFibGVQb255ZmlsbChyb290KSB7XG5cdHZhciByZXN1bHQ7XG5cdHZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuXHRpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGlmIChTeW1ib2wub2JzZXJ2YWJsZSkge1xuXHRcdFx0cmVzdWx0ID0gU3ltYm9sLm9ic2VydmFibGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdCA9IFN5bWJvbCgnb2JzZXJ2YWJsZScpO1xuXHRcdFx0U3ltYm9sLm9ic2VydmFibGUgPSByZXN1bHQ7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJlc3VsdCA9ICdAQG9ic2VydmFibGUnO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgcG9ueWZpbGwgZnJvbSAnLi9wb255ZmlsbCc7XG5cbnZhciByb290O1xuXG5pZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gbW9kdWxlO1xufSBlbHNlIHtcbiAgcm9vdCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG59XG5cbnZhciByZXN1bHQgPSBwb255ZmlsbChyb290KTtcbmV4cG9ydCBkZWZhdWx0IHJlc3VsdDtcbiIsImltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJ2xvZGFzaC1lcy9pc1BsYWluT2JqZWN0JztcbmltcG9ydCAkJG9ic2VydmFibGUgZnJvbSAnc3ltYm9sLW9ic2VydmFibGUnO1xuXG4vKipcbiAqIFRoZXNlIGFyZSBwcml2YXRlIGFjdGlvbiB0eXBlcyByZXNlcnZlZCBieSBSZWR1eC5cbiAqIEZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBJZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqIERvIG5vdCByZWZlcmVuY2UgdGhlc2UgYWN0aW9uIHR5cGVzIGRpcmVjdGx5IGluIHlvdXIgY29kZS5cbiAqL1xuZXhwb3J0IHZhciBBY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogJ0BAcmVkdXgvSU5JVCdcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIFJlZHV4IHN0b3JlIHRoYXQgaG9sZHMgdGhlIHN0YXRlIHRyZWUuXG4gKiBUaGUgb25seSB3YXkgdG8gY2hhbmdlIHRoZSBkYXRhIGluIHRoZSBzdG9yZSBpcyB0byBjYWxsIGBkaXNwYXRjaCgpYCBvbiBpdC5cbiAqXG4gKiBUaGVyZSBzaG91bGQgb25seSBiZSBhIHNpbmdsZSBzdG9yZSBpbiB5b3VyIGFwcC4gVG8gc3BlY2lmeSBob3cgZGlmZmVyZW50XG4gKiBwYXJ0cyBvZiB0aGUgc3RhdGUgdHJlZSByZXNwb25kIHRvIGFjdGlvbnMsIHlvdSBtYXkgY29tYmluZSBzZXZlcmFsIHJlZHVjZXJzXG4gKiBpbnRvIGEgc2luZ2xlIHJlZHVjZXIgZnVuY3Rpb24gYnkgdXNpbmcgYGNvbWJpbmVSZWR1Y2Vyc2AuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVkdWNlciBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV4dCBzdGF0ZSB0cmVlLCBnaXZlblxuICogdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGFjdGlvbiB0byBoYW5kbGUuXG4gKlxuICogQHBhcmFtIHthbnl9IFtwcmVsb2FkZWRTdGF0ZV0gVGhlIGluaXRpYWwgc3RhdGUuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBoeWRyYXRlIHRoZSBzdGF0ZSBmcm9tIHRoZSBzZXJ2ZXIgaW4gdW5pdmVyc2FsIGFwcHMsIG9yIHRvIHJlc3RvcmUgYVxuICogcHJldmlvdXNseSBzZXJpYWxpemVkIHVzZXIgc2Vzc2lvbi5cbiAqIElmIHlvdSB1c2UgYGNvbWJpbmVSZWR1Y2Vyc2AgdG8gcHJvZHVjZSB0aGUgcm9vdCByZWR1Y2VyIGZ1bmN0aW9uLCB0aGlzIG11c3QgYmVcbiAqIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGBjb21iaW5lUmVkdWNlcnNgIGtleXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5oYW5jZXIgVGhlIHN0b3JlIGVuaGFuY2VyLiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdFxuICogdG8gZW5oYW5jZSB0aGUgc3RvcmUgd2l0aCB0aGlyZC1wYXJ0eSBjYXBhYmlsaXRpZXMgc3VjaCBhcyBtaWRkbGV3YXJlLFxuICogdGltZSB0cmF2ZWwsIHBlcnNpc3RlbmNlLCBldGMuIFRoZSBvbmx5IHN0b3JlIGVuaGFuY2VyIHRoYXQgc2hpcHMgd2l0aCBSZWR1eFxuICogaXMgYGFwcGx5TWlkZGxld2FyZSgpYC5cbiAqXG4gKiBAcmV0dXJucyB7U3RvcmV9IEEgUmVkdXggc3RvcmUgdGhhdCBsZXRzIHlvdSByZWFkIHRoZSBzdGF0ZSwgZGlzcGF0Y2ggYWN0aW9uc1xuICogYW5kIHN1YnNjcmliZSB0byBjaGFuZ2VzLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgdmFyIF9yZWYyO1xuXG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIGVuaGFuY2VyID0gcHJlbG9hZGVkU3RhdGU7XG4gICAgcHJlbG9hZGVkU3RhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIGVuaGFuY2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuaGFuY2VyKGNyZWF0ZVN0b3JlKShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSByZWR1Y2VyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyO1xuICB2YXIgY3VycmVudFN0YXRlID0gcHJlbG9hZGVkU3RhdGU7XG4gIHZhciBjdXJyZW50TGlzdGVuZXJzID0gW107XG4gIHZhciBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycztcbiAgdmFyIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCkge1xuICAgIGlmIChuZXh0TGlzdGVuZXJzID09PSBjdXJyZW50TGlzdGVuZXJzKSB7XG4gICAgICBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycy5zbGljZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgc3RhdGUgdHJlZSBtYW5hZ2VkIGJ5IHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHJldHVybnMge2FueX0gVGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY2hhbmdlIGxpc3RlbmVyLiBJdCB3aWxsIGJlIGNhbGxlZCBhbnkgdGltZSBhbiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCxcbiAgICogYW5kIHNvbWUgcGFydCBvZiB0aGUgc3RhdGUgdHJlZSBtYXkgcG90ZW50aWFsbHkgaGF2ZSBjaGFuZ2VkLiBZb3UgbWF5IHRoZW5cbiAgICogY2FsbCBgZ2V0U3RhdGUoKWAgdG8gcmVhZCB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGluc2lkZSB0aGUgY2FsbGJhY2suXG4gICAqXG4gICAqIFlvdSBtYXkgY2FsbCBgZGlzcGF0Y2goKWAgZnJvbSBhIGNoYW5nZSBsaXN0ZW5lciwgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIGNhdmVhdHM6XG4gICAqXG4gICAqIDEuIFRoZSBzdWJzY3JpcHRpb25zIGFyZSBzbmFwc2hvdHRlZCBqdXN0IGJlZm9yZSBldmVyeSBgZGlzcGF0Y2goKWAgY2FsbC5cbiAgICogSWYgeW91IHN1YnNjcmliZSBvciB1bnN1YnNjcmliZSB3aGlsZSB0aGUgbGlzdGVuZXJzIGFyZSBiZWluZyBpbnZva2VkLCB0aGlzXG4gICAqIHdpbGwgbm90IGhhdmUgYW55IGVmZmVjdCBvbiB0aGUgYGRpc3BhdGNoKClgIHRoYXQgaXMgY3VycmVudGx5IGluIHByb2dyZXNzLlxuICAgKiBIb3dldmVyLCB0aGUgbmV4dCBgZGlzcGF0Y2goKWAgY2FsbCwgd2hldGhlciBuZXN0ZWQgb3Igbm90LCB3aWxsIHVzZSBhIG1vcmVcbiAgICogcmVjZW50IHNuYXBzaG90IG9mIHRoZSBzdWJzY3JpcHRpb24gbGlzdC5cbiAgICpcbiAgICogMi4gVGhlIGxpc3RlbmVyIHNob3VsZCBub3QgZXhwZWN0IHRvIHNlZSBhbGwgc3RhdGUgY2hhbmdlcywgYXMgdGhlIHN0YXRlXG4gICAqIG1pZ2h0IGhhdmUgYmVlbiB1cGRhdGVkIG11bHRpcGxlIHRpbWVzIGR1cmluZyBhIG5lc3RlZCBgZGlzcGF0Y2goKWAgYmVmb3JlXG4gICAqIHRoZSBsaXN0ZW5lciBpcyBjYWxsZWQuIEl0IGlzLCBob3dldmVyLCBndWFyYW50ZWVkIHRoYXQgYWxsIHN1YnNjcmliZXJzXG4gICAqIHJlZ2lzdGVyZWQgYmVmb3JlIHRoZSBgZGlzcGF0Y2goKWAgc3RhcnRlZCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBsYXRlc3RcbiAgICogc3RhdGUgYnkgdGhlIHRpbWUgaXQgZXhpdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIEEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBvbiBldmVyeSBkaXNwYXRjaC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGlzIGNoYW5nZSBsaXN0ZW5lci5cbiAgICovXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgaXNTdWJzY3JpYmVkID0gdHJ1ZTtcblxuICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICBuZXh0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgaWYgKCFpc1N1YnNjcmliZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcblxuICAgICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgICAgdmFyIGluZGV4ID0gbmV4dExpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgIG5leHRMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYW4gYWN0aW9uLiBJdCBpcyB0aGUgb25seSB3YXkgdG8gdHJpZ2dlciBhIHN0YXRlIGNoYW5nZS5cbiAgICpcbiAgICogVGhlIGByZWR1Y2VyYCBmdW5jdGlvbiwgdXNlZCB0byBjcmVhdGUgdGhlIHN0b3JlLCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZVxuICAgKiBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBnaXZlbiBgYWN0aW9uYC4gSXRzIHJldHVybiB2YWx1ZSB3aWxsXG4gICAqIGJlIGNvbnNpZGVyZWQgdGhlICoqbmV4dCoqIHN0YXRlIG9mIHRoZSB0cmVlLCBhbmQgdGhlIGNoYW5nZSBsaXN0ZW5lcnNcbiAgICogd2lsbCBiZSBub3RpZmllZC5cbiAgICpcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBwbGFpbiBvYmplY3QgYWN0aW9ucy4gSWYgeW91IHdhbnQgdG9cbiAgICogZGlzcGF0Y2ggYSBQcm9taXNlLCBhbiBPYnNlcnZhYmxlLCBhIHRodW5rLCBvciBzb21ldGhpbmcgZWxzZSwgeW91IG5lZWQgdG9cbiAgICogd3JhcCB5b3VyIHN0b3JlIGNyZWF0aW5nIGZ1bmN0aW9uIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgbWlkZGxld2FyZS4gRm9yXG4gICAqIGV4YW1wbGUsIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGByZWR1eC10aHVua2AgcGFja2FnZS4gRXZlbiB0aGVcbiAgICogbWlkZGxld2FyZSB3aWxsIGV2ZW50dWFsbHkgZGlzcGF0Y2ggcGxhaW4gb2JqZWN0IGFjdGlvbnMgdXNpbmcgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gQSBwbGFpbiBvYmplY3QgcmVwcmVzZW50aW5nIOKAnHdoYXQgY2hhbmdlZOKAnS4gSXQgaXNcbiAgICogYSBnb29kIGlkZWEgdG8ga2VlcCBhY3Rpb25zIHNlcmlhbGl6YWJsZSBzbyB5b3UgY2FuIHJlY29yZCBhbmQgcmVwbGF5IHVzZXJcbiAgICogc2Vzc2lvbnMsIG9yIHVzZSB0aGUgdGltZSB0cmF2ZWxsaW5nIGByZWR1eC1kZXZ0b29sc2AuIEFuIGFjdGlvbiBtdXN0IGhhdmVcbiAgICogYSBgdHlwZWAgcHJvcGVydHkgd2hpY2ggbWF5IG5vdCBiZSBgdW5kZWZpbmVkYC4gSXQgaXMgYSBnb29kIGlkZWEgdG8gdXNlXG4gICAqIHN0cmluZyBjb25zdGFudHMgZm9yIGFjdGlvbiB0eXBlcy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gRm9yIGNvbnZlbmllbmNlLCB0aGUgc2FtZSBhY3Rpb24gb2JqZWN0IHlvdSBkaXNwYXRjaGVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQsIGlmIHlvdSB1c2UgYSBjdXN0b20gbWlkZGxld2FyZSwgaXQgbWF5IHdyYXAgYGRpc3BhdGNoKClgIHRvXG4gICAqIHJldHVybiBzb21ldGhpbmcgZWxzZSAoZm9yIGV4YW1wbGUsIGEgUHJvbWlzZSB5b3UgY2FuIGF3YWl0KS5cbiAgICovXG4gIGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiAnICsgJ1VzZSBjdXN0b20gbWlkZGxld2FyZSBmb3IgYXN5bmMgYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFjdGlvbi50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG1heSBub3QgaGF2ZSBhbiB1bmRlZmluZWQgXCJ0eXBlXCIgcHJvcGVydHkuICcgKyAnSGF2ZSB5b3UgbWlzc3BlbGxlZCBhIGNvbnN0YW50PycpO1xuICAgIH1cblxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXJzIG1heSBub3QgZGlzcGF0Y2ggYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IHRydWU7XG4gICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50UmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycyA9IG5leHRMaXN0ZW5lcnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXSgpO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHJlZHVjZXIgY3VycmVudGx5IHVzZWQgYnkgdGhlIHN0b3JlIHRvIGNhbGN1bGF0ZSB0aGUgc3RhdGUuXG4gICAqXG4gICAqIFlvdSBtaWdodCBuZWVkIHRoaXMgaWYgeW91ciBhcHAgaW1wbGVtZW50cyBjb2RlIHNwbGl0dGluZyBhbmQgeW91IHdhbnQgdG9cbiAgICogbG9hZCBzb21lIG9mIHRoZSByZWR1Y2VycyBkeW5hbWljYWxseS4gWW91IG1pZ2h0IGFsc28gbmVlZCB0aGlzIGlmIHlvdVxuICAgKiBpbXBsZW1lbnQgYSBob3QgcmVsb2FkaW5nIG1lY2hhbmlzbSBmb3IgUmVkdXguXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRSZWR1Y2VyIFRoZSByZWR1Y2VyIGZvciB0aGUgc3RvcmUgdG8gdXNlIGluc3RlYWQuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZVJlZHVjZXIobmV4dFJlZHVjZXIpIHtcbiAgICBpZiAodHlwZW9mIG5leHRSZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBuZXh0UmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGN1cnJlbnRSZWR1Y2VyID0gbmV4dFJlZHVjZXI7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVyb3BlcmFiaWxpdHkgcG9pbnQgZm9yIG9ic2VydmFibGUvcmVhY3RpdmUgbGlicmFyaWVzLlxuICAgKiBAcmV0dXJucyB7b2JzZXJ2YWJsZX0gQSBtaW5pbWFsIG9ic2VydmFibGUgb2Ygc3RhdGUgY2hhbmdlcy5cbiAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgb2JzZXJ2YWJsZSBwcm9wb3NhbDpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxuICAgKi9cbiAgZnVuY3Rpb24gb2JzZXJ2YWJsZSgpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHZhciBvdXRlclN1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICByZXR1cm4gX3JlZiA9IHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIG1pbmltYWwgb2JzZXJ2YWJsZSBzdWJzY3JpcHRpb24gbWV0aG9kLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9ic2VydmVyIEFueSBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBvYnNlcnZlci5cbiAgICAgICAqIFRoZSBvYnNlcnZlciBvYmplY3Qgc2hvdWxkIGhhdmUgYSBgbmV4dGAgbWV0aG9kLlxuICAgICAgICogQHJldHVybnMge3N1YnNjcmlwdGlvbn0gQW4gb2JqZWN0IHdpdGggYW4gYHVuc3Vic2NyaWJlYCBtZXRob2QgdGhhdCBjYW5cbiAgICAgICAqIGJlIHVzZWQgdG8gdW5zdWJzY3JpYmUgdGhlIG9ic2VydmFibGUgZnJvbSB0aGUgc3RvcmUsIGFuZCBwcmV2ZW50IGZ1cnRoZXJcbiAgICAgICAqIGVtaXNzaW9uIG9mIHZhbHVlcyBmcm9tIHRoZSBvYnNlcnZhYmxlLlxuICAgICAgICovXG4gICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgICAgICBpZiAodHlwZW9mIG9ic2VydmVyICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHRoZSBvYnNlcnZlciB0byBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvYnNlcnZlU3RhdGUoKSB7XG4gICAgICAgICAgaWYgKG9ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZ2V0U3RhdGUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JzZXJ2ZVN0YXRlKCk7XG4gICAgICAgIHZhciB1bnN1YnNjcmliZSA9IG91dGVyU3Vic2NyaWJlKG9ic2VydmVTdGF0ZSk7XG4gICAgICAgIHJldHVybiB7IHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZSB9O1xuICAgICAgfVxuICAgIH0sIF9yZWZbJCRvYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIF9yZWY7XG4gIH1cblxuICAvLyBXaGVuIGEgc3RvcmUgaXMgY3JlYXRlZCwgYW4gXCJJTklUXCIgYWN0aW9uIGlzIGRpc3BhdGNoZWQgc28gdGhhdCBldmVyeVxuICAvLyByZWR1Y2VyIHJldHVybnMgdGhlaXIgaW5pdGlhbCBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgLy8gdGhlIGluaXRpYWwgc3RhdGUgdHJlZS5cbiAgZGlzcGF0Y2goeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gIHJldHVybiBfcmVmMiA9IHtcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyOiByZXBsYWNlUmVkdWNlclxuICB9LCBfcmVmMlskJG9ic2VydmFibGVdID0gb2JzZXJ2YWJsZSwgX3JlZjI7XG59IiwiLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4gIH0gY2F0Y2ggKGUpIHt9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tZW1wdHkgKi9cbn0iLCJpbXBvcnQgeyBBY3Rpb25UeXBlcyB9IGZyb20gJy4vY3JlYXRlU3RvcmUnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi91dGlscy93YXJuaW5nJztcblxuZnVuY3Rpb24gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2Uoa2V5LCBhY3Rpb24pIHtcbiAgdmFyIGFjdGlvblR5cGUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGU7XG4gIHZhciBhY3Rpb25OYW1lID0gYWN0aW9uVHlwZSAmJiAnXCInICsgYWN0aW9uVHlwZS50b1N0cmluZygpICsgJ1wiJyB8fCAnYW4gYWN0aW9uJztcblxuICByZXR1cm4gJ0dpdmVuIGFjdGlvbiAnICsgYWN0aW9uTmFtZSArICcsIHJlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZC4gJyArICdUbyBpZ25vcmUgYW4gYWN0aW9uLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuJztcbn1cblxuZnVuY3Rpb24gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShpbnB1dFN0YXRlLCByZWR1Y2VycywgYWN0aW9uLCB1bmV4cGVjdGVkS2V5Q2FjaGUpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgYXJndW1lbnROYW1lID0gYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBBY3Rpb25UeXBlcy5JTklUID8gJ3ByZWxvYWRlZFN0YXRlIGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTdG9yZScgOiAncHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXInO1xuXG4gIGlmIChyZWR1Y2VyS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ1N0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCAnICsgJ3RvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy4nO1xuICB9XG5cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGlucHV0U3RhdGUpKSB7XG4gICAgcmV0dXJuICdUaGUgJyArIGFyZ3VtZW50TmFtZSArICcgaGFzIHVuZXhwZWN0ZWQgdHlwZSBvZiBcIicgKyB7fS50b1N0cmluZy5jYWxsKGlucHV0U3RhdGUpLm1hdGNoKC9cXHMoW2EtenxBLVpdKykvKVsxXSArICdcIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyAnICsgKCdrZXlzOiBcIicgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArICdcIicpO1xuICB9XG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gIXJlZHVjZXJzLmhhc093blByb3BlcnR5KGtleSkgJiYgIXVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldO1xuICB9KTtcblxuICB1bmV4cGVjdGVkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XSA9IHRydWU7XG4gIH0pO1xuXG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuICdVbmV4cGVjdGVkICcgKyAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMSA/ICdrZXlzJyA6ICdrZXknKSArICcgJyArICgnXCInICsgdW5leHBlY3RlZEtleXMuam9pbignXCIsIFwiJykgKyAnXCIgZm91bmQgaW4gJyArIGFyZ3VtZW50TmFtZSArICcuICcpICsgJ0V4cGVjdGVkIHRvIGZpbmQgb25lIG9mIHRoZSBrbm93biByZWR1Y2VyIGtleXMgaW5zdGVhZDogJyArICgnXCInICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyAnXCIuIFVuZXhwZWN0ZWQga2V5cyB3aWxsIGJlIGlnbm9yZWQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVkdWNlclNhbml0eShyZWR1Y2Vycykge1xuICBPYmplY3Qua2V5cyhyZWR1Y2VycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHJlZHVjZXIgPSByZWR1Y2Vyc1trZXldO1xuICAgIHZhciBpbml0aWFsU3RhdGUgPSByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiBBY3Rpb25UeXBlcy5JTklUIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXIgXCInICsga2V5ICsgJ1wiIHJldHVybmVkIHVuZGVmaW5lZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uICcgKyAnSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0ICcgKyAnZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSAnICsgJ25vdCBiZSB1bmRlZmluZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSAnQEByZWR1eC9QUk9CRV9VTktOT1dOX0FDVElPTl8nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpLnNwbGl0KCcnKS5qb2luKCcuJyk7XG4gICAgaWYgKHR5cGVvZiByZWR1Y2VyKHVuZGVmaW5lZCwgeyB0eXBlOiB0eXBlIH0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VyIFwiJyArIGtleSArICdcIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBwcm9iZWQgd2l0aCBhIHJhbmRvbSB0eXBlLiAnICsgKCdEb25cXCd0IHRyeSB0byBoYW5kbGUgJyArIEFjdGlvblR5cGVzLklOSVQgKyAnIG9yIG90aGVyIGFjdGlvbnMgaW4gXCJyZWR1eC8qXCIgJykgKyAnbmFtZXNwYWNlLiBUaGV5IGFyZSBjb25zaWRlcmVkIHByaXZhdGUuIEluc3RlYWQsIHlvdSBtdXN0IHJldHVybiB0aGUgJyArICdjdXJyZW50IHN0YXRlIGZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCAnICsgJ2luIHdoaWNoIGNhc2UgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLCByZWdhcmRsZXNzIG9mIHRoZSAnICsgJ2FjdGlvbiB0eXBlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4nKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGRpZmZlcmVudCByZWR1Y2VyIGZ1bmN0aW9ucywgaW50byBhIHNpbmdsZVxuICogcmVkdWNlciBmdW5jdGlvbi4gSXQgd2lsbCBjYWxsIGV2ZXJ5IGNoaWxkIHJlZHVjZXIsIGFuZCBnYXRoZXIgdGhlaXIgcmVzdWx0c1xuICogaW50byBhIHNpbmdsZSBzdGF0ZSBvYmplY3QsIHdob3NlIGtleXMgY29ycmVzcG9uZCB0byB0aGUga2V5cyBvZiB0aGUgcGFzc2VkXG4gKiByZWR1Y2VyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVkdWNlcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBjb3JyZXNwb25kIHRvIGRpZmZlcmVudFxuICogcmVkdWNlciBmdW5jdGlvbnMgdGhhdCBuZWVkIHRvIGJlIGNvbWJpbmVkIGludG8gb25lLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpblxuICogaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXMgcmVkdWNlcnNgIHN5bnRheC4gVGhlIHJlZHVjZXJzIG1heSBuZXZlciByZXR1cm5cbiAqIHVuZGVmaW5lZCBmb3IgYW55IGFjdGlvbi4gSW5zdGVhZCwgdGhleSBzaG91bGQgcmV0dXJuIHRoZWlyIGluaXRpYWwgc3RhdGVcbiAqIGlmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlbSB3YXMgdW5kZWZpbmVkLCBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgZm9yIGFueVxuICogdW5yZWNvZ25pemVkIGFjdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgcmVkdWNlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgZXZlcnkgcmVkdWNlciBpbnNpZGUgdGhlXG4gKiBwYXNzZWQgb2JqZWN0LCBhbmQgYnVpbGRzIGEgc3RhdGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbWJpbmVSZWR1Y2VycyhyZWR1Y2Vycykge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBmaW5hbFJlZHVjZXJzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gcmVkdWNlcktleXNbaV07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuaW5nKCdObyByZWR1Y2VyIHByb3ZpZGVkIGZvciBrZXkgXCInICsga2V5ICsgJ1wiJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmaW5hbFJlZHVjZXJzW2tleV0gPSByZWR1Y2Vyc1trZXldO1xuICAgIH1cbiAgfVxuICB2YXIgZmluYWxSZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKGZpbmFsUmVkdWNlcnMpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIHVuZXhwZWN0ZWRLZXlDYWNoZSA9IHt9O1xuICB9XG5cbiAgdmFyIHNhbml0eUVycm9yO1xuICB0cnkge1xuICAgIGFzc2VydFJlZHVjZXJTYW5pdHkoZmluYWxSZWR1Y2Vycyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzYW5pdHlFcnJvciA9IGU7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gY29tYmluYXRpb24oKSB7XG4gICAgdmFyIHN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gICAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50c1sxXTtcblxuICAgIGlmIChzYW5pdHlFcnJvcikge1xuICAgICAgdGhyb3cgc2FuaXR5RXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB3YXJuaW5nTWVzc2FnZSA9IGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2Uoc3RhdGUsIGZpbmFsUmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKTtcbiAgICAgIGlmICh3YXJuaW5nTWVzc2FnZSkge1xuICAgICAgICB3YXJuaW5nKHdhcm5pbmdNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBuZXh0U3RhdGUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBmaW5hbFJlZHVjZXJLZXlzW2ldO1xuICAgICAgdmFyIHJlZHVjZXIgPSBmaW5hbFJlZHVjZXJzW2tleV07XG4gICAgICB2YXIgcHJldmlvdXNTdGF0ZUZvcktleSA9IHN0YXRlW2tleV07XG4gICAgICB2YXIgbmV4dFN0YXRlRm9yS2V5ID0gcmVkdWNlcihwcmV2aW91c1N0YXRlRm9yS2V5LCBhY3Rpb24pO1xuICAgICAgaWYgKHR5cGVvZiBuZXh0U3RhdGVGb3JLZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShrZXksIGFjdGlvbik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgbmV4dFN0YXRlW2tleV0gPSBuZXh0U3RhdGVGb3JLZXk7XG4gICAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBuZXh0U3RhdGVGb3JLZXkgIT09IHByZXZpb3VzU3RhdGVGb3JLZXk7XG4gICAgfVxuICAgIHJldHVybiBoYXNDaGFuZ2VkID8gbmV4dFN0YXRlIDogc3RhdGU7XG4gIH07XG59IiwiZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2goYWN0aW9uQ3JlYXRvci5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuXG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvbiBjcmVhdG9ycywgaW50byBhbiBvYmplY3Qgd2l0aCB0aGVcbiAqIHNhbWUga2V5cywgYnV0IHdpdGggZXZlcnkgZnVuY3Rpb24gd3JhcHBlZCBpbnRvIGEgYGRpc3BhdGNoYCBjYWxsIHNvIHRoZXlcbiAqIG1heSBiZSBpbnZva2VkIGRpcmVjdGx5LiBUaGlzIGlzIGp1c3QgYSBjb252ZW5pZW5jZSBtZXRob2QsIGFzIHlvdSBjYW4gY2FsbFxuICogYHN0b3JlLmRpc3BhdGNoKE15QWN0aW9uQ3JlYXRvcnMuZG9Tb21ldGhpbmcoKSlgIHlvdXJzZWxmIGp1c3QgZmluZS5cbiAqXG4gKiBGb3IgY29udmVuaWVuY2UsIHlvdSBjYW4gYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCxcbiAqIGFuZCBnZXQgYSBmdW5jdGlvbiBpbiByZXR1cm4uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IGFjdGlvbkNyZWF0b3JzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvblxuICogY3JlYXRvciBmdW5jdGlvbnMuIE9uZSBoYW5keSB3YXkgdG8gb2J0YWluIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzYFxuICogc3ludGF4LiBZb3UgbWF5IGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXNwYXRjaCBUaGUgYGRpc3BhdGNoYCBmdW5jdGlvbiBhdmFpbGFibGUgb24geW91ciBSZWR1eFxuICogc3RvcmUuXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufE9iamVjdH0gVGhlIG9iamVjdCBtaW1pY2tpbmcgdGhlIG9yaWdpbmFsIG9iamVjdCwgYnV0IHdpdGhcbiAqIGV2ZXJ5IGFjdGlvbiBjcmVhdG9yIHdyYXBwZWQgaW50byB0aGUgYGRpc3BhdGNoYCBjYWxsLiBJZiB5b3UgcGFzc2VkIGFcbiAqIGZ1bmN0aW9uIGFzIGBhY3Rpb25DcmVhdG9yc2AsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBhbHNvIGJlIGEgc2luZ2xlXG4gKiBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCkge1xuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzICE9PSAnb2JqZWN0JyB8fCBhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYmluZEFjdGlvbkNyZWF0b3JzIGV4cGVjdGVkIGFuIG9iamVjdCBvciBhIGZ1bmN0aW9uLCBpbnN0ZWFkIHJlY2VpdmVkICcgKyAoYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgYWN0aW9uQ3JlYXRvcnMpICsgJy4gJyArICdEaWQgeW91IHdyaXRlIFwiaW1wb3J0IEFjdGlvbkNyZWF0b3JzIGZyb21cIiBpbnN0ZWFkIG9mIFwiaW1wb3J0ICogYXMgQWN0aW9uQ3JlYXRvcnMgZnJvbVwiPycpO1xuICB9XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhY3Rpb25DcmVhdG9ycyk7XG4gIHZhciBib3VuZEFjdGlvbkNyZWF0b3JzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIHZhciBhY3Rpb25DcmVhdG9yID0gYWN0aW9uQ3JlYXRvcnNba2V5XTtcbiAgICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJvdW5kQWN0aW9uQ3JlYXRvcnNba2V5XSA9IGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kQWN0aW9uQ3JlYXRvcnM7XG59IiwiLyoqXG4gKiBDb21wb3NlcyBzaW5nbGUtYXJndW1lbnQgZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC4gVGhlIHJpZ2h0bW9zdFxuICogZnVuY3Rpb24gY2FuIHRha2UgbXVsdGlwbGUgYXJndW1lbnRzIGFzIGl0IHByb3ZpZGVzIHRoZSBzaWduYXR1cmUgZm9yXG4gKiB0aGUgcmVzdWx0aW5nIGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jcyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gb2J0YWluZWQgYnkgY29tcG9zaW5nIHRoZSBhcmd1bWVudCBmdW5jdGlvbnNcbiAqIGZyb20gcmlnaHQgdG8gbGVmdC4gRm9yIGV4YW1wbGUsIGNvbXBvc2UoZiwgZywgaCkgaXMgaWRlbnRpY2FsIHRvIGRvaW5nXG4gKiAoLi4uYXJncykgPT4gZihnKGgoLi4uYXJncykpKS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wb3NlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIGFyZztcbiAgICB9O1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmdW5jc1swXTtcbiAgfVxuXG4gIHZhciBsYXN0ID0gZnVuY3NbZnVuY3MubGVuZ3RoIC0gMV07XG4gIHZhciByZXN0ID0gZnVuY3Muc2xpY2UoMCwgLTEpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXN0LnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChjb21wb3NlZCwgZikge1xuICAgICAgcmV0dXJuIGYoY29tcG9zZWQpO1xuICAgIH0sIGxhc3QuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfTtcbn0iLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgY29tcG9zZSBmcm9tICcuL2NvbXBvc2UnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdG9yZSBlbmhhbmNlciB0aGF0IGFwcGxpZXMgbWlkZGxld2FyZSB0byB0aGUgZGlzcGF0Y2ggbWV0aG9kXG4gKiBvZiB0aGUgUmVkdXggc3RvcmUuIFRoaXMgaXMgaGFuZHkgZm9yIGEgdmFyaWV0eSBvZiB0YXNrcywgc3VjaCBhcyBleHByZXNzaW5nXG4gKiBhc3luY2hyb25vdXMgYWN0aW9ucyBpbiBhIGNvbmNpc2UgbWFubmVyLCBvciBsb2dnaW5nIGV2ZXJ5IGFjdGlvbiBwYXlsb2FkLlxuICpcbiAqIFNlZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UgYXMgYW4gZXhhbXBsZSBvZiB0aGUgUmVkdXggbWlkZGxld2FyZS5cbiAqXG4gKiBCZWNhdXNlIG1pZGRsZXdhcmUgaXMgcG90ZW50aWFsbHkgYXN5bmNocm9ub3VzLCB0aGlzIHNob3VsZCBiZSB0aGUgZmlyc3RcbiAqIHN0b3JlIGVuaGFuY2VyIGluIHRoZSBjb21wb3NpdGlvbiBjaGFpbi5cbiAqXG4gKiBOb3RlIHRoYXQgZWFjaCBtaWRkbGV3YXJlIHdpbGwgYmUgZ2l2ZW4gdGhlIGBkaXNwYXRjaGAgYW5kIGBnZXRTdGF0ZWAgZnVuY3Rpb25zXG4gKiBhcyBuYW1lZCBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gbWlkZGxld2FyZXMgVGhlIG1pZGRsZXdhcmUgY2hhaW4gdG8gYmUgYXBwbGllZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBzdG9yZSBlbmhhbmNlciBhcHBseWluZyB0aGUgbWlkZGxld2FyZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBtaWRkbGV3YXJlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoY3JlYXRlU3RvcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlLCBlbmhhbmNlcikge1xuICAgICAgdmFyIHN0b3JlID0gY3JlYXRlU3RvcmUocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKTtcbiAgICAgIHZhciBfZGlzcGF0Y2ggPSBzdG9yZS5kaXNwYXRjaDtcbiAgICAgIHZhciBjaGFpbiA9IFtdO1xuXG4gICAgICB2YXIgbWlkZGxld2FyZUFQSSA9IHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIF9kaXNwYXRjaChhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhaW4gPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUobWlkZGxld2FyZUFQSSk7XG4gICAgICB9KTtcbiAgICAgIF9kaXNwYXRjaCA9IGNvbXBvc2UuYXBwbHkodW5kZWZpbmVkLCBjaGFpbikoc3RvcmUuZGlzcGF0Y2gpO1xuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHN0b3JlLCB7XG4gICAgICAgIGRpc3BhdGNoOiBfZGlzcGF0Y2hcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG59IiwiaW1wb3J0IGNyZWF0ZVN0b3JlIGZyb20gJy4vY3JlYXRlU3RvcmUnO1xuaW1wb3J0IGNvbWJpbmVSZWR1Y2VycyBmcm9tICcuL2NvbWJpbmVSZWR1Y2Vycyc7XG5pbXBvcnQgYmluZEFjdGlvbkNyZWF0b3JzIGZyb20gJy4vYmluZEFjdGlvbkNyZWF0b3JzJztcbmltcG9ydCBhcHBseU1pZGRsZXdhcmUgZnJvbSAnLi9hcHBseU1pZGRsZXdhcmUnO1xuaW1wb3J0IGNvbXBvc2UgZnJvbSAnLi9jb21wb3NlJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4vdXRpbHMvd2FybmluZyc7XG5cbi8qXG4qIFRoaXMgaXMgYSBkdW1teSBmdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgZnVuY3Rpb24gbmFtZSBoYXMgYmVlbiBhbHRlcmVkIGJ5IG1pbmlmaWNhdGlvbi5cbiogSWYgdGhlIGZ1bmN0aW9uIGhhcyBiZWVuIG1pbmlmaWVkIGFuZCBOT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLCB3YXJuIHRoZSB1c2VyLlxuKi9cbmZ1bmN0aW9uIGlzQ3J1c2hlZCgpIHt9XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBpc0NydXNoZWQubmFtZSA9PT0gJ3N0cmluZycgJiYgaXNDcnVzaGVkLm5hbWUgIT09ICdpc0NydXNoZWQnKSB7XG4gIHdhcm5pbmcoJ1lvdSBhcmUgY3VycmVudGx5IHVzaW5nIG1pbmlmaWVkIGNvZGUgb3V0c2lkZSBvZiBOT0RFX0VOViA9PT0gXFwncHJvZHVjdGlvblxcJy4gJyArICdUaGlzIG1lYW5zIHRoYXQgeW91IGFyZSBydW5uaW5nIGEgc2xvd2VyIGRldmVsb3BtZW50IGJ1aWxkIG9mIFJlZHV4LiAnICsgJ1lvdSBjYW4gdXNlIGxvb3NlLWVudmlmeSAoaHR0cHM6Ly9naXRodWIuY29tL3plcnRvc2gvbG9vc2UtZW52aWZ5KSBmb3IgYnJvd3NlcmlmeSAnICsgJ29yIERlZmluZVBsdWdpbiBmb3Igd2VicGFjayAoaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMDAzMDAzMSkgJyArICd0byBlbnN1cmUgeW91IGhhdmUgdGhlIGNvcnJlY3QgY29kZSBmb3IgeW91ciBwcm9kdWN0aW9uIGJ1aWxkLicpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVTdG9yZSwgY29tYmluZVJlZHVjZXJzLCBiaW5kQWN0aW9uQ3JlYXRvcnMsIGFwcGx5TWlkZGxld2FyZSwgY29tcG9zZSB9OyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gd3JhcEFjdGlvbkNyZWF0b3JzO1xuXG52YXIgX3JlZHV4ID0gcmVxdWlyZSgncmVkdXgnKTtcblxuZnVuY3Rpb24gd3JhcEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4gKDAsIF9yZWR1eC5iaW5kQWN0aW9uQ3JlYXRvcnMpKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCk7XG4gIH07XG59IiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICB2YWx1ZSA9IE9iamVjdCh2YWx1ZSk7XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gdmFsdWUpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZGlzcGxheU5hbWU6IHRydWUsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIG1peGluczogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWUsXG4gICAgdHlwZTogdHJ1ZVxufTtcblxudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gICAgbmFtZTogdHJ1ZSxcbiAgICBsZW5ndGg6IHRydWUsXG4gICAgcHJvdG90eXBlOiB0cnVlLFxuICAgIGNhbGxlcjogdHJ1ZSxcbiAgICBhcmd1bWVudHM6IHRydWUsXG4gICAgYXJpdHk6IHRydWVcbn07XG5cbnZhciBpc0dldE93blByb3BlcnR5U3ltYm9sc0F2YWlsYWJsZSA9IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBjdXN0b21TdGF0aWNzKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7IC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHNBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIVJFQUNUX1NUQVRJQ1Nba2V5c1tpXV0gJiYgIUtOT1dOX1NUQVRJQ1Nba2V5c1tpXV0gJiYgKCFjdXN0b21TdGF0aWNzIHx8ICFjdXN0b21TdGF0aWNzW2tleXNbaV1dKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENvbXBvbmVudFtrZXlzW2ldXSA9IHNvdXJjZUNvbXBvbmVudFtrZXlzW2ldXTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBOT0RFX0VOViA9IHByb2Nlc3MuZW52Lk5PREVfRU5WO1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKE5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBjb25uZWN0O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9zdG9yZVNoYXBlID0gcmVxdWlyZSgnLi4vdXRpbHMvc3RvcmVTaGFwZScpO1xuXG52YXIgX3N0b3JlU2hhcGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RvcmVTaGFwZSk7XG5cbnZhciBfc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnLi4vdXRpbHMvc2hhbGxvd0VxdWFsJyk7XG5cbnZhciBfc2hhbGxvd0VxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYWxsb3dFcXVhbCk7XG5cbnZhciBfd3JhcEFjdGlvbkNyZWF0b3JzID0gcmVxdWlyZSgnLi4vdXRpbHMvd3JhcEFjdGlvbkNyZWF0b3JzJyk7XG5cbnZhciBfd3JhcEFjdGlvbkNyZWF0b3JzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dyYXBBY3Rpb25DcmVhdG9ycyk7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJy4uL3V0aWxzL3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKCdsb2Rhc2gvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XG5cbnZhciBfaG9pc3ROb25SZWFjdFN0YXRpY3MgPSByZXF1aXJlKCdob2lzdC1ub24tcmVhY3Qtc3RhdGljcycpO1xuXG52YXIgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hvaXN0Tm9uUmVhY3RTdGF0aWNzKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGRlZmF1bHRNYXBTdGF0ZVRvUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0TWFwU3RhdGVUb1Byb3BzKHN0YXRlKSB7XG4gIHJldHVybiB7fTtcbn07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBkZWZhdWx0TWFwRGlzcGF0Y2hUb1Byb3BzID0gZnVuY3Rpb24gZGVmYXVsdE1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCkge1xuICByZXR1cm4geyBkaXNwYXRjaDogZGlzcGF0Y2ggfTtcbn07XG52YXIgZGVmYXVsdE1lcmdlUHJvcHMgPSBmdW5jdGlvbiBkZWZhdWx0TWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBwYXJlbnRQcm9wcykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIHBhcmVudFByb3BzLCBzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzKTtcbn07XG5cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpIHtcbiAgcmV0dXJuIFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xufVxuXG52YXIgZXJyb3JPYmplY3QgPSB7IHZhbHVlOiBudWxsIH07XG5mdW5jdGlvbiB0cnlDYXRjaChmbiwgY3R4KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGN0eCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvck9iamVjdC52YWx1ZSA9IGU7XG4gICAgcmV0dXJuIGVycm9yT2JqZWN0O1xuICB9XG59XG5cbi8vIEhlbHBzIHRyYWNrIGhvdCByZWxvYWRpbmcuXG52YXIgbmV4dFZlcnNpb24gPSAwO1xuXG5mdW5jdGlvbiBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcblxuICB2YXIgc2hvdWxkU3Vic2NyaWJlID0gQm9vbGVhbihtYXBTdGF0ZVRvUHJvcHMpO1xuICB2YXIgbWFwU3RhdGUgPSBtYXBTdGF0ZVRvUHJvcHMgfHwgZGVmYXVsdE1hcFN0YXRlVG9Qcm9wcztcblxuICB2YXIgbWFwRGlzcGF0Y2ggPSB2b2lkIDA7XG4gIGlmICh0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbWFwRGlzcGF0Y2ggPSBtYXBEaXNwYXRjaFRvUHJvcHM7XG4gIH0gZWxzZSBpZiAoIW1hcERpc3BhdGNoVG9Qcm9wcykge1xuICAgIG1hcERpc3BhdGNoID0gZGVmYXVsdE1hcERpc3BhdGNoVG9Qcm9wcztcbiAgfSBlbHNlIHtcbiAgICBtYXBEaXNwYXRjaCA9ICgwLCBfd3JhcEFjdGlvbkNyZWF0b3JzMltcImRlZmF1bHRcIl0pKG1hcERpc3BhdGNoVG9Qcm9wcyk7XG4gIH1cblxuICB2YXIgZmluYWxNZXJnZVByb3BzID0gbWVyZ2VQcm9wcyB8fCBkZWZhdWx0TWVyZ2VQcm9wcztcbiAgdmFyIF9vcHRpb25zJHB1cmUgPSBvcHRpb25zLnB1cmUsXG4gICAgICBwdXJlID0gX29wdGlvbnMkcHVyZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IF9vcHRpb25zJHB1cmUsXG4gICAgICBfb3B0aW9ucyR3aXRoUmVmID0gb3B0aW9ucy53aXRoUmVmLFxuICAgICAgd2l0aFJlZiA9IF9vcHRpb25zJHdpdGhSZWYgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX29wdGlvbnMkd2l0aFJlZjtcblxuICB2YXIgY2hlY2tNZXJnZWRFcXVhbHMgPSBwdXJlICYmIGZpbmFsTWVyZ2VQcm9wcyAhPT0gZGVmYXVsdE1lcmdlUHJvcHM7XG5cbiAgLy8gSGVscHMgdHJhY2sgaG90IHJlbG9hZGluZy5cbiAgdmFyIHZlcnNpb24gPSBuZXh0VmVyc2lvbisrO1xuXG4gIHJldHVybiBmdW5jdGlvbiB3cmFwV2l0aENvbm5lY3QoV3JhcHBlZENvbXBvbmVudCkge1xuICAgIHZhciBjb25uZWN0RGlzcGxheU5hbWUgPSAnQ29ubmVjdCgnICsgZ2V0RGlzcGxheU5hbWUoV3JhcHBlZENvbXBvbmVudCkgKyAnKSc7XG5cbiAgICBmdW5jdGlvbiBjaGVja1N0YXRlU2hhcGUocHJvcHMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIGlmICghKDAsIF9pc1BsYWluT2JqZWN0MltcImRlZmF1bHRcIl0pKHByb3BzKSkge1xuICAgICAgICAoMCwgX3dhcm5pbmcyW1wiZGVmYXVsdFwiXSkobWV0aG9kTmFtZSArICcoKSBpbiAnICsgY29ubmVjdERpc3BsYXlOYW1lICsgJyBtdXN0IHJldHVybiBhIHBsYWluIG9iamVjdC4gJyArICgnSW5zdGVhZCByZWNlaXZlZCAnICsgcHJvcHMgKyAnLicpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTWVyZ2VkUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgcGFyZW50UHJvcHMpIHtcbiAgICAgIHZhciBtZXJnZWRQcm9wcyA9IGZpbmFsTWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBwYXJlbnRQcm9wcyk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjaGVja1N0YXRlU2hhcGUobWVyZ2VkUHJvcHMsICdtZXJnZVByb3BzJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VkUHJvcHM7XG4gICAgfVxuXG4gICAgdmFyIENvbm5lY3QgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgICAgX2luaGVyaXRzKENvbm5lY3QsIF9Db21wb25lbnQpO1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKSB7XG4gICAgICAgIHJldHVybiAhcHVyZSB8fCB0aGlzLmhhdmVPd25Qcm9wc0NoYW5nZWQgfHwgdGhpcy5oYXNTdG9yZVN0YXRlQ2hhbmdlZDtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIENvbm5lY3QocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbm5lY3QpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkpO1xuXG4gICAgICAgIF90aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICBfdGhpcy5zdG9yZSA9IHByb3BzLnN0b3JlIHx8IGNvbnRleHQuc3RvcmU7XG5cbiAgICAgICAgKDAsIF9pbnZhcmlhbnQyW1wiZGVmYXVsdFwiXSkoX3RoaXMuc3RvcmUsICdDb3VsZCBub3QgZmluZCBcInN0b3JlXCIgaW4gZWl0aGVyIHRoZSBjb250ZXh0IG9yICcgKyAoJ3Byb3BzIG9mIFwiJyArIGNvbm5lY3REaXNwbGF5TmFtZSArICdcIi4gJykgKyAnRWl0aGVyIHdyYXAgdGhlIHJvb3QgY29tcG9uZW50IGluIGEgPFByb3ZpZGVyPiwgJyArICgnb3IgZXhwbGljaXRseSBwYXNzIFwic3RvcmVcIiBhcyBhIHByb3AgdG8gXCInICsgY29ubmVjdERpc3BsYXlOYW1lICsgJ1wiLicpKTtcblxuICAgICAgICB2YXIgc3RvcmVTdGF0ZSA9IF90aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIF90aGlzLnN0YXRlID0geyBzdG9yZVN0YXRlOiBzdG9yZVN0YXRlIH07XG4gICAgICAgIF90aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfVxuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wdXRlU3RhdGVQcm9wcyA9IGZ1bmN0aW9uIGNvbXB1dGVTdGF0ZVByb3BzKHN0b3JlLCBwcm9wcykge1xuICAgICAgICBpZiAoIXRoaXMuZmluYWxNYXBTdGF0ZVRvUHJvcHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmVGaW5hbE1hcFN0YXRlKHN0b3JlLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICB2YXIgc3RhdGVQcm9wcyA9IHRoaXMuZG9TdGF0ZVByb3BzRGVwZW5kT25Pd25Qcm9wcyA/IHRoaXMuZmluYWxNYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIHByb3BzKSA6IHRoaXMuZmluYWxNYXBTdGF0ZVRvUHJvcHMoc3RhdGUpO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tTdGF0ZVNoYXBlKHN0YXRlUHJvcHMsICdtYXBTdGF0ZVRvUHJvcHMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGVQcm9wcztcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbmZpZ3VyZUZpbmFsTWFwU3RhdGUgPSBmdW5jdGlvbiBjb25maWd1cmVGaW5hbE1hcFN0YXRlKHN0b3JlLCBwcm9wcykge1xuICAgICAgICB2YXIgbWFwcGVkU3RhdGUgPSBtYXBTdGF0ZShzdG9yZS5nZXRTdGF0ZSgpLCBwcm9wcyk7XG4gICAgICAgIHZhciBpc0ZhY3RvcnkgPSB0eXBlb2YgbWFwcGVkU3RhdGUgPT09ICdmdW5jdGlvbic7XG5cbiAgICAgICAgdGhpcy5maW5hbE1hcFN0YXRlVG9Qcm9wcyA9IGlzRmFjdG9yeSA/IG1hcHBlZFN0YXRlIDogbWFwU3RhdGU7XG4gICAgICAgIHRoaXMuZG9TdGF0ZVByb3BzRGVwZW5kT25Pd25Qcm9wcyA9IHRoaXMuZmluYWxNYXBTdGF0ZVRvUHJvcHMubGVuZ3RoICE9PSAxO1xuXG4gICAgICAgIGlmIChpc0ZhY3RvcnkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlU3RhdGVQcm9wcyhzdG9yZSwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjaGVja1N0YXRlU2hhcGUobWFwcGVkU3RhdGUsICdtYXBTdGF0ZVRvUHJvcHMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwcGVkU3RhdGU7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wdXRlRGlzcGF0Y2hQcm9wcyA9IGZ1bmN0aW9uIGNvbXB1dGVEaXNwYXRjaFByb3BzKHN0b3JlLCBwcm9wcykge1xuICAgICAgICBpZiAoIXRoaXMuZmluYWxNYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmVGaW5hbE1hcERpc3BhdGNoKHN0b3JlLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlzcGF0Y2ggPSBzdG9yZS5kaXNwYXRjaDtcblxuICAgICAgICB2YXIgZGlzcGF0Y2hQcm9wcyA9IHRoaXMuZG9EaXNwYXRjaFByb3BzRGVwZW5kT25Pd25Qcm9wcyA/IHRoaXMuZmluYWxNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIHByb3BzKSA6IHRoaXMuZmluYWxNYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gpO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tTdGF0ZVNoYXBlKGRpc3BhdGNoUHJvcHMsICdtYXBEaXNwYXRjaFRvUHJvcHMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlzcGF0Y2hQcm9wcztcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbmZpZ3VyZUZpbmFsTWFwRGlzcGF0Y2ggPSBmdW5jdGlvbiBjb25maWd1cmVGaW5hbE1hcERpc3BhdGNoKHN0b3JlLCBwcm9wcykge1xuICAgICAgICB2YXIgbWFwcGVkRGlzcGF0Y2ggPSBtYXBEaXNwYXRjaChzdG9yZS5kaXNwYXRjaCwgcHJvcHMpO1xuICAgICAgICB2YXIgaXNGYWN0b3J5ID0gdHlwZW9mIG1hcHBlZERpc3BhdGNoID09PSAnZnVuY3Rpb24nO1xuXG4gICAgICAgIHRoaXMuZmluYWxNYXBEaXNwYXRjaFRvUHJvcHMgPSBpc0ZhY3RvcnkgPyBtYXBwZWREaXNwYXRjaCA6IG1hcERpc3BhdGNoO1xuICAgICAgICB0aGlzLmRvRGlzcGF0Y2hQcm9wc0RlcGVuZE9uT3duUHJvcHMgPSB0aGlzLmZpbmFsTWFwRGlzcGF0Y2hUb1Byb3BzLmxlbmd0aCAhPT0gMTtcblxuICAgICAgICBpZiAoaXNGYWN0b3J5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZURpc3BhdGNoUHJvcHMoc3RvcmUsIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY2hlY2tTdGF0ZVNoYXBlKG1hcHBlZERpc3BhdGNoLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcHBlZERpc3BhdGNoO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUudXBkYXRlU3RhdGVQcm9wc0lmTmVlZGVkID0gZnVuY3Rpb24gdXBkYXRlU3RhdGVQcm9wc0lmTmVlZGVkKCkge1xuICAgICAgICB2YXIgbmV4dFN0YXRlUHJvcHMgPSB0aGlzLmNvbXB1dGVTdGF0ZVByb3BzKHRoaXMuc3RvcmUsIHRoaXMucHJvcHMpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZVByb3BzICYmICgwLCBfc2hhbGxvd0VxdWFsMltcImRlZmF1bHRcIl0pKG5leHRTdGF0ZVByb3BzLCB0aGlzLnN0YXRlUHJvcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZVByb3BzID0gbmV4dFN0YXRlUHJvcHM7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUudXBkYXRlRGlzcGF0Y2hQcm9wc0lmTmVlZGVkID0gZnVuY3Rpb24gdXBkYXRlRGlzcGF0Y2hQcm9wc0lmTmVlZGVkKCkge1xuICAgICAgICB2YXIgbmV4dERpc3BhdGNoUHJvcHMgPSB0aGlzLmNvbXB1dGVEaXNwYXRjaFByb3BzKHRoaXMuc3RvcmUsIHRoaXMucHJvcHMpO1xuICAgICAgICBpZiAodGhpcy5kaXNwYXRjaFByb3BzICYmICgwLCBfc2hhbGxvd0VxdWFsMltcImRlZmF1bHRcIl0pKG5leHREaXNwYXRjaFByb3BzLCB0aGlzLmRpc3BhdGNoUHJvcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaFByb3BzID0gbmV4dERpc3BhdGNoUHJvcHM7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUudXBkYXRlTWVyZ2VkUHJvcHNJZk5lZWRlZCA9IGZ1bmN0aW9uIHVwZGF0ZU1lcmdlZFByb3BzSWZOZWVkZWQoKSB7XG4gICAgICAgIHZhciBuZXh0TWVyZ2VkUHJvcHMgPSBjb21wdXRlTWVyZ2VkUHJvcHModGhpcy5zdGF0ZVByb3BzLCB0aGlzLmRpc3BhdGNoUHJvcHMsIHRoaXMucHJvcHMpO1xuICAgICAgICBpZiAodGhpcy5tZXJnZWRQcm9wcyAmJiBjaGVja01lcmdlZEVxdWFscyAmJiAoMCwgX3NoYWxsb3dFcXVhbDJbXCJkZWZhdWx0XCJdKShuZXh0TWVyZ2VkUHJvcHMsIHRoaXMubWVyZ2VkUHJvcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5pc1N1YnNjcmliZWQgPSBmdW5jdGlvbiBpc1N1YnNjcmliZWQoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy51bnN1YnNjcmliZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLnRyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIHRyeVN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKHNob3VsZFN1YnNjcmliZSAmJiAhdGhpcy51bnN1YnNjcmliZSkge1xuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUgPSB0aGlzLnN0b3JlLnN1YnNjcmliZSh0aGlzLmhhbmRsZUNoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS50cnlVbnN1YnNjcmliZSA9IGZ1bmN0aW9uIHRyeVVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAodGhpcy51bnN1YnNjcmliZSkge1xuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy50cnlTdWJzY3JpYmUoKTtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgICBpZiAoIXB1cmUgfHwgISgwLCBfc2hhbGxvd0VxdWFsMltcImRlZmF1bHRcIl0pKG5leHRQcm9wcywgdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICB0aGlzLmhhdmVPd25Qcm9wc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIGNsZWFyQ2FjaGUoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hQcm9wcyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGVQcm9wcyA9IG51bGw7XG4gICAgICAgIHRoaXMubWVyZ2VkUHJvcHMgPSBudWxsO1xuICAgICAgICB0aGlzLmhhdmVPd25Qcm9wc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhhc1N0b3JlU3RhdGVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oYXZlU3RhdGVQcm9wc0JlZW5QcmVjYWxjdWxhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbmRlcmVkRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZmluYWxNYXBEaXNwYXRjaFRvUHJvcHMgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbmFsTWFwU3RhdGVUb1Byb3BzID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIENvbm5lY3QucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0b3JlU3RhdGUgPSB0aGlzLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIHZhciBwcmV2U3RvcmVTdGF0ZSA9IHRoaXMuc3RhdGUuc3RvcmVTdGF0ZTtcbiAgICAgICAgaWYgKHB1cmUgJiYgcHJldlN0b3JlU3RhdGUgPT09IHN0b3JlU3RhdGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHVyZSAmJiAhdGhpcy5kb1N0YXRlUHJvcHNEZXBlbmRPbk93blByb3BzKSB7XG4gICAgICAgICAgdmFyIGhhdmVTdGF0ZVByb3BzQ2hhbmdlZCA9IHRyeUNhdGNoKHRoaXMudXBkYXRlU3RhdGVQcm9wc0lmTmVlZGVkLCB0aGlzKTtcbiAgICAgICAgICBpZiAoIWhhdmVTdGF0ZVByb3BzQ2hhbmdlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGF2ZVN0YXRlUHJvcHNDaGFuZ2VkID09PSBlcnJvck9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVByb3BzUHJlY2FsY3VsYXRpb25FcnJvciA9IGVycm9yT2JqZWN0LnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhhdmVTdGF0ZVByb3BzQmVlblByZWNhbGN1bGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYXNTdG9yZVN0YXRlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBzdG9yZVN0YXRlOiBzdG9yZVN0YXRlIH0pO1xuICAgICAgfTtcblxuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuZ2V0V3JhcHBlZEluc3RhbmNlID0gZnVuY3Rpb24gZ2V0V3JhcHBlZEluc3RhbmNlKCkge1xuICAgICAgICAoMCwgX2ludmFyaWFudDJbXCJkZWZhdWx0XCJdKSh3aXRoUmVmLCAnVG8gYWNjZXNzIHRoZSB3cmFwcGVkIGluc3RhbmNlLCB5b3UgbmVlZCB0byBzcGVjaWZ5ICcgKyAneyB3aXRoUmVmOiB0cnVlIH0gYXMgdGhlIGZvdXJ0aCBhcmd1bWVudCBvZiB0aGUgY29ubmVjdCgpIGNhbGwuJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVmcy53cmFwcGVkSW5zdGFuY2U7XG4gICAgICB9O1xuXG4gICAgICBDb25uZWN0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBoYXZlT3duUHJvcHNDaGFuZ2VkID0gdGhpcy5oYXZlT3duUHJvcHNDaGFuZ2VkLFxuICAgICAgICAgICAgaGFzU3RvcmVTdGF0ZUNoYW5nZWQgPSB0aGlzLmhhc1N0b3JlU3RhdGVDaGFuZ2VkLFxuICAgICAgICAgICAgaGF2ZVN0YXRlUHJvcHNCZWVuUHJlY2FsY3VsYXRlZCA9IHRoaXMuaGF2ZVN0YXRlUHJvcHNCZWVuUHJlY2FsY3VsYXRlZCxcbiAgICAgICAgICAgIHN0YXRlUHJvcHNQcmVjYWxjdWxhdGlvbkVycm9yID0gdGhpcy5zdGF0ZVByb3BzUHJlY2FsY3VsYXRpb25FcnJvcixcbiAgICAgICAgICAgIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMucmVuZGVyZWRFbGVtZW50O1xuXG5cbiAgICAgICAgdGhpcy5oYXZlT3duUHJvcHNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzU3RvcmVTdGF0ZUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXZlU3RhdGVQcm9wc0JlZW5QcmVjYWxjdWxhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdGVQcm9wc1ByZWNhbGN1bGF0aW9uRXJyb3IgPSBudWxsO1xuXG4gICAgICAgIGlmIChzdGF0ZVByb3BzUHJlY2FsY3VsYXRpb25FcnJvcikge1xuICAgICAgICAgIHRocm93IHN0YXRlUHJvcHNQcmVjYWxjdWxhdGlvbkVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3VsZFVwZGF0ZVN0YXRlUHJvcHMgPSB0cnVlO1xuICAgICAgICB2YXIgc2hvdWxkVXBkYXRlRGlzcGF0Y2hQcm9wcyA9IHRydWU7XG4gICAgICAgIGlmIChwdXJlICYmIHJlbmRlcmVkRWxlbWVudCkge1xuICAgICAgICAgIHNob3VsZFVwZGF0ZVN0YXRlUHJvcHMgPSBoYXNTdG9yZVN0YXRlQ2hhbmdlZCB8fCBoYXZlT3duUHJvcHNDaGFuZ2VkICYmIHRoaXMuZG9TdGF0ZVByb3BzRGVwZW5kT25Pd25Qcm9wcztcbiAgICAgICAgICBzaG91bGRVcGRhdGVEaXNwYXRjaFByb3BzID0gaGF2ZU93blByb3BzQ2hhbmdlZCAmJiB0aGlzLmRvRGlzcGF0Y2hQcm9wc0RlcGVuZE9uT3duUHJvcHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGF2ZVN0YXRlUHJvcHNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHZhciBoYXZlRGlzcGF0Y2hQcm9wc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGhhdmVTdGF0ZVByb3BzQmVlblByZWNhbGN1bGF0ZWQpIHtcbiAgICAgICAgICBoYXZlU3RhdGVQcm9wc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHNob3VsZFVwZGF0ZVN0YXRlUHJvcHMpIHtcbiAgICAgICAgICBoYXZlU3RhdGVQcm9wc0NoYW5nZWQgPSB0aGlzLnVwZGF0ZVN0YXRlUHJvcHNJZk5lZWRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRVcGRhdGVEaXNwYXRjaFByb3BzKSB7XG4gICAgICAgICAgaGF2ZURpc3BhdGNoUHJvcHNDaGFuZ2VkID0gdGhpcy51cGRhdGVEaXNwYXRjaFByb3BzSWZOZWVkZWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYXZlTWVyZ2VkUHJvcHNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGhhdmVTdGF0ZVByb3BzQ2hhbmdlZCB8fCBoYXZlRGlzcGF0Y2hQcm9wc0NoYW5nZWQgfHwgaGF2ZU93blByb3BzQ2hhbmdlZCkge1xuICAgICAgICAgIGhhdmVNZXJnZWRQcm9wc0NoYW5nZWQgPSB0aGlzLnVwZGF0ZU1lcmdlZFByb3BzSWZOZWVkZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYXZlTWVyZ2VkUHJvcHNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhhdmVNZXJnZWRQcm9wc0NoYW5nZWQgJiYgcmVuZGVyZWRFbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHJlbmRlcmVkRWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aXRoUmVmKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlZEVsZW1lbnQgPSAoMCwgX3JlYWN0LmNyZWF0ZUVsZW1lbnQpKFdyYXBwZWRDb21wb25lbnQsIF9leHRlbmRzKHt9LCB0aGlzLm1lcmdlZFByb3BzLCB7XG4gICAgICAgICAgICByZWY6ICd3cmFwcGVkSW5zdGFuY2UnXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVuZGVyZWRFbGVtZW50ID0gKDAsIF9yZWFjdC5jcmVhdGVFbGVtZW50KShXcmFwcGVkQ29tcG9uZW50LCB0aGlzLm1lcmdlZFByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVkRWxlbWVudDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBDb25uZWN0O1xuICAgIH0oX3JlYWN0LkNvbXBvbmVudCk7XG5cbiAgICBDb25uZWN0LmRpc3BsYXlOYW1lID0gY29ubmVjdERpc3BsYXlOYW1lO1xuICAgIENvbm5lY3QuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG4gICAgQ29ubmVjdC5jb250ZXh0VHlwZXMgPSB7XG4gICAgICBzdG9yZTogX3N0b3JlU2hhcGUyW1wiZGVmYXVsdFwiXVxuICAgIH07XG4gICAgQ29ubmVjdC5wcm9wVHlwZXMgPSB7XG4gICAgICBzdG9yZTogX3N0b3JlU2hhcGUyW1wiZGVmYXVsdFwiXVxuICAgIH07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgQ29ubmVjdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVcGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnZlcnNpb24gPT09IHZlcnNpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBhcmUgaG90IHJlbG9hZGluZyFcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy50cnlTdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiAoMCwgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMltcImRlZmF1bHRcIl0pKENvbm5lY3QsIFdyYXBwZWRDb21wb25lbnQpO1xuICB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY29ubmVjdCA9IGV4cG9ydHMuUHJvdmlkZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfUHJvdmlkZXIgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvUHJvdmlkZXInKTtcblxudmFyIF9Qcm92aWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qcm92aWRlcik7XG5cbnZhciBfY29ubmVjdCA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9jb25uZWN0Jyk7XG5cbnZhciBfY29ubmVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb25uZWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmV4cG9ydHMuUHJvdmlkZXIgPSBfUHJvdmlkZXIyW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuY29ubmVjdCA9IF9jb25uZWN0MltcImRlZmF1bHRcIl07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuIiwidmFyIGVxdWFscyA9IHJlcXVpcmUoJy4uL2VxdWFscycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gX2luZGV4T2YobGlzdCwgYSwgaWR4KSB7XG4gIHZhciBpbmYsIGl0ZW07XG4gIC8vIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIGRvZXNuJ3QgZXhpc3QgYmVsb3cgSUU5XG4gIGlmICh0eXBlb2YgbGlzdC5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgYSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgICAvLyBtYW51YWxseSBjcmF3bCB0aGUgbGlzdCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuICswIGFuZCAtMFxuICAgICAgICAgIGluZiA9IDEgLyBhO1xuICAgICAgICAgIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaWR4XTtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSAwICYmIDEgLyBpdGVtID09PSBpbmYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoYSAhPT0gYSkge1xuICAgICAgICAgIC8vIE5hTlxuICAgICAgICAgIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgaXRlbSA9IGxpc3RbaWR4XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ251bWJlcicgJiYgaXRlbSAhPT0gaXRlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub24temVybyBudW1iZXJzIGNhbiB1dGlsaXNlIFNldFxuICAgICAgICByZXR1cm4gbGlzdC5pbmRleE9mKGEsIGlkeCk7XG5cbiAgICAgIC8vIGFsbCB0aGVzZSB0eXBlcyBjYW4gdXRpbGlzZSBTZXRcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiBsaXN0LmluZGV4T2YoYSwgaWR4KTtcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKGEgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBudWxsIGNhbiB1dGlsaXNlIFNldFxuICAgICAgICAgIHJldHVybiBsaXN0LmluZGV4T2YoYSwgaWR4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBhbnl0aGluZyBlbHNlIG5vdCBjb3ZlcmVkIGFib3ZlLCBkZWZlciB0byBSLmVxdWFsc1xuICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICBpZiAoZXF1YWxzKGxpc3RbaWR4XSwgYSkpIHtcbiAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuICAgIGlkeCArPSAxO1xuICB9XG4gIHJldHVybiAtMTtcbn07XG4iLCJ2YXIgX2luZGV4T2YgPSByZXF1aXJlKCcuL19pbmRleE9mJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfY29udGFpbnMoYSwgbGlzdCkge1xuICByZXR1cm4gX2luZGV4T2YobGlzdCwgYSwgMCkgPj0gMDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9xdW90ZShzKSB7XG4gIHZhciBlc2NhcGVkID0gc1xuICAgIC5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpXG4gICAgLnJlcGxhY2UoL1tcXGJdL2csICdcXFxcYicpICAvLyBcXGIgbWF0Y2hlcyB3b3JkIGJvdW5kYXJ5OyBbXFxiXSBtYXRjaGVzIGJhY2tzcGFjZVxuICAgIC5yZXBsYWNlKC9cXGYvZywgJ1xcXFxmJylcbiAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpXG4gICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKVxuICAgIC5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0JylcbiAgICAucmVwbGFjZSgvXFx2L2csICdcXFxcdicpXG4gICAgLnJlcGxhY2UoL1xcMC9nLCAnXFxcXDAnKTtcblxuICByZXR1cm4gJ1wiJyArIGVzY2FwZWQucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpICsgJ1wiJztcbn07XG4iLCIvKipcbiAqIFBvbHlmaWxsIGZyb20gPGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9JU09TdHJpbmc+LlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHBhZCA9IGZ1bmN0aW9uIHBhZChuKSB7IHJldHVybiAobiA8IDEwID8gJzAnIDogJycpICsgbjsgfTtcblxuICByZXR1cm4gdHlwZW9mIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nID09PSAnZnVuY3Rpb24nID9cbiAgICBmdW5jdGlvbiBfdG9JU09TdHJpbmcoZCkge1xuICAgICAgcmV0dXJuIGQudG9JU09TdHJpbmcoKTtcbiAgICB9IDpcbiAgICBmdW5jdGlvbiBfdG9JU09TdHJpbmcoZCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgZC5nZXRVVENGdWxsWWVhcigpICsgJy0nICtcbiAgICAgICAgcGFkKGQuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICtcbiAgICAgICAgcGFkKGQuZ2V0VVRDRGF0ZSgpKSArICdUJyArXG4gICAgICAgIHBhZChkLmdldFVUQ0hvdXJzKCkpICsgJzonICtcbiAgICAgICAgcGFkKGQuZ2V0VVRDTWludXRlcygpKSArICc6JyArXG4gICAgICAgIHBhZChkLmdldFVUQ1NlY29uZHMoKSkgKyAnLicgK1xuICAgICAgICAoZC5nZXRVVENNaWxsaXNlY29uZHMoKSAvIDEwMDApLnRvRml4ZWQoMykuc2xpY2UoMiwgNSkgKyAnWidcbiAgICAgICk7XG4gICAgfTtcbn0oKSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIF9jb21wbGVtZW50KGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsInZhciBfY29tcGxlbWVudCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2NvbXBsZW1lbnQnKTtcbnZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG52YXIgZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcblxuXG4vKipcbiAqIFRoZSBjb21wbGVtZW50IG9mIGBmaWx0ZXJgLlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIEZpbHRlcmFibGUgZiA9PiAoYSAtPiBCb29sZWFuKSAtPiBmIGEgLT4gZiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkXG4gKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJhYmxlXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBzZWUgUi5maWx0ZXIsIFIudHJhbnNkdWNlLCBSLmFkZEluZGV4XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgdmFyIGlzT2RkID0gKG4pID0+IG4gJSAyID09PSAxO1xuICpcbiAqICAgICAgUi5yZWplY3QoaXNPZGQsIFsxLCAyLCAzLCA0XSk7IC8vPT4gWzIsIDRdXG4gKlxuICogICAgICBSLnJlamVjdChpc09kZCwge2E6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KTsgLy89PiB7YjogMiwgZDogNH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHJlamVjdChwcmVkLCBmaWx0ZXJhYmxlKSB7XG4gIHJldHVybiBmaWx0ZXIoX2NvbXBsZW1lbnQocHJlZCksIGZpbHRlcmFibGUpO1xufSk7XG4iLCJ2YXIgX2NvbnRhaW5zID0gcmVxdWlyZSgnLi9fY29udGFpbnMnKTtcbnZhciBfbWFwID0gcmVxdWlyZSgnLi9fbWFwJyk7XG52YXIgX3F1b3RlID0gcmVxdWlyZSgnLi9fcXVvdGUnKTtcbnZhciBfdG9JU09TdHJpbmcgPSByZXF1aXJlKCcuL190b0lTT1N0cmluZycpO1xudmFyIGtleXMgPSByZXF1aXJlKCcuLi9rZXlzJyk7XG52YXIgcmVqZWN0ID0gcmVxdWlyZSgnLi4vcmVqZWN0Jyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfdG9TdHJpbmcoeCwgc2Vlbikge1xuICB2YXIgcmVjdXIgPSBmdW5jdGlvbiByZWN1cih5KSB7XG4gICAgdmFyIHhzID0gc2Vlbi5jb25jYXQoW3hdKTtcbiAgICByZXR1cm4gX2NvbnRhaW5zKHksIHhzKSA/ICc8Q2lyY3VsYXI+JyA6IF90b1N0cmluZyh5LCB4cyk7XG4gIH07XG5cbiAgLy8gIG1hcFBhaXJzIDo6IChPYmplY3QsIFtTdHJpbmddKSAtPiBbU3RyaW5nXVxuICB2YXIgbWFwUGFpcnMgPSBmdW5jdGlvbihvYmosIGtleXMpIHtcbiAgICByZXR1cm4gX21hcChmdW5jdGlvbihrKSB7IHJldHVybiBfcXVvdGUoaykgKyAnOiAnICsgcmVjdXIob2JqW2tdKTsgfSwga2V5cy5zbGljZSgpLnNvcnQoKSk7XG4gIH07XG5cbiAgc3dpdGNoIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkpIHtcbiAgICBjYXNlICdbb2JqZWN0IEFyZ3VtZW50c10nOlxuICAgICAgcmV0dXJuICcoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oJyArIF9tYXAocmVjdXIsIHgpLmpvaW4oJywgJykgKyAnKSknO1xuICAgIGNhc2UgJ1tvYmplY3QgQXJyYXldJzpcbiAgICAgIHJldHVybiAnWycgKyBfbWFwKHJlY3VyLCB4KS5jb25jYXQobWFwUGFpcnMoeCwgcmVqZWN0KGZ1bmN0aW9uKGspIHsgcmV0dXJuIC9eXFxkKyQvLnRlc3Qoayk7IH0sIGtleXMoeCkpKSkuam9pbignLCAnKSArICddJztcbiAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgPyAnbmV3IEJvb2xlYW4oJyArIHJlY3VyKHgudmFsdWVPZigpKSArICcpJyA6IHgudG9TdHJpbmcoKTtcbiAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIHJldHVybiAnbmV3IERhdGUoJyArIChpc05hTih4LnZhbHVlT2YoKSkgPyByZWN1cihOYU4pIDogX3F1b3RlKF90b0lTT1N0cmluZyh4KSkpICsgJyknO1xuICAgIGNhc2UgJ1tvYmplY3QgTnVsbF0nOlxuICAgICAgcmV0dXJuICdudWxsJztcbiAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyA/ICduZXcgTnVtYmVyKCcgKyByZWN1cih4LnZhbHVlT2YoKSkgKyAnKScgOiAxIC8geCA9PT0gLUluZmluaXR5ID8gJy0wJyA6IHgudG9TdHJpbmcoMTApO1xuICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnID8gJ25ldyBTdHJpbmcoJyArIHJlY3VyKHgudmFsdWVPZigpKSArICcpJyA6IF9xdW90ZSh4KTtcbiAgICBjYXNlICdbb2JqZWN0IFVuZGVmaW5lZF0nOlxuICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHgudG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHJlcHIgPSB4LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChyZXByICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICAgIHJldHVybiByZXByO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gJ3snICsgbWFwUGFpcnMoeCwga2V5cyh4KSkuam9pbignLCAnKSArICd9JztcbiAgfVxufTtcbiIsInZhciBfY3VycnkxID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkxJyk7XG52YXIgX3RvU3RyaW5nID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fdG9TdHJpbmcnKTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gdmFsdWUuIGBldmFsYCdpbmcgdGhlIG91dHB1dFxuICogc2hvdWxkIHJlc3VsdCBpbiBhIHZhbHVlIGVxdWl2YWxlbnQgdG8gdGhlIGlucHV0IHZhbHVlLiBNYW55IG9mIHRoZSBidWlsdC1pblxuICogYHRvU3RyaW5nYCBtZXRob2RzIGRvIG5vdCBzYXRpc2Z5IHRoaXMgcmVxdWlyZW1lbnQuXG4gKlxuICogSWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGBbb2JqZWN0IE9iamVjdF1gIHdpdGggYSBgdG9TdHJpbmdgIG1ldGhvZCBvdGhlclxuICogdGhhbiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AsIHRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2l0aCBubyBhcmd1bWVudHNcbiAqIHRvIHByb2R1Y2UgdGhlIHJldHVybiB2YWx1ZS4gVGhpcyBtZWFucyB1c2VyLWRlZmluZWQgY29uc3RydWN0b3IgZnVuY3Rpb25zXG4gKiBjYW4gcHJvdmlkZSBhIHN1aXRhYmxlIGB0b1N0cmluZ2AgbWV0aG9kLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgZnVuY3Rpb24gUG9pbnQoeCwgeSkge1xuICogICAgICAgdGhpcy54ID0geDtcbiAqICAgICAgIHRoaXMueSA9IHk7XG4gKiAgICAgfVxuICpcbiAqICAgICBQb2ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiAnbmV3IFBvaW50KCcgKyB0aGlzLnggKyAnLCAnICsgdGhpcy55ICsgJyknO1xuICogICAgIH07XG4gKlxuICogICAgIFIudG9TdHJpbmcobmV3IFBvaW50KDEsIDIpKTsgLy89PiAnbmV3IFBvaW50KDEsIDIpJ1xuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBzaWcgKiAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50b1N0cmluZyg0Mik7IC8vPT4gJzQyJ1xuICogICAgICBSLnRvU3RyaW5nKCdhYmMnKTsgLy89PiAnXCJhYmNcIidcbiAqICAgICAgUi50b1N0cmluZyhbMSwgMiwgM10pOyAvLz0+ICdbMSwgMiwgM10nXG4gKiAgICAgIFIudG9TdHJpbmcoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9KTsgLy89PiAne1wiYmFyXCI6IDIsIFwiYmF6XCI6IDMsIFwiZm9vXCI6IDF9J1xuICogICAgICBSLnRvU3RyaW5nKG5ldyBEYXRlKCcyMDAxLTAyLTAzVDA0OjA1OjA2WicpKTsgLy89PiAnbmV3IERhdGUoXCIyMDAxLTAyLTAzVDA0OjA1OjA2LjAwMFpcIiknXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gX2N1cnJ5MShmdW5jdGlvbiB0b1N0cmluZyh2YWwpIHsgcmV0dXJuIF90b1N0cmluZyh2YWwsIFtdKTsgfSk7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9pc0FycmF5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNBcnJheScpO1xudmFyIF9pc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9faXNGdW5jdGlvbicpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGNvbmNhdGVuYXRpbmcgdGhlIGdpdmVuIGxpc3RzIG9yIHN0cmluZ3MuXG4gKlxuICogTm90ZTogYFIuY29uY2F0YCBleHBlY3RzIGJvdGggYXJndW1lbnRzIHRvIGJlIG9mIHRoZSBzYW1lIHR5cGUsXG4gKiB1bmxpa2UgdGhlIG5hdGl2ZSBgQXJyYXkucHJvdG90eXBlLmNvbmNhdGAgbWV0aG9kLiBJdCB3aWxsIHRocm93XG4gKiBhbiBlcnJvciBpZiB5b3UgYGNvbmNhdGAgYW4gQXJyYXkgd2l0aCBhIG5vbi1BcnJheSB2YWx1ZS5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgY29uY2F0YCBtZXRob2Qgb2YgdGhlIGZpcnN0IGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IFthXSAtPiBbYV1cbiAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBhXG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gYlxuICogQHJldHVybiB7QXJyYXl8U3RyaW5nfVxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmNvbmNhdChbXSwgW10pOyAvLz0+IFtdXG4gKiAgICAgIFIuY29uY2F0KFs0LCA1LCA2XSwgWzEsIDIsIDNdKTsgLy89PiBbNCwgNSwgNiwgMSwgMiwgM11cbiAqICAgICAgUi5jb25jYXQoJ0FCQycsICdERUYnKTsgLy8gJ0FCQ0RFRidcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGNvbmNhdChhLCBiKSB7XG4gIGlmIChhID09IG51bGwgfHwgIV9pc0Z1bmN0aW9uKGEuY29uY2F0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IodG9TdHJpbmcoYSkgKyAnIGRvZXMgbm90IGhhdmUgYSBtZXRob2QgbmFtZWQgXCJjb25jYXRcIicpO1xuICB9XG4gIGlmIChfaXNBcnJheShhKSAmJiAhX2lzQXJyYXkoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHRvU3RyaW5nKGIpICsgJyBpcyBub3QgYW4gYXJyYXknKTtcbiAgfVxuICByZXR1cm4gYS5jb25jYXQoYik7XG59KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbGVzcyB0aGFuIHRoZSBzZWNvbmQ7IGBmYWxzZWBcbiAqIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIuZ3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmx0KDIsIDEpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIubHQoMiwgMik7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5sdCgyLCAzKTsgLy89PiB0cnVlXG4gKiAgICAgIFIubHQoJ2EnLCAneicpOyAvLz0+IHRydWVcbiAqICAgICAgUi5sdCgneicsICdhJyk7IC8vPT4gZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIGx0KGEsIGIpIHsgcmV0dXJuIGEgPCBiOyB9KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzZWNvbmQgYXJndW1lbnQgaWYgaXQgaXMgbm90IGBudWxsYCwgYHVuZGVmaW5lZGAgb3IgYE5hTmBcbiAqIG90aGVyd2lzZSB0aGUgZmlyc3QgYXJndW1lbnQgaXMgcmV0dXJuZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTAuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIGEgLT4gYiAtPiBhIHwgYlxuICogQHBhcmFtIHthfSB2YWwgVGhlIGRlZmF1bHQgdmFsdWUuXG4gKiBAcGFyYW0ge2J9IHZhbCBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGl0IGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICogQHJldHVybiB7Kn0gVGhlIHRoZSBzZWNvbmQgdmFsdWUgb3IgdGhlIGRlZmF1bHQgdmFsdWVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZGVmYXVsdFRvNDIgPSBSLmRlZmF1bHRUbyg0Mik7XG4gKlxuICogICAgICBkZWZhdWx0VG80MihudWxsKTsgIC8vPT4gNDJcbiAqICAgICAgZGVmYXVsdFRvNDIodW5kZWZpbmVkKTsgIC8vPT4gNDJcbiAqICAgICAgZGVmYXVsdFRvNDIoJ1JhbWRhJyk7ICAvLz0+ICdSYW1kYSdcbiAqICAgICAgZGVmYXVsdFRvNDIocGFyc2VJbnQoJ3N0cmluZycpKTsgLy89PiA0MlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gZGVmYXVsdFRvKGQsIHYpIHtcbiAgcmV0dXJuIHYgPT0gbnVsbCB8fCB2ICE9PSB2ID8gZCA6IHY7XG59KTtcbiIsInZhciBfY3VycnkyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9fY3VycnkyJyk7XG5cblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgdmFsdWUgYXQgYSBnaXZlbiBwYXRoLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBbU3RyaW5nXSAtPiB7azogdn0gLT4gdiB8IFVuZGVmaW5lZFxuICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCB0byB1c2UuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcmV0cmlldmUgdGhlIG5lc3RlZCBwcm9wZXJ0eSBmcm9tLlxuICogQHJldHVybiB7Kn0gVGhlIGRhdGEgYXQgYHBhdGhgLlxuICogQHNlZSBSLnByb3BcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnBhdGgoWydhJywgJ2InXSwge2E6IHtiOiAyfX0pOyAvLz0+IDJcbiAqICAgICAgUi5wYXRoKFsnYScsICdiJ10sIHtjOiB7YjogMn19KTsgLy89PiB1bmRlZmluZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkyKGZ1bmN0aW9uIHBhdGgocGF0aHMsIG9iaikge1xuICB2YXIgdmFsID0gb2JqO1xuICB2YXIgaWR4ID0gMDtcbiAgd2hpbGUgKGlkeCA8IHBhdGhzLmxlbmd0aCkge1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YWwgPSB2YWxbcGF0aHNbaWR4XV07XG4gICAgaWR4ICs9IDE7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn0pO1xuIiwidmFyIF9jdXJyeTMgPSByZXF1aXJlKCcuL2ludGVybmFsL19jdXJyeTMnKTtcbnZhciBkZWZhdWx0VG8gPSByZXF1aXJlKCcuL2RlZmF1bHRUbycpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuL3BhdGgnKTtcblxuXG4vKipcbiAqIElmIHRoZSBnaXZlbiwgbm9uLW51bGwgb2JqZWN0IGhhcyBhIHZhbHVlIGF0IHRoZSBnaXZlbiBwYXRoLCByZXR1cm5zIHRoZVxuICogdmFsdWUgYXQgdGhhdCBwYXRoLiBPdGhlcndpc2UgcmV0dXJucyB0aGUgcHJvdmlkZWQgZGVmYXVsdCB2YWx1ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIGEgLT4gW1N0cmluZ10gLT4gT2JqZWN0IC0+IGFcbiAqIEBwYXJhbSB7Kn0gZCBUaGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IHAgVGhlIHBhdGggdG8gdXNlLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHJldHJpZXZlIHRoZSBuZXN0ZWQgcHJvcGVydHkgZnJvbS5cbiAqIEByZXR1cm4geyp9IFRoZSBkYXRhIGF0IGBwYXRoYCBvZiB0aGUgc3VwcGxpZWQgb2JqZWN0IG9yIHRoZSBkZWZhdWx0IHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucGF0aE9yKCdOL0EnLCBbJ2EnLCAnYiddLCB7YToge2I6IDJ9fSk7IC8vPT4gMlxuICogICAgICBSLnBhdGhPcignTi9BJywgWydhJywgJ2InXSwge2M6IHtiOiAyfX0pOyAvLz0+IFwiTi9BXCJcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBfY3VycnkzKGZ1bmN0aW9uIHBhdGhPcihkLCBwLCBvYmopIHtcbiAgcmV0dXJuIGRlZmF1bHRUbyhkLCBwYXRoKHAsIG9iaikpO1xufSk7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXG5pbXBvcnQgeyBwYXRoT3IsIHBpcGUsIGN1cnJ5LCByZWR1Y2UsIGNvbmNhdCwgbWFwLCBsdCwgcHJvcE9yLCBwcm9wRXEsIGZpbHRlciB9IGZyb20gJ3JhbWRhJztcbmltcG9ydCB7IFByb2plY3QsIFJlY29yZGluZywgRGVsaXZlcmFibGUgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgSW1tdXRhYmxlIGZyb20gJ3NlYW1sZXNzLWltbXV0YWJsZSc7XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVBdCA9IGN1cnJ5KChrZXlBcnJheSwgbmV3VmFsLCBvYmopID0+IHtcbiAgY29uc3QgZGVlcE5ld1ZhbCA9IGtleUFycmF5LnJlZHVjZVJpZ2h0KFxuICAgIChyZXN1bHQsIGtleSkgPT4gKHsgW2tleV06IHJlc3VsdCB9KVxuICAgICwgbmV3VmFsXG4gICk7XG5cbiAgcmV0dXJuIEltbXV0YWJsZShvYmopLm1lcmdlKGRlZXBOZXdWYWwsIHsgZGVlcDogdHJ1ZSB9KTtcbn0pO1xuXG5leHBvcnQgY29uc3Qgc2VsZWN0ZWRQcm9qZWN0ID0gcGF0aE9yKG51bGwsIFsnc2VsZWN0ZWRQcm9qZWN0J10pO1xuXG4vLyBNb2RlbCAtPiBbUHJvamVjdF1cbmNvbnN0IHVuc2VsZWN0ZWRQcm9qZWN0cyA9IHBpcGUocHJvcE9yKG51bGwsICd1bnNlbGVjdGVkUHJvamVjdHMnKSwgdiA9PiB2IHx8IFtdKTtcblxuZXhwb3J0IGNvbnN0IGFsbFByb2plY3RzID0gbW9kZWwgPT4gKFxuICAgIHNlbGVjdGVkUHJvamVjdChtb2RlbClcbiAgICA/IHVuc2VsZWN0ZWRQcm9qZWN0cyhtb2RlbCkuY29uY2F0KHNlbGVjdGVkUHJvamVjdChtb2RlbCkpXG4gICAgOiB1bnNlbGVjdGVkUHJvamVjdHMobW9kZWwpXG4gICk7XG5cbmV4cG9ydCBjb25zdCByZWNvcmRpbmdzSW5mbyA9IG1vZGVsID0+IHtcbiAgY29uc3Qgbm9uWmVyb1JlY29yZGluZ1RpbWUgPSBwaXBlKFxuICAgIHByb3BPcihudWxsLCAncmVjb3JkaW5nJyksXG4gICAgUmVjb3JkaW5nLnRvdGFsVGltZSxcbiAgICBsdCgwKSwgLy8gSW50IC0+IEJvb2wuIFdoZXRoZXIgemVybyBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciB0aGF0IHdpbGwgYmUgcGFzc2VkXG4gICk7XG5cbiAgY29uc3QgcHJvamVjdFJlY29yZGluZ0luZm9zID0gcHJvamVjdCA9PiBwaXBlKFxuICAgIFByb2plY3QuZ2V0RGVsaXZlcmFibGVzLFxuICAgIG1hcChkID0+ICh7IHByb2plY3QsIGRlbGl2ZXJhYmxlOiBkLCByZWNvcmRpbmc6IERlbGl2ZXJhYmxlLmdldFJlY29yZGluZyhkKSB9KSlcbiAgKShwcm9qZWN0KTtcblxuICBjb25zdCBhbGwgPSBwaXBlKFxuICAgIGFsbFByb2plY3RzLFxuICAgIG1hcChwcm9qZWN0UmVjb3JkaW5nSW5mb3MpLFxuICAgIHJlZHVjZShjb25jYXQsIFtdKVxuICApKG1vZGVsKTtcblxuICByZXR1cm4gYWxsLmZpbHRlcihub25aZXJvUmVjb3JkaW5nVGltZSk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0UHJvamVjdCA9IGN1cnJ5KChwcm9qZWN0TmFtZSwgbW9kZWwpID0+IHBpcGUoXG4gIGFsbFByb2plY3RzLFxuICBmaWx0ZXIocHJvcEVxKCduYW1lJywgcHJvamVjdE5hbWUpKVxuKShtb2RlbCkpO1xuXG5leHBvcnQgY29uc3QgZ2V0RGVsaXZlcmFibGUgPSBjdXJyeSgoZGVsaXZlcmFibGVOYW1lLCBwcm9qZWN0TmFtZSwgbW9kZWwpID0+IHBpcGUoXG4gIGdldFByb2plY3QocHJvamVjdE5hbWUpLFxuICBQcm9qZWN0LmdldERlbGl2ZXJhYmxlcyxcbiAgZmlsdGVyKHByb3BFcSgnbmFtZScsIGRlbGl2ZXJhYmxlTmFtZSkpXG4pKG1vZGVsKSk7XG5cblxuZXhwb3J0IGNvbnN0IHVwZGF0ZVByb2plY3QgPSBjdXJyeSgocHJvamVjdCwgbW9kZWwsIG5ld1Byb2plY3QpID0+IHtcbiAgY29uc3QgcHJvamVjdE5hbWUgPSBQcm9qZWN0LmdldE5hbWUocHJvamVjdCk7XG4gIGlmICghKG1vZGVsICYmIHByb2plY3ROYW1lICYmIG5ld1Byb2plY3QpKSB7XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG5cbiAgY29uc3Qgc2FtZVByb2plY3ROYW1lID0gcHJvcEVxKCduYW1lJywgcHJvamVjdE5hbWUpO1xuICBjb25zdCB1cGRhdGluZ1NlbGVjdGVkUHJvamVjdCA9IHByb2plY3ROYW1lID09PSBwcm9wT3IobnVsbCwgJ25hbWUnLCBtb2RlbC5zZWxlY3RlZFByb2plY3QpO1xuICBjb25zdCB1cGRhdGluZ1Vuc2VsZWN0ZWRQcm9qZWN0ID0gISF1bnNlbGVjdGVkUHJvamVjdHMobW9kZWwpLmZpbmQoc2FtZVByb2plY3ROYW1lKTtcblxuICBpZiAodXBkYXRpbmdTZWxlY3RlZFByb2plY3QpIHtcbiAgICByZXR1cm4gdXBkYXRlQXQoXG4gICAgICBbJ3NlbGVjdGVkUHJvamVjdCddLFxuICAgICAgbmV3UHJvamVjdCxcbiAgICAgIG1vZGVsXG4gICAgKTtcbiAgfSBlbHNlIGlmICh1cGRhdGluZ1Vuc2VsZWN0ZWRQcm9qZWN0KSB7XG4gICAgY29uc3QgbmV3VW5zZWxlY3RlZFByb2plY3RzID0gdW5zZWxlY3RlZFByb2plY3RzKG1vZGVsKVxuICAgICAgLm1hcChwID0+IChzYW1lUHJvamVjdE5hbWUocCkgPyBuZXdQcm9qZWN0IDogcCkpO1xuXG4gICAgcmV0dXJuIHVwZGF0ZUF0KFxuICAgICAgWyd1bnNlbGVjdGVkUHJvamVjdHMnXSxcbiAgICAgIG5ld1Vuc2VsZWN0ZWRQcm9qZWN0cyxcbiAgICAgIG1vZGVsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBtb2RlbDtcbn0pO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tbmVzdGVkLXRlcm5hcnkgKi9cbmltcG9ydCBWaWV3IGZyb20gJy4vdmlldyc7XG5pbXBvcnQgeyBjb25uZWN0IH0gZnJvbSAncmVhY3QtcmVkdXgnO1xuaW1wb3J0IHtcbiAgc2VsZWN0ZWRQcm9qZWN0LFxuICBhbGxQcm9qZWN0cyxcbiAgcmVjb3JkaW5nc0luZm8sXG59IGZyb20gJy4vdXBkYXRlL3V0aWxzJztcblxuLy8gSG9vayB0aGluZ3MgdXAgaGVyZS5cbmNvbnN0IG1hcFN0YXRlVG9Qcm9wcyA9IChtb2RlbCkgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbXBsZXhpdHlcbiAgcmV0dXJuIHtcbiAgICBzZWxlY3RlZFByb2plY3Q6IHNlbGVjdGVkUHJvamVjdChtb2RlbCksXG4gICAgYWxsUHJvamVjdHM6IGFsbFByb2plY3RzKG1vZGVsKSxcbiAgICByZWNvcmRpbmdzSW5mbzogcmVjb3JkaW5nc0luZm8obW9kZWwpLFxuICAgIGlzTWluaW1pc2VkOiBtb2RlbC5taW5pbWlzZWQsXG4gIH07XG59O1xuXG5jb25zdCBtYXBEaXNwYXRjaFRvUHJvcHMgPSAoZGlzcGF0Y2gpID0+ICh7IGRpc3BhdGNoIH0pO1xuXG5jb25zdCBXaWRnZXQgPSBjb25uZWN0KFxuICBtYXBTdGF0ZVRvUHJvcHMsXG4gIG1hcERpc3BhdGNoVG9Qcm9wcyxcbikoVmlldyk7XG5cbmV4cG9ydCBkZWZhdWx0IFdpZGdldDtcbiIsImltcG9ydCB7XG4gIHR5cGVDaGVja2VycyxcbiAgUHJvamVjdCxcbn0gZnJvbSAnLi4vdHlwZXMnO1xuY29uc3Qge1xuICBzdHJpbmcsXG4gIG9iamVjdCxcbiAgYXJyYXksXG4gIG51bGxhYmxlLFxuICBib29sLFxufSA9IHR5cGVDaGVja2VycztcblxuY29uc3QgbW9kZWxUeXBlID0gb2JqZWN0KHtcbiAgbWluaW1pc2VkOiBib29sLFxuICBzZXJ2ZXJVUkw6IHN0cmluZyxcbiAgdW5zZWxlY3RlZFByb2plY3RzOiBudWxsYWJsZShhcnJheShQcm9qZWN0LnR5cGVDaGVjaykpLFxuICBzZWxlY3RlZFByb2plY3Q6IG51bGxhYmxlKFByb2plY3QudHlwZUNoZWNrKSxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtb2RlbFR5cGU7XG4iLCJ2YXIgX2N1cnJ5MiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2N1cnJ5MicpO1xudmFyIF9pc1N0cmluZyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvX2lzU3RyaW5nJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiB0aGUgZ2l2ZW4gbGlzdCBvciBzdHJpbmcuIElmIG4gaXMgbmVnYXRpdmUgdGhlXG4gKiBlbGVtZW50IGF0IGluZGV4IGxlbmd0aCArIG4gaXMgcmV0dXJuZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IGEgfCBVbmRlZmluZWRcbiAqIEBzaWcgTnVtYmVyIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7Kn0gbGlzdFxuICogQHJldHVybiB7Kn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgbGlzdCA9IFsnZm9vJywgJ2JhcicsICdiYXonLCAncXV1eCddO1xuICogICAgICBSLm50aCgxLCBsaXN0KTsgLy89PiAnYmFyJ1xuICogICAgICBSLm50aCgtMSwgbGlzdCk7IC8vPT4gJ3F1dXgnXG4gKiAgICAgIFIubnRoKC05OSwgbGlzdCk7IC8vPT4gdW5kZWZpbmVkXG4gKlxuICogICAgICBSLm50aCgyLCAnYWJjJyk7IC8vPT4gJ2MnXG4gKiAgICAgIFIubnRoKDMsICdhYmMnKTsgLy89PiAnJ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9jdXJyeTIoZnVuY3Rpb24gbnRoKG9mZnNldCwgbGlzdCkge1xuICB2YXIgaWR4ID0gb2Zmc2V0IDwgMCA/IGxpc3QubGVuZ3RoICsgb2Zmc2V0IDogb2Zmc2V0O1xuICByZXR1cm4gX2lzU3RyaW5nKGxpc3QpID8gbGlzdC5jaGFyQXQoaWR4KSA6IGxpc3RbaWR4XTtcbn0pO1xuIiwidmFyIG50aCA9IHJlcXVpcmUoJy4vbnRoJyk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBsaXN0IG9yIHN0cmluZy4gSW4gc29tZSBsaWJyYXJpZXNcbiAqIHRoaXMgZnVuY3Rpb24gaXMgbmFtZWQgYGZpcnN0YC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBhIHwgVW5kZWZpbmVkXG4gKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLnRhaWwsIFIuaW5pdCwgUi5sYXN0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5oZWFkKFsnZmknLCAnZm8nLCAnZnVtJ10pOyAvLz0+ICdmaSdcbiAqICAgICAgUi5oZWFkKFtdKTsgLy89PiB1bmRlZmluZWRcbiAqXG4gKiAgICAgIFIuaGVhZCgnYWJjJyk7IC8vPT4gJ2EnXG4gKiAgICAgIFIuaGVhZCgnJyk7IC8vPT4gJydcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBudGgoMCk7XG4iLCJpbXBvcnQgeyBhbGxQcm9qZWN0cywgdXBkYXRlUHJvamVjdCwgcmVjb3JkaW5nc0luZm8gfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IFByb2plY3QsIFJlY29yZGluZywgRGVsaXZlcmFibGUsIE1heWJlIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgY3VycnksIGZpbmQsIHBpcGUsIGZpbHRlciwgcHJvcCwgaGVhZCB9IGZyb20gJ3JhbWRhJztcblxuLy8gTW9kZWwgLT4ge1Byb2plY3QsIERlbGl2ZXJhYmxlfSAtPiBNb2RlbFxuY29uc3QgdG9nZ2xlRGVsaXZlcmFibGVSZWNvcmRpbmcgPSBjdXJyeSgobW9kZWwsIHsgcHJvamVjdCwgZGVsaXZlcmFibGUgfSkgPT5cbiAgTWF5YmUub2YoZGVsaXZlcmFibGUpXG4gICAgLm1hcChEZWxpdmVyYWJsZS5nZXRSZWNvcmRpbmcpXG4gICAgLm1hcChSZWNvcmRpbmcudG9nZ2xlUmVjb3JkaW5nKVxuICAgIC5tYXAoRGVsaXZlcmFibGUuc2V0UmVjb3JkaW5nKGRlbGl2ZXJhYmxlKSlcbiAgICAubWFwKFByb2plY3QudXBkYXRlRGVsaXZlcmFibGUocHJvamVjdCkpXG4gICAgLm1hcCh1cGRhdGVQcm9qZWN0KHByb2plY3QsIG1vZGVsKSlcbiAgICAud2l0aERlZmF1bHQobW9kZWwpXG4pO1xuXG4vLyBNb2RlbCAtPiBNYXliZVxuY29uc3QgZmluZFJlY29yZGluZ0RlbGl2ZXJhYmxlID0gbW9kZWwgPT5cbiAgTWF5YmUub2YobW9kZWwpXG4gICAgLm1hcChyZWNvcmRpbmdzSW5mbylcbiAgICAubWFwKGZpbHRlcihwaXBlKHByb3AoJ3JlY29yZGluZycpLCBSZWNvcmRpbmcuaXNSZWNvcmRpbmcpKSlcbiAgICAubWFwKGhlYWQpO1xuXG4vLyBNb2RlbCAtPiBNb2RlbFxuY29uc3Qgc3RvcEFsbFJlY29yZGluZ3MgPSBtb2RlbCA9PlxuICBNYXliZS5vZihtb2RlbClcbiAgICAubWFwKG0gPT4gY29uc29sZS5sb2coJ3N0b3BwaW5nIGFsbCByZWNvcmRpbmdzIGZvcicsIG1vZGVsKSB8fCBtKVxuICAgIC5jaGFpbihmaW5kUmVjb3JkaW5nRGVsaXZlcmFibGUpXG4gICAgLm1hcCh0b2dnbGVEZWxpdmVyYWJsZVJlY29yZGluZyhtb2RlbCkpXG4gICAgLm1hcChzdG9wQWxsUmVjb3JkaW5ncylcbiAgICAud2l0aERlZmF1bHQobW9kZWwpO1xuXG4vLyBQcm9qZWN0IC0+IE1heWJlKFByb2plY3QpXG5jb25zdCBnZXRVcFRvRGF0ZVByb2plY3QgPSBjdXJyeSgocHJvamVjdCwgbW9kZWwpID0+XG4gIE1heWJlLm9mKG1vZGVsKVxuICAgIC5tYXAoYWxsUHJvamVjdHMpXG4gICAgLm1hcChmaW5kKFByb2plY3QuaXNTYW1lKHByb2plY3QpKSlcbik7XG5cbmV4cG9ydCBkZWZhdWx0IChtb2RlbCwgeyBwcm9qZWN0LCBkZWxpdmVyYWJsZSB9KSA9PlxuICBNYXliZS5vZihtb2RlbClcbiAgICAubWFwKHN0b3BBbGxSZWNvcmRpbmdzKVxuICAgIC5jaGFpbihjaGFuZ2VkTW9kZWwgPT5cbiAgICAgIGdldFVwVG9EYXRlUHJvamVjdChwcm9qZWN0LCBjaGFuZ2VkTW9kZWwpXG4gICAgICAubWFwKHAgPT5cbiAgICAgICAgdG9nZ2xlRGVsaXZlcmFibGVSZWNvcmRpbmcoXG4gICAgICAgICAgY2hhbmdlZE1vZGVsLFxuICAgICAgICAgIHsgcHJvamVjdDogcCwgZGVsaXZlcmFibGUgfVxuICAgICAgICApKVxuICAgIClcbiAgICAud2l0aERlZmF1bHQobW9kZWwpO1xuIiwiaW1wb3J0IHsgcHJvcEVxLCBwcm9wT3IsIHJlamVjdCwgcGlwZSB9IGZyb20gJ3JhbWRhJztcbmltcG9ydCB7XG4gIGFsbFByb2plY3RzLFxuICB1cGRhdGVBdCxcbn0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IChtb2RlbCwgYWN0aW9uKSA9PiB7XG4gIGNvbnN0IHsgcHJvamVjdCA9IG51bGwgfSA9IGFjdGlvbjtcblxuICBjb25zdCBwcm9qZWN0TmFtZSA9IHByb3BPcihudWxsLCAnbmFtZScsIHByb2plY3QpO1xuICBjb25zdCBuZXdVbnNlbGVjdGVkUHJvamVjdHMgPSBwaXBlKFxuICAgIGFsbFByb2plY3RzLFxuICAgIHJlamVjdChwcm9wRXEoJ25hbWUnLCBwcm9qZWN0TmFtZSkpXG4gICkobW9kZWwpO1xuXG4gIHJldHVybiBwaXBlKFxuICAgIHVwZGF0ZUF0KFsnc2VsZWN0ZWRQcm9qZWN0J10sIHByb2plY3QpLFxuICAgIHVwZGF0ZUF0KFsndW5zZWxlY3RlZFByb2plY3RzJ10sIG5ld1Vuc2VsZWN0ZWRQcm9qZWN0cylcbiAgKShtb2RlbCk7XG59O1xuIiwiaW1wb3J0IHsgUHJvamVjdCB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IHBpcGUgfSBmcm9tICdyYW1kYSc7XG5pbXBvcnQgeyB1cGRhdGVQcm9qZWN0IH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IChtb2RlbCwgYWN0aW9uKSA9PiB7XG4gIGNvbnN0IHsgcHJvamVjdCwgZGVsaXZlcmFibGUgPSBudWxsIH0gPSBhY3Rpb247XG5cbiAgcmV0dXJuICFwcm9qZWN0XG4gICAgPyBtb2RlbFxuICAgIDogcGlwZShcbiAgICAgIFByb2plY3Quc2V0U2VsZWN0ZWREZWxpdmVyYWJsZShwcm9qZWN0KSxcbiAgICAgIHVwZGF0ZVByb2plY3QocHJvamVjdCwgbW9kZWwpXG4gICAgKShkZWxpdmVyYWJsZSk7XG59O1xuIiwiaW1wb3J0IHsgdXBkYXRlQXQgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IHBpcGUsIG1hcCB9IGZyb20gJ3JhbWRhJztcblxuY29uc3QgcHJvY2Vzc1Jhd0RlbGl2ZXJhYmxlcyA9IG1hcChcbiAgICAoeyBuYW1lLCB1cmwgfSkgPT4gKHtcbiAgICAgIG5hbWUsXG4gICAgICB1cmwsXG4gICAgICByZWNvcmRpbmc6IG51bGwsXG4gICAgfSlcbik7XG5cbmNvbnN0IHByb2Nlc3NSYXdQcm9qZWN0cyA9IG1hcChcbiAgKHsgbmFtZSwgdXJsLCBkZWxpdmVyYWJsZXMgfSkgPT4gKHtcbiAgICBuYW1lLFxuICAgIHVybCxcbiAgICB1bnNlbGVjdGVkRGVsaXZlcmFibGVzOiBwcm9jZXNzUmF3RGVsaXZlcmFibGVzKGRlbGl2ZXJhYmxlcyksXG4gICAgc2VsZWN0ZWREZWxpdmVyYWJsZTogbnVsbCxcbiAgfSlcbik7XG5cbmV4cG9ydCBkZWZhdWx0IChtb2RlbCwgYWN0aW9uKSA9PiB7XG4gIGNvbnN0IG5ld1Byb2plY3RzID0gcHJvY2Vzc1Jhd1Byb2plY3RzKGFjdGlvbi5yYXdQcm9qZWN0cyk7XG4gIHJldHVybiBwaXBlKFxuICAgIHVwZGF0ZUF0KFsndW5zZWxlY3RlZFByb2plY3RzJ10sIG5ld1Byb2plY3RzKSxcbiAgICB1cGRhdGVBdChbJ3NlbGVjdGVkUHJvamVjdCddLCBudWxsKSxcbiAgKShtb2RlbCk7XG59O1xuIiwiaW1wb3J0IHsgdXBkYXRlQXQgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGlzTmlsIH0gZnJvbSAncmFtZGEnO1xuXG5leHBvcnQgZGVmYXVsdCAobW9kZWwsIGFjdGlvbikgPT4ge1xuICBjb25zdCBtaW5pbWlzZSA9IGlzTmlsKGFjdGlvbi5taW5pbWlzZSlcbiAgICA/ICFtb2RlbC5taW5pbWlzZWRcbiAgICA6ICEhYWN0aW9uLm1pbmltaXNlO1xuICByZXR1cm4gdXBkYXRlQXQoWydtaW5pbWlzZWQnXSwgbWluaW1pc2UsIG1vZGVsKTtcbn07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXG5pbXBvcnQgbW9kZWxUeXBlIGZyb20gJy4uL21vZGVsJztcbmltcG9ydCB7IFZhbGlkYXRpb24gfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBwaXBlIH0gZnJvbSAncmFtZGEnO1xuaW1wb3J0IEltbXV0YWJsZSBmcm9tICdzZWFtbGVzcy1pbW11dGFibGUnO1xuaW1wb3J0IHRvZ2dsZVJlY29yZGluZyBmcm9tICcuL3RvZ2dsZVJlY29yZGluZyc7XG5pbXBvcnQgc2VsZWN0UHJvamVjdCBmcm9tICcuL3NlbGVjdFByb2plY3QnO1xuaW1wb3J0IHNlbGVjdERlbGl2ZXJhYmxlIGZyb20gJy4vc2VsZWN0RGVsaXZlcmFibGUnO1xuaW1wb3J0IHNldFByb2plY3RzIGZyb20gJy4vc2V0UHJvamVjdHMnO1xuaW1wb3J0IHRvZ2dsZU1pbmltaXNlZCBmcm9tICcuL3RvZ2dsZU1pbmltaXNlZCc7XG5cbmNvbnN0IGFjdGlvbkhhbmRsZXJzID0ge1xuICB0b2dnbGVSZWNvcmRpbmcsXG4gIHNlbGVjdFByb2plY3QsXG4gIHNlbGVjdERlbGl2ZXJhYmxlLFxuICBzZXRQcm9qZWN0cyxcbiAgdG9nZ2xlTWluaW1pc2VkLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXBkYXRlKG1vZGVsLCBhY3Rpb24pIHtcbiAgY29uc3QgYWN0aW9uTmFtZSA9IGFjdGlvbi50eXBlLnJlcGxhY2UoJ1dJREdFVF8nLCAnJyk7XG4gIGNvbnN0IGhhbmRsZXIgPSBhY3Rpb25IYW5kbGVyc1thY3Rpb25OYW1lXTtcblxuICBpZiAoIWhhbmRsZXIpIHtcbiAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgYWN0aW9uOicsIGFjdGlvbk5hbWUpO1xuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuXG4gIHJldHVybiBwaXBlKFxuICAgIGhhbmRsZXIsXG4gICAgdiA9PiBJbW11dGFibGUuYXNNdXRhYmxlKHYsIHsgZGVlcDogdHJ1ZSB9KSxcbiAgICBtb2RlbFR5cGUsXG4gICAgVmFsaWRhdGlvbi50aHJvd0ZhaWx1cmUsXG4gICAgVmFsaWRhdGlvbi53aXRoRGVmYXVsdChudWxsKSxcbiAgICBJbW11dGFibGVcbiAgKShtb2RlbCwgYWN0aW9uKTtcbn1cbiIsImltcG9ydCB7IGNyZWF0ZVN0b3JlIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IFdpZGdldFVwZGF0ZSBmcm9tICcuL1dpZGdldC91cGRhdGUnO1xuaW1wb3J0IHsgc2V0UHJvamVjdHMgfSBmcm9tICcuL1dpZGdldC9hY3Rpb25zJztcblxuY29uc3QgaW5pdGlhbE1vZGVsID0ge1xuICBtaW5pbWlzZWQ6IGZhbHNlLFxuICBzZXJ2ZXJVUkw6ICcuL2RhdGEuanNvbicsXG4gIHVuc2VsZWN0ZWRQcm9qZWN0czogbnVsbCxcbiAgc2VsZWN0ZWRQcm9qZWN0OiBudWxsLFxufTtcblxuY29uc3Qgc3RvcmUgPSBjcmVhdGVTdG9yZShXaWRnZXRVcGRhdGUsIGluaXRpYWxNb2RlbCk7XG5cbi8vIFBlcmZvcm0gc29tZSBhc3luYyBpbml0aWFsaXNhdGlvbiB0YXNrXG5cbmZldGNoKGluaXRpYWxNb2RlbC5zZXJ2ZXJVUkwpXG4gIC50aGVuKHIgPT4gci5qc29uKCkpXG4gIC50aGVuKHIgPT4gci5wcm9qZWN0cylcbiAgLy8gU2V0IHByb2plY3RzIGlzIGluc2lkZSBhIGZ1bmN0aW9uIHNvIHRoYXQgd2UgdXNlIHRoaXMuc3RhdGUubW9kZWwgYXQgdGhlXG4gIC8vIHRpbWUgb2YgdGhlIHJlc3BvbnNlLCByYXRoZXIgdGhhbiBhdCB0aGUgdGltZSBvZiB0aGUgcmVxdWVzdC5cbiAgLnRoZW4ocHJvaiA9PlxuICAgIHN0b3JlLmRpc3BhdGNoKHNldFByb2plY3RzKHByb2opKSxcbiAgKTtcblxuZXhwb3J0IGRlZmF1bHQgc3RvcmU7XG4iLCIvKiBlc2xpbnQtZW52IGphc21pbmUgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAsIG5vLXVuZGVyc2NvcmUtZGFuZ2xlICovXG5pbXBvcnQge1xuICBWYWxpZGF0aW9uLFxufSBmcm9tICcuLi8uLi9qcy90eXBlcyc7XG5cbmRlc2NyaWJlKCdWYWxpZGF0aW9uIHR5cGUnLCAoKSA9PiB7XG4gIGNvbnN0IHN1Y2Nlc3NWYWwgPSAnc3VjY2Vzcyc7XG4gIGNvbnN0IHN1Y2Nlc3NWYWwyID0gJ3N1Y2Nlc3MyJztcbiAgY29uc3QgZmFpbHVyZVZhbCA9ICdmYWlsdXJlJztcbiAgY29uc3QgYVN1Y2Nlc3MgPSBWYWxpZGF0aW9uLlN1Y2Nlc3Moc3VjY2Vzc1ZhbCk7XG4gIGNvbnN0IGFTdWNjZXNzMiA9IFZhbGlkYXRpb24uU3VjY2VzcyhzdWNjZXNzVmFsMik7XG4gIGNvbnN0IGFGYWlsdXJlID0gVmFsaWRhdGlvbi5GYWlsdXJlKGZhaWx1cmVWYWwpO1xuXG4gIGl0KCdjcmVhdGVzIGEgc3VjY2VzcyB2YWx1ZSB3aXRoIGEgdHJ1dGh5IHBhcmFtZXRlcicsICgpID0+IHtcbiAgICBjb25zdCBhID0gVmFsaWRhdGlvbi5TdWNjZXNzKDEyMyk7XG4gICAgZXhwZWN0KGEuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgIGV4cGVjdChWYWxpZGF0aW9uLmlzU3VjY2VzcyhhKSkudG9CZSh0cnVlKTtcbiAgfSk7XG5cbiAgaXQoJ2NyZWF0ZXMgYSBmYWlsdXJlIHdpdGggdGhlIEZhaWx1cmUgZnVuY3Rpb24gZXZlbiBpZiB0aGUgdmFsdWUgaXMgdHJ1dGh5JywgKCkgPT4ge1xuICAgIGV4cGVjdChWYWxpZGF0aW9uLkZhaWx1cmUoJ2EgcmVhc29uJykuaXNTdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgfSk7XG5cbiAgaXQoJ3JldHVybnMgdGhlIGRlZmF1bHQgdmFsdWUgd2hlbiBGYWlsdXJlIHdpdGggd2l0aERlZmFsYXVsdCcsICgpID0+IHtcbiAgICBleHBlY3QoVmFsaWRhdGlvbi5GYWlsdXJlKCkud2l0aERlZmF1bHQoJ2RlZmF1bHQnKSkudG9FcXVhbCgnZGVmYXVsdCcpO1xuICAgIGV4cGVjdChWYWxpZGF0aW9uLndpdGhEZWZhdWx0KCdkZWZhdWx0JywgVmFsaWRhdGlvbi5GYWlsdXJlKCkpKS50b0VxdWFsKCdkZWZhdWx0Jyk7XG4gIH0pO1xuXG4gIGl0KCdyZXR1cm5zIHRoZSBtYWluIHZhbHVlIHdoZW4gU3VjY2VzcyB3aXRoIHdpdGhEZWZhbGF1bHQnLCAoKSA9PiB7XG4gICAgZXhwZWN0KGFTdWNjZXNzLndpdGhEZWZhdWx0KCdlcnJvcicpKS50b0VxdWFsKHN1Y2Nlc3NWYWwpO1xuICAgIGV4cGVjdChWYWxpZGF0aW9uLndpdGhEZWZhdWx0KCdlcnJvcicsIGFTdWNjZXNzKSkudG9FcXVhbChzdWNjZXNzVmFsKTtcbiAgfSk7XG5cblxuICBpdCgnbWFwcyBzdWNjZXNzZXMgYW5kIG5vdCBmYWlsdXJlcycsICgpID0+IHtcbiAgICBleHBlY3QoYVN1Y2Nlc3MubWFwKF8gPT4gJ3InKS5fdmFsdWUpLnRvRXF1YWwoJ3InKTtcbiAgICBleHBlY3QoVmFsaWRhdGlvbi5tYXAoXyA9PiAncicsIGFTdWNjZXNzKS5fdmFsdWUpLnRvRXF1YWwoJ3InKTtcbiAgICBleHBlY3QoVmFsaWRhdGlvbi5tYXAoXyA9PiAncicpKGFTdWNjZXNzKS5fdmFsdWUpLnRvRXF1YWwoJ3InKTtcblxuICAgIGV4cGVjdChhRmFpbHVyZS5tYXAoXyA9PiAncicpLl92YWx1ZSkudG9FcXVhbChmYWlsdXJlVmFsKTtcbiAgICBleHBlY3QoVmFsaWRhdGlvbi5tYXAoXyA9PiAncicsIGFGYWlsdXJlKS5fdmFsdWUpLnRvRXF1YWwoZmFpbHVyZVZhbCk7XG4gICAgZXhwZWN0KFZhbGlkYXRpb24ubWFwKF8gPT4gJ3InKShhRmFpbHVyZSkuX3ZhbHVlKS50b0VxdWFsKGZhaWx1cmVWYWwpO1xuICB9KTtcblxuICBpdCgnb3V0cHV0cyBhIFZhbGlkYXRpb24gdHlwZSB3aGVuIG1hcHBpbmcnLCAoKSA9PiB7XG4gICAgZXhwZWN0KGFTdWNjZXNzLm1hcChfID0+ICdyJykgaW5zdGFuY2VvZiBWYWxpZGF0aW9uKS50b0JlKHRydWUpO1xuICAgIGV4cGVjdChWYWxpZGF0aW9uLm1hcChfID0+ICdyJywgYVN1Y2Nlc3MpIGluc3RhbmNlb2YgVmFsaWRhdGlvbikudG9CZSh0cnVlKTtcbiAgICBleHBlY3QoVmFsaWRhdGlvbi5tYXAoXyA9PiAncicpKGFTdWNjZXNzKSBpbnN0YW5jZW9mIFZhbGlkYXRpb24pLnRvQmUodHJ1ZSk7XG5cbiAgICBleHBlY3QoYUZhaWx1cmUubWFwKF8gPT4gJ3InKSBpbnN0YW5jZW9mIFZhbGlkYXRpb24pLnRvQmUodHJ1ZSk7XG4gICAgZXhwZWN0KFZhbGlkYXRpb24ubWFwKF8gPT4gJ3InLCBhRmFpbHVyZSkgaW5zdGFuY2VvZiBWYWxpZGF0aW9uKS50b0JlKHRydWUpO1xuICAgIGV4cGVjdChWYWxpZGF0aW9uLm1hcChfID0+ICdyJykoYUZhaWx1cmUpIGluc3RhbmNlb2YgVmFsaWRhdGlvbikudG9CZSh0cnVlKTtcbiAgfSk7XG5cbiAgaXQoJ21hcHMgb25seSBzdWNjZXNzZXMgd2l0aCBtYXBTdWNjZXNzJywgKCkgPT4ge1xuICAgIGV4cGVjdChhU3VjY2Vzcy5tYXBTdWNjZXNzKF8gPT4gJ3InKS5fdmFsdWUpLnRvRXF1YWwoJ3InKTtcbiAgICBleHBlY3QoVmFsaWRhdGlvbi5tYXBTdWNjZXNzKF8gPT4gJ3InLCBhU3VjY2VzcykuX3ZhbHVlKS50b0VxdWFsKCdyJyk7XG4gICAgZXhwZWN0KFZhbGlkYXRpb24ubWFwU3VjY2VzcyhfID0+ICdyJykoYVN1Y2Nlc3MpLl92YWx1ZSkudG9FcXVhbCgncicpO1xuXG4gICAgZXhwZWN0KGFGYWlsdXJlLm1hcFN1Y2Nlc3MoXyA9PiAncicpLl92YWx1ZSkudG9FcXVhbChmYWlsdXJlVmFsKTtcbiAgICBleHBlY3QoVmFsaWRhdGlvbi5tYXBTdWNjZXNzKF8gPT4gJ3InLCBhRmFpbHVyZSkuX3ZhbHVlKS50b0VxdWFsKGZhaWx1cmVWYWwpO1xuICAgIGV4cGVjdChWYWxpZGF0aW9uLm1hcFN1Y2Nlc3MoXyA9PiAncicpKGFGYWlsdXJlKS5fdmFsdWUpLnRvRXF1YWwoZmFpbHVyZVZhbCk7XG4gIH0pO1xuXG4gIGl0KCdtYXBzIG9ubHkgZmFpbHVyZXMgd2l0aCBtYXBGYWlsdXJlJywgKCkgPT4ge1xuICAgIGV4cGVjdChhU3VjY2Vzcy5tYXBGYWlsdXJlKF8gPT4gJ3InKS5fdmFsdWUpLnRvRXF1YWwoc3VjY2Vzc1ZhbCk7XG4gICAgZXhwZWN0KFZhbGlkYXRpb24ubWFwRmFpbHVyZShfID0+ICdyJywgYVN1Y2Nlc3MpLl92YWx1ZSkudG9FcXVhbChzdWNjZXNzVmFsKTtcbiAgICBleHBlY3QoVmFsaWRhdGlvbi5tYXBGYWlsdXJlKF8gPT4gJ3InKShhU3VjY2VzcykuX3ZhbHVlKS50b0VxdWFsKHN1Y2Nlc3NWYWwpO1xuXG4gICAgZXhwZWN0KGFGYWlsdXJlLm1hcEZhaWx1cmUoXyA9PiAncicpLl92YWx1ZSkudG9FcXVhbCgncicpO1xuICAgIGV4cGVjdChWYWxpZGF0aW9uLm1hcEZhaWx1cmUoXyA9PiAncicsIGFGYWlsdXJlKS5fdmFsdWUpLnRvRXF1YWwoJ3InKTtcbiAgICBleHBlY3QoVmFsaWRhdGlvbi5tYXBGYWlsdXJlKF8gPT4gJ3InKShhRmFpbHVyZSkuX3ZhbHVlKS50b0VxdWFsKCdyJyk7XG4gIH0pO1xuXG4gIGl0KCd0aHJvd3Mgd2l0aCB0aHJvd0ZhaWx1cmUgd2hlbiBGYWlsdXJlIGFuZCBkb2VzblxcJ3Qgd2hlbiBTdWNjZXNzJywgKCkgPT4ge1xuICAgIGV4cGVjdChfID0+IGFGYWlsdXJlLnRocm93RmFpbHVyZSgpKS50b1Rocm93KCk7XG4gICAgZXhwZWN0KF8gPT4gVmFsaWRhdGlvbi50aHJvd0ZhaWx1cmUoYUZhaWx1cmUpKS50b1Rocm93KCk7XG5cbiAgICBleHBlY3QoXyA9PiBhU3VjY2Vzcy50aHJvd0ZhaWx1cmUoKSkubm90LnRvVGhyb3coKTtcbiAgICBleHBlY3QoXyA9PiBWYWxpZGF0aW9uLnRocm93RmFpbHVyZShhU3VjY2VzcykpLm5vdC50b1Rocm93KCk7XG4gIH0pO1xuXG4gIGl0KCdjYWxscyB0aGUgY2FsbGJhY2sgd2l0aCBhbmRUaGVuIG9ubHkgd2hlbiBTdWNjZXNzJywgKCkgPT4ge1xuICAgIGV4cGVjdChhU3VjY2Vzcy5hbmRUaGVuKF8gPT4gYVN1Y2Nlc3MyKSkudG9FcXVhbChhU3VjY2VzczIpO1xuICAgIGV4cGVjdChWYWxpZGF0aW9uLmFuZFRoZW4oXyA9PiBhU3VjY2VzczIsIGFTdWNjZXNzKSkudG9FcXVhbChhU3VjY2VzczIpO1xuICAgIGV4cGVjdChWYWxpZGF0aW9uLmFuZFRoZW4oXyA9PiBhU3VjY2VzczIpKGFTdWNjZXNzKSkudG9FcXVhbChhU3VjY2VzczIpO1xuXG4gICAgZXhwZWN0KGFGYWlsdXJlLmFuZFRoZW4oXyA9PiAncicpKS50b0VxdWFsKGFGYWlsdXJlKTtcbiAgICBleHBlY3QoVmFsaWRhdGlvbi5hbmRUaGVuKF8gPT4gJ3InLCBhRmFpbHVyZSkpLnRvRXF1YWwoYUZhaWx1cmUpO1xuICAgIGV4cGVjdChWYWxpZGF0aW9uLmFuZFRoZW4oXyA9PiAncicpKGFGYWlsdXJlKSkudG9FcXVhbChhRmFpbHVyZSk7XG4gIH0pO1xuXG4gIGl0KCd0aHJvd3Mgd2hlbiBhbmRUaGVuIGNhbGxiYWNrIGRvZXMgbm90IHJldHVybiBhIHZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgZXhwZWN0KF8gPT4gYVN1Y2Nlc3MuYW5kVGhlbihfID0+ICdyJykpLnRvVGhyb3coKTtcbiAgICBleHBlY3QoXyA9PiBWYWxpZGF0aW9uLmFuZFRoZW4oXyA9PiAncicsIGFTdWNjZXNzKSkudG9UaHJvdygpO1xuICAgIGV4cGVjdChfID0+IFZhbGlkYXRpb24uYW5kVGhlbihfID0+ICdyJykoYVN1Y2Nlc3MpKS50b1Rocm93KCk7XG4gIH0pO1xuXG4gIGl0KCdjaGFpbnMgb25seSBzdWNjZXNzZXMnLCAoKSA9PiB7XG4gICAgY29uc3Qgc3VjY2VzczEgPSBWYWxpZGF0aW9uLlN1Y2Nlc3MoJzEnKTtcbiAgICBjb25zdCBzdWNjZXNzMiA9IFZhbGlkYXRpb24uU3VjY2VzcygnMicpO1xuXG4gICAgZXhwZWN0KHN1Y2Nlc3MxLmNoYWluKHN1Y2Nlc3MyKS5fdmFsdWUpLnRvRXF1YWwoJzInKTtcbiAgICBleHBlY3QoVmFsaWRhdGlvbi5jaGFpbihzdWNjZXNzMSwgc3VjY2VzczIpLl92YWx1ZSkudG9FcXVhbCgnMicpO1xuICAgIGV4cGVjdChWYWxpZGF0aW9uLmNoYWluKHN1Y2Nlc3MxKShzdWNjZXNzMikuX3ZhbHVlKS50b0VxdWFsKCcyJyk7XG5cbiAgICBleHBlY3QoYUZhaWx1cmUuY2hhaW4oc3VjY2VzczIpLl92YWx1ZSkudG9FcXVhbChmYWlsdXJlVmFsKTtcbiAgICBleHBlY3QoVmFsaWRhdGlvbi5jaGFpbihhRmFpbHVyZSwgc3VjY2VzczIpLl92YWx1ZSkudG9FcXVhbChmYWlsdXJlVmFsKTtcbiAgICBleHBlY3QoVmFsaWRhdGlvbi5jaGFpbihhRmFpbHVyZSkoc3VjY2VzczIpLl92YWx1ZSkudG9FcXVhbChmYWlsdXJlVmFsKTtcbiAgfSk7XG59KTtcbiIsIi8qIGVzbGludC1lbnYgamFzbWluZSAqL1xuLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCwgbm8tdW5kZXJzY29yZS1kYW5nbGUgKi9cbmltcG9ydCB7IHBpcGUgfSBmcm9tICdyYW1kYSc7XG5pbXBvcnQge1xuICBEZWxpdmVyYWJsZSxcbiAgUmVjb3JkaW5nLFxuICBWYWxpZGF0aW9uLFxufSBmcm9tICcuLi8uLi9qcy90eXBlcyc7XG5cbmRlc2NyaWJlKCdEZWxpdmVyYWJsZSB0eXBlJywgKCkgPT4ge1xuICBjb25zdCBkZWxpdk5hbWUgPSAnbmFtZSc7XG4gIGNvbnN0IGRlbGl2VXJsID0gJ3VybCc7XG4gIGNvbnN0IGRlbGl2UmVjID0gUmVjb3JkaW5nLm9mKHsgc3RhcnRUaW1lOiBudWxsLCBpbnRlcnZhbHM6IFtdIH0pO1xuICBjb25zdCB2YWxpZE9iamVjdCA9IHsgbmFtZTogZGVsaXZOYW1lLCB1cmw6IGRlbGl2VXJsLCByZWNvcmRpbmc6IGRlbGl2UmVjIH07XG4gIGNvbnN0IHZhbGlkRGVsaXYgPSBEZWxpdmVyYWJsZS5vZih2YWxpZE9iamVjdCk7XG4gIGNvbnN0IHZhbGlkT2JqZWN0Tm9SZWMgPSB7IG5hbWU6IGRlbGl2TmFtZSwgdXJsOiBkZWxpdlVybCwgcmVjb3JkaW5nOiBudWxsIH07XG4gIGNvbnN0IHZhbGlkRGVsaXZOb1JlYyA9IERlbGl2ZXJhYmxlLm9mKHZhbGlkT2JqZWN0Tm9SZWMpO1xuXG4gIGl0KCd0eXBlIGNoZWNrcyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgY29uc3QgaW52YWxpZDEgPSB7IG5hbWU6ICdhc2ZkJywgdXJsOiAnYWRzZicsIHJlY29yZGluZzogJ2FzZGZhJyB9O1xuICAgIGNvbnN0IGludmFsaWQyID0geyBuYW1lOiBudWxsLCB1cmw6ICdhZHNmJywgcmVjb3JkaW5nOiBudWxsIH07XG4gICAgY29uc3QgaW52YWxpZDMgPSB7IG5hbWU6ICdhc2RmJywgdXJsOiBudWxsLCByZWNvcmRpbmc6IG51bGwgfTtcblxuICAgIGV4cGVjdChWYWxpZGF0aW9uLmlzU3VjY2VzcyhEZWxpdmVyYWJsZS50eXBlQ2hlY2soaW52YWxpZDEpKSkudG9FcXVhbChmYWxzZSk7XG4gICAgZXhwZWN0KFZhbGlkYXRpb24uaXNTdWNjZXNzKERlbGl2ZXJhYmxlLnR5cGVDaGVjayhpbnZhbGlkMikpKS50b0VxdWFsKGZhbHNlKTtcbiAgICBleHBlY3QoVmFsaWRhdGlvbi5pc1N1Y2Nlc3MoRGVsaXZlcmFibGUudHlwZUNoZWNrKGludmFsaWQzKSkpLnRvRXF1YWwoZmFsc2UpO1xuICAgIGV4cGVjdChWYWxpZGF0aW9uLmlzU3VjY2VzcyhEZWxpdmVyYWJsZS50eXBlQ2hlY2sodmFsaWRPYmplY3QpKSkudG9FcXVhbCh0cnVlKTtcbiAgICBleHBlY3QoVmFsaWRhdGlvbi5pc1N1Y2Nlc3MoRGVsaXZlcmFibGUudHlwZUNoZWNrKHZhbGlkT2JqZWN0Tm9SZWMpKSkudG9FcXVhbCh0cnVlKTtcbiAgfSk7XG5cbiAgaXQoJ3JldHVucyBhIHJlY29yZGluZyBldmVuIGlmIHRoZSBEZWxpdmVyYWJsZSBkb2VzblxcJ3QgaGF2ZSBvbmUgeWV0JywgKCkgPT4ge1xuICAgIGV4cGVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIERlbGl2ZXJhYmxlLmdldFJlY29yZGluZyxcbiAgICAgICAgUmVjb3JkaW5nLnR5cGVDaGVjayxcbiAgICAgICAgVmFsaWRhdGlvbi5pc1N1Y2Nlc3NcbiAgICAgICkoe30pXG4gICAgKS50b0VxdWFsKHRydWUpO1xuICAgIGV4cGVjdChEZWxpdmVyYWJsZS5nZXRSZWNvcmRpbmcobnVsbCkpLnRvRXF1YWwobnVsbCk7XG4gICAgZXhwZWN0KERlbGl2ZXJhYmxlLmdldFJlY29yZGluZyh1bmRlZmluZWQpKS50b0VxdWFsKG51bGwpO1xuICAgIGV4cGVjdChEZWxpdmVyYWJsZS5nZXRSZWNvcmRpbmcoeyByZWNvcmRpbmc6IGRlbGl2UmVjIH0pKS50b0VxdWFsKGRlbGl2UmVjKTtcbiAgfSk7XG5cbiAgaXQoJ3JldHVybnMgbmFtZSBhbmQgZG9lc25cXCd0IHRocm93IHdpdGggbnVsbCcsICgpID0+IHtcbiAgICBleHBlY3QoRGVsaXZlcmFibGUuZ2V0TmFtZSh2YWxpZERlbGl2KSkudG9FcXVhbChkZWxpdk5hbWUpO1xuICAgIGV4cGVjdChfID0+IERlbGl2ZXJhYmxlLmdldE5hbWUobnVsbCkpLm5vdC50b1Rocm93KCk7XG4gIH0pO1xuXG4gIGl0KCdyZXR1cm5zIHVybCBhbmQgZG9lc25cXCd0IHRocm93IHdpdGggbnVsbCcsICgpID0+IHtcbiAgICBleHBlY3QoRGVsaXZlcmFibGUuZ2V0VXJsKHZhbGlkRGVsaXYpKS50b0VxdWFsKGRlbGl2VXJsKTtcbiAgICBleHBlY3QoXyA9PiBEZWxpdmVyYWJsZS5nZXRVcmwobnVsbCkpLm5vdC50b1Rocm93KCk7XG4gIH0pO1xuXG4gIGl0KCdyZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBjb3JyZWN0IHJlY29yZGluZyB3aGVuIHVzaW5nIHNldFJlY29yZGluZycsICgpID0+IHtcbiAgICBjb25zdCBzZXRBbmRHZXRSZWNvcmRpbmcgPSBwaXBlKERlbGl2ZXJhYmxlLnNldFJlY29yZGluZywgRGVsaXZlcmFibGUuZ2V0UmVjb3JkaW5nKTtcblxuICAgIGV4cGVjdChzZXRBbmRHZXRSZWNvcmRpbmcodmFsaWREZWxpdk5vUmVjLCBkZWxpdlJlYykpLnRvRXF1YWwoZGVsaXZSZWMpO1xuICAgIGV4cGVjdChzZXRBbmRHZXRSZWNvcmRpbmcobnVsbCwgdmFsaWREZWxpdikpLnRvRXF1YWwobnVsbCk7XG4gICAgZXhwZWN0KF8gPT4gc2V0QW5kR2V0UmVjb3JkaW5nKG51bGwsIG51bGwpKS5ub3QudG9UaHJvdygpO1xuICB9KTtcbn0pO1xuIiwiLyogZXNsaW50LWVudiBqYXNtaW5lICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwLCBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuaW1wb3J0IHsgcGlwZSB9IGZyb20gJ3JhbWRhJztcbmltcG9ydCB7XG4gIFJlY29yZGluZyxcbiAgVmFsaWRhdGlvbixcbiAgVGltZUludGVydmFsLFxufSBmcm9tICcuLi8uLi9qcy90eXBlcyc7XG5cblxuZGVzY3JpYmUoJ1JlY29yZGluZyB0eXBlJywgKCkgPT4ge1xuICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gIGNvbnN0IHNlY0ludGVydmFsNSA9IFRpbWVJbnRlcnZhbC5vZih7XG4gICAgc3RhcnQ6IG5ldyBEYXRlKG5vdyAtIDEwMCAqIDEwMDApLFxuICAgIGVuZDogbmV3IERhdGUobm93IC0gOTUgKiAxMDAwKSxcbiAgfSk7XG4gIGNvbnN0IHNlY0ludGVydmFsMTAgPSBUaW1lSW50ZXJ2YWwub2Yoe1xuICAgIHN0YXJ0OiBuZXcgRGF0ZShub3cgLSAyMDAgKiAxMDAwKSxcbiAgICBlbmQ6IG5ldyBEYXRlKG5vdyAtIDE5MCAqIDEwMDApLFxuICB9KTtcblxuICBjb25zdCB2YWxpZDEgPSB7IHN0YXJ0VGltZTogbnVsbCwgaW50ZXJ2YWxzOiBbXSB9O1xuICBjb25zdCB2YWxpZDFSdW5uaW5nID0geyBzdGFydFRpbWU6IG5ldyBEYXRlKCksIGludGVydmFsczogW10gfTtcbiAgY29uc3QgdmFsaWQyID0geyBzdGFydFRpbWU6IG51bGwsIGludGVydmFsczogW1xuICAgIHNlY0ludGVydmFsNSxcbiAgICBzZWNJbnRlcnZhbDEwLFxuICBdIH07XG4gIGNvbnN0IHZhbGlkMlJ1bm5pbmcgPSB7IHN0YXJ0VGltZTogbmV3IERhdGUoKSwgaW50ZXJ2YWxzOiBbXG4gICAgc2VjSW50ZXJ2YWw1LFxuICAgIHNlY0ludGVydmFsMTAsXG4gIF0gfTtcblxuICBpdCgndHlwZSBjaGVja3MgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgIGNvbnN0IGludmFsaWQxID0ge307XG4gICAgY29uc3QgaW52YWxpZDFSdW5uaW5nID0geyBzdGFydFRpbWU6ICdhZHNmJywgaW50ZXJ2YWxzOiBbXSB9O1xuICAgIGNvbnN0IGludmFsaWQyID0geyBzdGFydFRpbWU6ICdhZHNmJywgaW50ZXJ2YWxzOiBudWxsIH07XG4gICAgY29uc3QgdmFsaWRhdGVzID0gcGlwZShSZWNvcmRpbmcudHlwZUNoZWNrLCBWYWxpZGF0aW9uLmlzU3VjY2Vzcyk7XG5cbiAgICBleHBlY3QodmFsaWRhdGVzKGludmFsaWQxKSkudG9CZShmYWxzZSk7XG4gICAgZXhwZWN0KHZhbGlkYXRlcyhpbnZhbGlkMVJ1bm5pbmcpKS50b0JlKGZhbHNlKTtcbiAgICBleHBlY3QodmFsaWRhdGVzKGludmFsaWQyKSkudG9CZShmYWxzZSk7XG5cbiAgICBleHBlY3QodmFsaWRhdGVzKHZhbGlkMSkpLnRvQmUodHJ1ZSk7XG4gICAgZXhwZWN0KHZhbGlkYXRlcyh2YWxpZDFSdW5uaW5nKSkudG9CZSh0cnVlKTtcbiAgICBleHBlY3QodmFsaWRhdGVzKHZhbGlkMikpLnRvQmUodHJ1ZSk7XG4gICAgZXhwZWN0KHZhbGlkYXRlcyh2YWxpZDJSdW5uaW5nKSkudG9CZSh0cnVlKTtcbiAgfSk7XG5cbiAgaXQoJ3JldHVybnMgdGhlIHN0YXJ0VGltZSBhbmQgZG9lcyBub3QgYnJlYWsgd2l0aCBudWxsJywgKCkgPT4ge1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIGV4cGVjdChSZWNvcmRpbmcuZ2V0U3RhcnRUaW1lKHsgc3RhcnRUaW1lOiBkYXRlIH0pKS50b0VxdWFsKGRhdGUpO1xuICAgIGV4cGVjdChSZWNvcmRpbmcuZ2V0U3RhcnRUaW1lKHsgc3RhcnRUaW1lOiBudWxsIH0pKS50b0VxdWFsKG51bGwpO1xuICAgIGV4cGVjdChSZWNvcmRpbmcuZ2V0U3RhcnRUaW1lKHt9KSkudG9FcXVhbChudWxsKTtcbiAgICBleHBlY3QoXyA9PiBSZWNvcmRpbmcuZ2V0U3RhcnRUaW1lKG51bGwpKS5ub3QudG9UaHJvdygpO1xuICB9KTtcblxuICBpdCgnYWx3YXlzIHJldHVybnMgYW4gYXJyYXkgZm9yIGdldEludGVydmFscycsICgpID0+IHtcbiAgICBjb25zdCBpbnRlcnZhbHMgPSBbc2VjSW50ZXJ2YWwxMCwgc2VjSW50ZXJ2YWw1XTtcbiAgICBjb25zdCBpbnRlcnZhbElzQXJyYXkgPSBwaXBlKFJlY29yZGluZy5nZXRJbnRlcnZhbHMsIHYgPT4gQXJyYXkuaXNBcnJheSh2KSk7XG5cbiAgICBleHBlY3QoaW50ZXJ2YWxJc0FycmF5KHsgaW50ZXJ2YWxzIH0pKS50b0VxdWFsKHRydWUpO1xuICAgIGV4cGVjdChpbnRlcnZhbElzQXJyYXkoeyBpbnRlcnZhbHM6IG51bGwgfSkpLnRvRXF1YWwodHJ1ZSk7XG4gICAgZXhwZWN0KGludGVydmFsSXNBcnJheSh7fSkpLnRvRXF1YWwodHJ1ZSk7XG4gICAgZXhwZWN0KGludGVydmFsSXNBcnJheShudWxsKSkudG9FcXVhbCh0cnVlKTtcbiAgICBleHBlY3QoXyA9PiBSZWNvcmRpbmcuZ2V0SW50ZXJ2YWxzKG51bGwpKS5ub3QudG9UaHJvdygpO1xuICB9KTtcblxuICBpdCgnc2V0cyB0aGUgaW50ZXJ2YWwgd2l0aG91dCB0aHJvd2luZyB3aXRoIG51bGwnLCAoKSA9PiB7XG4gICAgZXhwZWN0KF8gPT4gUmVjb3JkaW5nLnNldEludGVydmFscyhudWxsLCBudWxsKSkubm90LnRvVGhyb3coKTtcbiAgICBleHBlY3QoXyA9PiBSZWNvcmRpbmcuc2V0SW50ZXJ2YWxzKG51bGwsIFtdKSkubm90LnRvVGhyb3coKTtcbiAgICBleHBlY3QoXyA9PiBSZWNvcmRpbmcuc2V0SW50ZXJ2YWxzKHsgaW50ZXJ2YWxzOiBbXSB9LCBudWxsKSkubm90LnRvVGhyb3coKTtcbiAgICBleHBlY3QoXyA9PiBSZWNvcmRpbmcuc2V0SW50ZXJ2YWxzKHsgaW50ZXJ2YWxzOiBbXSB9LCB1bmRlZmluZWQpKS5ub3QudG9UaHJvdygpO1xuICAgIGV4cGVjdChfID0+IFJlY29yZGluZy5zZXRJbnRlcnZhbHMoeyBpbnRlcnZhbHM6IFtdIH0sICdhc2ZhZHNmJykpLm5vdC50b1Rocm93KCk7XG4gICAgZXhwZWN0KF8gPT4gUmVjb3JkaW5nLnNldEludGVydmFscygnYXNhc2RmJywgJ2FzZmFkc2YnKSkubm90LnRvVGhyb3coKTtcbiAgICBleHBlY3QoXyA9PiBSZWNvcmRpbmcuc2V0SW50ZXJ2YWxzKCdhc2FzZGYnLCBbXSkpLm5vdC50b1Rocm93KCk7XG4gIH0pO1xuXG4gIGl0KCdzZXRJbnRlcnZhbHMgd29ya3MnLCAoKSA9PiB7XG4gICAgY29uc3QgZW1wdHkgPSBbXTtcbiAgICBjb25zdCBpbnRlcnZhbHMgPSBbc2VjSW50ZXJ2YWwxMCwgc2VjSW50ZXJ2YWw1XTtcbiAgICBjb25zdCBzZXRBbmRHZXRJbnRlcnZhbHMgPSBwaXBlKFJlY29yZGluZy5zZXRJbnRlcnZhbHMsIFJlY29yZGluZy5nZXRJbnRlcnZhbHMpO1xuICAgIGV4cGVjdChzZXRBbmRHZXRJbnRlcnZhbHMoeyBpbnRlcnZhbHM6IFtdIH0sIGludGVydmFscykpLnRvRXF1YWwoaW50ZXJ2YWxzKTtcbiAgICBleHBlY3Qoc2V0QW5kR2V0SW50ZXJ2YWxzKHsgaW50ZXJ2YWxzIH0sIGVtcHR5KSkudG9FcXVhbChlbXB0eSk7XG4gICAgZXhwZWN0KHNldEFuZEdldEludGVydmFscyh7fSwgZW1wdHkpKS50b0VxdWFsKGVtcHR5KTtcbiAgfSk7XG5cbiAgaXQoJ3NheXMgd2hldGhlciBpc1JlY29yZGluZyBvciBub3QnLCAoKSA9PiB7XG4gICAgZXhwZWN0KFJlY29yZGluZy5pc1JlY29yZGluZyh2YWxpZDFSdW5uaW5nKSkudG9FcXVhbCh0cnVlKTtcbiAgICBleHBlY3QoUmVjb3JkaW5nLmlzUmVjb3JkaW5nKHZhbGlkMikpLnRvRXF1YWwoZmFsc2UpO1xuICAgIGV4cGVjdChfID0+IFJlY29yZGluZy5pc1JlY29yZGluZyhudWxsKSkubm90LnRvVGhyb3coKTtcbiAgfSk7XG5cbiAgaXQoJ3NldHMgdGhlIGNvcnJlY3Qgc3RhcnRUaW1lIGluIHRvZ2dsZVJlY29yZGluZycsICgpID0+IHtcbiAgICBjb25zdCB0b2dnbGVkVmFsdWUgPSBwaXBlKFJlY29yZGluZy50b2dnbGVSZWNvcmRpbmcsIFJlY29yZGluZy5pc1JlY29yZGluZyk7XG4gICAgY29uc3QgdG9nZ2xlZFN0YXJ0VGltZSA9IHBpcGUoUmVjb3JkaW5nLnRvZ2dsZVJlY29yZGluZywgUmVjb3JkaW5nLmdldFN0YXJ0VGltZSk7XG4gICAgZXhwZWN0KHRvZ2dsZWRWYWx1ZSh2YWxpZDFSdW5uaW5nKSkudG9FcXVhbChmYWxzZSk7XG4gICAgZXhwZWN0KHRvZ2dsZWRWYWx1ZSh2YWxpZDEpKS50b0VxdWFsKHRydWUpO1xuICAgIGV4cGVjdCh0b2dnbGVkVmFsdWUobnVsbCkpLnRvRXF1YWwoZmFsc2UpO1xuICAgIGV4cGVjdCh0b2dnbGVkU3RhcnRUaW1lKHZhbGlkMVJ1bm5pbmcpKS50b0JlKG51bGwpO1xuICAgIGV4cGVjdCh0b2dnbGVkU3RhcnRUaW1lKHZhbGlkMikudmFsdWVPZigpKS50b0JlTGVzc1RoYW5PckVxdWFsKG5ldyBEYXRlKCkudmFsdWVPZigpKTtcbiAgfSk7XG5cbiAgaXQoJ2NhbGN1bGF0ZXMgdGhlIHRvdGFsIHRpbWUgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgIGNvbnN0IHNlYzE1ID0geyBzdGFydFRpbWU6IG51bGwsIGludGVydmFsczogW3NlY0ludGVydmFsMTAsIHNlY0ludGVydmFsNV0gfTtcbiAgICBjb25zdCBzZWMxNVJ1bm5pbmcgPSB7IHN0YXJ0VGltZTogbmV3IERhdGUoKSwgaW50ZXJ2YWxzOiBbc2VjSW50ZXJ2YWwxMCwgc2VjSW50ZXJ2YWw1XSB9O1xuICAgIGNvbnN0IHNlYzAgPSB7IHN0YXJ0VGltZTogbnVsbCwgaW50ZXJ2YWxzOiBbXSB9O1xuICAgIGNvbnN0IHNlYzBSdW5uaW5nID0geyBzdGFydFRpbWU6IG5ldyBEYXRlKCksIGludGVydmFsczogW10gfTtcblxuICAgIGV4cGVjdChSZWNvcmRpbmcudG90YWxUaW1lKHNlYzE1KSkudG9FcXVhbCgxMDAwICogMTUpO1xuICAgIGV4cGVjdChSZWNvcmRpbmcudG90YWxUaW1lKHNlYzApKS50b0VxdWFsKDApO1xuICAgIGV4cGVjdChSZWNvcmRpbmcudG90YWxUaW1lKHNlYzE1UnVubmluZykpLnRvQmVHcmVhdGVyVGhhbigxMDAgKiAxNSk7XG4gICAgZXhwZWN0KFJlY29yZGluZy50b3RhbFRpbWUoc2VjMFJ1bm5pbmcpKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gIH0pO1xuXG4gIGl0KCdkb2VzIG5vdCBicmVhayB3aGVuIHRvdGFsVGltZSByZWNlaXZlcyBudWxsIGFuZCBhbHdheXMgcmV0dXJucyBhIG51bWJlcicsICgpID0+IHtcbiAgICBleHBlY3QoXyA9PiBSZWNvcmRpbmcudG90YWxUaW1lKG51bGwpKS5ub3QudG9UaHJvdygpO1xuICAgIGV4cGVjdChSZWNvcmRpbmcudG90YWxUaW1lKG51bGwpKS50b0VxdWFsKDApO1xuICAgIGV4cGVjdChSZWNvcmRpbmcudG90YWxUaW1lKCkpLnRvRXF1YWwoMCk7XG4gICAgZXhwZWN0KFJlY29yZGluZy50b3RhbFRpbWUoe30pKS50b0VxdWFsKDApO1xuICAgIGV4cGVjdChSZWNvcmRpbmcudG90YWxUaW1lKFtdKSkudG9FcXVhbCgwKTtcbiAgfSk7XG59KTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi9cbi8qIGVzbGludC1lbnYgamFzbWluZSAqL1xuXG5pbXBvcnQgeyBwaXBlIH0gZnJvbSAncmFtZGEnO1xuaW1wb3J0IHsgTWF5YmUgfSBmcm9tICcuLi8uLi9qcy90eXBlcyc7XG5cblxuZGVzY3JpYmUoJ01heWJlIHR5cGUnLCAoKSA9PiB7XG4gIGNvbnN0IGNyZWF0ZWRKdXN0V2l0aE9mID0gcGlwZShNYXliZS5vZiwgTWF5YmUuaXNKdXN0KTtcbiAgY29uc3QgY3JlYXRlZEp1c3QgPSBwaXBlKE1heWJlLkp1c3QsIE1heWJlLmlzSnVzdCk7XG4gIGNvbnN0IGNyZWF0ZWROb3RoaW5nID0gcGlwZShNYXliZS5Ob3RoaW5nLCBNYXliZS5pc05vdGhpbmcpO1xuICBjb25zdCBkZWZhdWx0VmFsID0gJ2RlZmF1bHQnO1xuICBjb25zdCBqdXN0VmFsID0gJ2FzZmQnO1xuXG4gIGl0KCdjcmVhdGVzIGEgSnVzdCB3aGVuIHBhc3NlZCB0cnV0aHkgYW5kIGZhbHN5IG5vbi1udWxsIHZhbHVlcycsICgpID0+IHtcbiAgICBleHBlY3QoY3JlYXRlZEp1c3QoJzEnKSkudG9CZSh0cnVlKTtcbiAgICBleHBlY3QoY3JlYXRlZEp1c3Qoe30pKS50b0JlKHRydWUpO1xuICAgIGV4cGVjdChjcmVhdGVkSnVzdCh0cnVlKSkudG9CZSh0cnVlKTtcbiAgICBleHBlY3QoY3JlYXRlZEp1c3QoZmFsc2UpKS50b0JlKHRydWUpO1xuICAgIGV4cGVjdChjcmVhdGVkSnVzdChbXSkpLnRvQmUodHJ1ZSk7XG4gIH0pO1xuXG4gIGl0KCdjcmVhdGVzIGEgTm90aGluZyB3aGVuIHBhc3NlZCBhbnl0aGluZyB3aXRoIHRoZSBOb3RoaW5nIGNvbnN0cnVjdG9yJywgKCkgPT4ge1xuICAgIGV4cGVjdChjcmVhdGVkTm90aGluZygnMScpKS50b0JlKHRydWUpO1xuICAgIGV4cGVjdChjcmVhdGVkTm90aGluZyh7fSkpLnRvQmUodHJ1ZSk7XG4gICAgZXhwZWN0KGNyZWF0ZWROb3RoaW5nKHRydWUpKS50b0JlKHRydWUpO1xuICAgIGV4cGVjdChjcmVhdGVkTm90aGluZyhmYWxzZSkpLnRvQmUodHJ1ZSk7XG4gICAgZXhwZWN0KGNyZWF0ZWROb3RoaW5nKFtdKSkudG9CZSh0cnVlKTtcbiAgICBleHBlY3QoY3JlYXRlZE5vdGhpbmcobnVsbCkpLnRvQmUodHJ1ZSk7XG4gICAgZXhwZWN0KGNyZWF0ZWROb3RoaW5nKCkpLnRvQmUodHJ1ZSk7XG4gIH0pO1xuXG4gIGl0KCdjcmVhdGVzIGEgTm90aGluZyBpZiBudWxsIG9yIHVuZGVmaW5lZCBpcyBwYXNzZWQgdG8gdGhlIGdlbmVyYWwgY29uc3RydWN0b3InLCAoKSA9PiB7XG4gICAgZXhwZWN0KGNyZWF0ZWRKdXN0V2l0aE9mKG51bGwpKS50b0JlKGZhbHNlKTtcbiAgICBleHBlY3QoY3JlYXRlZEp1c3RXaXRoT2YoKSkudG9CZShmYWxzZSk7XG4gIH0pO1xuXG4gIGl0KCdjcmVhdGVzIGEgSnVzdCBpZiBzb21ldGhpbmcgaXMgcGFzc2VkIHRvIHRoZSBnZW5lcmFsIGNvbnN0cnVjdG9yJywgKCkgPT4ge1xuICAgIGV4cGVjdChjcmVhdGVkSnVzdFdpdGhPZignMScpKS50b0JlKHRydWUpO1xuICAgIGV4cGVjdChjcmVhdGVkSnVzdFdpdGhPZih7fSkpLnRvQmUodHJ1ZSk7XG4gICAgZXhwZWN0KGNyZWF0ZWRKdXN0V2l0aE9mKHRydWUpKS50b0JlKHRydWUpO1xuICAgIGV4cGVjdChjcmVhdGVkSnVzdFdpdGhPZihmYWxzZSkpLnRvQmUodHJ1ZSk7XG4gICAgZXhwZWN0KGNyZWF0ZWRKdXN0V2l0aE9mKFtdKSkudG9CZSh0cnVlKTtcbiAgfSk7XG5cbiAgaXQoJ1JldHVucyBkZWZhdWx0IG9ubHkgdG8gTm90aGluZyB2YWx1ZXMnLCAoKSA9PiB7XG4gICAgZXhwZWN0KE1heWJlLndpdGhEZWZhdWx0KGRlZmF1bHRWYWwsIE1heWJlLkp1c3QoanVzdFZhbCkpKS50b0VxdWFsKGp1c3RWYWwpO1xuICAgIGV4cGVjdChNYXliZS53aXRoRGVmYXVsdChkZWZhdWx0VmFsLCBNYXliZS5Ob3RoaW5nKGp1c3RWYWwpKSkudG9FcXVhbChkZWZhdWx0VmFsKTtcbiAgfSk7XG5cbiAgaXQoJ21hcHMgSnVzdCBvbmx5IHZhbHVlcycsICgpID0+IHtcbiAgICBjb25zdCBtYXBwZWRWYWwgPSAnbWFwcGVkJztcbiAgICBjb25zdCBmdW5jID0gXyA9PiBtYXBwZWRWYWw7XG4gICAgY29uc3QgbWFwQW5kR2V0RGVmYXVsdCA9IHBpcGUoTWF5YmUubWFwKGZ1bmMpLCBNYXliZS53aXRoRGVmYXVsdChkZWZhdWx0VmFsKSk7XG4gICAgZXhwZWN0KG1hcEFuZEdldERlZmF1bHQoTWF5YmUuSnVzdChqdXN0VmFsKSkpLnRvRXF1YWwobWFwcGVkVmFsKTtcbiAgICBleHBlY3QobWFwQW5kR2V0RGVmYXVsdChNYXliZS5Ob3RoaW5nKGp1c3RWYWwpKSkudG9FcXVhbChkZWZhdWx0VmFsKTtcbiAgfSk7XG5cbiAgaXQoJ2RvZXNuXFwnIGRvZXMgbm90IGNvbnRpbnVlIG1hcHBpbmcgd2hlbiBhIG51bGwgdmFsdWUgYXBwZWFycycsICgpID0+IHtcbiAgICBleHBlY3QoXG4gICAgICBNYXliZS5vZihqdXN0VmFsKVxuICAgICAgLm1hcChfID0+IG51bGwpXG4gICAgICAubWFwKF8gPT4ganVzdFZhbClcbiAgICAgIC53aXRoRGVmYXVsdChkZWZhdWx0VmFsKVxuICAgICkudG9FcXVhbChkZWZhdWx0VmFsKTtcbiAgfSk7XG5cbiAgaXQoJ21hcHMgb25seSB0d28gSnVzdHMgaW4gbWFwMicsICgpID0+IHtcbiAgICBjb25zdCBtYXBwZWRWYWwgPSAnbWFwcGVkJztcbiAgICBjb25zdCBmdW5jID0gXyA9PiBtYXBwZWRWYWw7XG4gICAgY29uc3QgbWFwMkFuZEdldERlZmF1bHQgPSBwaXBlKE1heWJlLm1hcDIoZnVuYyksIE1heWJlLndpdGhEZWZhdWx0KGRlZmF1bHRWYWwpKTtcbiAgICBleHBlY3QobWFwMkFuZEdldERlZmF1bHQoTWF5YmUuSnVzdChqdXN0VmFsKSwgTWF5YmUuSnVzdChqdXN0VmFsKSkpLnRvRXF1YWwobWFwcGVkVmFsKTtcbiAgICBleHBlY3QobWFwMkFuZEdldERlZmF1bHQoTWF5YmUuSnVzdChqdXN0VmFsKSwgTWF5YmUuTm90aGluZyhqdXN0VmFsKSkpLnRvRXF1YWwoZGVmYXVsdFZhbCk7XG4gICAgZXhwZWN0KG1hcDJBbmRHZXREZWZhdWx0KE1heWJlLk5vdGhpbmcoanVzdFZhbCksIE1heWJlLkp1c3QoanVzdFZhbCkpKS50b0VxdWFsKGRlZmF1bHRWYWwpO1xuICAgIGV4cGVjdChtYXAyQW5kR2V0RGVmYXVsdChNYXliZS5Ob3RoaW5nKGp1c3RWYWwpLCBNYXliZS5Ob3RoaW5nKGp1c3RWYWwpKSkudG9FcXVhbChkZWZhdWx0VmFsKTtcbiAgfSk7XG5cbiAgaXQoJ2hhcyBjdXJyaWVkIG1hcHMnLCAoKSA9PiB7XG4gICAgY29uc3QgbWFwcGVkVmFsID0gJ21hcHBlZCc7XG4gICAgZXhwZWN0KFxuICAgICAgTWF5YmUud2l0aERlZmF1bHQoXG4gICAgICAgIGRlZmF1bHRWYWwsXG4gICAgICAgIE1heWJlLm1hcChfID0+IG1hcHBlZFZhbCkoTWF5YmUuSnVzdCgnaicpKVxuICAgICAgKVxuICAgICkudG9FcXVhbChtYXBwZWRWYWwpO1xuICB9KTtcbn0pO1xuIiwiLyogZXNsaW50LWVudiBqYXNtaW5lICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwLCBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuaW1wb3J0IHsgcGlwZSB9IGZyb20gJ3JhbWRhJztcbmltcG9ydCB7XG4gIFZhbGlkYXRpb24sXG4gIFRpbWVJbnRlcnZhbCxcbn0gZnJvbSAnLi4vLi4vanMvdHlwZXMnO1xuXG5kZXNjcmliZSgnVGltZUludGVydmFsIHR5cGUnLCAoKSA9PiB7XG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gIGNvbnN0IHZhbGlkT2JqID0geyBzdGFydDogbmV3IERhdGUobm93KSwgZW5kOiBuZXcgRGF0ZShub3cgKyA1ICogMTAwMCkgfTtcblxuICBpdCgnY2hlY2tzIGZvciB0eXBlcyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgY29uc3QgaW52YWxpZDEgPSB7fTtcbiAgICBjb25zdCBpbnZhbGlkMiA9IHsgc3RhcnQ6IG5ldyBEYXRlKCkgfTtcbiAgICBjb25zdCBpbnZhbGlkMyA9IHsgc3RhcnQ6IG5ldyBEYXRlKCksIGVuZDogJycgfTtcbiAgICBjb25zdCBpbnZhbGlkNCA9IHsgc3RhcnQ6IG5ldyBEYXRlLCBlbmQ6IDEyMyB9O1xuICAgIGNvbnN0IGludmFsaWQ1ID0geyBlbmQ6IG5ldyBEYXRlIH07XG5cbiAgICBjb25zdCB2YWxpZGF0ZXMgPSBwaXBlKFRpbWVJbnRlcnZhbC50eXBlQ2hlY2ssIFZhbGlkYXRpb24uaXNTdWNjZXNzKTtcbiAgICBleHBlY3QodmFsaWRhdGVzKGludmFsaWQxKSkudG9FcXVhbChmYWxzZSk7XG4gICAgZXhwZWN0KHZhbGlkYXRlcyhpbnZhbGlkMikpLnRvRXF1YWwoZmFsc2UpO1xuICAgIGV4cGVjdCh2YWxpZGF0ZXMoaW52YWxpZDMpKS50b0VxdWFsKGZhbHNlKTtcbiAgICBleHBlY3QodmFsaWRhdGVzKGludmFsaWQ0KSkudG9FcXVhbChmYWxzZSk7XG4gICAgZXhwZWN0KHZhbGlkYXRlcyhpbnZhbGlkNSkpLnRvRXF1YWwoZmFsc2UpO1xuICB9KTtcblxuICBpdCgncmV0dXJucyBzdGFydCBkYXRlIHdpdGhvdXQgYnJlYWtpbmcgd2l0aCBudWxsJywgKCkgPT4ge1xuICAgIGV4cGVjdChUaW1lSW50ZXJ2YWwuZ2V0U3RhcnQodmFsaWRPYmopKS50b0VxdWFsKHZhbGlkT2JqLnN0YXJ0KTtcbiAgICBleHBlY3QoVGltZUludGVydmFsLmdldFN0YXJ0KHt9KSkudG9FcXVhbChudWxsKTtcbiAgICBleHBlY3QoVGltZUludGVydmFsLmdldFN0YXJ0KG51bGwpKS50b0VxdWFsKG51bGwpO1xuICAgIGV4cGVjdChUaW1lSW50ZXJ2YWwuZ2V0U3RhcnQodW5kZWZpbmVkKSkudG9FcXVhbChudWxsKTtcbiAgfSk7XG5cbiAgaXQoJ3JldHVybnMgZW5kIGRhdGUgd2l0aG91dCBicmVha2luZyB3aXRoIG51bGwnLCAoKSA9PiB7XG4gICAgZXhwZWN0KFRpbWVJbnRlcnZhbC5nZXRFbmQodmFsaWRPYmopKS50b0VxdWFsKHZhbGlkT2JqLmVuZCk7XG4gICAgZXhwZWN0KFRpbWVJbnRlcnZhbC5nZXRFbmQoe30pKS50b0VxdWFsKG51bGwpO1xuICAgIGV4cGVjdChUaW1lSW50ZXJ2YWwuZ2V0RW5kKG51bGwpKS50b0VxdWFsKG51bGwpO1xuICAgIGV4cGVjdChUaW1lSW50ZXJ2YWwuZ2V0RW5kKHVuZGVmaW5lZCkpLnRvRXF1YWwobnVsbCk7XG4gIH0pO1xuXG4gIGl0KCdjYWxjdWxhdGVzIHRoZSBkYXRlIGRpZmZlcmVuY2UgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgIGV4cGVjdChUaW1lSW50ZXJ2YWwuZ2V0VmFsdWUodmFsaWRPYmopKS50b0VxdWFsKDUgKiAxMDAwKTtcbiAgfSk7XG5cbiAgaXQoJ3JldHVybnMgbnVsbCBpZiBhbiBpbnZhbGlkIFRpbWVJbnRlcnZhbCBvYmplY3QgaXMgcHJvdmlkZWQgaW4gZ2V0VmFsdWUnLCAoKSA9PiB7XG4gICAgZXhwZWN0KF8gPT4gVGltZUludGVydmFsLmdldFZhbHVlKG51bGwpKS5ub3QudG9UaHJvdygpO1xuICAgIGV4cGVjdChUaW1lSW50ZXJ2YWwuZ2V0VmFsdWUobnVsbCkpLnRvRXF1YWwobnVsbCk7XG4gICAgZXhwZWN0KFRpbWVJbnRlcnZhbC5nZXRWYWx1ZSh1bmRlZmluZWQpKS50b0VxdWFsKG51bGwpO1xuICAgIGV4cGVjdChUaW1lSW50ZXJ2YWwuZ2V0VmFsdWUoe30pKS50b0VxdWFsKG51bGwpO1xuICAgIGV4cGVjdChUaW1lSW50ZXJ2YWwuZ2V0VmFsdWUoW10pKS50b0VxdWFsKG51bGwpO1xuICB9KTtcbn0pO1xuIiwiLyogZXNsaW50LWVudiBqYXNtaW5lICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwLCBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuaW1wb3J0IHsgcGlwZSB9IGZyb20gJ3JhbWRhJztcbmltcG9ydCB7XG4gIFByb2plY3QsXG4gIFJlY29yZGluZyxcbiAgVmFsaWRhdGlvbixcbn0gZnJvbSAnLi4vLi4vanMvdHlwZXMnO1xuXG5kZXNjcmliZSgnUHJvamVjdCB0eXBlJywgKCkgPT4ge1xuICBjb25zdCBkZWxpdlJlYyA9IFJlY29yZGluZy5vZih7IHN0YXJ0VGltZTogbnVsbCwgaW50ZXJ2YWxzOiBbXSB9KTtcbiAgY29uc3QgbW9ja0RlbGl2ZXJhYmxlID0geyBuYW1lOiAnYWFhJywgdXJsOiAnd3d3JywgcmVjb3JkaW5nOiBkZWxpdlJlYyB9O1xuICBjb25zdCB2YWxpZE5hbWUgPSAnbmFtZSc7XG4gIGNvbnN0IHZhbGlkVXJsID0gJ3VybCc7XG4gIGNvbnN0IHVuc2VsZWN0ZWREZWxpdmVyYWJsZXMgPSBbbW9ja0RlbGl2ZXJhYmxlXTtcbiAgY29uc3QgdmFsaWQgPSB7XG4gICAgbmFtZTogdmFsaWROYW1lLFxuICAgIHVybDogdmFsaWRVcmwsXG4gICAgdW5zZWxlY3RlZERlbGl2ZXJhYmxlcyxcbiAgICBzZWxlY3RlZERlbGl2ZXJhYmxlOiBtb2NrRGVsaXZlcmFibGUsXG4gIH07XG5cbiAgaXQoJ3R5cGVDaGVja3Mgb2snLCAoKSA9PiB7XG4gICAgY29uc3QgaW52YWxpZDEgPSB7XG4gICAgICBuYW1lOiB2YWxpZE5hbWUsXG4gICAgICB1cmw6IHZhbGlkVXJsLFxuICAgICAgdW5zZWxlY3RlZERlbGl2ZXJhYmxlczogbnVsbCxcbiAgICAgIHNlbGVjdGVkRGVsaXZlcmFibGU6IG51bGwsXG4gICAgfTtcbiAgICBjb25zdCBpbnZhbGlkMiA9IHtcbiAgICAgIG5hbWU6IHZhbGlkTmFtZSxcbiAgICAgIHVybDogdmFsaWRVcmwsXG4gICAgICB1bnNlbGVjdGVkRGVsaXZlcmFibGVzOiBbXSxcbiAgICAgIHNlbGVjdGVkRGVsaXZlcmFibGU6IFtdLFxuICAgIH07XG4gICAgY29uc3QgaW52YWxpZDMgPSB7fTtcblxuICAgIGNvbnN0IGlzVmFsaWQgPSBwaXBlKFByb2plY3QudHlwZUNoZWNrLCBWYWxpZGF0aW9uLmlzU3VjY2Vzcyk7XG4gICAgZXhwZWN0KGlzVmFsaWQoaW52YWxpZDEpKS50b0VxdWFsKGZhbHNlKTtcbiAgICBleHBlY3QoaXNWYWxpZChpbnZhbGlkMikpLnRvRXF1YWwoZmFsc2UpO1xuICAgIGV4cGVjdChpc1ZhbGlkKGludmFsaWQzKSkudG9FcXVhbChmYWxzZSk7XG4gICAgZXhwZWN0KGlzVmFsaWQodmFsaWQpKS50b0VxdWFsKHRydWUpO1xuICB9KTtcblxuICBpdCgncmV0dXJucyBuYW1lIHdpdGhvdXQgYnJlYWtpbmcgd2l0aCBudWxsJywgKCkgPT4ge1xuICAgIGNvbnN0IGdldE5hbWUgPSBwaXBlKFByb2plY3Qub2YsIFByb2plY3QuZ2V0TmFtZSk7XG4gICAgZXhwZWN0KGdldE5hbWUodmFsaWQpKS50b0VxdWFsKHZhbGlkTmFtZSk7XG4gICAgZXhwZWN0KGdldE5hbWUoe30pKS50b0VxdWFsKG51bGwpO1xuICAgIGV4cGVjdChnZXROYW1lKCkpLnRvRXF1YWwobnVsbCk7XG4gICAgZXhwZWN0KGdldE5hbWUobnVsbCkpLnRvRXF1YWwobnVsbCk7XG4gIH0pO1xuXG4gIGl0KCdyZXR1cm5zIHVybCB3aXRob3V0IGJyZWFraW5nIHdpdGggbnVsbCcsICgpID0+IHtcbiAgICBjb25zdCBnZXRVcmwgPSBwaXBlKFByb2plY3Qub2YsIFByb2plY3QuZ2V0VXJsKTtcbiAgICBleHBlY3QoZ2V0VXJsKHZhbGlkKSkudG9FcXVhbCh2YWxpZFVybCk7XG4gICAgZXhwZWN0KGdldFVybCh7fSkpLnRvRXF1YWwobnVsbCk7XG4gICAgZXhwZWN0KGdldFVybCgpKS50b0VxdWFsKG51bGwpO1xuICAgIGV4cGVjdChnZXRVcmwobnVsbCkpLnRvRXF1YWwobnVsbCk7XG4gIH0pO1xuXG4gIGl0KCdyZXR1cm5zIGRlbGl2ZXJhYmxlcyB3aXRob3V0IGJyZWFraW5nIHdpdGggbnVsbCcsICgpID0+IHtcbiAgICBjb25zdCBnZXREZWxpdmVyYWJsZXMgPSBwaXBlKFByb2plY3Qub2YsIFByb2plY3QuZ2V0RGVsaXZlcmFibGVzKTtcbiAgICBleHBlY3QoZ2V0RGVsaXZlcmFibGVzKHZhbGlkKS5maW5kKG0gPT4gbS51cmwgPT09IG1vY2tEZWxpdmVyYWJsZS51cmwpKS50b0JlVHJ1dGh5KCk7XG4gICAgZXhwZWN0KGdldERlbGl2ZXJhYmxlcyh7fSkpLnRvRXF1YWwoW10pO1xuICAgIGV4cGVjdChnZXREZWxpdmVyYWJsZXMoKSkudG9FcXVhbChbXSk7XG4gICAgZXhwZWN0KGdldERlbGl2ZXJhYmxlcyhudWxsKSkudG9FcXVhbChbXSk7XG4gIH0pO1xuXG4gIGl0KCdyZXR1cm5zIHNlbGVjdGVkRGVsaXZlcmFibGUgd2l0aG91dCBicmVha2luZyB3aXRoIG51bGwnLCAoKSA9PiB7XG4gICAgY29uc3QgZ2V0U2VsZWN0ZWREZWxpdmVyYWJsZSA9IHBpcGUoUHJvamVjdC5vZiwgUHJvamVjdC5nZXRTZWxlY3RlZERlbGl2ZXJhYmxlKTtcbiAgICBleHBlY3QoZ2V0U2VsZWN0ZWREZWxpdmVyYWJsZSh2YWxpZCkpLnRvRXF1YWwobW9ja0RlbGl2ZXJhYmxlKTtcbiAgICBleHBlY3QoZ2V0U2VsZWN0ZWREZWxpdmVyYWJsZSh7fSkpLnRvRXF1YWwobnVsbCk7XG4gICAgZXhwZWN0KGdldFNlbGVjdGVkRGVsaXZlcmFibGUoKSkudG9FcXVhbChudWxsKTtcbiAgICBleHBlY3QoZ2V0U2VsZWN0ZWREZWxpdmVyYWJsZShudWxsKSkudG9FcXVhbChudWxsKTtcbiAgfSk7XG5cbiAgaXQoJ3VwZGF0ZXMgYSBkZWxpdmVyYWJsZSB0aGF0IGlzIHNlbGVjdGVkJywgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tEZWxpdmVyYWJsZUNoYW5nZWQgPSBPYmplY3QuYXNzaWduKHt9LCBtb2NrRGVsaXZlcmFibGUsIHsgdXJsOiAnampqJyB9KTtcbiAgICBjb25zdCBtb2NrUHJvamVjdCA9IHtcbiAgICAgIG5hbWU6ICdhc2ZkJyxcbiAgICAgIHVybDogJ2FzZGYnLFxuICAgICAgdW5zZWxlY3RlZERlbGl2ZXJhYmxlczogW10sXG4gICAgICBzZWxlY3RlZERlbGl2ZXJhYmxlOiBtb2NrRGVsaXZlcmFibGUsXG4gICAgfTtcblxuICAgIGNvbnN0IHVwZGF0ZUFuZEdldERlbGl2ZXJhYmxlcyA9IHBpcGUoXG4gICAgICBQcm9qZWN0LnVwZGF0ZURlbGl2ZXJhYmxlLFxuICAgICAgUHJvamVjdC5nZXREZWxpdmVyYWJsZXMsXG4gICAgKTtcblxuICAgIGV4cGVjdChcbiAgICAgIHVwZGF0ZUFuZEdldERlbGl2ZXJhYmxlcyhtb2NrUHJvamVjdCwgbW9ja0RlbGl2ZXJhYmxlQ2hhbmdlZClcbiAgICAgICAgLmZpbmQobSA9PiBtLnVybCA9PT0gbW9ja0RlbGl2ZXJhYmxlQ2hhbmdlZC51cmwpXG4gICAgKS50b0JlVHJ1dGh5KCk7XG4gICAgZXhwZWN0KFxuICAgICAgdXBkYXRlQW5kR2V0RGVsaXZlcmFibGVzKG1vY2tQcm9qZWN0LCBtb2NrRGVsaXZlcmFibGVDaGFuZ2VkKVxuICAgICAgICAuZmluZChtID0+IG0udXJsID09PSBtb2NrRGVsaXZlcmFibGUudXJsKVxuICAgICkudG9CZUZhbHN5KCk7XG4gIH0pO1xuXG4gIGl0KCd1cGRhdGVzIGEgZGVsaXZlcmFibGUgdGhhdCBpcyBub3Qgc2VsZWN0ZWQnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja0RlbGl2ZXJhYmxlQ2hhbmdlZCA9IE9iamVjdC5hc3NpZ24oe30sIG1vY2tEZWxpdmVyYWJsZSwgeyB1cmw6ICdqamonIH0pO1xuICAgIGNvbnN0IG1vY2tQcm9qZWN0ID0ge1xuICAgICAgbmFtZTogJ2FzZmQnLFxuICAgICAgdXJsOiAnYXNkZicsXG4gICAgICB1bnNlbGVjdGVkRGVsaXZlcmFibGVzOiBbbW9ja0RlbGl2ZXJhYmxlXSxcbiAgICAgIHNlbGVjdGVkRGVsaXZlcmFibGU6IG51bGwsXG4gICAgfTtcblxuICAgIGNvbnN0IHVwZGF0ZUFuZEdldERlbGl2ZXJhYmxlcyA9IHBpcGUoXG4gICAgICBQcm9qZWN0LnVwZGF0ZURlbGl2ZXJhYmxlLFxuICAgICAgUHJvamVjdC5nZXREZWxpdmVyYWJsZXMsXG4gICAgKTtcblxuICAgIGV4cGVjdChcbiAgICAgIHVwZGF0ZUFuZEdldERlbGl2ZXJhYmxlcyhtb2NrUHJvamVjdCwgbW9ja0RlbGl2ZXJhYmxlQ2hhbmdlZClcbiAgICAgICAgLmZpbmQobSA9PiBtLnVybCA9PT0gbW9ja0RlbGl2ZXJhYmxlQ2hhbmdlZC51cmwpXG4gICAgKS50b0JlVHJ1dGh5KCk7XG4gICAgZXhwZWN0KFxuICAgICAgdXBkYXRlQW5kR2V0RGVsaXZlcmFibGVzKG1vY2tQcm9qZWN0LCBtb2NrRGVsaXZlcmFibGVDaGFuZ2VkKVxuICAgICAgICAuZmluZChtID0+IG0udXJsID09PSBtb2NrRGVsaXZlcmFibGUudXJsKVxuICAgICkudG9CZUZhbHN5KCk7XG4gIH0pO1xuXG4gIGl0KCdoYW5kbGVzIG51bGxzIHdoZW4gdXBkYXRpbmcgZGVsaXZlcmFibGVzJywgKCkgPT4ge1xuICAgIGV4cGVjdChfID0+IFByb2plY3QudXBkYXRlRGVsaXZlcmFibGUobnVsbCwgbnVsbCkpLm5vdC50b1Rocm93KCk7XG4gICAgZXhwZWN0KF8gPT4gUHJvamVjdC51cGRhdGVEZWxpdmVyYWJsZSh2YWxpZCwgbnVsbCkpLm5vdC50b1Rocm93KCk7XG4gICAgZXhwZWN0KF8gPT4gUHJvamVjdC51cGRhdGVEZWxpdmVyYWJsZSh2YWxpZCwgdmFsaWQpKS5ub3QudG9UaHJvdygpO1xuICB9KTtcbn0pO1xuIiwiLyogZXNsaW50LWVudiBqYXNtaW5lICovXG5pbXBvcnQgdG9nZ2xlUmVjb3JkaW5nIGZyb20gJy4uLy4uL2pzL1dpZGdldC91cGRhdGUvdG9nZ2xlUmVjb3JkaW5nJztcbmltcG9ydCB7IFJlY29yZGluZywgRGVsaXZlcmFibGUgfSBmcm9tICcuLi8uLi9qcy90eXBlcyc7XG5pbXBvcnQgeyBwaXBlLCBwcm9wIH0gZnJvbSAncmFtZGEnO1xuaW1wb3J0IHsgcmVjb3JkaW5nc0luZm8gfSBmcm9tICcuLi8uLi9qcy9XaWRnZXQvdXBkYXRlL3V0aWxzJztcblxuY29uc3QgbW9ja0RlbGl2ZXJhYmxlID0ge1xuICBcIm5hbWVcIjogXCJSdXNoIHdpdGggcG9zc2libGUgY2xpZW50c1wiLFxuICBcInVybFwiOiBcImxvY2FsaG9zdDo4MDgwL2RlbGl2ZXJhYmxlcy9ydXNoLWNvbGQtY2FsbFwiLFxuICBcInJlY29yZGluZ1wiOiB7XG4gICAgXCJzdGFydFRpbWVcIjogbnVsbCxcbiAgICBcImludGVydmFsc1wiOiBbe1xuICAgICAgXCJzdGFydFwiOiBcIjIwMTYtMTItMTNUMTM6Mzc6MDEuNDY1WlwiLFxuICAgICAgXCJlbmRcIjogXCIyMDE2LTEyLTEzVDEzOjQxOjIzLjQ1N1pcIlxuICAgIH1dXG4gIH1cbn1cblxuY29uc3QgbW9ja1Byb2plY3QgPSB7XG4gIFwibmFtZVwiOiBcIlJ1c2hlZCBwcm9qZWN0XCIsXG4gIFwidXJsXCI6IFwibG9jYWxob3N0OjgwODAvcHJvamVjdHMvcnVzaGVkLXByb2plY3RcIixcbiAgXCJ1bnNlbGVjdGVkRGVsaXZlcmFibGVzXCI6IFtcbiAgICBtb2NrRGVsaXZlcmFibGUsIHtcbiAgICBcIm5hbWVcIjogXCJSdXNoIHdpdGggb25saW5lIGFkc1wiLFxuICAgIFwidXJsXCI6IFwibG9jYWxob3N0OjgwODAvZGVsaXZlcmFibGVzL3J1c2gtYnV5LWFkc1wiLFxuICAgIFwicmVjb3JkaW5nXCI6IHtcbiAgICAgIFwic3RhcnRUaW1lXCI6IG51bGwsXG4gICAgICBcImludGVydmFsc1wiOiBbe1xuICAgICAgICBcInN0YXJ0XCI6IFwiMjAxNi0xMi0xM1QxMzozNjo1OC45NDFaXCIsXG4gICAgICAgIFwiZW5kXCI6IFwiMjAxNi0xMi0xM1QxMzozNzowMS40NjBaXCJcbiAgICAgIH1dXG4gICAgfVxuICB9LCB7XG4gICAgXCJuYW1lXCI6IFwiUnVzaCB3aXRoIGxvZ29cIixcbiAgICBcInVybFwiOiBcImxvY2FsaG9zdDo4MDgwL2RlbGl2ZXJhYmxlcy9ydXNoLWNyZWF0ZS1sb2dvXCIsXG4gICAgXCJyZWNvcmRpbmdcIjogbnVsbFxuICB9XSxcbiAgXCJzZWxlY3RlZERlbGl2ZXJhYmxlXCI6IG1vY2tEZWxpdmVyYWJsZVxufTtcblxuY29uc3QgbW9ja1Vuc2VsZWN0ZWREZWxpdmVyYWJsZSA9IHtcbiAgXCJuYW1lXCI6IFwiVXNlbGVzcyBsb2dvXCIsXG4gIFwidXJsXCI6IFwibG9jYWxob3N0OjgwODAvZGVsaXZlcmFibGVzL3VzZWxlc3MtY3JlYXRlLWxvZ29cIixcbiAgXCJyZWNvcmRpbmdcIjogbnVsbFxufTtcblxuY29uc3QgbW9ja1Vuc2VsZWN0ZWRQcm9qZWN0ID0ge1xuICBcIm5hbWVcIjogXCJVc2VsZXNzIHByb2plY3RcIixcbiAgXCJ1cmxcIjogXCJsb2NhbGhvc3Q6ODA4MC9wcm9qZWN0cy9ydXNoZWQtcHJvamVjdFwiLFxuICBcInVuc2VsZWN0ZWREZWxpdmVyYWJsZXNcIjogW1xuICAgIG1vY2tVbnNlbGVjdGVkRGVsaXZlcmFibGUsIHtcbiAgICBcIm5hbWVcIjogXCJVc2VsZXNzIG9ubGluZSBhZHNcIixcbiAgICBcInVybFwiOiBcImxvY2FsaG9zdDo4MDgwL2RlbGl2ZXJhYmxlcy91c2VsZXNzLWJ1eS1hZHNcIixcbiAgICBcInJlY29yZGluZ1wiOiBudWxsXG4gIH0sIHtcbiAgICBcIm5hbWVcIjogXCJVc2VsZXNzIHBvc3NpYmxlIGNsaWVudHNcIixcbiAgICBcInVybFwiOiBcImxvY2FsaG9zdDo4MDgwL2RlbGl2ZXJhYmxlcy91c2VsZXNzLWNvbGQtY2FsbFwiLFxuICAgIFwicmVjb3JkaW5nXCI6IG51bGxcbiAgfV0sXG4gIFwic2VsZWN0ZWREZWxpdmVyYWJsZVwiOiBudWxsXG59O1xuXG5jb25zdCBtb2NrTW9kZWwgPSB7XG4gIFwibWluaW1pc2VkXCI6IGZhbHNlLFxuICBcInNlcnZlclVSTFwiOiBcIi4vZGF0YS5qc29uXCIsXG4gIFwidW5zZWxlY3RlZFByb2plY3RzXCI6IFtcbiAgICBtb2NrVW5zZWxlY3RlZFByb2plY3QsIHtcbiAgICBcIm5hbWVcIjogXCJCaWcgcHJvamVjdFwiLFxuICAgIFwidXJsXCI6IFwibG9jYWxob3N0OjgwODAvcHJvamVjdHMvYmlnLXByb2plY3RcIixcbiAgICBcInVuc2VsZWN0ZWREZWxpdmVyYWJsZXNcIjogW3tcbiAgICAgIFwibmFtZVwiOiBcIkNvbGQgY2FsbCBwb3NzaWJsZSBjbGllbnRzXCIsXG4gICAgICBcInVybFwiOiBcImxvY2FsaG9zdDo4MDgwL2RlbGl2ZXJhYmxlcy9jb2xkLWNhbGxcIixcbiAgICAgIFwicmVjb3JkaW5nXCI6IHtcbiAgICAgICAgXCJzdGFydFRpbWVcIjogXCIyMDE2LTEyLTEzVDEzOjM3OjUyLjA3OFpcIiwgLy8vIElzIHJlY29yZGluZ1xuICAgICAgICBcImludGVydmFsc1wiOiBbe1xuICAgICAgICAgIFwic3RhcnRcIjogXCIyMDE2LTEyLTEzVDEzOjM2OjUyLjA3OFpcIixcbiAgICAgICAgICBcImVuZFwiOiBcIjIwMTYtMTItMTNUMTM6MzY6NTUuMDEzWlwiXG4gICAgICAgIH1dXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgXCJuYW1lXCI6IFwiQnV5IG9ubGluZSBhZHNcIixcbiAgICAgIFwidXJsXCI6IFwibG9jYWxob3N0OjgwODAvZGVsaXZlcmFibGVzL2J1eS1hZHNcIixcbiAgICAgIFwicmVjb3JkaW5nXCI6IHtcbiAgICAgICAgXCJzdGFydFRpbWVcIjogXCIyMDE2LTEyLTEzVDEzOjM5OjUyLjA3OFpcIiwgLy8gSXMgcmVjb3JkaW5nXG4gICAgICAgIFwiaW50ZXJ2YWxzXCI6IFt7XG4gICAgICAgICAgXCJzdGFydFwiOiBcIjIwMTYtMTItMTNUMTM6MzY6NTAuMzA5WlwiLFxuICAgICAgICAgIFwiZW5kXCI6IFwiMjAxNi0xMi0xM1QxMzozNjo1Mi4wNzVaXCJcbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9XSxcbiAgICBcInNlbGVjdGVkRGVsaXZlcmFibGVcIjoge1xuICAgICAgXCJuYW1lXCI6IFwiQ3JlYXRlIGxvZ29cIixcbiAgICAgIFwidXJsXCI6IFwibG9jYWxob3N0OjgwODAvZGVsaXZlcmFibGVzL2NyZWF0ZS1sb2dvXCIsXG4gICAgICBcInJlY29yZGluZ1wiOiB7XG4gICAgICAgIFwic3RhcnRUaW1lXCI6IG51bGwsXG4gICAgICAgIFwiaW50ZXJ2YWxzXCI6IFt7XG4gICAgICAgICAgXCJzdGFydFwiOiBcIjIwMTYtMTItMTNUMTM6MzY6NTUuMDE4WlwiLFxuICAgICAgICAgIFwiZW5kXCI6IFwiMjAxNi0xMi0xM1QxMzozNjo1OC45MzVaXCJcbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9XG4gIH1dLFxuICBcInNlbGVjdGVkUHJvamVjdFwiOiB7XG4gICAgXCJuYW1lXCI6IFwiUnVzaGVkIHByb2plY3RcIixcbiAgICBcInVybFwiOiBcImxvY2FsaG9zdDo4MDgwL3Byb2plY3RzL3J1c2hlZC1wcm9qZWN0XCIsXG4gICAgXCJ1bnNlbGVjdGVkRGVsaXZlcmFibGVzXCI6IFt7XG4gICAgICBcIm5hbWVcIjogXCJSdXNoIHdpdGggb25saW5lIGFkc1wiLFxuICAgICAgXCJ1cmxcIjogXCJsb2NhbGhvc3Q6ODA4MC9kZWxpdmVyYWJsZXMvcnVzaC1idXktYWRzXCIsXG4gICAgICBcInJlY29yZGluZ1wiOiB7XG4gICAgICAgIFwic3RhcnRUaW1lXCI6IG51bGwsXG4gICAgICAgIFwiaW50ZXJ2YWxzXCI6IFt7XG4gICAgICAgICAgXCJzdGFydFwiOiBcIjIwMTYtMTItMTNUMTM6MzY6NTguOTQxWlwiLFxuICAgICAgICAgIFwiZW5kXCI6IFwiMjAxNi0xMi0xM1QxMzozNzowMS40NjBaXCJcbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBcIm5hbWVcIjogXCJSdXNoIHdpdGggbG9nb1wiLFxuICAgICAgXCJ1cmxcIjogXCJsb2NhbGhvc3Q6ODA4MC9kZWxpdmVyYWJsZXMvcnVzaC1jcmVhdGUtbG9nb1wiLFxuICAgICAgXCJyZWNvcmRpbmdcIjogbnVsbFxuICAgIH1dLFxuICAgIFwic2VsZWN0ZWREZWxpdmVyYWJsZVwiOiB7XG4gICAgICBcIm5hbWVcIjogXCJSdXNoIHdpdGggcG9zc2libGUgY2xpZW50c1wiLFxuICAgICAgXCJ1cmxcIjogXCJsb2NhbGhvc3Q6ODA4MC9kZWxpdmVyYWJsZXMvcnVzaC1jb2xkLWNhbGxcIixcbiAgICAgIFwicmVjb3JkaW5nXCI6IHtcbiAgICAgICAgXCJzdGFydFRpbWVcIjogXCIyMDE2LTEyLTEzVDEzOjQxOjI0LjIwMlpcIixcbiAgICAgICAgXCJpbnRlcnZhbHNcIjogW3tcbiAgICAgICAgICBcInN0YXJ0XCI6IFwiMjAxNi0xMi0xM1QxMzozNzowMS40NjVaXCIsXG4gICAgICAgICAgXCJlbmRcIjogXCIyMDE2LTEyLTEzVDEzOjQxOjIzLjQ1N1pcIlxuICAgICAgICB9XVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5kZXNjcmliZSgnVXBkYXRlLnRvZ2dsZVJlY29yZGluZycsICgpID0+IHtcbiAgaXQoJ3N0b3BzIG90aGVyIHJlY29yZGluZ3Mgd2hlbiB0b2dnbGluZyB0aGUgc2VsZWN0ZWQgcHJvamVjdCcsICgpID0+IHtcbiAgICBjb25zdCBtb2NrQWN0aW9uID0ge1xuICAgICAgcHJvamVjdDogbW9ja1Byb2plY3QsXG4gICAgICBkZWxpdmVyYWJsZTogbW9ja0RlbGl2ZXJhYmxlLFxuICAgIH07XG5cbiAgICBjb25zdCB0b2dnbGVkTW9kZWwgPSB0b2dnbGVSZWNvcmRpbmcobW9ja01vZGVsLCBtb2NrQWN0aW9uKTtcblxuICAgIGNvbnN0IGRlbGl2ZXJhYmxlc1JlY29yZGluZyA9IHJlY29yZGluZ3NJbmZvKHRvZ2dsZWRNb2RlbClcbiAgICAgIC5maWx0ZXIocGlwZShwcm9wKCdyZWNvcmRpbmcnKSwgUmVjb3JkaW5nLmlzUmVjb3JkaW5nKSlcbiAgICAgIC5tYXAocHJvcCgnZGVsaXZlcmFibGUnKSk7XG5cbiAgICBleHBlY3QoZGVsaXZlcmFibGVzUmVjb3JkaW5nLmxlbmd0aCkudG9FcXVhbCgxKTtcbiAgICBjb25zdCBzYW1lTmFtZSA9XG4gICAgICBEZWxpdmVyYWJsZS5nZXROYW1lKG1vY2tEZWxpdmVyYWJsZSlcbiAgICAgID09PSBEZWxpdmVyYWJsZS5nZXROYW1lKGRlbGl2ZXJhYmxlc1JlY29yZGluZ1swXSk7XG4gICAgZXhwZWN0KHNhbWVOYW1lKS50b0VxdWFsKHRydWUpO1xuICB9KTtcblxuICBpdCgnc3RvcHMgb3RoZXIgcmVjb3JkaW5ncyB3aGVuIHRvZ2dsaW5nIGFuIHVuc2VsZWN0ZWQgcHJvamVjdCBhbmQgZGVsaXZlcmFibGUnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9ja0FjdGlvbiA9IHtcbiAgICAgIHByb2plY3Q6IG1vY2tVbnNlbGVjdGVkUHJvamVjdCxcbiAgICAgIGRlbGl2ZXJhYmxlOiBtb2NrVW5zZWxlY3RlZERlbGl2ZXJhYmxlLFxuICAgIH07XG5cbiAgICBjb25zdCB0b2dnbGVkTW9kZWwgPSB0b2dnbGVSZWNvcmRpbmcobW9ja01vZGVsLCBtb2NrQWN0aW9uKTtcblxuICAgIGNvbnN0IGRlbGl2ZXJhYmxlc1JlY29yZGluZyA9IHJlY29yZGluZ3NJbmZvKHRvZ2dsZWRNb2RlbClcbiAgICAgIC5maWx0ZXIocGlwZShwcm9wKCdyZWNvcmRpbmcnKSwgUmVjb3JkaW5nLmlzUmVjb3JkaW5nKSlcbiAgICAgIC5tYXAocHJvcCgnZGVsaXZlcmFibGUnKSk7XG5cbiAgICBleHBlY3QoZGVsaXZlcmFibGVzUmVjb3JkaW5nLmxlbmd0aCkudG9FcXVhbCgxKTtcbiAgICBjb25zdCBzYW1lTmFtZSA9XG4gICAgICBEZWxpdmVyYWJsZS5nZXROYW1lKG1vY2tVbnNlbGVjdGVkRGVsaXZlcmFibGUpXG4gICAgICA9PT0gRGVsaXZlcmFibGUuZ2V0TmFtZShkZWxpdmVyYWJsZXNSZWNvcmRpbmdbMF0pO1xuICAgIGV4cGVjdChzYW1lTmFtZSkudG9FcXVhbCh0cnVlKTtcbiAgfSk7XG59KTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgV2lkZ2V0IGZyb20gJy4vV2lkZ2V0JztcbmltcG9ydCBzdG9yZSBmcm9tICcuL3N0b3JlJztcbmltcG9ydCAnLi4vdGVzdHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHdyYXBwZXI6IEhUTUxFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgUmVhY3RET00ucmVuZGVyKDxXaWRnZXQgc3RvcmU9e3N0b3JlfSAvPiwgd3JhcHBlcik7XG4gIHJldHVybiB3cmFwcGVyO1xufVxuIl0sIm5hbWVzIjpbImludmFyaWFudCIsInJlcXVpcmUkJDAiLCJ0d29Bcmd1bWVudFBvb2xlciIsImZvdXJBcmd1bWVudFBvb2xlciIsIlBvb2xlZENsYXNzIiwiUmVhY3RDdXJyZW50T3duZXIiLCJlbXB0eUZ1bmN0aW9uIiwid2FybmluZyIsImNhbkRlZmluZVByb3BlcnR5IiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiX2Fzc2lnbiIsInJlcXVpcmUkJDQiLCJyZXF1aXJlJCQzIiwicmVxdWlyZSQkMiIsInJlcXVpcmUkJDEiLCJoYXNPd25Qcm9wZXJ0eSIsIlJlYWN0RWxlbWVudCIsImdldEl0ZXJhdG9yRm4iLCJLZXlFc2NhcGVVdGlscyIsInJlcXVpcmUkJDUiLCJ0cmF2ZXJzZUFsbENoaWxkcmVuIiwiUmVhY3RDaGlsZHJlbiIsIlJlYWN0Tm9vcFVwZGF0ZVF1ZXVlIiwiZW1wdHlPYmplY3QiLCJSZWFjdENvbXBvbmVudCIsIlJlYWN0UHVyZUNvbXBvbmVudCIsIlJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzIiwicmVxdWlyZSQkNyIsInJlcXVpcmUkJDYiLCJSZWFjdENsYXNzIiwiUmVhY3RDb21wb25lbnRUcmVlSG9vayIsIlJlYWN0UHJvcFR5cGVzU2VjcmV0IiwiY2hlY2tSZWFjdFR5cGVTcGVjIiwiUmVhY3RFbGVtZW50VmFsaWRhdG9yIiwiUmVhY3RET01GYWN0b3JpZXMiLCJSZWFjdFByb3BUeXBlcyIsIm9ubHlDaGlsZCIsInJlcXVpcmUkJDExIiwicmVxdWlyZSQkMTAiLCJyZXF1aXJlJCQ5IiwicmVxdWlyZSQkOCIsIlJlYWN0IiwiRE9NUHJvcGVydHkiLCJSZWFjdERPTUNvbXBvbmVudEZsYWdzIiwiUmVhY3RET01Db21wb25lbnRUcmVlIiwiQVJJQURPTVByb3BlcnR5Q29uZmlnIiwiRXZlbnRQbHVnaW5SZWdpc3RyeSIsIlJlYWN0RXJyb3JVdGlscyIsIkV2ZW50UGx1Z2luVXRpbHMiLCJhY2N1bXVsYXRlSW50byIsImZvckVhY2hBY2N1bXVsYXRlZCIsIkV2ZW50UGx1Z2luSHViIiwiRXZlbnRQcm9wYWdhdG9ycyIsIkV4ZWN1dGlvbkVudmlyb25tZW50Iiwib25lQXJndW1lbnRQb29sZXIiLCJ0aHJlZUFyZ3VtZW50UG9vbGVyIiwiZml2ZUFyZ3VtZW50UG9vbGVyIiwic3RhbmRhcmRSZWxlYXNlciIsIkRFRkFVTFRfUE9PTF9TSVpFIiwiREVGQVVMVF9QT09MRVIiLCJhZGRQb29saW5nVG8iLCJnZXRUZXh0Q29udGVudEFjY2Vzc29yIiwiRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlIiwiU3ludGhldGljRXZlbnQiLCJTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50IiwiU3ludGhldGljSW5wdXRFdmVudCIsIkJlZm9yZUlucHV0RXZlbnRQbHVnaW4iLCJDYWxsYmFja1F1ZXVlIiwiUmVhY3RGZWF0dXJlRmxhZ3MiLCJSZWFjdE93bmVyIiwiUmVhY3RSZWYiLCJSZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rIiwiUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2siLCJwZXJmb3JtYW5jZSIsInBlcmZvcm1hbmNlTm93IiwiUmVhY3REZWJ1Z1Rvb2wiLCJSZWFjdEluc3RydW1lbnRhdGlvbiIsIlJlYWN0UmVjb25jaWxlciIsIlJlYWN0VXBkYXRlcyIsImdldEV2ZW50VGFyZ2V0IiwiaXNFdmVudFN1cHBvcnRlZCIsImlzVGV4dElucHV0RWxlbWVudCIsImV2ZW50VHlwZXMiLCJDaGFuZ2VFdmVudFBsdWdpbiIsIkRlZmF1bHRFdmVudFBsdWdpbk9yZGVyIiwiU3ludGhldGljVUlFdmVudCIsIlZpZXdwb3J0TWV0cmljcyIsImdldEV2ZW50TW9kaWZpZXJTdGF0ZSIsIlN5bnRoZXRpY01vdXNlRXZlbnQiLCJFbnRlckxlYXZlRXZlbnRQbHVnaW4iLCJIVE1MRE9NUHJvcGVydHlDb25maWciLCJET01OYW1lc3BhY2VzIiwiY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiIsInNldElubmVySFRNTCIsImVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciIsInNldFRleHRDb250ZW50IiwiRE9NTGF6eVRyZWUiLCJ0b0FycmF5IiwiY3JlYXRlQXJyYXlGcm9tTWl4ZWQiLCJkdW1teU5vZGUiLCJnZXRNYXJrdXBXcmFwIiwiY3JlYXRlTm9kZXNGcm9tTWFya3VwIiwiRGFuZ2VyIiwiRE9NQ2hpbGRyZW5PcGVyYXRpb25zIiwiUmVhY3RET01JRE9wZXJhdGlvbnMiLCJSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCIsImZvY3VzTm9kZSIsIkF1dG9Gb2N1c1V0aWxzIiwiQ1NTUHJvcGVydHkiLCJjYW1lbGl6ZSIsImNhbWVsaXplU3R5bGVOYW1lIiwiaXNVbml0bGVzc051bWJlciIsImRhbmdlcm91c1N0eWxlVmFsdWUiLCJoeXBoZW5hdGUiLCJtc1BhdHRlcm4iLCJoeXBoZW5hdGVTdHlsZU5hbWUiLCJtZW1vaXplU3RyaW5nT25seSIsIkNTU1Byb3BlcnR5T3BlcmF0aW9ucyIsInF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyIiwiRE9NUHJvcGVydHlPcGVyYXRpb25zIiwiUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiIsImdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lIiwiUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyIiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiTGlua2VkVmFsdWVVdGlscyIsIlJlYWN0RE9NSW5wdXQiLCJkaWRXYXJuVmFsdWVMaW5rIiwiZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlIiwiUmVhY3RET01TZWxlY3QiLCJfaGFuZGxlQ2hhbmdlIiwiUmVhY3RET01PcHRpb24iLCJmb3JjZVVwZGF0ZUlmTW91bnRlZCIsIlJlYWN0RE9NVGV4dGFyZWEiLCJSZWFjdENvbXBvbmVudEVudmlyb25tZW50IiwiUmVhY3RJbnN0YW5jZU1hcCIsIlJlYWN0Tm9kZVR5cGVzIiwiaXMiLCJzaGFsbG93RXF1YWwiLCJzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCIsInJlcXVpcmUkJDE0IiwicmVxdWlyZSQkMTMiLCJyZXF1aXJlJCQxMiIsIlJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IiwiUmVhY3RFbXB0eUNvbXBvbmVudCIsIlJlYWN0SG9zdENvbXBvbmVudCIsImdldE5leHREZWJ1Z0lEIiwiaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCIsImVzY2FwZSIsInVuZXNjYXBlIiwiSVRFUkFUT1JfU1lNQk9MIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJTRVBBUkFUT1IiLCJTVUJTRVBBUkFUT1IiLCJkaWRXYXJuQWJvdXRNYXBzIiwiZ2V0Q29tcG9uZW50S2V5IiwidHJhdmVyc2VBbGxDaGlsZHJlbkltcGwiLCJSZWFjdENoaWxkUmVjb25jaWxlciIsImZsYXR0ZW5DaGlsZHJlbiIsImVucXVldWUiLCJSZWFjdE11bHRpQ2hpbGQiLCJlbnF1ZXVlVXBkYXRlIiwiUmVhY3RVcGRhdGVRdWV1ZSIsIl9jbGFzc0NhbGxDaGVjayIsIndhcm5Ob29wIiwiUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSIsIlRyYW5zYWN0aW9uIiwiVFJBTlNBQ1RJT05fV1JBUFBFUlMiLCJSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uIiwidmFsaWRhdGVET01OZXN0aW5nIiwicmVxdWlyZSQkMjUiLCJyZXF1aXJlJCQyNCIsInJlcXVpcmUkJDIzIiwicmVxdWlyZSQkMjIiLCJyZXF1aXJlJCQyMSIsInJlcXVpcmUkJDIwIiwicmVxdWlyZSQkMTkiLCJyZXF1aXJlJCQxOCIsInJlcXVpcmUkJDE3IiwicmVxdWlyZSQkMTYiLCJyZXF1aXJlJCQxNSIsIkZsYWdzIiwiUkVTRVJWRURfUFJPUFMiLCJSZWFjdERPTUNvbXBvbmVudCIsIlJlYWN0RE9NRW1wdHlDb21wb25lbnQiLCJSZWFjdERPTVRleHRDb21wb25lbnQiLCJSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5IiwiRXZlbnRMaXN0ZW5lciIsImdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uIiwiUmVhY3RFdmVudExpc3RlbmVyIiwiUmVhY3RJbmplY3Rpb24iLCJnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0IiwiUmVhY3RET01TZWxlY3Rpb24iLCJpc05vZGUiLCJpc1RleHROb2RlIiwiY29udGFpbnNOb2RlIiwiZ2V0QWN0aXZlRWxlbWVudCIsIlJlYWN0SW5wdXRTZWxlY3Rpb24iLCJSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uIiwiTWl4aW4iLCJTVkdET01Qcm9wZXJ0eUNvbmZpZyIsImFjdGl2ZUVsZW1lbnQiLCJhY3RpdmVFbGVtZW50SW5zdCIsIlNlbGVjdEV2ZW50UGx1Z2luIiwiU3ludGhldGljQW5pbWF0aW9uRXZlbnQiLCJTeW50aGV0aWNDbGlwYm9hcmRFdmVudCIsIlN5bnRoZXRpY0ZvY3VzRXZlbnQiLCJnZXRFdmVudENoYXJDb2RlIiwiZ2V0RXZlbnRLZXkiLCJTeW50aGV0aWNLZXlib2FyZEV2ZW50IiwiU3ludGhldGljRHJhZ0V2ZW50IiwiU3ludGhldGljVG91Y2hFdmVudCIsIlN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCIsIlN5bnRoZXRpY1doZWVsRXZlbnQiLCJnZXREaWN0aW9uYXJ5S2V5IiwiaXNJbnRlcmFjdGl2ZSIsIlNpbXBsZUV2ZW50UGx1Z2luIiwiRE9DX05PREVfVFlQRSIsIlJlYWN0RE9NQ29udGFpbmVySW5mbyIsIlJlYWN0RE9NRmVhdHVyZUZsYWdzIiwiYWRsZXIzMiIsIlJlYWN0TWFya3VwQ2hlY2tzdW0iLCJBVFRSX05BTUUiLCJFTEVNRU5UX05PREVfVFlQRSIsIkRPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSIsIlJlYWN0TW91bnQiLCJnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZSIsImZpbmRET01Ob2RlIiwiUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rIiwiaGFuZGxlRWxlbWVudCIsIlJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayIsIndhcm5lZFByb3BlcnRpZXMiLCJ2YWxpZGF0ZVByb3BlcnR5IiwiUmVhY3RET01JbnZhbGlkQVJJQUhvb2siLCJSZWFjdFZlcnNpb24iLCJSZWFjdERPTSIsIl9pc1BsYWNlaG9sZGVyIiwiX2N1cnJ5MSIsIl9jdXJyeTIiLCJfc2xpY2UiLCJfaXNBcnJheSIsIl9pc1RyYW5zZm9ybWVyIiwiX2Rpc3BhdGNoYWJsZSIsIl9maWx0ZXIiLCJfaXNPYmplY3QiLCJfeHdyYXAiLCJfYXJpdHkiLCJiaW5kIiwiX2lzU3RyaW5nIiwiaXNBcnJheUxpa2UiLCJfcmVkdWNlIiwiX3hmaWx0ZXIiLCJfaGFzIiwiX2lzQXJndW1lbnRzIiwia2V5cyIsIl9tYXAiLCJfeGZCYXNlIiwiX3htYXAiLCJfY3VycnlOIiwiY3VycnlOIiwibWFwIiwiX2N1cnJ5MyIsIl9hcnJheUZyb21JdGVyYXRvciIsIl9mdW5jdGlvbk5hbWUiLCJpZGVudGljYWwiLCJ0eXBlIiwiX2VxdWFscyIsImVxdWFscyIsInByb3BFcSIsIl9yZWR1Y2VkIiwiX3hmaW5kIiwicHJvcE9yIiwiX3BpcGUiLCJfY2hlY2tGb3JNZXRob2QiLCJzbGljZSIsInBpcGUiLCJfZXh0ZW5kcyIsImN1cnJ5IiwidHlwZXMiLCJNYXRoIiwicmFuZG9tIiwiTWF5YmUiLCJ2YWx1ZSIsImlzSnVzdCIsInVuZGVmaW5lZCIsIkp1c3QiLCJpc05vdGhpbmciLCJ3aXRoRGVmYXVsdCIsImRlZmF1bHRWYWwiLCJmIiwib2YiLCJOb3RoaW5nIiwiY2hhaW4iLCJ2IiwiXyIsIl9kZWZhdWx0IiwibWFwMiIsInYxIiwidjIiLCJtYXBJZiIsImNvbmRpdGlvbiIsIlJlbW90ZURhdGEiLCJpc1N1Y2Nlc3MiLCJTdWNjZXNzIiwiaXNGYWlsdXJlIiwiRmFpbHVyZSIsImlzTG9hZGluZyIsIkxvYWRpbmciLCJsb2ciLCJpc05vdEFza2VkIiwiTm90QXNrZWQiLCJlbHNlVmFsIiwibWFwU3VjY2VzcyIsIm1hcExvYWRpbmciLCJtYXBGYWlsdXJlIiwidG9NYXliZSIsIl92YWx1ZSIsIlZhbGlkYXRpb24iLCJ0aHJvd0ZhaWx1cmUiLCJhc3NlcnQiLCJhbmRUaGVuIiwidmFsIiwiZXJyTXNnIiwicHJvcCIsImVycm9yTWVzc2FnZSIsImludCIsImZsb2F0Iiwic3RyaW5nIiwiYm9vbCIsIm51bGxUeXBlIiwiYXJyYXkiLCJzdWJUeXBlIiwiQXJyYXkiLCJpc0FycmF5Iiwic3ViVHlwZXNWYWxpZGF0aW9uIiwicmVkdWNlIiwiZGF0ZSIsIkRhdGUiLCJudWxsYWJsZSIsIm1heWJlIiwiX2RlZmF1bHQyIiwicmVtb3RlRGF0YSIsInJlcXVlc3QiLCJSZXF1ZXN0IiwicmVzcG9uc2UiLCJSZXNwb25zZSIsImhhdmVTYW1lS2V5cyIsIm8xIiwibzIiLCJrMSIsIk9iamVjdCIsImsyIiwib3V0Iiwia2V5IiwiaW5jbHVkZXMiLCJvYmplY3QiLCJ0eXBlU2lnbmF0dXJlIiwiX2RlZmF1bHQzIiwib3V0Y29tZSIsImdsb2JhbCIsImltbXV0YWJsZUNvbnN0cnVjdG9yIiwidHlwZUNoZWNrZXIiLCJjdXN0b21DaGVjayIsIkltbXV0YWJsZSIsInR5cGVDaGVjayIsIlRpbWVJbnRlcnZhbCIsImdldFN0YXJ0IiwibW9kZWwiLCJzdGFydCIsImdldEVuZCIsImVuZCIsImdldFZhbHVlIiwibWF5YmVTdGFydCIsInZhbHVlT2YiLCJtYXliZUVuZCIsInMiLCJlIiwiYXNzaWduIiwiaXNSZWNvcmRpbmciLCJzZXRTdGFydFRpbWUiLCJuZXdJbnRlcnZhbCIsImdldFN0YXJ0VGltZSIsIndpdGhTdGFydFRpbWUiLCJzZXRJbnRlcnZhbHMiLCJnZXRJbnRlcnZhbHMiLCJjYWxjdWxhdGVSdW5uaW5nVGltZSIsInN0YXJ0VGltZSIsImludGVydmFscyIsImludGVydmFsc1N1bSIsInN1bVNpbmNlU3RhcnRUaW1lIiwiZCIsIlJlY29yZGluZyIsInIiLCJpbXV0YWJsZU1vZGVsIiwibWVyZ2UiLCJkZWVwIiwiX2RlZmF1bHQ0IiwidG9nZ2xlUmVjb3JkaW5nIiwiX3RvZ2dsZVJlY29yZGluZyIsInRvdGFsVGltZSIsIl90b3RhbFRpbWUiLCJEZWxpdmVyYWJsZSIsImdldFJlY29yZGluZyIsImRlbGl2ZXJhYmxlIiwicmVjb3JkaW5nIiwiZ2V0TmFtZSIsImdldFVybCIsInNldFJlY29yZGluZyIsIm5ld1JlY29yZGluZyIsImlzU2FtZSIsImQxIiwiZDIiLCJQcm9qZWN0IiwiZ2V0U2VsZWN0ZWREZWxpdmVyYWJsZSIsImdldERlbGl2ZXJhYmxlcyIsInNldFNlbGVjdGVkRGVsaXZlcmFibGUiLCJuZXdTZWxlY3RlZCIsImFsbCIsIm5ld0RlbGl2ZXJhYmxlcyIsImZpbHRlciIsInVwZGF0ZURlbGl2ZXJhYmxlIiwibmV3RGVsaXZlcmFibGUiLCJzYW1lTmFtZSIsImRlbGl2IiwibmFtZSIsInVuc2VsZWN0ZWREZWxpdmVyYWJsZXMiLCJmaW5kIiwibmV3VW5zZWxlY3RlZCIsInAxIiwicDIiLCJfTWF5YmUiLCJfUmVtb3RlRGF0YSIsIl9WYWxpZGF0aW9uIiwidHlwZUNoZWNrZXJzIiwiX3R5cGVDaGVja2VycyIsIl9SZWNvcmRpbmciLCJfVGltZUludGVydmFsIiwiX0RlbGl2ZXJhYmxlIiwiX1Byb2plY3QiLCJwYWQyIiwibnVtIiwibWlsbGlzZWNvbmRzVG9UaW1lU3RyaW5nIiwibXMiLCJzZWNvbmRzIiwiZmxvb3IiLCJtaW51dGVzIiwiaG91cnMiLCJUaW1lciIsIkNvbXBvbmVudCIsInRpbWVvdXQiLCJwcm9wcyIsInNldFRpbWVvdXQiLCJmb3JjZVVwZGF0ZSIsInRpbWVTdHJpbmciLCJtaW5XaWR0aCIsImxlbmd0aCIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsInByb2plY3QiLCJzZWxlY3REZWxpdmVyYWJsZSIsInNlbGVjdFByb2plY3QiLCJzZXRQcm9qZWN0cyIsInJhd1Byb2plY3RzIiwidG9nZ2xlTWluaW1pc2VkIiwibWluaW1pc2UiLCJSZWNvcmRpbmdSb3ciLCJzdG9yZSIsImRpc3BhdGNoIiwidG9PcHRpb24iLCJlbCIsImxhYmVsIiwic2FtZU5hbWVBc09wdGlvblZhbHVlIiwic3RyaW5nSWRlbnRpZmllciIsInJ1bm5pbmdUaW1lciIsInJlY29yZGluZ3NJbmZvIiwiX2RlZmF1bHQ1IiwiX2RlZmF1bHQ2IiwiX2RlZmF1bHQ3IiwiV2lkZ2V0Iiwic2VsZWN0ZWREZWxpdmVyYWJsZSIsInNlbGVjdGVkUHJvamVjdCIsImFjdGl2ZVJlY29yZGluZyIsImlzTWluaW1pc2VkIiwicHJvamVjdE9wdGlvbnMiLCJhbGxQcm9qZWN0cyIsImRlbGl2ZXJhYmxlT3B0aW9ucyIsInRpbWVUcmFja2VyQ2xpY2siLCJjaGFuZ2VQcm9qZWN0Iiwib3B0aW9uIiwiYWN0aW9uIiwiY2hhbmdlRGVsaXZlcmFibGUiLCJfZGVmYXVsdDgiLCJzb3J0IiwiaW5mbzEiLCJpbmZvMiIsImluZm8iLCJTeW1ib2wiLCJvYmplY3RQcm90byIsInN5bVRvU3RyaW5nVGFnIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJyb290IiwicG9ueWZpbGwiLCIkJG9ic2VydmFibGUiLCJmcmVlR2xvYmFsIiwiZnJlZVNlbGYiLCJnZXRSYXdUYWciLCJvYmplY3RUb1N0cmluZyIsIm51bGxUYWciLCJ1bmRlZmluZWRUYWciLCJiYXNlR2V0VGFnIiwib3ZlckFyZyIsImdldFByb3RvdHlwZSIsImlzT2JqZWN0TGlrZSIsIm9iamVjdFRhZyIsImZ1bmNQcm90byIsImZ1bmNUb1N0cmluZyIsIm9iamVjdEN0b3JTdHJpbmciLCJpc1BsYWluT2JqZWN0IiwiX2lzRnVuY3Rpb24iLCJfaW5kZXhPZiIsIl9jb250YWlucyIsIl9xdW90ZSIsIl90b0lTT1N0cmluZyIsIl9jb21wbGVtZW50IiwicmVqZWN0IiwiX3RvU3RyaW5nIiwidG9TdHJpbmciLCJkZWZhdWx0VG8iLCJwYXRoIiwicGF0aE9yIiwidXBkYXRlQXQiLCJrZXlBcnJheSIsIm5ld1ZhbCIsIm9iaiIsImRlZXBOZXdWYWwiLCJyZWR1Y2VSaWdodCIsInJlc3VsdCIsInVuc2VsZWN0ZWRQcm9qZWN0cyIsImNvbmNhdCIsIm5vblplcm9SZWNvcmRpbmdUaW1lIiwicHJvamVjdFJlY29yZGluZ0luZm9zIiwiZ2V0UHJvamVjdCIsInByb2plY3ROYW1lIiwiX2RlZmF1bHQ5IiwiX2RlZmF1bHQxMCIsImdldERlbGl2ZXJhYmxlIiwiZGVsaXZlcmFibGVOYW1lIiwidXBkYXRlUHJvamVjdCIsIm5ld1Byb2plY3QiLCJzYW1lUHJvamVjdE5hbWUiLCJ1cGRhdGluZ1NlbGVjdGVkUHJvamVjdCIsInVwZGF0aW5nVW5zZWxlY3RlZFByb2plY3QiLCJuZXdVbnNlbGVjdGVkUHJvamVjdHMiLCJwIiwibWFwU3RhdGVUb1Byb3BzIiwibWluaW1pc2VkIiwibWFwRGlzcGF0Y2hUb1Byb3BzIiwiY29ubmVjdCIsIlZpZXciLCJtb2RlbFR5cGUiLCJudGgiLCJ0b2dnbGVEZWxpdmVyYWJsZVJlY29yZGluZyIsImZpbmRSZWNvcmRpbmdEZWxpdmVyYWJsZSIsInN0b3BBbGxSZWNvcmRpbmdzIiwibSIsImNvbnNvbGUiLCJnZXRVcFRvRGF0ZVByb2plY3QiLCJjaGFuZ2VkTW9kZWwiLCJwcm9jZXNzUmF3RGVsaXZlcmFibGVzIiwidXJsIiwicHJvY2Vzc1Jhd1Byb2plY3RzIiwiZGVsaXZlcmFibGVzIiwibmV3UHJvamVjdHMiLCJhY3Rpb25IYW5kbGVycyIsInVwZGF0ZSIsImFjdGlvbk5hbWUiLCJyZXBsYWNlIiwiaGFuZGxlciIsIndhcm4iLCJhc011dGFibGUiLCJpbml0aWFsTW9kZWwiLCJjcmVhdGVTdG9yZSIsIldpZGdldFVwZGF0ZSIsImZldGNoIiwic2VydmVyVVJMIiwidGhlbiIsImpzb24iLCJwcm9qZWN0cyIsInByb2oiLCJkZXNjcmliZSIsInN1Y2Nlc3NWYWwiLCJzdWNjZXNzVmFsMiIsImZhaWx1cmVWYWwiLCJhU3VjY2VzcyIsImFTdWNjZXNzMiIsImFGYWlsdXJlIiwiYSIsInRvQmUiLCJ0b0VxdWFsIiwidG9UaHJvdyIsIm5vdCIsInN1Y2Nlc3MxIiwic3VjY2VzczIiLCJkZWxpdk5hbWUiLCJkZWxpdlVybCIsImRlbGl2UmVjIiwidmFsaWRPYmplY3QiLCJ2YWxpZERlbGl2IiwidmFsaWRPYmplY3ROb1JlYyIsInZhbGlkRGVsaXZOb1JlYyIsImludmFsaWQxIiwiaW52YWxpZDIiLCJpbnZhbGlkMyIsInNldEFuZEdldFJlY29yZGluZyIsIm5vdyIsInNlY0ludGVydmFsNSIsInNlY0ludGVydmFsMTAiLCJ2YWxpZDEiLCJ2YWxpZDFSdW5uaW5nIiwidmFsaWQyIiwidmFsaWQyUnVubmluZyIsImludmFsaWQxUnVubmluZyIsInZhbGlkYXRlcyIsImludGVydmFsSXNBcnJheSIsImVtcHR5Iiwic2V0QW5kR2V0SW50ZXJ2YWxzIiwidG9nZ2xlZFZhbHVlIiwidG9nZ2xlZFN0YXJ0VGltZSIsInRvQmVMZXNzVGhhbk9yRXF1YWwiLCJzZWMxNSIsInNlYzE1UnVubmluZyIsInNlYzAiLCJzZWMwUnVubmluZyIsInRvQmVHcmVhdGVyVGhhbiIsImNyZWF0ZWRKdXN0V2l0aE9mIiwiY3JlYXRlZEp1c3QiLCJjcmVhdGVkTm90aGluZyIsImp1c3RWYWwiLCJtYXBwZWRWYWwiLCJmdW5jIiwibWFwQW5kR2V0RGVmYXVsdCIsIm1hcDJBbmRHZXREZWZhdWx0IiwidmFsaWRPYmoiLCJpbnZhbGlkNCIsImludmFsaWQ1IiwibW9ja0RlbGl2ZXJhYmxlIiwidmFsaWROYW1lIiwidmFsaWRVcmwiLCJ2YWxpZCIsImlzVmFsaWQiLCJ0b0JlVHJ1dGh5IiwibW9ja0RlbGl2ZXJhYmxlQ2hhbmdlZCIsIm1vY2tQcm9qZWN0IiwidXBkYXRlQW5kR2V0RGVsaXZlcmFibGVzIiwidG9CZUZhbHN5IiwibW9ja1Vuc2VsZWN0ZWREZWxpdmVyYWJsZSIsIm1vY2tVbnNlbGVjdGVkUHJvamVjdCIsIm1vY2tNb2RlbCIsIm1vY2tBY3Rpb24iLCJ0b2dnbGVkTW9kZWwiLCJkZWxpdmVyYWJsZXNSZWNvcmRpbmciLCJ3cmFwcGVyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwicmVuZGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBRUEsSUFBSSxjQUFjLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUM7QUFDckQsSUFBSSxnQkFBZ0IsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLG9CQUFvQixDQUFDOztBQUU3RCxTQUFTLFFBQVEsQ0FBQyxHQUFHLEVBQUU7Q0FDdEIsSUFBSSxHQUFHLEtBQUssSUFBSSxJQUFJLEdBQUcsS0FBSyxTQUFTLEVBQUU7RUFDdEMsTUFBTSxJQUFJLFNBQVMsQ0FBQyx1REFBdUQsQ0FBQyxDQUFDO0VBQzdFOztDQUVELE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQ25C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QUFHbkssZUFBYSxDQUFDOztBQUV2QyxBQUFJLEFBQXFDLEFBQUU7Ozs7Ozs7Ozs7Ozs7RUFhekMsSUFBSSxXQUFXLEdBQUcsQ0FBQyxTQUFTLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsS0FB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QUFDLEVBQUUsQ0FBQztDQUN0RCxFQUFFLENBQUMsQ0FBQzs7QUNiTCxZQUFjLEdBQUcsU0FBU0MsUUFBTSxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUU7O0VBRXRDLFFBQVEsQ0FBQztJQUNQLEtBQUssQ0FBQyxFQUFFLE9BQU8sV0FBVyxFQUFFLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQ2hFLEtBQUssQ0FBQyxFQUFFLE9BQU8sU0FBUyxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUNsRSxLQUFLLENBQUMsRUFBRSxPQUFPLFNBQVMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQ3RFLEtBQUssQ0FBQyxFQUFFLE9BQU8sU0FBUyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQzFFLEtBQUssQ0FBQyxFQUFFLE9BQU8sU0FBUyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUM5RSxLQUFLLENBQUMsRUFBRSxPQUFPLFNBQVMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQ2xGLEtBQUssQ0FBQyxFQUFFLE9BQU8sU0FBUyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQ3RGLEtBQUssQ0FBQyxFQUFFLE9BQU8sU0FBUyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUMxRixLQUFLLENBQUMsRUFBRSxPQUFPLFNBQVMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQzlGLEtBQUssQ0FBQyxFQUFFLE9BQU8sU0FBUyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQ2xHLEtBQUssRUFBRSxFQUFFLE9BQU8sU0FBUyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUN2RyxTQUFTLE1BQU0sSUFBSSxLQUFLLENBQUMsNkVBQTZFLENBQUMsQ0FBQztHQUN6RztDQUNGLENBQUM7O0FDaEJGLElBQUksTUFBTSxHQUFHeE8sUUFB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TUFBTSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUseUZBQXlGLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLDZIQUE2SCxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxtQ0FBbUMsRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUseUZBQXlGLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLGlIQUFpSCxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUscURBQXFELEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLHFHQUFxRyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsdVFBQXVRLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLGlFQUFpRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSx5Q0FBeUMsRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUs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LEVBQUUsRUFBRSxFQUFFLElBQUksVUFBVSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDLFVBQVUsSUFBSSxLQUFLLENBQUMsQ0FBQyxVQUFVLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxDQUFDLElBQUksT0FBTyxJQUFJLFVBQVUsRUFBRSxVQUFVLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsVUFBVSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsT0FBTyxVQUFVLFdBQVcsRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLEVBQUUsSUFBSSxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksV0FBVyxFQUFFLGdCQUFnQixDQUFDLFdBQVcsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDLE9BQU8sV0FBVyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQzs7QUFFdGpCLElBQUksSUFBSSxHQUFHLFNBQVMsR0FBRyxDQUFDLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEVBQUUsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLENBQUMsU0FBUyxFQUFFLE9BQU8sTUFBTSxFQUFFLEVBQUUsSUFBSSxNQUFNLEdBQUcsRUFBRSxFQUFFLFFBQVEsR0FBRyxHQUFHLEVBQUUsUUFBUSxHQUFHLEdBQUcsQ0FBQyxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQyxJQUFJLE1BQU0sS0FBSyxJQUFJLEVBQUUsTUFBTSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLElBQUksR0FBRyxNQUFNLENBQUMsd0JBQXdCLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLEtBQUssU0FBUyxFQUFFLEVBQUUsSUFBSSxNQUFNLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksTUFBTSxLQUFLLElBQUksRUFBRSxFQUFFLE9BQU8sU0FBUyxDQUFDLEVBQUUsTUFBTSxFQUFFLEVBQUUsR0FBRyxNQUFNLENBQUMsQ0FBQyxHQUFHLEdBQUcsUUFBUSxDQUFDLENBQUMsR0FBRyxHQUFHLFFBQVEsQ0FBQyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsQ0FBQyxJQUFJLEdBQUcsTUFBTSxHQUFHLFNBQVMsQ0FBQyxDQUFDLFNBQVMsU0FBUyxDQUFDLEVBQUUsRUFBRSxNQUFNLElBQUksT0FBTyxJQUFJLElBQUksRUFBRSxFQUFFLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLE1BQU0sRUFBRSxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxNQUFNLEtBQUssU0FBUyxFQUFFLEVBQUUsT0FBTyxTQUFTLENBQUMsRUFBRSxDQUFDLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDOztBQUVscEIsU0FBUyxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsRUFBRSxPQUFPLEdBQUcsSUFBSSxHQUFHLENBQUMsVUFBVSxHQUFHLEdBQUcsR0FBRyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFOztBQUVqRyxTQUFTLGVBQWUsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxFQUFFLElBQUksR0FBRyxJQUFJLEdBQUcsRUFBRSxFQUFFLE1BQU0sQ0FBQyxjQUFjLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUsTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUMsRUFBRSxDQUFDLE9BQU8sR0FB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